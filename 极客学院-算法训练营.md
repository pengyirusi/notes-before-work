Master Theorem

![image-20210310102641432](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210310102641432.png)

+ ArrayList

  When insert or delete an element, ArrayList will create a new Array and execute a System.arraycopy. Doing those constantly will reduce efficiency.

+ SkipList

  space for time | increase dimension

  multi-dimension index | log2n-dimension index

  ![image-20210310112351440](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210310112351440.png)

  Time complexity: O(log n), Space complexity: O(n)

+ #### [283. Move Zeroes](https://leetcode-cn.com/problems/move-zeroes/)

  Given an array `nums`, write a function to move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.

  **Example:**

  ```
  Input: [0,1,0,3,12]
  Output: [1,3,12,0,0]
  ```

  **Note**:

  1. You must do this **in-place** without making a copy of the array.
  2. Minimize the total number of operations.

  ```java
  class Solution {
      public void moveZeroes(int[] nums) {
          int i = 0;
          for (int j = 0; j < nums.length; j++) {
              if (nums[j] != 0) {
                  swap(nums, i, j);
                  i++;
              }
          }
      }
  
      private void swap(int[] nums, int i, int j) {
          int t = nums[i];
          nums[i] = nums[j];
          nums[j] = t;
      }
  }
  ```

+ #### [11. Container With Most Water](https://leetcode-cn.com/problems/container-with-most-water/)

  Given `n` non-negative integers `a1, a2, ..., an` , where each represents a point at coordinate `(i, ai)`. `n` vertical lines are drawn such that the two endpoints of the line `i` is at `(i, ai)` and `(i, 0)`. Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.

  **Notice** that you may not slant the container.

  **Example 1:**

  ![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)

  ```
  Input: height = [1,8,6,2,5,4,8,3,7]
  Output: 49
  Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
  ```

  **Example 2:**

  ```
  Input: height = [1,1]
  Output: 1
  ```

  **Example 3:**

  ```
  Input: height = [4,3,2,1,4]
  Output: 16
  ```

  **Example 4:**

  ```
  Input: height = [1,2,1]
  Output: 2
  ```

  **Constraints:**

  - `n == height.length`
  - `2 <= n <= 105`
  - `0 <= height[i] <= 104`

  ```java
  class Solution {
      public int maxArea(int[] height) {
          int res = 0;
          for (int i = 0, j = height.length - 1; i < j; ) {
              int minHeight = height[i] < height[j] ? height[i++] : height[j--];
              res = Math.max(res, (j - i + 1) * minHeight); //plus 1
          }
          return res;
      }
  }
  ```

+ #### [70. Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/)

  You are climbing a staircase. It takes `n` steps to reach the top.

  Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?

  **Example 1:**

  ```
  Input: n = 2
  Output: 2
  Explanation: There are two ways to climb to the top.
  1. 1 step + 1 step
  2. 2 steps
  ```

  **Example 2:**

  ```
  Input: n = 3
  Output: 3
  Explanation: There are three ways to climb to the top.
  1. 1 step + 1 step + 1 step
  2. 1 step + 2 steps
  3. 2 steps + 1 step
  ```

  **Constraints:**

  - `1 <= n <= 45`

  ```java
  class Solution {
      public int climbStairs(int n) {
          if (n < 4) return n;
          int a = 1, b = 2, c = 3;
          while (n-- > 3) {
              a = b;
              b = c;
              c = a + b;
          }
          return c;
      }
  }
  ```

+ #### [15. 3Sum](https://leetcode-cn.com/problems/3sum/)

  Given an array `nums` of *n* integers, are there elements *a*, *b*, *c* in `nums` such that *a* + *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.

  Notice that the solution set must not contain duplicate triplets.

  **Example 1:**

  ```
  Input: nums = [-1,0,1,2,-1,-4]
  Output: [[-1,-1,2],[-1,0,1]]
  ```

  **Example 2:**

  ```
  Input: nums = []
  Output: []
  ```

  **Example 3:**

  ```
  Input: nums = [0]
  Output: []
  ```

  **Constraints:**

  - `0 <= nums.length <= 3000`
  - `-105 <= nums[i] <= 105`

  ```java
  class Solution {
      public List<List<Integer>> threeSum(int[] nums) {
          List<List<Integer>> res = new ArrayList<>();
          Arrays.sort(nums);
          for (int i = 0; i < nums.length - 2 && nums[i] <= 0; i++) {
              if (i > 0 && nums[i] == nums[i - 1]) continue;
              for (int j = i + 1, k = nums.length - 1; j < k; ) {
                  int sum = nums[j] + nums[k];
                  if (j > i + 1 && nums[j] == nums[j - 1] || sum < -nums[i]) {
                      j++;
                  } else if (k < nums.length - 1 && nums[k] == nums[k + 1] || sum > -nums[i]) {
                      k--;
                  } else {
                      res.add(Arrays.asList(nums[i], nums[j], nums[k]));
                      j++;
                      k--;
                  }
              }
          }
          return res;
      }
  }
  ```

+ #### [141. Linked List Cycle](https://leetcode-cn.com/problems/linked-list-cycle/)

  Given `head`, the head of a linked list, determine if the linked list has a cycle in it.

  There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.

  Return `true` *if there is a cycle in the linked list*. Otherwise, return `false`.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

  ```
  Input: head = [3,2,0,-4], pos = 1
  Output: true
  Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)

  ```
  Input: head = [1,2], pos = 0
  Output: true
  Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
  ```

  **Example 3:**

  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)

  ```
  Input: head = [1], pos = -1
  Output: false
  Explanation: There is no cycle in the linked list.
  ```

  **Constraints:**

  - The number of the nodes in the list is in the range `[0, 104]`.
  - `-105 <= Node.val <= 105`
  - `pos` is `-1` or a **valid index** in the linked-list.

  ```java
  public class Solution {
      public boolean hasCycle(ListNode head) {
          if (head == null || head.next == null) return false; 
          ListNode fast = head.next, slow = head;
          while (fast != null && fast.next != null) {
              if (fast == slow) return true;
              fast = fast.next.next;
              slow = slow.next;
          }
          return false;
      }
  }
  ```

+ #### [142. Linked List Cycle II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

  Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.

  There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.

  **Notice** that you **should not modify** the linked list.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

  ```
  Input: head = [3,2,0,-4], pos = 1
  Output: tail connects to node index 1
  Explanation: There is a cycle in the linked list, where tail connects to the second node.
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)

  ```
  Input: head = [1,2], pos = 0
  Output: tail connects to node index 0
  Explanation: There is a cycle in the linked list, where tail connects to the first node.
  ```

  **Example 3:**

  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)

  ```
  Input: head = [1], pos = -1
  Output: no cycle
  Explanation: There is no cycle in the linked list.
  ```

  **Constraints:**

  - The number of the nodes in the list is in the range `[0, 104]`.
  - `-105 <= Node.val <= 105`
  - `pos` is `-1` or a **valid index** in the linked-list.

  **Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?

  ```java
  public class Solution {
      public ListNode detectCycle(ListNode head) {
          if (head == null || head.next == null) return null;
          ListNode fast = head, slow = head;
          while (fast != null && fast.next != null) {
              fast = fast.next.next;
              slow = slow.next;
              if (fast == slow) {
                  fast = head;
                  while (fast != slow) {
                      fast = fast.next;
                      slow = slow.next;
                  }
                  return fast;
              }
          }
          return null;
      }
  }
  ```

+ #### [206. Reverse Linked List](https://leetcode-cn.com/problems/reverse-linked-list/)

  Given the `head` of a singly linked list, reverse the list, and return *the reversed list*.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

  ```
  Input: head = [1,2,3,4,5]
  Output: [5,4,3,2,1]
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

  ```
  Input: head = [1,2]
  Output: [2,1]
  ```

  **Example 3:**

  ```
  Input: head = []
  Output: []
  ```

  **Constraints:**

  - The number of nodes in the list is the range `[0, 5000]`.
  - `-5000 <= Node.val <= 5000`

  ```java
  class Solution {
      public ListNode reverseList(ListNode head) {
          if (head == null || head.next == null) return head;
          ListNode res = new ListNode();
          while (head != null) {
              ListNode cur = head;
              head = head.next;
              cur.next = res.next;
              res.next = cur;
          }
          return res.next;
      }
  }
  ```

+ #### [24. Swap Nodes in Pairs](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

  Given a linked list, swap every two adjacent nodes and return its head.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

  ```
  Input: head = [1,2,3,4]
  Output: [2,1,4,3]
  ```

  **Example 2:**

  ```
  Input: head = []
  Output: []
  ```

  **Example 3:**

  ```
  Input: head = [1]
  Output: [1]
  ```

  **Constraints:**

  - The number of nodes in the list is in the range `[0, 100]`.
  - `0 <= Node.val <= 100`

  **Follow up:** Can you solve the problem without modifying the values in the list's nodes? (i.e., Only nodes themselves may be changed.)

  ```java
  class Solution {
      public ListNode swapPairs(ListNode head) {
          if (head == null || head.next == null) return head;
          ListNode res = new ListNode();
          ListNode cur = res;
          while (head != null && head.next != null) {
              ListNode a = head, b = head.next;
              a.next = b.next;
              b.next = a;
              cur.next = b;
              cur = a;
              head = cur.next;
          }
          return res.next;
      }
  }
  ```


+ Stack

   extends class Vector

  ```java
  Stack<T> stack = new Stack<>();
  ```

  API: `empty() peek() pop() push(E item) search(Object o)`

  Recommended in practice:

  ```java
  Deque<T> stack = new ArrayDeque<T>();
  ```

+ Queue

  not a class, is a interface | has many class

  API:

  ![image-20210312100946162](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210312100946162.png)

+ Deque

  announce:`/dek/` | Double-End Queue

  not a class, is a interface | has many class

  API:

  ![image-20210312101246198](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210312101246198.png)

+ Priority Queue

  implements Collection and Queue

  【Time complex】Insert: O(1), Get: O(log n)

  backend：heap / BST - binary search tree / treap

  API:

  ![image-20210312102541460](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210312102541460.png)

+ Summary of common  data structure operations

  ![image-20210312103513135](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210312103513135.png)

+ #### [26. Remove Duplicates from Sorted Array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

  Given a sorted array *nums*, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each element appears only *once* and returns the new length.

  Do not allocate extra space for another array, you must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.

  **Clarification:**

  Confused why the returned value is an integer but your answer is an array?

  Note that the input array is passed in by **reference**, which means a modification to the input array will be known to the caller as well.

  Internally you can think of this:

  ```
  // nums is passed in by reference. (i.e., without making a copy)
  int len = removeDuplicates(nums);
  
  // any modification to nums in your function would be known by the caller.
  // using the length returned by your function, it prints the first len elements.
  for (int i = 0; i < len; i++) {
      print(nums[i]);
  }
  ```

  **Example 1:**

  ```
  Input: nums = [1,1,2]
  Output: 2, nums = [1,2]
  Explanation: Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the returned length.
  ```

  **Example 2:**

  ```
  Input: nums = [0,0,1,1,1,2,2,3,3,4]
  Output: 5, nums = [0,1,2,3,4]
  Explanation: Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn't matter what values are set beyond the returned length.
  ```

  **Constraints:**

  - `0 <= nums.length <= 3 * 104`
  - `-104 <= nums[i] <= 104`
  - `nums` is sorted in ascending order.

  ```java
  class Solution {
      public int removeDuplicates(int[] nums) {
          int i = 0;
          for (int j = 1; j < nums.length; j++) {
              if (nums[i] != nums[j]) {
                  nums[++i] = nums[j];
              }
          }
          return i + 1;
      }
  }
  ```

+ #### [189. Rotate Array](https://leetcode-cn.com/problems/rotate-array/)

  Given an array, rotate the array to the right by *k* steps, where *k* is non-negative.

  **Follow up:**

  - Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.
  - Could you do it in-place with O(1) extra space?

  **Example 1:**

  ```
  Input: nums = [1,2,3,4,5,6,7], k = 3
  Output: [5,6,7,1,2,3,4]
  Explanation:
  rotate 1 steps to the right: [7,1,2,3,4,5,6]
  rotate 2 steps to the right: [6,7,1,2,3,4,5]
  rotate 3 steps to the right: [5,6,7,1,2,3,4]
  ```

  **Example 2:**

  ```
  Input: nums = [-1,-100,3,99], k = 2
  Output: [3,99,-1,-100]
  Explanation: 
  rotate 1 steps to the right: [99,-1,-100,3]
  rotate 2 steps to the right: [3,99,-1,-100]
  ```

  **Constraints:**

  - `1 <= nums.length <= 2 * 104`
  - `-231 <= nums[i] <= 231 - 1`
  - `0 <= k <= 105`

  ```java
  class Solution {
      public void rotate(int[] nums, int k) {
          int len = nums.length;
          k = k % len;
          reverse(nums, 0, len - 1);
          reverse(nums, 0, k - 1);
          reverse(nums, k, len - 1);
      }
  
      private void reverse(int[] nums, int i, int j) {
          while (i < j) {
              int t = nums[i];
              nums[i] = nums[j];
              nums[j] = t;
              i++;
              j--;
          }
      }
  }
  ```

+ #### [88. Merge Sorted Array](https://leetcode-cn.com/problems/merge-sorted-array/)

  Given two sorted integer arrays `nums1` and `nums2`, merge `nums2` into `nums1` as one sorted array.

  The number of elements initialized in `nums1` and `nums2` are `m` and `n` respectively. You may assume that `nums1` has a size equal to `m + n` such that it has enough space to hold additional elements from `nums2`.

  **Example 1:**

  ```
  Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
  Output: [1,2,2,3,5,6]
  ```

  **Example 2:**

  ```
  Input: nums1 = [1], m = 1, nums2 = [], n = 0
  Output: [1]
  ```

  **Constraints:**

  - `nums1.length == m + n`
  - `nums2.length == n`
  - `0 <= m, n <= 200`
  - `1 <= m + n <= 200`
  - `-109 <= nums1[i], nums2[i] <= 109`

  ```java
  class Solution {
      public void merge(int[] nums1, int m, int[] nums2, int n) {
          int i = m - 1, j = n - 1;
          for (int k = m + n - 1; i >= 0 && j >= 0; k--) {
              nums1[k] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];
          }
          while (j >= 0) nums1[j] = nums2[j--];
      }
  }
  ```

+ #### [66. Plus One](https://leetcode-cn.com/problems/plus-one/)

  Given a **non-empty** array of decimal digits representing a non-negative integer, increment one to the integer.

  The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.

  You may assume the integer does not contain any leading zero, except the number 0 itself.

  **Example 1:**

  ```
  Input: digits = [1,2,3]
  Output: [1,2,4]
  Explanation: The array represents the integer 123.
  ```

  **Example 2:**

  ```
  Input: digits = [4,3,2,1]
  Output: [4,3,2,2]
  Explanation: The array represents the integer 4321.
  ```

  **Example 3:**

  ```
  Input: digits = [0]
  Output: [1]
  ```

  **Constraints:**

  - `1 <= digits.length <= 100`
  - `0 <= digits[i] <= 9`

  ```java
  class Solution {
      public int[] plusOne(int[] digits) {
          int len = digits.length;
          int carry = 1;
          for (int i = len - 1; i >= 0 && carry > 0; i--) {
              int num = digits[i] + 1;
              digits[i] = num % 10;
              carry = num / 10;
          }
          if (carry == 0) return digits;
          int[] res = new int[len + 1];
          res[0] = 1;
          return res;
      }
  }
  ```

+ #### [21. Merge Two Sorted Lists](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

  Merge two sorted linked lists and return it as a **sorted** list. The list should be made by splicing together the nodes of the first two lists.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

  ```
  Input: l1 = [1,2,4], l2 = [1,3,4]
  Output: [1,1,2,3,4,4]
  ```

  **Example 2:**

  ```
  Input: l1 = [], l2 = []
  Output: []
  ```

  **Example 3:**

  ```
  Input: l1 = [], l2 = [0]
  Output: [0]
  ```

  **Constraints:**

  - The number of nodes in both lists is in the range `[0, 50]`.
  - `-100 <= Node.val <= 100`
  - Both `l1` and `l2` are sorted in **non-decreasing** order.

  ```java
  class Solution {
      public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
          ListNode res = new ListNode();
          ListNode cur = res;
          while (l1 != null && l2 != null) {
              if (l1.val < l2.val) {
                  cur.next = l1;
                  l1 = l1.next;
              } else {
                  cur.next = l2;
                  l2 = l2.next;
              }
              cur = cur.next;
          }
          if (l1 != null) cur.next = l1;
          if (l2 != null) cur.next = l2;
          return res.next;
      }
  }
  ```

+ #### [25. Reverse Nodes in k-Group](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

  Given a linked list, reverse the nodes of a linked list *k* at a time and return its modified list.

  *k* is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of *k* then left-out nodes, in the end, should remain as it is.

  **Follow up:**

  - Could you solve the problem in `O(1)` extra memory space?
  - You may not alter the values in the list's nodes, only nodes itself may be changed.

   

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

  ```
  Input: head = [1,2,3,4,5], k = 2
  Output: [2,1,4,3,5]
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

  ```
  Input: head = [1,2,3,4,5], k = 3
  Output: [3,2,1,4,5]
  ```

  **Example 3:**

  ```
  Input: head = [1,2,3,4,5], k = 1
  Output: [1,2,3,4,5]
  ```

  **Example 4:**

  ```
  Input: head = [1], k = 1
  Output: [1]
  ```

  **Constraints:**

  - The number of nodes in the list is in the range `sz`.
  - `1 <= sz <= 5000`
  - `0 <= Node.val <= 1000`
  - `1 <= k <= sz`

  ```java
  class Solution {
      public ListNode reverseKGroup(ListNode head, int k) {
          if (head == null || k == 1) return head;
          ListNode res = new ListNode();
          ListNode cur = res;
          Deque<ListNode> deque = new LinkedList<>();
          while (head != null) {
              for (int i = 0; i < k && head != null; i++) {
                  deque.addLast(head);
                  head = head.next;
              }
              if (deque.size() != k) {
                  cur.next = deque.pollFirst();
                  break;
              }
              while (!deque.isEmpty()) {
                  ListNode node = deque.pollLast();
                  node.next = null;
                  cur.next = node;
                  cur = cur.next;
              }
          }
          return res.next;
      }
  }
  ```

+ #### [20. Valid Parentheses](https://leetcode-cn.com/problems/valid-parentheses/)

   Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

   An input string is valid if:

   1. Open brackets must be closed by the same type of brackets.
   2. Open brackets must be closed in the correct order.

   **Example 1:**

   ```
   Input: s = "()"
   Output: true
   ```

   **Example 2:**

   ```
   Input: s = "()[]{}"
   Output: true
   ```

   **Example 3:**

   ```
   Input: s = "(]"
   Output: false
   ```

   **Example 4:**

   ```
   Input: s = "([)]"
   Output: false
   ```

   **Example 5:**

   ```
   Input: s = "{[]}"
   Output: true
   ```

   **Constraints:**

   - `1 <= s.length <= 104`
   - `s` consists of parentheses only `'()[]{}'`.

   ```java
   // violence recursion
   class Solution {
       Map<Character, Integer> map = new HashMap<>();
       {
           map.put('(', -3);
           map.put('[', -2);
           map.put('{', -1);
           map.put('}', 1);
           map.put(']', 2);
           map.put(')', 3);
       }
       public boolean isValid(String s) {
           int len = s.length();
           if (len == 0) return true;
           if (len == 1) return false;
           for (int i = 0; i < len - 1; i++) {
               int left = map.get(s.charAt(i));
               int right = map.get(s.charAt(i+1));
               if (left < 0 && left == -right) {
                   return isValid(s.substring(0, i) + s.substring(i+2, len));
               }
           }
           return false;
       }
   }
   ```

   ```java
   // stack
   class Solution {
       public boolean isValid(String s) {
           Stack<Character> stack = new Stack<>();
           Map<Character, Character> map = new HashMap<>();
           map.put('}', '{');
           map.put(']', '[');
           map.put(')', '(');
           for (char c : s.toCharArray()) {
               if (map.containsKey(c)) {
                   if (stack.isEmpty() || stack.peek() != map.get(c)) {
                       return false;
                   }
                   stack.pop();
               } else {
                   stack.push(c);
               }
           }
           return stack.isEmpty();
       }
   }
   ```

+ #### [155. Min Stack](https://leetcode-cn.com/problems/min-stack/)

   Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

   - push(x) -- Push element x onto stack.
   - pop() -- Removes the element on top of the stack.
   - top() -- Get the top element.
   - getMin() -- Retrieve the minimum element in the stack.

   **Example 1:**

   ```
   Input
   ["MinStack","push","push","push","getMin","pop","top","getMin"]
   [[],[-2],[0],[-3],[],[],[],[]]
   
   Output
   [null,null,null,null,-3,null,0,-2]
   
   Explanation
   MinStack minStack = new MinStack();
   minStack.push(-2);
   minStack.push(0);
   minStack.push(-3);
   minStack.getMin(); // return -3
   minStack.pop();
   minStack.top();    // return 0
   minStack.getMin(); // return -2
   ```

   **Constraints:**

   - Methods `pop`, `top` and `getMin` operations will always be called on **non-empty** stacks.

   ```java
   class MinStack {
       Stack<Integer> stack1;
       Stack<Integer> stack2;
       /** initialize your data structure here. */
       public MinStack() {
           stack1 = new Stack<>();
           stack2 = new Stack<>();
       }
       
       public void push(int x) {
           stack1.push(x);
           int min = stack2.isEmpty() || x < stack2.peek() ? x : stack2.peek();
           stack2.push(min);
       }
       
       public void pop() {
           stack1.pop();
           stack2.pop();
       }
       
       public int top() {
           return stack1.peek();
       }
       
       public int getMin() {
           return stack2.peek();
       }
   }
   ```

+ #### [84. Largest Rectangle in Histogram](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

   Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return *the area of the largest rectangle in the histogram*.

    

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

   ```
   Input: heights = [2,1,5,6,2,3]
   Output: 10
   Explanation: The above is a histogram where width of each bar is 1.
   The largest rectangle is shown in the red area, which has an area = 10 units.
   ```

   **Example 2:**

   ![img](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)

   ```
   Input: heights = [2,4]
   Output: 4
   ```

   **Constraints:**

   - `1 <= heights.length <= 105`
   - `0 <= heights[i] <= 104`

   ```java
   // violence O(n^2) overtime
   class Solution {
       public int largestRectangleArea(int[] heights) {
           int len = heights.length;
           int res = 0;
           for (int i = 0; i < len; i++) {
               int minHeight = heights[i];
               for (int j = i; j < len; j++) {
                   minHeight = Math.min(minHeight, heights[j]);
                   res = Math.max((j-i+1)*minHeight, res);
               }
           }
           return res;
       }
   }
   ```

   ```java
   // stack O(n)
   class Solution {
       public int largestRectangleArea(int[] heights) {
           Stack<Integer> stack = new Stack<>();
           stack.push(-1);
           int res = heights[0], len = heights.length;
           // left bound is certain
           for (int i = 0; i < len; i++) {
               while (stack.peek() != -1 && heights[stack.peek()] >= heights[i]) {
                   int area = (i - 1 - stack.peek()) * heights[stack.pop()];
                   res = Math.max(res, area);
               }
               stack.push(i);
           }
           // right bound is certain
           while (stack.peek() != -1) {
               res = Math.max(res, (len - 1 - stack.peek()) * heights[stack.pop()]);
           }
           return res;
       }
   }
   ```

+ #### [641. Design Circular Deque](https://leetcode-cn.com/problems/design-circular-deque/)

   Design your implementation of the circular double-ended queue (deque).

   Your implementation should support following operations:

   - `MyCircularDeque(k)`: Constructor, set the size of the deque to be k.
   - `insertFront()`: Adds an item at the front of Deque. Return true if the operation is successful.
   - `insertLast()`: Adds an item at the rear of Deque. Return true if the operation is successful.
   - `deleteFront()`: Deletes an item from the front of Deque. Return true if the operation is successful.
   - `deleteLast()`: Deletes an item from the rear of Deque. Return true if the operation is successful.
   - `getFront()`: Gets the front item from the Deque. If the deque is empty, return -1.
   - `getRear()`: Gets the last item from Deque. If the deque is empty, return -1.
   - `isEmpty()`: Checks whether Deque is empty or not. 
   - `isFull()`: Checks whether Deque is full or not.

   **Example:**

   ```
   MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3
   circularDeque.insertLast(1);			// return true
   circularDeque.insertLast(2);			// return true
   circularDeque.insertFront(3);			// return true
   circularDeque.insertFront(4);			// return false, the queue is full
   circularDeque.getRear();  			// return 2
   circularDeque.isFull();				// return true
   circularDeque.deleteLast();			// return true
   circularDeque.insertFront(4);			// return true
   circularDeque.getFront();			// return 4
   ```

   **Note:**

   - All values will be in the range of [0, 1000].
   - The number of operations will be in the range of [1, 1000].
   - Please do not use the built-in Deque library.

   ```java
   class MyCircularDeque {
       int cap;
       Deque<Integer> deque;
       /** Initialize your data structure here. Set the size of the deque to be k. */
       public MyCircularDeque(int k) {
           cap = k;
           deque = new LinkedList<>();
       }
       
       /** Adds an item at the front of Deque. Return true if the operation is successful. */
       public boolean insertFront(int value) {
           if (cap == 0) return false;
           deque.addFirst(value);
           cap--;
           return true;
       }
       
       /** Adds an item at the rear of Deque. Return true if the operation is successful. */
       public boolean insertLast(int value) {
           if (cap == 0) return false;
           deque.addLast(value);
           cap--;
           return true;
       }
       
       /** Deletes an item from the front of Deque. Return true if the operation is successful. */
       public boolean deleteFront() {
           if (deque.isEmpty()) return false;
           deque.removeFirst();
           cap++;
           return true;
       }
       
       /** Deletes an item from the rear of Deque. Return true if the operation is successful. */
       public boolean deleteLast() {
           if (deque.isEmpty()) return false;
           deque.removeLast();
           cap++;
           return true;
       }
       
       /** Get the front item from the deque. */
       public int getFront() {
           if (deque.isEmpty()) return -1;
           return deque.peekFirst();
       }
       
       /** Get the last item from the deque. */
       public int getRear() {
           if (deque.isEmpty()) return -1;
           return deque.peekLast();
       }
       
       /** Checks whether the circular deque is empty or not. */
       public boolean isEmpty() {
           return deque.isEmpty();
       }
       
       /** Checks whether the circular deque is full or not. */
       public boolean isFull() {
           return cap == 0;
       }
   }
   ```

+ #### [42. Trapping Rain Water](https://leetcode-cn.com/problems/trapping-rain-water/)

   Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

   ```
   Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
   Output: 6
   Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
   ```

   **Example 2:**

   ```
   Input: height = [4,2,0,3,2,5]
   Output: 9
   ```

   **Constraints:**

   - `n == height.length`
   - `0 <= n <= 3 * 104`
   - `0 <= height[i] <= 105`

   ```java
   class Solution {
       public int trap(int[] height) {
           Stack<Integer> stack = new Stack<>();
           int res = 0;
           for (int i = 0; i < height.length; i++) {
               while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                   int index = stack.pop();
                   if (stack.isEmpty()) break;
                   int h = height[index];
                   res += (i - stack.peek() - 1) * (Math.min(height[i], height[stack.peek()]) - h);
               }
               stack.push(i);
           }
           return res;
       }
   }
   ```

   ```java
   class Solution {
       public int trap(int[] height) {
           if (height.length == 0) return 0;
           int l = height[0], r = height[height.length - 1]; // max of l & r
           int i = 0, j = height.length - 1;
           int res = 0;
           while (i < j) {
               if (l < r) { // right higher, deside by left_max
                   res += l - height[i];
                   i++;
                   l = Math.max(l, height[i]);
               } else {
                   res += r - height[j];
                   j--;
                   r = Math.max(r, height[j]);
               }
           }
           return res;
       }
   }
   ```

+ Hash Table

   key ---find by **hash function**---> value

   Hash Collisions --> LinkedList

   constantly: HashMap / TreeMap / HashSet / TreeSet

   HashSet's source code: use HashMap's backend, set.add(e) => map.put(e, PRESENT)

   HashMap:

   

   

+ #### [242. Valid Anagram](https://leetcode-cn.com/problems/valid-anagram/)

   Given two strings `s` and `t`, return `true` *if* `t` *is an anagram of* `s`*, and* `false` *otherwise*.

   **Example 1:**

   ```
   Input: s = "anagram", t = "nagaram"
   Output: true
   ```

   **Example 2:**

   ```
   Input: s = "rat", t = "car"
   Output: false
   ```

   **Constraints:**

   - `1 <= s.length, t.length <= 5 * 104`
   - `s` and `t` consist of lowercase English letters.

   ```java
   class Solution {
       public boolean isAnagram(String s, String t) {
           int[] map = new int[26]; // Unicode => 256
           for (char c : s.toCharArray()) {
               map[c - 'a']++;
           }
           for (char c : t.toCharArray()) {
               map[c - 'a']--;
           }
           for (int i = 0; i < 26; i++) {
               if (map[i] != 0) return false;
           }
           return true;
       }
   }
   ```

+ #### [49. Group Anagrams](https://leetcode-cn.com/problems/group-anagrams/)

   Given an array of strings `strs`, group **the anagrams** together. You can return the answer in **any order**.

   An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

   **Example 1:**

   ```
   Input: strs = ["eat","tea","tan","ate","nat","bat"]
   Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
   ```

   **Example 2:**

   ```
   Input: strs = [""]
   Output: [[""]]
   ```

   **Example 3:**

   ```
   Input: strs = ["a"]
   Output: [["a"]]
   ```

   **Constraints:**

   - `1 <= strs.length <= 104`
   - `0 <= strs[i].length <= 100`
   - `strs[i]` consists of lower-case English letters.

   ```java
   class Solution {
       public List<List<String>> groupAnagrams(String[] strs) {
           List<List<String>> res = new ArrayList<>();
           int len = strs.length;
           String[] sortedStrs = new String[len];
           for (int i = 0; i < len; i++) {
               char[] chs = strs[i].toCharArray();
               Arrays.sort(chs);
               sortedStrs[i] = String.valueOf(chs);
           }
           Map<String, List<String>> map = new HashMap<>();
           for (int i = 0; i < len; i++) {
               List<String> list = map.getOrDefault(sortedStrs[i], new ArrayList<>());
               list.add(strs[i]);
               map.put(sortedStrs[i], list);
           }
           for (String key : map.keySet()) {
               res.add(map.get(key));
           }
           return res;
       }
   }
   ```

+ List: one next

   Tree: multi next, no cycle

   Graph: has cycle

+ Binary Search Tree

   left children < root < right children (children! not child!)

   Time Complexity: lookup O(log n), insert O(log n)

+ #### [94. Binary Tree Inorder Traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

   Given the `root` of a binary tree, return *the inorder traversal of its nodes' values*.

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

   ```
   Input: root = [1,null,2,3]
   Output: [1,3,2]
   ```

   **Example 2:**

   ```
   Input: root = []
   Output: []
   ```

   **Example 3:**

   ```
   Input: root = [1]
   Output: [1]
   ```

   **Example 4:**

   ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)

   ```
   Input: root = [1,2]
   Output: [2,1]
   ```

   **Example 5:**

   ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

   ```
   Input: root = [1,null,2]
   Output: [1,2]
   ```

   **Constraints:**

   - The number of nodes in the tree is in the range `[0, 100]`.
   - `-100 <= Node.val <= 100`

   ```java
   class Solution {
       public List<Integer> inorderTraversal(TreeNode root) {
           List<Integer> res = new ArrayList<>();
           helper(res, root);
           return res;
       }
   
       private void helper(List<Integer> list, TreeNode root) {
           if (root == null) return ;
           helper(list, root.left);
           list.add(root.val);
           helper(list, root.right);
       }
   }
   ```

+ #### [144. Binary Tree Preorder Traversal](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

   Given the `root` of a binary tree, return *the preorder traversal of its nodes' values*.

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

   ```
   Input: root = [1,null,2,3]
   Output: [1,2,3]
   ```

   **Example 2:**

   ```
   Input: root = []
   Output: []
   ```

   **Example 3:**

   ```
   Input: root = [1]
   Output: [1]
   ```

   **Example 4:**

   ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)

   ```
   Input: root = [1,2]
   Output: [1,2]
   ```

   **Example 5:**

   ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

   ```
   Input: root = [1,null,2]
   Output: [1,2]
   ```

   **Constraints:**

   - The number of nodes in the tree is in the range `[0, 100]`.
   - `-100 <= Node.val <= 100`

   ```java
   class Solution {
       public List<Integer> preorderTraversal(TreeNode root) {
           List<Integer> res = new ArrayList<>();
           helper(res, root);
           return res;
       }
   
       private void helper(List<Integer> list, TreeNode root) {
           if (root == null) return ;
           list.add(root.val);
           helper(list, root.left);
           helper(list, root.right);
       }
   }
   ```

+ #### [590. N-ary Tree Postorder Traversal](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)

   Given the `root` of an n-ary tree, return *the postorder traversal of its nodes' values*.

   Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

   ```
   Input: root = [1,null,3,2,4,null,5,6]
   Output: [5,6,3,2,4,1]
   ```

   **Example 2:**

   ![img](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)

   ```
   Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
   Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]
   ```

   **Constraints:**

   - The number of nodes in the tree is in the range `[0, 104]`.
   - `0 <= Node.val <= 104`
   - The height of the n-ary tree is less than or equal to `1000`.

    ```java
   class Solution {
       public List<Integer> postorder(Node root) {
           List<Integer> res = new ArrayList<>();
           helper(res, root);
           return res;
       }
   
       private void helper(List<Integer> list, Node root) {
           if (root == null) return ;
           for (Node child : root.children) {
               helper(list, child);
           }
           list.add(root.val);
       }
   }
    ```

+ #### [589. N-ary Tree Preorder Traversal](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

   Given the `root` of an n-ary tree, return *the preorder traversal of its nodes' values*.

   Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

   ```
   Input: root = [1,null,3,2,4,null,5,6]
   Output: [1,3,5,6,2,4]
   ```

   **Example 2:**

   ![img](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)

   ```
   Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
   Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]
   ```

   **Constraints:**

   - The number of nodes in the tree is in the range `[0, 104]`.
   - `0 <= Node.val <= 104`
   - The height of the n-ary tree is less than or equal to `1000`.

   ```java
   class Solution {
       public List<Integer> preorder(Node root) {
           List<Integer> res = new ArrayList<>();
           helper(root, res);
           return res;
       }
   
       private void helper(Node root, List<Integer> list) {
           if (root == null) return ;
           list.add(root.val);
           for (Node child : root.children) {
               helper(child, list);
           }
       }
   }
   ```

+ #### [429. N-ary Tree Level Order Traversal](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

   Given an n-ary tree, return the *level order* traversal of its nodes' values.

   *Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).*

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

   ```
   Input: root = [1,null,3,2,4,null,5,6]
   Output: [[1],[3,2,4],[5,6]]
   ```

   **Example 2:**

   ![img](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)

   ```
   Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
   Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
   ```

   **Constraints:**

   - The height of the n-ary tree is less than or equal to `1000`
   - The total number of nodes is between `[0, 104]`

   ```java
   class Solution {
       public List<List<Integer>> levelOrder(Node root) {
           List<List<Integer>> res = new ArrayList<>();
           if (root == null) return res;
           Deque<Node> queue = new LinkedList<>();
           queue.addLast(root);
           while (!queue.isEmpty()) {
               List<Integer> list = new ArrayList<>();
               int size = queue.size();
               while (size-- > 0) {
                   Node node = queue.pollFirst();
                   list.add(node.val);
                   for (Node child : node.children) {
                       queue.addLast(child);
                   }
               }
               res.add(list);
           }
           return res;
       }
   }
   ```

+ #### [239. Sliding Window Maximum](https://leetcode-cn.com/problems/sliding-window-maximum/)

   You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

   Return *the max sliding window*.

   **Example 1:**

   ```
   Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
   Output: [3,3,5,5,6,7]
   Explanation: 
   Window position                Max
   ---------------               -----
   [1  3  -1] -3  5  3  6  7       3
    1 [3  -1  -3] 5  3  6  7       3
    1  3 [-1  -3  5] 3  6  7       5
    1  3  -1 [-3  5  3] 6  7       5
    1  3  -1  -3 [5  3  6] 7       6
    1  3  -1  -3  5 [3  6  7]      7
   ```

   **Example 2:**

   ```
   Input: nums = [1], k = 1
   Output: [1]
   ```

   **Example 3:**

   ```
   Input: nums = [1,-1], k = 1
   Output: [1,-1]
   ```

   **Example 4:**

   ```
   Input: nums = [9,11], k = 2
   Output: [11]
   ```

   **Example 5:**

   ```
   Input: nums = [4,-2], k = 2
   Output: [4]
   ```

   **Constraints:**

   - `1 <= nums.length <= 105`
   - `-104 <= nums[i] <= 104`
   - `1 <= k <= nums.length`

   ```java
   class Solution {
       public int[] maxSlidingWindow(int[] nums, int k) {
           int len = nums.length;
           int[] res = new int[len - k + 1];
           Deque<Integer> deque = new LinkedList<>();
           for (int i = 0; i < k; i++) {
               while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                   deque.pollLast();
               }
               deque.addLast(i);
           }
           for (int i = k; i < len; i++) {
               int front = deque.peekFirst();
               res[i - k] = nums[front];
               if (front + k <= i) {
                   deque.pollFirst();
               }
               while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                   deque.pollLast();
               }
               deque.addLast(i);
           }
           res[len - k] = nums[deque.peekFirst()];
           return res;
       }
   }
   ```

+ Recursion

   layer by layer

   ```java
   private xxxx recursion(level, param1, param2, ...) {
       // recursion terminator
       if (level > MAX_LEVEL) {
           process_result;
           return xxx;
       }
       
       // process logic in current level
       process(level, data...);
       
       // drill down
       recursion(level + 1, p1, p2, ...);
       
       // reverse the current level status if needed
   }
   ```

+ #### [70. Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/)

   You are climbing a staircase. It takes `n` steps to reach the top.

   Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?

   **Example 1:**

   ```
   Input: n = 2
   Output: 2
   Explanation: There are two ways to climb to the top.
   1. 1 step + 1 step
   2. 2 steps
   ```

   **Example 2:**

   ```
   Input: n = 3
   Output: 3
   Explanation: There are three ways to climb to the top.
   1. 1 step + 1 step + 1 step
   2. 1 step + 2 steps
   3. 2 steps + 1 step
   ```

   **Constraints:**

   - `1 <= n <= 45`

   ```java
   class Solution {
       public int climbStairs(int n) {
           Map<Integer, Integer> map = new HashMap<>();
           map.put(1, 1);
           map.put(2, 2);
           return helper(map, n);
       }
   
       private int helper(Map<Integer, Integer> map, int n) {
           if (map.containsKey(n)) {
               return map.get(n);
           }
           int nStair = helper(map, n-2) + helper(map, n-1);
           map.put(n, nStair);
           return nStair;
       }
   }
   ```

+ #### [22. Generate Parentheses](https://leetcode-cn.com/problems/generate-parentheses/)

   Given `n` pairs of parentheses, write a function to *generate all combinations of well-formed parentheses*.

   **Example 1:**

   ```
   Input: n = 3
   Output: ["((()))","(()())","(())()","()(())","()()()"]
   ```

   **Example 2:**

   ```
   Input: n = 1
   Output: ["()"]
   ```

   **Constraints:**

   - `1 <= n <= 8`

   ```java
   class Solution {
       public List<String> generateParenthesis(int n) {
           List<String> res = new ArrayList<>();
           helper(res, 0, 0, n*2, "");
           return res;
       }
   
       private void helper(List<String> list, int l, int r, int max, String s) {
           if (l + r == max) {
               list.add(s);
               return ;
           }
           if (l < max / 2) helper(list, l + 1, r, max, s + "(");
           if (l > r) helper(list, l, r + 1, max, s + ")");
       }
   }
   ```

+ #### [98. Validate Binary Search Tree](https://leetcode-cn.com/problems/validate-binary-search-tree/)

   Given the `root` of a binary tree, *determine if it is a valid binary search tree (BST)*.

   A **valid BST** is defined as follows:

   - The left subtree of a node contains only nodes with keys **less than** the node's key.
   - The right subtree of a node contains only nodes with keys **greater than** the node's key.
   - Both the left and right subtrees must also be binary search trees.

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

   ```
   Input: root = [2,1,3]
   Output: true
   ```

   **Example 2:**

   ![img](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

   ```
   Input: root = [5,1,4,null,null,3,6]
   Output: false
   Explanation: The root node's value is 5 but its right child's value is 4.
   ```

   **Constraints:**

   - The number of nodes in the tree is in the range `[1, 104]`.
   - `-231 <= Node.val <= 231 - 1`

   ```java
   // inorder
   class Solution {
       private long cur = Long.MIN_VALUE;
       boolean flag = true;
       public boolean isValidBST(TreeNode root) {
           if (root == null) return true;
           if (flag && root.left != null) isValidBST(root.left);
           if (root.val <= cur) flag = false;
           cur = root.val;
           if (flag && root.right != null) isValidBST(root.right);
           return flag;
       }
   }
   ```

   ```java
   // min bound max bound
   class Solution {
       public boolean isValidBST(TreeNode root) {
           if (root == null) return true;
           return recur(root, Long.MIN_VALUE, Long.MAX_VALUE);
       }
   
       private boolean recur(TreeNode root, long min, long max) {
           if (root.val <= min || root.val >= max) {
               return false;
           }
           boolean left = true, right = true;
           if (root.left != null) left = recur(root.left, min, root.val);
           if (root.right != null) right = recur(root.right, root.val, max);
           return left && right;
       }
   }
   ```

+ #### [226. Invert Binary Tree](https://leetcode-cn.com/problems/invert-binary-tree/)

   Given the `root` of a binary tree, invert the tree, and return *its root*.

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

   ```
   Input: root = [4,2,7,1,3,6,9]
   Output: [4,7,2,9,6,3,1]
   ```

   **Example 2:**

   ![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

   ```
   Input: root = [2,1,3]
   Output: [2,3,1]
   ```

   **Example 3:**

   ```
   Input: root = []
   Output: []
   ```

   **Constraints:**

   - The number of nodes in the tree is in the range `[0, 100]`.
   - `-100 <= Node.val <= 100`

   ```java
   class Solution {
       public TreeNode invertTree(TreeNode root) {
           if (root == null) return null;
           TreeNode left = invertTree(root.left);
           TreeNode right = invertTree(root.right);
           root.left = right;
           root.right = left;
           return root;
       }
   }
   ```

+ #### [104. Maximum Depth of Binary Tree](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

   Given the `root` of a binary tree, return *its maximum depth*.

   A binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

   ```
   Input: root = [3,9,20,null,null,15,7]
   Output: 3
   ```

   **Example 2:**

   ```
   Input: root = [1,null,2]
   Output: 2
   ```

   **Example 3:**

   ```
   Input: root = []
   Output: 0
   ```

   **Example 4:**

   ```
   Input: root = [0]
   Output: 1
   ```

   **Constraints:**

   - The number of nodes in the tree is in the range `[0, 104]`.
   - `-100 <= Node.val <= 100`

   ```java
   class Solution {
       public int maxDepth(TreeNode root) {
           if (root == null) return 0;
           return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
       }
   }
   ```

+ #### [111. Minimum Depth of Binary Tree](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

   Given a binary tree, find its minimum depth.

   The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

   **Note:** A leaf is a node with no children.

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

   ```
   Input: root = [3,9,20,null,null,15,7]
   Output: 2
   ```

   **Example 2:**

   ```
   Input: root = [2,null,3,null,4,null,5,null,6]
   Output: 5
   ```

   **Constraints:**

   - The number of nodes in the tree is in the range `[0, 105]`.
   - `-1000 <= Node.val <= 1000`

   ```java
   class Solution {
       public int minDepth(TreeNode root) {
           if (root == null) return 0;
           if (root.left == null && root.right == null) {
               return 1;
           }
           int left = root.left == null ? Integer.MAX_VALUE : minDepth(root.left);
           int right = root.right == null ? Integer.MAX_VALUE : minDepth(root.right);
           return 1 + Math.min(left, right);
       }
   }
   ```

+ #### [236. Lowest Common Ancestor of a Binary Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

   Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

   According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

   ```
   Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
   Output: 3
   Explanation: The LCA of nodes 5 and 1 is 3.
   ```

   **Example 2:**

   ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

   ```
   Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
   Output: 5
   Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
   ```

   **Example 3:**

   ```
   Input: root = [1,2], p = 1, q = 2
   Output: 1
   ```

   **Constraints:**

   - The number of nodes in the tree is in the range `[2, 105]`.
   - `-109 <= Node.val <= 109`
   - All `Node.val` are **unique**.
   - `p != q`
   - `p` and `q` will exist in the tree.

   ```java
   class Solution {
       public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
           if(root == null || root == p || root == q) return root;
           TreeNode left = lowestCommonAncestor(root.left, p, q);
           TreeNode right = lowestCommonAncestor(root.right, p, q);
           if(left == null) return right;
           if(right == null) return left;
           return root;
       }
   }
   ```

+ #### [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

   Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return *the binary tree*.

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

   ```
   Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
   Output: [3,9,20,null,null,15,7]
   ```

   **Example 2:**

   ```
   Input: preorder = [-1], inorder = [-1]
   Output: [-1]
   ```

   **Constraints:**

   - `1 <= preorder.length <= 3000`
   - `inorder.length == preorder.length`
   - `-3000 <= preorder[i], inorder[i] <= 3000`
   - `preorder` and `inorder` consist of **unique** values.
   - Each value of `inorder` also appears in `preorder`.
   - `preorder` is **guaranteed** to be the preorder traversal of the tree.
   - `inorder` is **guaranteed** to be the inorder traversal of the tree.

   ```java
   class Solution {
       public TreeNode buildTree(int[] preorder, int[] inorder) {
           int len = preorder.length;
           if (len == 0) return null;
           return recur(preorder, 0, len - 1, inorder, 0, len - 1);
       }
   
       private TreeNode recur(int[] preorder, int pl, int pr, int[] inorder, int il, int ir) {
           if (pl > pr) return null;
           TreeNode root = new TreeNode(preorder[pl]);
           int i = il;
           for ( ; i <= ir; i++) {
               if (preorder[pl] == inorder[i]) {
                   break;
               }
           }
           int leftNums = i - il;
           TreeNode left = recur(preorder, pl + 1, pl + 1 + leftNums - 1, inorder, il, i - 1);
           TreeNode right = recur(preorder, pl + 1 + leftNums, pr, inorder, i + 1, ir);
           root.left = left;
           root.right = right;
           return root;
       }
   }
   ```

+ #### [77. Combinations](https://leetcode-cn.com/problems/combinations/)

   Given two integers *n* and *k*, return all possible combinations of *k* numbers out of 1 ... *n*.

   You may return the answer in **any order**.

   **Example 1:**

   ```
   Input: n = 4, k = 2
   Output:
   [
     [2,4],
     [3,4],
     [2,3],
     [1,2],
     [1,3],
     [1,4],
   ]
   ```

   **Example 2:**

   ```
   Input: n = 1, k = 1
   Output: [[1]]
   ```

   **Constraints:**

   - `1 <= n <= 20`
   - `1 <= k <= n`

   ```java
   class Solution {
       public List<List<Integer>> combine(int n, int k) {
           List<List<Integer>> res = new ArrayList<>();
           List<Integer> list = new ArrayList<>();
           recur(res, n, k, list, 1);
           return res;
       }
   
       private void recur(List<List<Integer>> lists, int n, int k, List<Integer> list, int num) {
           if (list.size() == k) {
               lists.add(new ArrayList(list));
               return ;
           }
           for (int i = num; i <= n; i++) {
               list.add(i);
               recur(lists, n, k, list, i + 1);
               list.remove(list.size() - 1);
           }
       }
   }
   ```

+ Division

   find sub-problems, split and merge

   ```python
   def divide_conquer(problem, param1, param2, ...):
       # recursion terminator
       if problem is None:
           print_result
           return
       # prepare data
       data = prepare_data(problem)
       subproblems = split_problem(problem, data)
       # conquer subproblems
       subresult1 = self.divide_conquer(subproblems[0], p1, p2, ...)
       subresult2 = self.divide_conquer(subproblems[1], p1, p2, ...)
       subresult3 = self.divide_conquer(subproblems[2], p1, p2, ...)
       ...
       # process and generate the final result
       result = process_result(subresult1, subresult2, subresult3, ...)
       
       # revert the current level states
   ```

+ BackTracking

+ #### [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

   Implement [pow(*x*, *n*)](http://www.cplusplus.com/reference/valarray/pow/), which calculates *x* raised to the power *n* (i.e. xn).

   **Example 1:**

   ```
   Input: x = 2.00000, n = 10
   Output: 1024.00000
   ```

   **Example 2:**

   ```
   Input: x = 2.10000, n = 3
   Output: 9.26100
   ```

   **Example 3:**

   ```
   Input: x = 2.00000, n = -2
   Output: 0.25000
   Explanation: 2-2 = 1/22 = 1/4 = 0.25
   ```

   **Constraints:**

   - `-100.0 < x < 100.0`
   - `-231 <= n <= 231-1`
   - `-104 <= xn <= 104`

   ```java
   class Solution {
       public double myPow(double x, int n) {
           if (x == 0 || x == 1) return x;
           if (n == 0) return 1;
           long n1 = n;
           if (n1 < 0) {
               x = 1 / x;
               n1 = -n1;
           }
           return divide(x, n1);
       }
   
       private double divide(double x, long n) {
           if (n == 1) return x;
           double subresult = divide(x, n/2);
           return subresult * subresult * (n%2 == 0 ? 1 : x);
       }
   }
   ```

+ #### [78. Subsets](https://leetcode-cn.com/problems/subsets/)

   Given an integer array `nums` of **unique** elements, return *all possible subsets (the power set)*.

   The solution set **must not** contain duplicate subsets. Return the solution in **any order**.

   **Example 1:**

   ```
   Input: nums = [1,2,3]
   Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
   ```

   **Example 2:**

   ```
   Input: nums = [0]
   Output: [[],[0]]
   ```

   **Constraints:**

   - `1 <= nums.length <= 10`
   - `-10 <= nums[i] <= 10`
   - All the numbers of `nums` are **unique**.

   ```java
   class Solution {
       public List<List<Integer>> subsets(int[] nums) {
           List<List<Integer>> res = new ArrayList<>();
           List<Integer> list = new ArrayList<>();
           dfs(res, list, nums, 0);
           return res;
       }
   
       private void dfs(List<List<Integer>> res, List<Integer> list, int[] nums, int number) {
           if (number == nums.length) {
               res.add(new ArrayList<>(list));
               return ;
           }
           // branch1
           dfs(res, list, nums, number + 1);
           // branch2
           list.add(nums[number]);
           dfs(res, list, nums, number + 1);
           list.remove(list.size() - 1);
       }
   }
   ```

   ```java
   class Solution {
       public List<List<Integer>> subsets(int[] nums) {
           List<List<Integer>> res = new ArrayList<>();
           res.add(new ArrayList<>());
           for (int i = 0; i < nums.length; i++) {
               for (int j = 0; j < (int)Math.pow(2, i); j++) {
                   List<Integer> list = new ArrayList<>(res.get(j));
                   list.add(nums[i]);
                   res.add(list);
               }
           }
           return res;
       }
   }
   ```

+ #### [169. Majority Element](https://leetcode-cn.com/problems/majority-element/)

   Given an array `nums` of size `n`, return *the majority element*.

   The majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.

   **Example 1:**

   ```
   Input: nums = [3,2,3]
   Output: 3
   ```

   **Example 2:**

   ```
   Input: nums = [2,2,1,1,1,2,2]
   Output: 2
   ```

   **Constraints:**

   - `n == nums.length`
   - `1 <= n <= 5 * 104`
   - `-231 <= nums[i] <= 231 - 1`

   ```java
   class Solution {
       public int majorityElement(int[] nums) {
           int res = nums[0], quantity = 1;
           for (int i = 1; i < nums.length; i++) {
               if (nums[i] == res) quantity++;
               else if (quantity > 0) quantity--;
               else {
                   res = nums[i];
                   quantity = 1;
               }
           }
           return res;
       }
   }
   ```

   ```java
   class Solution {
       public int majorityElement(int[] nums) {
           Arrays.sort(nums);
           return nums[nums.length / 2];
       }
   }
   ```

   ```java
   // divise for division
   class Solution {
       private int countInRange(int[] nums, int num, int lo, int hi) {
           int count = 0;
           for (int i = lo; i <= hi; i++) {
               if (nums[i] == num) {
                   count++;
               }
           }
           return count;
       }
   
       private int majorityElementRec(int[] nums, int lo, int hi) {
           // base case; 
           // the only element in an array of size 1 is the majority element.
           if (lo == hi) {
               return nums[lo];
           }
   
           // recurse on left and right halves of this slice.
           int mid = (hi - lo) / 2 + lo;
           int left = majorityElementRec(nums, lo, mid);
           int right = majorityElementRec(nums, mid + 1, hi);
   
           // if the two halves agree on the majority element, return it.
           if (left == right) {
               return left;
           }
   
           // otherwise, count each element and return the "winner".
           int leftCount = countInRange(nums, left, lo, hi);
           int rightCount = countInRange(nums, right, lo, hi);
   
           return leftCount > rightCount ? left : right;
       }
   
       public int majorityElement(int[] nums) {
           return majorityElementRec(nums, 0, nums.length - 1);
       }
   }
   ```

+ #### [17. Letter Combinations of a Phone Number](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

   Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.

   A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

   ![img](https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)

   **Example 1:**

   ```
   Input: digits = "23"
   Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
   ```

   **Example 2:**

   ```
   Input: digits = ""
   Output: []
   ```

   **Example 3:**

   ```
   Input: digits = "2"
   Output: ["a","b","c"]
   ```

   **Constraints:**

   - `0 <= digits.length <= 4`
   - `digits[i]` is a digit in the range `['2', '9']`.

   ```java
   class Solution {
       String[] letters = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
       public List<String> letterCombinations(String digits) {
           List<String> res = new ArrayList<>();
           if (digits == null || digits.length() == 0) return res;
           StringBuilder sb = new StringBuilder();
           dfs(res, sb, digits, 0);
           return res;
       }
   
       private void dfs(List<String> res, StringBuilder sb, String digits, int index) {
           if (index == digits.length()) {
               res.add(String.valueOf(sb));
               return ;
           }
           for (char ch : letters[digits.charAt(index) - '0'].toCharArray()) {
               sb.append(ch);
               dfs(res, sb, digits, index + 1);
               sb.deleteCharAt(sb.length() - 1);
           }
       } 
   }
   ```

+ #### [51. N-Queens](https://leetcode-cn.com/problems/n-queens/)

   The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.

   Given an integer `n`, return *all distinct solutions to the **n-queens puzzle***.

   Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

   ```
   Input: n = 4
   Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
   Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above
   ```

   **Example 2:**

   ```
   Input: n = 1
   Output: [["Q"]]
   ```

   **Constraints:**

   - `1 <= n <= 9`

   ```java
   class Solution {
       public List<List<String>> solveNQueens(int n) {
           List<List<String>> res = new ArrayList<>();
           char[][] board = new char[n][n];
           for (int i = 0; i < n; i++) {
               for (int j = 0; j < n; j++) {
                   board[i][j] = '.';
               }
           }
           Set[] sets = new Set[3]; // |:j, \:j-i, /:i+j
           for (int i = 0; i < 3; i++) {
               sets[i] = new HashSet<>();
           }
           dfs(res, board,0, n, sets);
           return res;
       }
   
       private void dfs(List<List<String>> res, char[][] board, int i, int n, Set[] sets) {
           if (i == n) {
               List<String> list = new ArrayList<>();
               for (char[] chs : board) {
                   list.add(String.valueOf(chs));
               }
               res.add(list);
               return ;
           }
           for (int j = 0; j < n; j++) {
               if (sets[0].contains(j) || sets[1].contains(j-i) || sets[2].contains(i+j)) {
                   continue;
               }
               board[i][j] = 'Q';
               sets[0].add(j);
               sets[1].add(j-i);
               sets[2].add(i+j);
               dfs(res, board, i + 1, n, sets);
               board[i][j] = '.';
               sets[0].remove(j);
               sets[1].remove(j-i);
               sets[2].remove(i+j);
           }
       }
   }
   ```

+ dfs & bfs

   ergodic: every node lookup once

   ```python
   # dfs - recursion
   def dfs(node):
       if node in visited:
           # already visited
           return
       
       visited.add(node)
       
       # process current logic
       
       for next_node in node.nexts:
           dfs(next_node)
           
   # dfs - not recursion, use stack
   def dfs(root):
       if root is None:
           return []
       
       visited, stack = [], [root]
       
       while stack:
           node = stack.pop()
           visited.add(node)
           
           # process current node
           
           for next_node in node.nexts:
           	stack.push(next_node)
               
           # other processing work
   ```

   ```python
   # bfs - use queue
   def bfs(graph, start, end)：
   	queue = []
       queue.append(start)
       visited.add(start)
       
       while queue:
           node = queue.pop()
           visited.add(node)
           
           process(node)
           for next_node in node.nexts:
           	queue.push(next_node)
               
           # other processing work
   ```

+ #### [102. Binary Tree Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

   Given the `root` of a binary tree, return *the level order traversal of its nodes' values*. (i.e., from left to right, level by level).

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

   ```
   Input: root = [3,9,20,null,null,15,7]
   Output: [[3],[9,20],[15,7]]
   ```

   **Example 2:**

   ```
   Input: root = [1]
   Output: [[1]]
   ```

   **Example 3:**

   ```
   Input: root = []
   Output: []
   ```

   **Constraints:**

   - The number of nodes in the tree is in the range `[0, 2000]`.
   - `-1000 <= Node.val <= 1000`

   ```java
   // bfs - 1ms
   class Solution {
       public List<List<Integer>> levelOrder(TreeNode root) {
           List<List<Integer>> res = new ArrayList<>();
           if (root == null) return res;
           Deque<TreeNode> queue = new LinkedList<>();
           queue.addLast(root);
           while (!queue.isEmpty()) {
               int size = queue.size();
               List<Integer> list = new LinkedList<>();
               while (size-- > 0) {
                   TreeNode node = queue.pollFirst();
                   list.add(node.val);
                   if (node.left != null) queue.addLast(node.left);
                   if (node.right != null) queue.addLast(node.right);
               }
               res.add(list);
           }
           return res;
       }
   }
   
   // dfs - 0ms
   class Solution {
       public List<List<Integer>> levelOrder(TreeNode root) {
           List<List<Integer>> res = new ArrayList<>();
           if (root == null) return res;
           dfs(res, root, 1);
           return res;
       }
   
       private void dfs(List<List<Integer>> res, TreeNode root, int deep) {
           if (root == null) return ;
           if (deep > res.size()) {
               res.add(new ArrayList<>());
           }
           res.get(deep - 1).add(root.val);
           dfs(res, root.left, deep + 1);
           dfs(res, root.right, deep + 1);
       }
   }
   ```

+ #### [433. Minimum Genetic Mutation](https://leetcode-cn.com/problems/minimum-genetic-mutation/)

   A gene string can be represented by an 8-character long string, with choices from `"A"`, `"C"`, `"G"`, `"T"`.

   Suppose we need to investigate about a mutation (mutation from "start" to "end"), where ONE mutation is defined as ONE single character changed in the gene string.

   For example, `"AACCGGTT"` -> `"AACCGGTA"` is 1 mutation.

   Also, there is a given gene "bank", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.

   Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from "start" to "end". If there is no such a mutation, return -1.

   **Note:**

   1. Starting point is assumed to be valid, so it might not be included in the bank.
   2. If multiple mutations are needed, all mutations during in the sequence must be valid.
   3. You may assume start and end string is not the same.

   **Example 1:**

   ```
   start: "AACCGGTT"
   end:   "AACCGGTA"
   bank: ["AACCGGTA"]
   
   return: 1
   ```

   **Example 2:**

   ```
   start: "AACCGGTT"
   end:   "AAACGGTA"
   bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]
   
   return: 2
   ```

   **Example 3:**

   ```
   start: "AAAAACCC"
   end:   "AACCCCCC"
   bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]
   
   return: 3
   ```

   ```java
   class Solution {
       public int minMutation(String start, String end, String[] bank) {
           int n = bank.length;
           boolean[] visited = new boolean[n];
           int res = 0;
           Deque<String> queue = new LinkedList<>();
           queue.addLast(start);
           while (!queue.isEmpty()) {
               int size = queue.size();
               res++;
               while (size-- > 0) {
                   String s = queue.pollFirst();
                   for (int i = 0; i < n; i++) {
                       if (visited[i]) continue;
                       if (can(s, bank[i])) {
                           if (bank[i].equals(end)) return res;
                           queue.addLast(bank[i]);
                           visited[i] = true;
                       }
                   }
               }
           }
           return -1;
       }
   
       private boolean can(String s, String t) {
           boolean flag = false;
           for (int i = 0; i < 8; i++) {
               if (s.charAt(i) != t.charAt(i)) {
                   if (flag) return false;
                   flag = true;
               }
           }
           return true;
       }
   }
   ```

+ #### [515. Find Largest Value in Each Tree Row](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

   Given the `root` of a binary tree, return *an array of the largest value in each row* of the tree **(0-indexed)**.

    

   **Example 1:**

   ![img](https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg)

   ```
   Input: root = [1,3,2,5,3,null,9]
   Output: [1,3,9]
   ```

   **Example 2:**

   ```
   Input: root = [1,2,3]
   Output: [1,3]
   ```

   **Example 3:**

   ```
   Input: root = [1]
   Output: [1]
   ```

   **Example 4:**

   ```
   Input: root = [1,null,2]
   Output: [1,2]
   ```

   **Example 5:**

   ```
   Input: root = []
   Output: []
   ```

   **Constraints:**

   - The number of nodes in the tree will be in the range `[0, 104]`.
   - `-231 <= Node.val <= 231 - 1`

   ```java
   class Solution {
       public List<Integer> largestValues(TreeNode root) {
           List<Integer> res = new ArrayList<>();
           bfs(res, root, 1);
           return res;
       }
   
       private void bfs(List<Integer> res, TreeNode root, int deep) {
           if (root == null) return ;
           if (deep > res.size()) {
               res.add(root.val);
           } else {
               res.set(deep - 1, Math.max(res.get(deep - 1), root.val));
           }
           bfs(res, root.left, deep + 1);
           bfs(res, root.right, deep + 1);
       }
   }
   ```

+ #### [46. Permutations](https://leetcode-cn.com/problems/permutations/)

   Given an array `nums` of distinct integers, return *all the possible permutations*. You can return the answer in **any order**.

   **Example 1:**

   ```
   Input: nums = [1,2,3]
   Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
   ```

   **Example 2:**

   ```
   Input: nums = [0,1]
   Output: [[0,1],[1,0]]
   ```

   **Example 3:**

   ```
   Input: nums = [1]
   Output: [[1]]
   ```

   **Constraints:**

   - `1 <= nums.length <= 6`
   - `-10 <= nums[i] <= 10`
   - All the integers of `nums` are **unique**.

   ```java
   class Solution {
       public List<List<Integer>> permute(int[] nums) {
           List<List<Integer>> res = new ArrayList<>();
           int n = nums.length;
           boolean[] visited = new boolean[n];
           List<Integer> list = new ArrayList<>();
           dfs(nums, res, list, visited, n);
           return res;
       }
   
       private void dfs(int[] nums, List<List<Integer>> res, List<Integer> list, boolean[] visited, int n) {
           int size = list.size();
           if (size == n) {
               res.add(new ArrayList<>(list));
               return ;
           }
           for (int i = 0; i < n; i++) {
               if (visited[i]) continue;
               list.add(nums[i]);
               visited[i] = true;
               dfs(nums, res, list, visited, n);
               visited[i] = false;
               list.remove(size);
           }
       }
   }
   ```


+ Greedy

  best in present

  The difference between Greedy and Dynamic Programming is that it makes choices on the solutions of each sub-problem and can't rollback. 

  Dynamic Programming saves the previous operation results, and selects the current according to the previous results, and has the function of rollback.

+ #### [455. Assign Cookies](https://leetcode-cn.com/problems/assign-cookies/)

  Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.

  Each child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with; and each cookie `j` has a size `s[j]`. If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`, and the child `i` will be content. Your goal is to maximize the number of your content children and output the maximum number.

  **Example 1:**

  ```
  Input: g = [1,2,3], s = [1,1]
  Output: 1
  Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
  And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
  You need to output 1.
  ```

  **Example 2:**

  ```
  Input: g = [1,2], s = [1,2,3]
  Output: 2
  Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
  You have 3 cookies and their sizes are big enough to gratify all of the children, 
  You need to output 2.
  ```

  **Constraints:**

  - `1 <= g.length <= 3 * 104`
  - `0 <= s.length <= 3 * 104`
  - `1 <= g[i], s[j] <= 231 - 1`

  ```java
  class Solution {
      public int findContentChildren(int[] g, int[] s) {
          int res = 0;
          Arrays.sort(g);
          Arrays.sort(s);
          for (int i = 0, j = 0; i < g.length && j < s.length; j++) {
              if (g[i] <= s[j]) {
                  res++;
                  i++;
              } 
          }
          return res;
      }
  }
  ```

+ #### [122. Best Time to Buy and Sell Stock II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

  You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

  Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

  **Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

  **Example 1:**

  ```
  Input: prices = [7,1,5,3,6,4]
  Output: 7
  Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
  Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
  ```

  **Example 2:**

  ```
  Input: prices = [1,2,3,4,5]
  Output: 4
  Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
  Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.
  ```

  **Example 3:**

  ```
  Input: prices = [7,6,4,3,1]
  Output: 0
  Explanation: In this case, no transaction is done, i.e., max profit = 0.
  ```

  **Constraints:**

  - `1 <= prices.length <= 3 * 104`
  - `0 <= prices[i] <= 104`

  ```java
  class Solution {
      public int maxProfit(int[] prices) {
          int res = 0;
          for (int i = 1; i < prices.length; i++) {
              res += Math.max(0, prices[i] - prices[i - 1]);
          }
          return res;
      }
  }
  ```

+ #### [55. Jump Game](https://leetcode-cn.com/problems/jump-game/)

  Given an array of non-negative integers `nums`, you are initially positioned at the **first index** of the array.

  Each element in the array represents your maximum jump length at that position.

  Determine if you are able to reach the last index.

  **Example 1:**

  ```
  Input: nums = [2,3,1,1,4]
  Output: true
  Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
  ```

  **Example 2:**

  ```
  Input: nums = [3,2,1,0,4]
  Output: false
  Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
  ```

  **Constraints:**

  - `1 <= nums.length <= 3 * 104`
  - `0 <= nums[i] <= 105`

  ```java
  class Solution {
      public boolean canJump(int[] nums) {
          int end = nums.length - 1;
          for (int i = end; i >= 0; i--) {
              if (nums[i] + i >= end) {
                  end = i;
              }
          }
          return end == 0;
      }
  }
  ```

+ #### [45. Jump Game II](https://leetcode-cn.com/problems/jump-game-ii/)

  Given an array of non-negative integers `nums`, you are initially positioned at the first index of the array.

  Each element in the array represents your maximum jump length at that position.

  Your goal is to reach the last index in the minimum number of jumps.

  You can assume that you can always reach the last index.

  **Example 1:**

  ```
  Input: nums = [2,3,1,1,4]
  Output: 2
  Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
  ```

  **Example 2:**

  ```
  Input: nums = [2,3,0,1,4]
  Output: 2
  ```

  **Constraints:**

  - `1 <= nums.length <= 1000`
  - `0 <= nums[i] <= 105`

  ```java
  class Solution {
      public int jump(int[] nums) {
          if (nums.length < 2) return 0;
          int bound = 0;
          int time = 0;
          int end = 0;
          for (int i = 0; i < nums.length; ) {
              time++;
              for (int j = i; j <= bound; j++) {
                  end = Math.max(end, j + nums[j]);
              }
              if (end >= nums.length - 1) break;
              i = bound + 1;
              bound = end;
          }
          return time;
      }
  }
  ```

+ #### [860. Lemonade Change](https://leetcode-cn.com/problems/lemonade-change/)

  At a lemonade stand, each lemonade costs `$5`. 

  Customers are standing in a queue to buy from you, and order one at a time (in the order specified by `bills`).

  Each customer will only buy one lemonade and pay with either a `$5`, `$10`, or `$20` bill. You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.

  Note that you don't have any change in hand at first.

  Return `true` if and only if you can provide every customer with correct change.

  **Example 1:**

  ```
  Input: [5,5,5,10,20]
  Output: true
  Explanation: 
  From the first 3 customers, we collect three $5 bills in order.
  From the fourth customer, we collect a $10 bill and give back a $5.
  From the fifth customer, we give a $10 bill and a $5 bill.
  Since all customers got correct change, we output true.
  ```

  **Example 2:**

  ```
  Input: [5,5,10]
  Output: true
  ```

  **Example 3:**

  ```
  Input: [10,10]
  Output: false
  ```

  **Example 4:**

  ```
  Input: [5,5,10,10,20]
  Output: false
  Explanation: 
  From the first two customers in order, we collect two $5 bills.
  For the next two customers in order, we collect a $10 bill and give back a $5 bill.
  For the last customer, we can't give change of $15 back because we only have two $10 bills.
  Since not every customer received correct change, the answer is false.
  ```

  **Note:**

  - `0 <= bills.length <= 10000`
  - `bills[i]` will be either `5`, `10`, or `20`.

  ```java
  class Solution {
      public boolean lemonadeChange(int[] bills) {
          int[] bucks = new int[2];
          for (int bill : bills) {
              if (bill == 5) {
                  bucks[0]++;
              } else if (bill == 10) {
                  if (bucks[0] == 0) return false;
                  bucks[0]--;
                  bucks[1]++;
              } else if (bucks[1] > 0) {
                  bill -= 10;
                  bucks[1] --;
                  if (bucks[0] == 0) return false;
                  bucks[0]--;
              } else {
                  if (bucks[0] < 3) return false;
                  bucks[0] -= 3;
              }
          }
          return true;
      }
  }
  ```

+ #### [200. Number of Islands](https://leetcode-cn.com/problems/number-of-islands/)

  Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*.

  An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

  **Example 1:**

  ```
  Input: grid = [
    ["1","1","1","1","0"],
    ["1","1","0","1","0"],
    ["1","1","0","0","0"],
    ["0","0","0","0","0"]
  ]
  Output: 1
  ```

  **Example 2:**

  ```
  Input: grid = [
    ["1","1","0","0","0"],
    ["1","1","0","0","0"],
    ["0","0","1","0","0"],
    ["0","0","0","1","1"]
  ]
  Output: 3
  ```

  **Constraints:**

  - `m == grid.length`
  - `n == grid[i].length`
  - `1 <= m, n <= 300`
  - `grid[i][j]` is `'0'` or `'1'`.

  ```java
  class Solution {
      int[][] directs = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
      public int numIslands(char[][] grid) {
          int res = 0;
          int m = grid.length, n = grid[0].length;
          for (int i = 0; i < m; i++) {
              for (int j = 0; j < n; j++) {
                  if (grid[i][j] == '0') continue;
                  res++;
                  sink(grid, i, j);
              }
          }
          return res;
      }
  
      private void sink(char[][] grid, int i, int j) {
          grid[i][j] = '0';
          for (int[] dir : directs) {
              int x = i + dir[0], y = j + dir[1];
              if (in(grid, x, y) && grid[x][y] == '1') {
                  sink(grid, x, y);
              }
          }
      }
  
      private boolean in(char[][] grid, int x, int y) {
          return x >= 0 && y >= 0 && x < grid.length && y < grid[0].length;
      }
  }
  ```

+ #### [874. Walking Robot Simulation](https://leetcode-cn.com/problems/walking-robot-simulation/)

  A robot on an infinite XY-plane starts at point `(0, 0)` and faces north. The robot can receive one of three possible types of `commands`:

  - `-2`: turn left `90` degrees,
  - `-1`: turn right `90` degrees, or
  - `1 <= k <= 9`: move forward `k` units.

  Some of the grid squares are `obstacles`. The `ith` obstacle is at grid point `obstacles[i] = (xi, yi)`.

  If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)

  Return *the maximum Euclidean distance that the robot will be from the origin **squared** (i.e. if the distance is* `5`*, return* `25`*)*.

  **Note:**

  - North means +Y direction.
  - East means +X direction.
  - South means -Y direction.
  - West means -X direction.

  **Example 1:**

  ```
  Input: commands = [4,-1,3], obstacles = []
  Output: 25
  Explanation: The robot starts at (0, 0):
  1. Move north 4 units to (0, 4).
  2. Turn right.
  3. Move east 3 units to (3, 4).
  The furthest point away from the origin is (3, 4), which is 32 + 42 = 25 units away.
  ```

  **Example 2:**

  ```
  Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
  Output: 65
  Explanation: The robot starts at (0, 0):
  1. Move north 4 units to (0, 4).
  2. Turn right.
  3. Move east 1 unit and get blocked by the obstacle at (2, 4), robot is at (1, 4).
  4. Turn left.
  5. Move north 4 units to (1, 8).
  The furthest point away from the origin is (1, 8), which is 12 + 82 = 65 units away.
  ```

  **Constraints:**

  - `1 <= commands.length <= 104`
  - `commands[i]` is one of the values in the list `[-2,-1,1,2,3,4,5,6,7,8,9]`.
  - `0 <= obstacles.length <= 104`
  - `-3 * 104 <= xi, yi <= 3 * 104`
  - The answer is guaranteed to be less than `231`.

  ```java
  class Solution {
      int[][] dirs = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}}; // ->left  <-right
      Set<String> set = new HashSet<>();
      int max = 0;
      public int robotSim(int[] commands, int[][] obstacles) {
          int[] pos = {0, 0};
          for (int[] obstacle : obstacles) {
              set.add(""+obstacle[0]+","+obstacle[1]);
          }
          dfs(pos, 0, commands, 0);
          return max;
      }
  
      private void dfs(int[] pos, int face, int[] commands, int i) {
          if (i == commands.length) return;
          if (commands[i] < 0) {
              face = (face + (commands[i] == -2 ? 1 : 3)) % 4;
              i++;
          } else {
              int[] next = {pos[0] + dirs[face][0], pos[1] + dirs[face][1]};
              if (set.contains(""+next[0]+","+next[1])) {
                  i++;
              } else {
                  commands[i]--;
                  pos[0] = next[0];
                  pos[1] = next[1];
                  max = Math.max(max, pos[0]*pos[0] + pos[1]*pos[1]);
                  if (commands[i] == 0) i++;
              }
          }
          dfs(pos, face, commands, i);
      }
  }
  ```

+ #### [127. Word Ladder](https://leetcode-cn.com/problems/word-ladder/)

  A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words such that:

  - The first word in the sequence is `beginWord`.
  - The last word in the sequence is `endWord`.
  - Only one letter is different between each adjacent pair of words in the sequence.
  - Every word in the sequence is in `wordList`.

  Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return *the **number of words** in the **shortest transformation sequence** from* `beginWord` *to* `endWord`*, or* `0` *if no such sequence exists.*

  **Example 1:**

  ```
  Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
  Output: 5
  Explanation: One shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog" with 5 words.
  ```

  **Example 2:**

  ```
  Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
  Output: 0
  Explanation: The endWord "cog" is not in wordList, therefore there is no possible transformation.
  ```

  **Constraints:**

  - `1 <= beginWord.length <= 10`
  - `endWord.length == beginWord.length`
  - `1 <= wordList.length <= 5000`
  - `wordList[i].length == beginWord.length`
  - `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.
  - `beginWord != endWord`
  - All the strings in `wordList` are **unique**.

  ```java
  class Solution {
      public int ladderLength(String beginWord, String endWord, List<String> wordList) {
          Deque<String> deque = new LinkedList<>();
          deque.addLast(beginWord);
          Set<String> set = new HashSet<>();
          int res = 0;
          while (!deque.isEmpty()) {
              int size = deque.size();
              res++;
              while (size-- > 0) {
                  String s = deque.pollFirst();
                  if (s.equals(endWord)) return res;
                  for (String t : wordList) {
                      if (set.size() == wordList.size()) break;
                      if (set.contains(t)) continue;
                      if (can(s, t)) {
                          deque.addLast(t);
                          set.add(t);
                      }
                  }
              }
          }
          return 0;
      }
      private boolean can(String s, String t) {
          boolean flag = true;
          for (int i = 0; i < s.length(); i++) {
              if (s.charAt(i) != t.charAt(i)) {
                  if (flag) flag = false;
                  else return false;
              }
          }
          return true;
      }
  }
  ```

+ Binary Search

  premise : 1. monotonicity 2. exist upper and lower bound 3. index accessible

  ```python
  left, right = 0, len(array) - 1
  while left <= right:
      mid = (right - left) / 2 + left
      if array[mid] == target:
          # find the target !
          break or return result
      elif array[mid] < target:
          left = mid + 1
      else
      	right = mid - 1
  ```

+ #### [69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/)

  Given a non-negative integer `x`, compute and return *the square root of* `x`.

  Since the return type is an integer, the decimal digits are **truncated**, and only **the integer part** of the result is returned.

  **Example 1:**

  ```
  Input: x = 4
  Output: 2
  ```

  **Example 2:**

  ```
  Input: x = 8
  Output: 2
  Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.
  ```

  ```java
  class Solution {
      public int mySqrt(int x) {
          if (x == 0 || x == 1) {
              return x;
          }
          int left = 1, right = x;
          while (left <= right) {
              int mid = left + (right - left) / 2;
              if ((long)mid * mid > x) {
                  right = mid - 1;
              } else {
                  left = mid + 1;
              }
          }
          return right;
      }
  }
  ```

  ```java
  // Newton iterative method
  class Solution {
      public int mySqrt(int x) {
          if (x == 0) {
              return 0;
          }
  
          double C = x, x0 = x;
          while (true) {
              double xi = 0.5 * (x0 + C / x0);
              if (Math.abs(x0 - xi) < 1e-7) {
                  break;
              }
              x0 = xi;
          }
          return (int) x0;
      }
  }
  ```

+ #### [33. Search in Rotated Sorted Array](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

  There is an integer array `nums` sorted in ascending order (with **distinct** values).

  Prior to being passed to your function, `nums` is **rotated** at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

  Given the array `nums` **after** the rotation and an integer `target`, return *the index of* `target` *if it is in* `nums`*, or* `-1` *if it is not in* `nums`.

  **Example 1:**

  ```
  Input: nums = [4,5,6,7,0,1,2], target = 0
  Output: 4
  ```

  **Example 2:**

  ```
  Input: nums = [4,5,6,7,0,1,2], target = 3
  Output: -1
  ```

  **Example 3:**

  ```
  Input: nums = [1], target = 0
  Output: -1
  ```

  **Constraints:**

  - `1 <= nums.length <= 5000`
  - `-104 <= nums[i] <= 104`
  - All values of `nums` are **unique**.
  - `nums` is guaranteed to be rotated at some pivot.
  - `-104 <= target <= 104`

  ```java
  class Solution {
      public int search(int[] nums, int target) {
          int left = 0, right = nums.length - 1;
          while (left <= right) {
              int mid = (right - left) / 2 + left;
              if (nums[mid] == target) {
                  return mid;
              } else if (nums[left] <= nums[mid]){ // left is orderly
                  if (target < nums[mid] && target >= nums[left]) {
                      right = mid - 1;
                  } else {
                      left = mid + 1;
                  }
              } else { // right is orderly
                  if (target > nums[mid] && target <= nums[right]){
                      left = mid + 1;
                  } else {
                      right = mid - 1;
                  }
              }
          }
          return -1;
      }
  }
  ```

+ #### [367. Valid Perfect Square](https://leetcode-cn.com/problems/valid-perfect-square/)

  Given a **positive** integer *num*, write a function which returns True if *num* is a perfect square else False.

  **Follow up:** **Do not** use any built-in library function such as `sqrt`.

  **Example 1:**

  ```
  Input: num = 16
  Output: true
  ```

  **Example 2:**

  ```
  Input: num = 14
  Output: false
  ```

  **Constraints:**

  - `1 <= num <= 2^31 - 1`

  ```java
  class Solution {
      public boolean isPerfectSquare(int num) {
          if (num == 0 || num == 1) return true;
          int left = 1, right = num;
          while (left <= right) {
              int mid = (right - left) / 2 + left;
              if ((long) mid * mid == num) {
                  return true;
              } else if ((long) mid * mid > num) {
                  right = mid - 1;
              } else {
                  left = mid + 1;
              }
          }
          return right * right == num;
      }
  }
  ```

+ #### [74. Search a 2D Matrix](https://leetcode-cn.com/problems/search-a-2d-matrix/)

  Write an efficient algorithm that searches for a value in an `m x n` matrix. This matrix has the following properties:

  - Integers in each row are sorted from left to right.
  - The first integer of each row is greater than the last integer of the previous row.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

  ```
  Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
  Output: true
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg)

  ```
  Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
  Output: false
  ```

  **Constraints:**

  - `m == matrix.length`
  - `n == matrix[i].length`
  - `1 <= m, n <= 100`
  - `-104 <= matrix[i][j], target <= 104`

  ```java
  class Solution {
      public boolean searchMatrix(int[][] matrix, int target) {
          if (matrix.length == 0) return false;
          int n = matrix.length, m = matrix[0].length;
          for (int i = 0, j = m - 1; i < n && j >= 0; ) {
              if (matrix[i][j] == target) {
                  return true;
              } else if (matrix[i][j] < target) {
                  i++;
              } else {
                  j--;
              }
          }
          return false;
      }
  }
  ```

+ #### [153. Find Minimum in Rotated Sorted Array](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

  Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:

  - `[4,5,6,7,0,1,2]` if it was rotated `4` times.
  - `[0,1,2,4,5,6,7]` if it was rotated `7` times.

  Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

  Given the sorted rotated array `nums` of **unique** elements, return *the minimum element of this array*.

  **Example 1:**

  ```
  Input: nums = [3,4,5,1,2]
  Output: 1
  Explanation: The original array was [1,2,3,4,5] rotated 3 times.
  ```

  **Example 2:**

  ```
  Input: nums = [4,5,6,7,0,1,2]
  Output: 0
  Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
  ```

  **Example 3:**

  ```
  Input: nums = [11,13,15,17]
  Output: 11
  Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
  ```

  **Constraints:**

  - `n == nums.length`
  - `1 <= n <= 5000`
  - `-5000 <= nums[i] <= 5000`
  - All the integers of `nums` are **unique**.
  - `nums` is sorted and rotated between `1` and `n` times.

  ```java
  class Solution {
      public int findMin(int[] nums) {
          int left = 0, right = nums.length - 1;
          while (left < right) {
              int mid = (right - left) / 2 + left;
              if (nums[left] <= nums[mid]) { // when length == 1, left == mid
                  if (nums[mid] < nums[right]) {
                      return nums[left];
                  } else {
                      left = mid + 1;
                  }
              } else {
                  right = mid;
              }
          }
          return nums[right];
      }
  }
  ```

+ Dynamic Programming

  Simplifying a complicated problem by breaking it down into simpler sub-problems (in a recursive manner)

  bottom up

  divide & conquer + optimal substructure

  has status cache

+ Count the paths

  ![image-20210318104512545](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210318104512545.png)

  Recursion: `dp[i][j] = dp[i + 1][j] + dp[i][j + 1]`

+ #### [1143. Longest Common Subsequence](https://leetcode-cn.com/problems/longest-common-subsequence/)

  Given two strings `text1` and `text2`, return *the length of their longest **common subsequence**.* If there is no **common subsequence**, return `0`.

  A **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

  - For example, `"ace"` is a subsequence of `"abcde"`.

  A **common subsequence** of two strings is a subsequence that is common to both strings.

  **Example 1:**

  ```
  Input: text1 = "abcde", text2 = "ace" 
  Output: 3  
  Explanation: The longest common subsequence is "ace" and its length is 3.
  ```

  **Example 2:**

  ```
  Input: text1 = "abc", text2 = "abc"
  Output: 3
  Explanation: The longest common subsequence is "abc" and its length is 3.
  ```

  **Example 3:**

  ```
  Input: text1 = "abc", text2 = "def"
  Output: 0
  Explanation: There is no such common subsequence, so the result is 0.
  ```

  **Constraints:**

  - `1 <= text1.length, text2.length <= 1000`
  - `text1` and `text2` consist of only lowercase English characters.

  ```java
  class Solution {
      public int longestCommonSubsequence(String text1, String text2) {
          int n = text1.length(), m = text2.length();
          int[][] dp = new int[n + 1][m + 1];
          for (int i = 1; i < n + 1; i++) {
              for (int j = 1; j < m + 1; j++) {
                  if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                      dp[i][j] = dp[i - 1][j - 1] + 1;
                  } else {
                      dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                  }
              }
          }
          return dp[n][m];
      }
  }
  ```

+ #### [62. Unique Paths](https://leetcode-cn.com/problems/unique-paths/)

  A robot is located at the top-left corner of a `m x n` grid (marked 'Start' in the diagram below).

  The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

  How many possible unique paths are there?

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

  ```
  Input: m = 3, n = 7
  Output: 28
  ```

  **Example 2:**

  ```
  Input: m = 3, n = 2
  Output: 3
  Explanation:
  From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
  1. Right -> Down -> Down
  2. Down -> Down -> Right
  3. Down -> Right -> Down
  ```

  **Example 3:**

  ```
  Input: m = 7, n = 3
  Output: 28
  ```

  **Example 4:**

  ```
  Input: m = 3, n = 3
  Output: 6
  ```

  **Constraints:**

  - `1 <= m, n <= 100`
  - It's guaranteed that the answer will be less than or equal to `2 * 109`.

  ```java
  class Solution {
      public int uniquePaths(int m, int n) {
          int[] dp = new int[n];
          Arrays.fill(dp, 1);
          for (int i = 1; i < m; i++) {
              for (int j = 1; j < n; j++) {
                  dp[j] += dp[j - 1];
              }
          }
          return dp[n - 1];
      }
  }
  ```

+ #### [63. Unique Paths II](https://leetcode-cn.com/problems/unique-paths-ii/)

  A robot is located at the top-left corner of a `m x n` grid (marked 'Start' in the diagram below).

  The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

  Now consider if some obstacles are added to the grids. How many unique paths would there be?

  An obstacle and space is marked as `1` and `0` respectively in the grid.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

  ```
  Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
  Output: 2
  Explanation: There is one obstacle in the middle of the 3x3 grid above.
  There are two ways to reach the bottom-right corner:
  1. Right -> Right -> Down -> Down
  2. Down -> Down -> Right -> Right
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)

  ```
  Input: obstacleGrid = [[0,1],[0,0]]
  Output: 1
  ```

  **Constraints:**

  - `m == obstacleGrid.length`
  - `n == obstacleGrid[i].length`
  - `1 <= m, n <= 100`
  - `obstacleGrid[i][j]` is `0` or `1`.

  ```java
  class Solution {
      public int uniquePathsWithObstacles(int[][] obstacleGrid) {
          obstacleGrid[0][0] = obstacleGrid[0][0] == 1 ? 0 : 1;
          for (int i = 1; i < obstacleGrid.length; i++) {
              obstacleGrid[i][0] = obstacleGrid[i][0] == 1 ? 0 : obstacleGrid[i - 1][0];
          }
          for (int j = 1; j < obstacleGrid[0].length; j++) {
              obstacleGrid[0][j] = obstacleGrid[0][j] == 1 ? 0 : obstacleGrid[0][j - 1];
          }
          for (int i = 1; i < obstacleGrid.length; i++) {
              for (int j = 1; j < obstacleGrid[0].length; j++) {
                  obstacleGrid[i][j] = obstacleGrid[i][j] == 1 ? 0 :obstacleGrid[i-1][j] + obstacleGrid[i][j-1];
              }
          }
          return obstacleGrid[obstacleGrid.length - 1][obstacleGrid[0].length - 1];
      }
  }
  ```

+ #### [53. Maximum Subarray](https://leetcode-cn.com/problems/maximum-subarray/)

  Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return *its sum*.

  **Example 1:**

  ```
  Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
  Output: 6
  Explanation: [4,-1,2,1] has the largest sum = 6.
  ```

  **Example 2:**

  ```
  Input: nums = [1]
  Output: 1
  ```

  **Example 3:**

  ```
  Input: nums = [5,4,-1,7,8]
  Output: 23
  ```

  **Constraints:**

  - `1 <= nums.length <= 3 * 104`
  - `-105 <= nums[i] <= 105`

  **Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.

  ```java
  class Solution {
      public int maxSubArray(int[] nums) {
          int max = nums[0];
          for (int i = 1; i < nums.length; i++) {
              nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);
              max = Math.max(max, nums[i]);
          }
          return max;
      }
  }
  
  // recur
  class Solution {
      int res;
      public int maxSubArray(int[] nums) {
          res = Math.max(nums[0], nums[nums.length - 1]);
          recur(nums, nums.length - 1);
          return res;
      }
  
      private int recur(int[] nums, int end) {
          if (end == 0) return nums[end];
          int a = Math.max(0, recur(nums, end - 1)) + nums[end];
          res = Math.max(res, a);
          return a;
      }
  }
  ```

+ new climb stairs

  step: 1 2 3, two adjacent steps cannot be the same.

+ #### [120. Triangle](https://leetcode-cn.com/problems/triangle/)

  Given a `triangle` array, return *the minimum path sum from top to bottom*.

  For each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.

  **Example 1:**

  ```
  Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
  Output: 11
  Explanation: The triangle looks like:
     2
    3 4
   6 5 7
  4 1 8 3
  The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
  ```

  **Example 2:**

  ```
  Input: triangle = [[-10]]
  Output: -10
  ```

  **Constraints:**

  - `1 <= triangle.length <= 200`
  - `triangle[0].length == 1`
  - `triangle[i].length == triangle[i - 1].length + 1`
  - `-104 <= triangle[i][j] <= 104`

  **Follow up:** Could you do this using only `O(n)` extra space, where `n` is the total number of rows in the triangle?

  ```java
  // division: problem(i,j) = min(sub(i+1,j),sub(i+1,j+1)) + a[i,j]
  // dp array: f[i,j]
  // dp equation: f[i][j] = Math.min(f[i+1][j], f[i+1][j+1]) + a[i][j]
  class Solution {
      public int minimumTotal(List<List<Integer>> triangle) {
          int n = triangle.size();
          int[] dp = new int[n];
          for (int i = 0; i < n; i++) {
              dp[i] = triangle.get(n-1).get(i);
          }
          for (int i = n-2; i >= 0; i--) {
              for (int j = 0; j <= i; j++) {
                  dp[j] = triangle.get(i).get(j) + Math.min(dp[j], dp[j+1]);
              }
          }
          return dp[0];
      }
  }
  
  // memo dfs
  ```

+ #### [152. Maximum Product Subarray](https://leetcode-cn.com/problems/maximum-product-subarray/)

  Given an integer array `nums`, find a contiguous non-empty subarray within the array that has the largest product, and return *the product*.

  It is **guaranteed** that the answer will fit in a **32-bit** integer.

  A **subarray** is a contiguous subsequence of the array.

  **Example 1:**

  ```
  Input: nums = [2,3,-2,4]
  Output: 6
  Explanation: [2,3] has the largest product 6.
  ```

  **Example 2:**

  ```
  Input: nums = [-2,0,-1]
  Output: 0
  Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
  ```

  **Constraints:**

  - `1 <= nums.length <= 2 * 104`
  - `-10 <= nums[i] <= 10`

  ```java
  class Solution {
      public int maxProduct(int[] nums) {
          int res = nums[0];
          int min = nums[0], max = nums[0];
          for (int i = 1; i < nums.length; i++) {
              int t = min;
              min = Math.min(Math.min(nums[i], nums[i] * min), nums[i] * max);
              max = Math.max(Math.max(nums[i], nums[i] * max), nums[i] * t);
              res = Math.max(res, max);
          }
          return res;
      }
  }
  ```

+ #### [322. Coin Change](https://leetcode-cn.com/problems/coin-change/)

  You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.

  Return *the fewest number of coins that you need to make up that amount*. If that amount of money cannot be made up by any combination of the coins, return `-1`.

  You may assume that you have an infinite number of each kind of coin.

  **Example 1:**

  ```
  Input: coins = [1,2,5], amount = 11
  Output: 3
  Explanation: 11 = 5 + 5 + 1
  ```

  **Example 2:**

  ```
  Input: coins = [2], amount = 3
  Output: -1
  ```

  **Example 3:**

  ```
  Input: coins = [1], amount = 0
  Output: 0
  ```

  **Example 4:**

  ```
  Input: coins = [1], amount = 1
  Output: 1
  ```

  **Example 5:**

  ```
  Input: coins = [1], amount = 2
  Output: 2
  ```

  **Constraints:**

  - `1 <= coins.length <= 12`
  - `1 <= coins[i] <= 231 - 1`
  - `0 <= amount <= 104`

  ```java
  // recur over time
  class Solution {
      int res = Integer.MAX_VALUE;
      public int coinChange(int[] coins, int amount) {
          bfs(coins, amount, 0);
          return res == Integer.MAX_VALUE ? -1 : res;
      }
  
      private void bfs(int[] coins, int amount, int num) {
          if (amount < 0) return ; 
          if (amount == 0) {
              res = Math.min(res, num);
              return ;
          }
          for (int coin : coins) {
              bfs(coins, amount - coin, num + 1);
          }
      }
  }
  
  // DP
  // subproblems: problem[i] = 1 + min(sub(i-coin1),sub(i-coin2),...)
  // dp array: f(n) = min(f(n-k), fpr k in [1,2,5]) + 1
  // dp equation
  class Solution {
      public int coinChange(int[] coins, int amount) {
          int max = amount + 1;
          int[] dp = new int[amount + 1];
          Arrays.fill(dp, max);
          dp[0] = 0;
          for (int i = 1; i <= amount; i++) {
              for (int coin : coins) {
                  if (coin <= i) {
                      dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                  }
              }
          }
          return dp[amount] > amount ? -1 : dp[amount];
      }
  }
  ```

+ #### [198. House Robber](https://leetcode-cn.com/problems/house-robber/)

  You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

  Given an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.

  **Example 1:**

  ```
  Input: nums = [1,2,3,1]
  Output: 4
  Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
  Total amount you can rob = 1 + 3 = 4.
  ```

  **Example 2:**

  ```
  Input: nums = [2,7,9,3,1]
  Output: 12
  Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
  Total amount you can rob = 2 + 9 + 1 = 12.
  ```

  **Constraints:**

  - `1 <= nums.length <= 100`
  - `0 <= nums[i] <= 400`

  ```java
  class Solution {
      public int rob(int[] nums) {
          if (nums.length == 1) return nums[0];
          nums[1] = Math.max(nums[0], nums[1]);
          for (int i = 2; i < nums.length; i++) {
              nums[i] = Math.max(nums[i] + nums[i-2], nums[i-1]);
          }
          return nums[nums.length - 1];
      }
  }
  
  class Solution {
      public int rob(int[] nums) {
          if (nums.length == 1) return nums[0];
          int[][] dp = new int[nums.length][2];
          dp[0][0] = 0; // not rob
          dp[0][1] = nums[0]; // rob
          for (int i = 1; i < nums.length; i++) {
              dp[i][0] = Math.max(dp[i-1][1], dp[i-1][0]);
              dp[i][1] = dp[i-1][0] + nums[i];
          }
          return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);
      }
  }
  ```

+ #### [213. House Robber II](https://leetcode-cn.com/problems/house-robber-ii/)

  You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

  Given an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.

  **Example 1:**

  ```
  Input: nums = [2,3,2]
  Output: 3
  Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
  ```

  **Example 2:**

  ```
  Input: nums = [1,2,3,1]
  Output: 4
  Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
  Total amount you can rob = 1 + 3 = 4.
  ```

  **Example 3:**

  ```
  Input: nums = [0]
  Output: 0
  ```

  **Constraints:**

  - `1 <= nums.length <= 100`
  - `0 <= nums[i] <= 1000`

  ```java
  class Solution {
      public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
          if (nums.length == 2) return Math.max(nums[0],nums[1]);
          int a = rob(nums, 0, nums.length - 2);
          int b = rob(nums, 1, nums.length - 1);
          return Math.max(a, b);
      }
  
      private int rob(int[] nums, int l, int r) {
          if (l == r) return nums[0];
          if (l + 1 == r) return Math.max(nums[0],nums[1]);
          int[] dp = new int[r - l + 1];
          dp[0] = nums[l];
          dp[1] = Math.max(nums[l], nums[l+1]);
          for (int i = l+2; i <= r; i++) {
              dp[i-l] = Math.max(dp[i-l-1], dp[i-l-2]+nums[i]);
          }
          return dp[r-l];
      }
  }
  ```
  
+ #### [121. Best Time to Buy and Sell Stock](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

  You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

  You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

  Return *the maximum profit you can achieve from this transaction*. If you cannot achieve any profit, return `0`.

  **Example 1:**

  ```
  Input: prices = [7,1,5,3,6,4]
  Output: 5
  Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
  Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
  ```

  **Example 2:**

  ```
  Input: prices = [7,6,4,3,1]
  Output: 0
  Explanation: In this case, no transactions are done and the max profit = 0.
  ```

  **Constraints:**

  - `1 <= prices.length <= 105`
  - `0 <= prices[i] <= 104`

  ```java
  class Solution {
      public int maxProfit(int[] prices) {
          int min = prices[0];
          int res = 0;
          for (int i = 1; i < prices.length; i++) {
              res = Math.max(res, prices[i] - min);
              min = Math.min(min, prices[i]);
          }
          return res;
      }
  }
  ```

+ Trie

  ![image-20210320130554112](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210320130554112.png)

  inner

  ![image-20210320130731713](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210320130731713.png)

+ #### [208. Implement Trie (Prefix Tree)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

  Trie (we pronounce "try") or prefix tree is a tree data structure used to retrieve a key in a strings dataset. There are various applications of this very efficient data structure, such as autocomplete and spellchecker.

  Implement the Trie class:

  - `Trie()` initializes the trie object.
  - `void insert(String word)` inserts the string `word` to the trie.
  - `boolean search(String word)` returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise.
  - `boolean startsWith(String prefix)` returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.

  **Example 1:**

  ```
  Input
  ["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
  [[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
  Output
  [null, null, true, false, true, null, true]
  
  Explanation
  Trie trie = new Trie();
  trie.insert("apple");
  trie.search("apple");   // return True
  trie.search("app");     // return False
  trie.startsWith("app"); // return True
  trie.insert("app");
  trie.search("app");     // return True
  ```

  **Constraints:**

  - `1 <= word.length, prefix.length <= 2000`
  - `word` and `prefix` consist of lowercase English letters.
  - At most `3 * 104` calls will be made to `insert`, `search`, and `startsWith`.

  ```java
  public class Trie {
      private boolean isString = false;
      private Trie[] next = new Trie[26];
  
      public Trie() {
  
      }
  
      public void insert(String word) {
          Trie root = this;
          char[] w = word.toCharArray();
          for (int i = 0; i < w.length; i++) {
              if (root.next[w[i] - 'a'] == null)
                  root.next[w[i] - 'a'] = new Trie();
              root = root.next[w[i] - 'a'];
          }
          root.isString = true;
      }
  
      public boolean search(String word) {
          Trie root = this;
          char[] w = word.toCharArray();
          for (int i = 0; i < w.length; i++) {
              if (root.next[w[i] - 'a'] == null) 
                  return false;
              root = root.next[w[i] - 'a'];
          }
          return root.isString;
      }
      
      public boolean startsWith(String prefix) {
          Trie root = this;
          char[] p = prefix.toCharArray();
          for (int i = 0; i < p.length; i++) {
              if (root.next[p[i] - 'a'] == null)
                  return false;
              root = root.next[p[i] - 'a'];
          }
          return true;
      }
  }
  ```

+ #### [212. Word Search II](https://leetcode-cn.com/problems/word-search-ii/)

  Given an `m x n` `board` of characters and a list of strings `words`, return *all words on the board*.

  Each word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

   

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)

  ```
  Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
  Output: ["eat","oath"]
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)

  ```
  Input: board = [["a","b"],["c","d"]], words = ["abcb"]
  Output: []
  ```

   

  **Constraints:**

  - `m == board.length`
  - `n == board[i].length`
  - `1 <= m, n <= 12`
  - `board[i][j]` is a lowercase English letter.
  - `1 <= words.length <= 3 * 104`
  - `1 <= words[i].length <= 10`
  - `words[i]` consists of lowercase English letters.
  - All the strings of `words` are unique.

  ```java
  class Solution {
      int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};
      Trie trie = new Trie();
      public List<String> findWords(char[][] board, String[] words) {
          for (String word : words) {
              trie.insert(word);
          }
          Set<String> set = new HashSet<>();
          StringBuilder sb = new StringBuilder();
          for (int i = 0; i < board.length; i++) {
              for (int j = 0; j < board[0].length; j++) {
                  dfs(set, sb, board, i, j);
              }
          }
          return new ArrayList<>(set);
      }
  
      private void dfs(Set<String> set, StringBuilder sb, char[][] board, int i, int j) { 
          sb.append(board[i][j]);
          if (!trie.startsWith(sb.toString())) {
              sb.deleteCharAt(sb.length() - 1);
              return ;
          }
          if (trie.search(sb.toString())) {
              set.add(sb.toString());
          }
          char t = board[i][j];
          board[i][j] = '.';
          for (int[] dir : dirs) {
              int x = i + dir[0], y = j + dir[1];
              if (x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] != '.') {
                  dfs(set, sb, board, x, y);
              }
          }
          board[i][j] = t;
          sb.deleteCharAt(sb.length() - 1);
      }
  }
  
  class Trie {...}
  ```

+ Disjoint Set

  ```java
  // Java Template
  class UnionFind {
      int count = 0;
      int[] parent;
  
      public UnionFind(int n) {
          count = n;
          parent = new int[n];
          for (int i = 0; i < n; i++) {
              parent[i] = i;
          }
      }
  
      int find(int p) {
          while (p != parent[p]) {
              p = parent[parent[p]];
          }
          return p;
      }
  
      void union(int p, int q) {
          int rootP = find(p);
          int rootQ = find(q);
          if (rootP != rootQ) {
              parent[rootP] = rootQ;
              count--;
          }
      }
  }
  ```

+ #### [547. Number of Provinces(Friend-Circles)](https://leetcode-cn.com/problems/number-of-provinces/)

  There are `n` cities. Some of them are connected, while some are not. If city `a` is connected directly with city `b`, and city `b` is connected directly with city `c`, then city `a` is connected indirectly with city `c`.

  A **province** is a group of directly or indirectly connected cities and no other cities outside of the group.

  You are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if the `ith` city and the `jth` city are directly connected, and `isConnected[i][j] = 0` otherwise.

  Return *the total number of **provinces***.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg)

  ```
  Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]
  Output: 2
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg)

  ```
  Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]
  Output: 3
  ```

  **Constraints:**

  - `1 <= n <= 200`
  - `n == isConnected.length`
  - `n == isConnected[i].length`
  - `isConnected[i][j]` is `1` or `0`.
  - `isConnected[i][i] == 1`
  - `isConnected[i][j] == isConnected[j][i]`

  ```java
  class Solution {
      public int findCircleNum(int[][] isConnected) {
          int n = isConnected.length;
          UnionFind unionFind = new UnionFind(n);
          for (int i = 0; i < n; i++) {
              for (int j = i + 1; j < n; j++) {
                  if (isConnected[i][j] == 1) {
                      unionFind.union(i, j);
                  }
              }
          }
          return unionFind.count;
      }
  }
  
  class UnionFind {...}
  ```

+ #### [200. Number of Islands](https://leetcode-cn.com/problems/number-of-islands/)

  Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*.

  An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

  **Example 1:**

  ```
  Input: grid = [
    ["1","1","1","1","0"],
    ["1","1","0","1","0"],
    ["1","1","0","0","0"],
    ["0","0","0","0","0"]
  ]
  Output: 1
  ```

  **Example 2:**

  ```
  Input: grid = [
    ["1","1","0","0","0"],
    ["1","1","0","0","0"],
    ["0","0","1","0","0"],
    ["0","0","0","1","1"]
  ]
  Output: 3
  ```

  **Constraints:**

  - `m == grid.length`
  - `n == grid[i].length`
  - `1 <= m, n <= 300`
  - `grid[i][j]` is `'0'` or `'1'`.

  ```java
  class Solution {
      public int numIslands(char[][] grid) {
          int m = grid.length, n = grid[0].length;
          UnionFind unionFind = new UnionFind(m, n);
          int zero = 0;
          for (int i = 0; i < m; i++) {
              for (int j = 0; j < n; j++) {
                  if (grid[i][j] == '0') {
                      zero++;
                      continue;
                  }
                  if (i-1 >= 0 && grid[i-1][j] == '1') {
                      unionFind.union(i*n + j, (i-1)*n + j);
                  }
                  if (j-1 >= 0 && grid[i][j-1] == '1') {
                      unionFind.union(i*n + j, i*n + j - 1);
                  }
                  if (j+1 < n && grid[i][j+1] == '1') {
                      unionFind.union(i*n + j, i*n + j + 1);
                  }
                  if (i+1 < m && grid[i+1][j] == '1') {
                      unionFind.union(i*n + j, (i+1)*n + j);
                  }
              }
          }
          return unionFind.count - zero;
      }
  }
  
  class UnionFind {
      int count = 0;
      int[] parent;
      public UnionFind(int m, int n) {
          count = m * n;
          parent= new int[count];
          for (int i = 0; i < m; i++) {
              for (int j = 0; j < n; j++) {
                  parent[i*n + j] = i*n + j;
              }
          }
      }
  
      int find(int k) {
          while (parent[k] != k) {
              k = parent[parent[k]];
          }
          return k;
      }
  
      void union(int p, int q) {
          int rootP = find(p);
          int rootQ = find(q);
          if (rootP != rootQ) {
              parent[rootP] = rootQ;
              count--;
          }
      }
  }
  ```

+ #### [130. Surrounded Regions](https://leetcode-cn.com/problems/surrounded-regions/)

  Given an `m x n` matrix `board` containing `'X'` and `'O'`, *capture all regions surrounded by* `'X'`.

  A region is **captured** by flipping all `'O'`s into `'X'`s in that surrounded region.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)

  ```
  Input: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
  Output: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
  Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
  ```

  **Example 2:**

  ```
  Input: board = [["X"]]
  Output: [["X"]]
  ```

  **Constraints:**

  - `m == board.length`
  - `n == board[i].length`
  - `1 <= m, n <= 200`
  - `board[i][j]` is `'X'` or `'O'`.

  ```java
  class Solution {
      int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};
      public void solve(char[][] board) {
          int m = board.length, n = board[0].length;
          for (int i = 0; i < m; i++) {
              if (board[i][0] == 'O') {
                  dfs(board, i, 0);
              }
              if (board[i][n-1] == 'O') {
                  dfs(board, i, n-1);
              }
          }
          for (int j = 1; j < n-1; j++) {
              if (board[0][j] == 'O') {
                  dfs(board, 0, j);
              }
              if (board[m-1][j] == 'O') {
                  dfs(board, m-1, j);
              }
          }
          for (int i = 0; i < m; i++) {
              for (int j = 0; j < n; j++) {
                  if (board[i][j] == 'O') board[i][j] = 'X';
              }
          }
          for (int i = 0; i < m; i++) {
              for (int j = 0; j < n; j++) {
                  if (board[i][j] == '.') board[i][j] = 'O';
              }
          }
      }
  
      private void dfs(char[][] board, int i, int j) {
          board[i][j] = '.';
          for (int[] dir : dirs) {
              int x = i + dir[0], y = j + dir[1];
              if (x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] == 'O') {
                  dfs(board, x, y);
              }
          }
      }
  }
  ```

+ Advanced Search

  + Pruning

  + Bidirectional Breadth First Search

  + Heuristic search (A* Search)

    ```java
    public class AStar
    {
        public final static int BAR = 1; // 障碍值
        public final static int PATH = 2; // 路径
        public final static int DIRECT_VALUE = 10; // 横竖移动代价
        public final static int OBLIQUE_VALUE = 14; // 斜移动代价
    
        Queue<Node> openList = new PriorityQueue<Node>(); // 优先队列(升序)
        List<Node> closeList = new ArrayList<Node>();
    
        /**
         * 开始算法
         */
        public void start(MapInfo mapInfo)
        {
            if(mapInfo==null) return;
            // clean
            openList.clear();
            closeList.clear();
            // 开始搜索
            openList.add(mapInfo.start);
            moveNodes(mapInfo);
        }
    
        /**
         * 移动当前结点
         */
        private void moveNodes(MapInfo mapInfo)
        {
            while (!openList.isEmpty())
            {
                Node current = openList.poll();
                closeList.add(current);
                addNeighborNodeInOpen(mapInfo,current);
                if (isCoordInClose(mapInfo.end.coord))
                {
                    drawPath(mapInfo.maps, mapInfo.end);
                    break;
                }
            }
        }
    
        /**
         * 在二维数组中绘制路径
         */
        private void drawPath(int[][] maps, Node end)
        {
            if(end==null||maps==null) return;
            System.out.println("总代价：" + end.G);
            while (end != null)
            {
                Coord c = end.coord;
                maps[c.y][c.x] = PATH;
                end = end.parent;
            }
        }
    
        /**
         * 添加所有邻结点到open表
         */
        private void addNeighborNodeInOpen(MapInfo mapInfo,Node current)
        {
            int x = current.coord.x;
            int y = current.coord.y;
            // 左
            addNeighborNodeInOpen(mapInfo,current, x - 1, y, DIRECT_VALUE);
            // 上
            addNeighborNodeInOpen(mapInfo,current, x, y - 1, DIRECT_VALUE);
            // 右
            addNeighborNodeInOpen(mapInfo,current, x + 1, y, DIRECT_VALUE);
            // 下
            addNeighborNodeInOpen(mapInfo,current, x, y + 1, DIRECT_VALUE);
            // 左上
            addNeighborNodeInOpen(mapInfo,current, x - 1, y - 1, OBLIQUE_VALUE);
            // 右上
            addNeighborNodeInOpen(mapInfo,current, x + 1, y - 1, OBLIQUE_VALUE);
            // 右下
            addNeighborNodeInOpen(mapInfo,current, x + 1, y + 1, OBLIQUE_VALUE);
            // 左下
            addNeighborNodeInOpen(mapInfo,current, x - 1, y + 1, OBLIQUE_VALUE);
        }
    
        /**
         * 添加一个邻结点到open表
         */
        private void addNeighborNodeInOpen(MapInfo mapInfo,Node current, int x, int y, int value)
        {
            if (canAddNodeToOpen(mapInfo,x, y))
            {
                Node end=mapInfo.end;
                Coord coord = new Coord(x, y);
                int G = current.G + value; // 计算邻结点的G值
                Node child = findNodeInOpen(coord);
                if (child == null)
                {
                    int H=calcH(end.coord,coord); // 计算H值
                    if(isEndNode(end.coord,coord))
                    {
                        child=end;
                        child.parent=current;
                        child.G=G;
                        child.H=H;
                    }
                    else
                    {
                        child = new Node(coord, current, G, H);
                    }
                    openList.add(child);
                }
                else if (child.G > G)
                {
                    child.G = G;
                    child.parent = current;
                    openList.add(child);
                }
            }
        }
    
        /**
         * 从Open列表中查找结点
         */
        private Node findNodeInOpen(Coord coord)
        {
            if (coord == null || openList.isEmpty()) return null;
            for (Node node : openList)
            {
                if (node.coord.equals(coord))
                {
                    return node;
                }
            }
            return null;
        }
    
    
        /**
         * 计算H的估值：“曼哈顿”法，坐标分别取差值相加
         */
        private int calcH(Coord end,Coord coord)
        {
            return Math.abs(end.x - coord.x)
                    + Math.abs(end.y - coord.y);
        }
    
        /**
         * 判断结点是否是最终结点
         */
        private boolean isEndNode(Coord end,Coord coord)
        {
            return coord != null && end.equals(coord);
        }
    
        /**
         * 判断结点能否放入Open列表
         */
        private boolean canAddNodeToOpen(MapInfo mapInfo,int x, int y)
        {
            // 是否在地图中
            if (x < 0 || x >= mapInfo.width || y < 0 || y >= mapInfo.hight) return false;
            // 判断是否是不可通过的结点
            if (mapInfo.maps[y][x] == BAR) return false;
            // 判断结点是否存在close表
            if (isCoordInClose(x, y)) return false;
    
            return true;
        }
    
        /**
         * 判断坐标是否在close表中
         */
        private boolean isCoordInClose(Coord coord)
        {
            return coord!=null&&isCoordInClose(coord.x, coord.y);
        }
    
        /**
         * 判断坐标是否在close表中
         */
        private boolean isCoordInClose(int x, int y)
        {
            if (closeList.isEmpty()) return false;
            for (Node node : closeList)
            {
                if (node.coord.x == x && node.coord.y == y)
                {
                    return true;
                }
            }
            return false;
        }
    }
    ```

+ #### [36. Valid Sudoku](https://leetcode-cn.com/problems/valid-sudoku/)

  Determine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated **according to the following rules**:

  1. Each row must contain the digits `1-9` without repetition.
  2. Each column must contain the digits `1-9` without repetition.
  3. Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without repetition.

  **Note:**

  - A Sudoku board (partially filled) could be valid but is not necessarily solvable.
  - Only the filled cells need to be validated according to the mentioned rules.

  ```
  Input: board = 
  [["5","3",".",".","7",".",".",".","."]
  ,["6",".",".","1","9","5",".",".","."]
  ,[".","9","8",".",".",".",".","6","."]
  ,["8",".",".",".","6",".",".",".","3"]
  ,["4",".",".","8",".","3",".",".","1"]
  ,["7",".",".",".","2",".",".",".","6"]
  ,[".","6",".",".",".",".","2","8","."]
  ,[".",".",".","4","1","9",".",".","5"]
  ,[".",".",".",".","8",".",".","7","9"]]
  Output: true
  ```

  **Example 2:**

  ```
  Input: board = 
  [["8","3",".",".","7",".",".",".","."]
  ,["6",".",".","1","9","5",".",".","."]
  ,[".","9","8",".",".",".",".","6","."]
  ,["8",".",".",".","6",".",".",".","3"]
  ,["4",".",".","8",".","3",".",".","1"]
  ,["7",".",".",".","2",".",".",".","6"]
  ,[".","6",".",".",".",".","2","8","."]
  ,[".",".",".","4","1","9",".",".","5"]
  ,[".",".",".",".","8",".",".","7","9"]]
  Output: false
  Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
  ```

  **Constraints:**

  - `board.length == 9`
  - `board[i].length == 9`
  - `board[i][j]` is a digit or `'.'`.

  ```java
  class Solution {
      public boolean isValidSudoku(char[][] board) {
          boolean[][] rows = new boolean[9][9];
          boolean[][] cols = new boolean[9][9];
          boolean[][] blocks = new boolean[9][9];
          for (int i = 0; i < 9; i++) {
              for (int j = 0; j < 9; j++) {
                  if (board[i][j] == '.') continue;
                  if (rows[i][board[i][j] - '1']) return false;
                  if (cols[j][board[i][j] - '1']) return false;
                  int block = i/3 * 3 + j/3;
                  if (blocks[block][board[i][j] - '1']) return false;
                  rows[i][board[i][j] - '1'] = true;
                  cols[j][board[i][j] - '1'] = true;
                  blocks[block][board[i][j] - '1'] = true;
              }
          }
          return true;
      }
  }
  ```

+ #### [37. Sudoku Solver](https://leetcode-cn.com/problems/sudoku-solver/)

  Write a program to solve a Sudoku puzzle by filling the empty cells.

  A sudoku solution must satisfy **all of the following rules**:

  1. Each of the digits `1-9` must occur exactly once in each row.
  2. Each of the digits `1-9` must occur exactly once in each column.
  3. Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.

  The `'.'` character indicates empty cells.

  ```
  Input: board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
  Output: [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
  Explanation: The input board is shown above and the only valid solution is shown below:
  ```

  **Constraints:**

  - `board.length == 9`
  - `board[i].length == 9`
  - `board[i][j]` is a digit or `'.'`.
  - It is **guaranteed** that the input board has only one solution.

  ```java
  class Solution {
      boolean[][] rows = new boolean[9][9];
      boolean[][] cols = new boolean[9][9];
      boolean[][] blocks = new boolean[9][9];
      char[] nums = {'1','2','3','4','5','6','7','8','9'};
      char[][] board;
      public void solveSudoku(char[][] board) {
          this.board = board;
          for (int i = 0; i < 9; i++) {
              for (int j = 0; j < 9; j++) {
                  if (board[i][j] == '.') continue;
                  rows[i][board[i][j] - '1'] = true;
                  cols[j][board[i][j] - '1'] = true;
                  blocks[i/3 * 3 + j/3][board[i][j] - '1'] = true;
              }
          }
          dfs(0, 0);
      }
  
      private boolean dfs(int i, int j) {
          if (j == 9){
              i++;
              j = 0;
              if (i == 9) return true;
          }
          if (board[i][j] != '.') {
              return dfs(i, j + 1);
          }
          for (char num : nums) {
              if (rows[i][num - '1'] || cols[j][num - '1'] || blocks[i/3 * 3 + j/3][num - '1']) {
                  continue;
              }
              board[i][j] = num;
              rows[i][num - '1'] = true;
              cols[j][num - '1'] = true;
              blocks[i/3 * 3 + j/3][num - '1'] = true;
              if (dfs(i, j + 1)) return true;
              rows[i][num - '1'] = false;
              cols[j][num - '1'] = false;
              blocks[i/3 * 3 + j/3][num - '1'] = false;
              board[i][j] = '.';
          }
          return false;
      }
  }
  ```

+ #### [1091. Shortest Path in Binary Matrix](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)

  Given an `n x n` binary matrix `grid`, return *the length of the shortest **clear path** in the matrix*. If there is no clear path, return `-1`.

  A **clear path** in a binary matrix is a path from the **top-left** cell (i.e., `(0, 0)`) to the **bottom-right** cell (i.e., `(n - 1, n - 1)`) such that:

  - All the visited cells of the path are `0`.
  - All the adjacent cells of the path are **8-directionally** connected (i.e., they are different and they share an edge or a corner).

  The **length of a clear path** is the number of visited cells of this path.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2021/02/18/example1_1.png)

  ```
  Input: grid = [[0,1],[1,0]]
  Output: 2
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2021/02/18/example2_1.png)

  ```
  Input: grid = [[0,0,0],[1,1,0],[1,1,0]]
  Output: 4
  ```

  **Example 3:**

  ```
  Input: grid = [[1,0,0],[1,1,0],[1,1,0]]
  Output: -1
  ```

  **Constraints:**

  - `n == grid.length`
  - `n == grid[i].length`
  - `1 <= n <= 100`
  - `grid[i][j] is 0 or 1`

  ```java
  class Solution {
      int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};
      public int shortestPathBinaryMatrix(int[][] grid) {
          if (grid[0][0] == 1) return -1;
          Deque<int[]> deque = new LinkedList<>();
          int m = grid.length, n = grid[0].length;
          deque.addLast(new int[]{0,0});
          grid[0][0] = 1;
          int res = 0;
          while (!deque.isEmpty()) {
              int size = deque.size();
              res++;
              while (size-- > 0) {
                  int[] pos = deque.pollFirst();
                  int x = pos[0], y = pos[1];
                  if (x == m - 1 && y == n - 1) {
                      return res;
                  }
                  for (int[] dir : dirs) {
                      int i = x + dir[0], j = y + dir[1];
                      if (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length && grid[i][j] == 0) {
                          deque.addLast(new int[]{i, j});
                          grid[i][j] = 1;
                      } 
                  }
              }
          }
          return -1;
      }
  }
  ```

+ AVL Tree

  ![image-20210321134703685](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210321134703685.png)

+ Red Black Tree

  ![image-20210321135736985](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210321135736985.png)

  vs AVL Tree

  ![image-20210321135935972](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210321135935972.png)

+ Bit Operation

  ```
  <<: 0011=>0110
  >>: 0110=>0011
  | : 0011|1011=>1011
  & : 0011&1011=>0011
  ~ : 0011=>1100
  ^ : 0011^1011=>1000
  
  x ^ 0 = x
  x ^ (~x) = (~0) = 1s(all one)
  x ^ 1s = ~x
  x ^ x = 0
  ```

  ![image-20210321155408408](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210321155408408.png)

  apply

  ![image-20210321155525641](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210321155525641.png)

+ #### [191. Number of 1 Bits](https://leetcode-cn.com/problems/number-of-1-bits/)

  Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)).

  **Note:**

  - Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
  - In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two's_complement). Therefore, in **Example 3**, the input represents the signed integer. `-3`.

  **Example 1:**

  ```
  Input: n = 00000000000000000000000000001011
  Output: 3
  Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
  ```

  **Example 2:**

  ```
  Input: n = 00000000000000000000000010000000
  Output: 1
  Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
  ```

  **Example 3:**

  ```
  Input: n = 11111111111111111111111111111101
  Output: 31
  Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
  ```

  **Constraints:**

  - The input must be a **binary string** of length `32`.

  ```java
  public class Solution {
      public int hammingWeight(int n) {
          int res = 0;
          while (n != 0) {
              res += (n&1) == 1 ? 1 : 0;
              n = n >>> 1;
          }
          return res;
      }
  }
  ```

+ #### [231. Power of Two](https://leetcode-cn.com/problems/power-of-two/)

  Given an integer `n`, return *`true` if it is a power of two. Otherwise, return `false`*.

  An integer `n` is a power of two, if there exists an integer `x` such that `n == 2x`.

  **Example 1:**

  ```
  Input: n = 1
  Output: true
  Explanation: 20 = 1
  ```

  **Example 2:**

  ```
  Input: n = 16
  Output: true
  Explanation: 24 = 16
  ```

  **Example 3:**

  ```
  Input: n = 3
  Output: false
  ```

  **Example 4:**

  ```
  Input: n = 4
  Output: true
  ```

  **Example 5:**

  ```
  Input: n = 5
  Output: false
  ```

  **Constraints:**

  - `-231 <= n <= 231 - 1`

  ```java
  class Solution {
      public boolean isPowerOfTwo(int n) {
          return n > 0 && (n & (n - 1)) == 0;
      }
  }
  ```

+ #### [190. Reverse Bits](https://leetcode-cn.com/problems/reverse-bits/)

  Reverse bits of a given 32 bits unsigned integer.

  **Note:**

  - Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
  - In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two's_complement). Therefore, in **Example 2** above, the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.

  **Follow up**:

  If this function is called many times, how would you optimize it?

  **Example 1:**

  ```
  Input: n = 00000010100101000001111010011100
  Output:    964176192 (00111001011110000010100101000000)
  Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.
  ```

  **Example 2:**

  ```
  Input: n = 11111111111111111111111111111101
  Output:   3221225471 (10111111111111111111111111111111)
  Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.
  ```

  **Constraints:**

  - The input must be a **binary string** of length `32`

  ```java
  public class Solution {
      // you need treat n as an unsigned value
      public int reverseBits(int n) {
          int res = 0;
          for (int i = 0; i < 32; i++) {
              res <<= 1;
              res += n & 1;
              n >>>= 1;
          }
          return res;
      }
  }
  ```

+ #### [338. Counting Bits](https://leetcode-cn.com/problems/counting-bits/)

  Given an integer `num`, return *an array of the number of* `1`*'s in the binary representation of every number in the range* `[0, num]`.

  **Example 1:**

  ```
  Input: num = 2
  Output: [0,1,1]
  Explanation:
  0 --> 0
  1 --> 1
  2 --> 10
  ```

  **Example 2:**

  ```
  Input: num = 5
  Output: [0,1,1,2,1,2]
  Explanation:
  0 --> 0
  1 --> 1
  2 --> 10
  3 --> 11
  4 --> 100
  5 --> 101
  ```

  **Constraints:**

  - `0 <= num <= 105`

  ```java
  // stupid count
  class Solution {
      public int[] countBits(int num) {
          int[] res = new int[num + 1];
          for (int i = 1; i <= num; i++) {
              res[i] = countBit(i);
          }
          return res;
      }
  
      private int countBit(int num) {
          if (num == 0) return 0;
          return 1 + countBit(num & (num - 1));
      }
  }
  
  // DP
  class Solution {
      public int[] countBits(int num) {
          int[] bits = new int[num + 1];
          for (int i = 1; i <= num; i++) {
              bits[i] = bits[i >> 1] + (i & 1);
          }
          return bits;
      }
  }
  ```

+ LRU Cache (least recently used)

  multi-level cache in CPU

  ![image-20210322081926011](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322081926011.png)

  LRU: Hash Table + Double Linked List

  ![image-20210322082414832](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322082414832.png)

  Time complexity: O(1) lookup,  O(1) update/modify

  [其他缓存替换方法](https://en.wikipedia.org/wiki/Cache_replacement_policies)

+ #### [146. LRU Cache](https://leetcode-cn.com/problems/lru-cache/)

  Design a data structure that follows the constraints of a **[Least Recently Used (LRU) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU)**.

  Implement the `LRUCache` class:

  - `LRUCache(int capacity)` Initialize the LRU cache with **positive** size `capacity`.
  - `int get(int key)` Return the value of the `key` if the key exists, otherwise return `-1`.
  - `void put(int key, int value)` Update the value of the `key` if the `key` exists. Otherwise, add the `key-value` pair to the cache. If the number of keys exceeds the `capacity` from this operation, **evict** the least recently used key.

  **Follow up:**
  Could you do `get` and `put` in `O(1)` time complexity?

  **Example 1:**

  ```
  Input
  ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
  [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
  Output
  [null, null, null, 1, null, -1, null, -1, 3, 4]
  
  Explanation
  LRUCache lRUCache = new LRUCache(2);
  lRUCache.put(1, 1); // cache is {1=1}
  lRUCache.put(2, 2); // cache is {1=1, 2=2}
  lRUCache.get(1);    // return 1
  lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
  lRUCache.get(2);    // returns -1 (not found)
  lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
  lRUCache.get(1);    // return -1 (not found)
  lRUCache.get(3);    // return 3
  lRUCache.get(4);    // return 4
  ```

  **Constraints:**

  - `1 <= capacity <= 3000`
  - `0 <= key <= 3000`
  - `0 <= value <= 104`
  - At most `3 * 104` calls will be made to `get` and `put`.

  ```java
  class LRUCache {
      class DLinkedNode {
          int key;
          int value;
          DLinkedNode pre;
          DLinkedNode next;
          public DLinkedNode () {
              
          }
          public DLinkedNode (int key, int value) {
              this.key = key;
              this.value = value;
          }
      }
      
      private Map<Integer, DLinkedNode> cache = new HashMap<>();
      private int size;
      private int cap;
      private DLinkedNode head, tail;
  
      public LRUCache(int capacity) {
          this.size = 0;
          this.cap = capacity;
          head = new DLinkedNode();
          tail = new DLinkedNode();
          head.next = tail;
          tail.pre = head;
      }
  
      public int get(int key) {
          DLinkedNode node = cache.get(key);
          if (node == null) {
              return -1;
          }
          moveToHead(node);
          return node.value;
      }
  
      public void put(int key, int value) {
          DLinkedNode node = cache.get(key);
          if (node == null) {
              DLinkedNode newNode = new DLinkedNode(key, value);
              cache.put(key, newNode);
              addToHead(newNode);
              size++;
              if (size > cap) {
                  DLinkedNode tail = removeTail();
                  cache.remove(tail.key);
                  size--;
              }
          } else {
              node.value = value;
              moveToHead(node);
          }
      }
  
      private void moveToHead(DLinkedNode node) {
          removeNode(node);
          addToHead(node);
      }
  
      private void removeNode(DLinkedNode node) {
          node.pre.next = node.next;
          node.next.pre = node.pre;
      }
  
      private void addToHead(DLinkedNode node) {
          node.pre = head;
          node.next = head.next;
          head.next.pre = node;
          head.next = node;
      }
  
      private DLinkedNode removeTail() {
          DLinkedNode res = tail.pre;
          removeNode(res);
          return res;
      }
  }
  ```

+ Bloom Filter

  套在外层的缓存！

  一个很长的二进制向量和一系列随机映射函数。

  布隆过滤器可以用于检索一个元素是否在一个集合中。

  优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。

  ![image-20210322080759635](Z:\Perpetual-Motion-Machine\打工\春招\简历\image-20210322080759635.png)

  只要有一个映射位是0，元素一定不存在；映射位都是1也不一定存在，存在误差。

  案例：

  1. 比特币网络
  2. 分布式系统（Map-Reduce） - Hadoop、search engine
  3. Redis缓存
  4. 垃圾邮件、评论等的过滤

  Java 实现：[示例 1](https://github.com/lovasoa/bloomfilter/blob/master/src/main/java/BloomFilter.java) [示例 2](https://github.com/Baqend/Orestes-Bloomfilter)

+ Sort

  ![image-20210322090858421](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322090858421.png)

  ![image-20210322090927281](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322090927281.png)

  重点：堆排序，快速排序，归并排序

  归并：先排序左右子数组，然后合并两个有序子数组
  快排：先调配出左右子数组，然后对于左右子数组进行排序

+ #### [1122. Relative Sort Array](https://leetcode-cn.com/problems/relative-sort-array/)

  Given two arrays `arr1` and `arr2`, the elements of `arr2` are distinct, and all elements in `arr2` are also in `arr1`.

  Sort the elements of `arr1` such that the relative ordering of items in `arr1` are the same as in `arr2`. Elements that don't appear in `arr2` should be placed at the end of `arr1` in **ascending** order.

  **Example 1:**

  ```
  Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
  Output: [2,2,2,1,4,3,3,9,6,7,19]
  ```

  **Constraints:**

  - `1 <= arr1.length, arr2.length <= 1000`
  - `0 <= arr1[i], arr2[i] <= 1000`
  - All the elements of `arr2` are **distinct**.
  - Each `arr2[i]` is in `arr1`.

  ```java
  class Solution {
      public int[] relativeSortArray(int[] arr1, int[] arr2) {
          int i = 0;
          for (int i2 = 0; i2 < arr2.length; i2++) {
              for (int i1 = 0; i1 < arr1.length; i1++) {
                  if (arr1[i1] == arr2[i2]) {
                      int t = arr1[i];
                      arr1[i++] = arr1[i1];
                      arr1[i1] = t;
                  }
              }
          }
          Arrays.sort(arr1, i, arr1.length);
          return arr1;
      }
  }
  ```

+ #### [56. Merge Intervals](https://leetcode-cn.com/problems/merge-intervals/)

  Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return *an array of the non-overlapping intervals that cover all the intervals in the input*.

  **Example 1:**

  ```
  Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
  Output: [[1,6],[8,10],[15,18]]
  Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
  ```

  **Example 2:**

  ```
  Input: intervals = [[1,4],[4,5]]
  Output: [[1,5]]
  Explanation: Intervals [1,4] and [4,5] are considered overlapping.
  ```

  **Constraints:**

  - `1 <= intervals.length <= 104`
  - `intervals[i].length == 2`
  - `0 <= starti <= endi <= 104`

  ```java
  class Solution {
      public int[][] merge(int[][] intervals) {
          Deque<int[]> deque = new LinkedList<>();
          Arrays.sort(intervals, (x,y)->(x[1]-y[1]));
          Arrays.sort(intervals, (x,y)->(x[0]-y[0]));
          for (int[] interval : intervals) {
              if (deque.isEmpty()) {
                  deque.addLast(interval);
                  continue;
              }
              int end = deque.peekLast()[1];
              if (interval[0] <= end) {
                  deque.peekLast()[1] = Math.max(end, interval[1]);
              } else {
                  deque.addLast(interval);
              }
          }
          int n = deque.size();
          int[][] res = new int[n][2];
          for (int i = 0; i < n; i++) {
              res[i] = deque.pollFirst();
          }
          return res;
      }
  }
  ```

+ #### [493. Reverse Pairs](https://leetcode-cn.com/problems/reverse-pairs/)

  Given an array `nums`, we call `(i, j)` an ***important reverse pair\*** if `i < j` and `nums[i] > 2*nums[j]`.

  You need to return the number of important reverse pairs in the given array.

  **Example1:**

  ```
  Input: [1,3,2,3,1]
  Output: 2
  ```

  **Example2:**

  ```
  Input: [2,4,3,5,1]
  Output: 3
  ```

  **Note:**

  1. The length of the given array will not exceed `50,000`.
  2. All the numbers in the input array are in the range of 32-bit integer.

  ```java
  class Solution {
      int res = 0;
      public int reversePairs(int[] nums) {
          mergeSort(nums, 0, nums.length - 1);
          return res;
      }
  
      private void mergeSort(int[] nums, int left, int right) {
          if (right <= left) return ;
          int mid = (right - left) / 2 + left;
          mergeSort(nums, left, mid);
          mergeSort(nums, mid + 1, right);
          merge(nums, left, mid, right);
      }
  
      private void merge(int[] nums, int l1, int r1, int r2) {
          // count res
          int p = l1, q = r1 + 1;
          while (p <= r1 && q <= r2) {
              if (nums[p] > (long) nums[q] * 2) {
                  res += r1 - p + 1;
                  q++;
              } else p++;
          }
  
          int[] arr = new int[r2 - l1 + 1];
          int start = l1, i = 0, l2 = r1 + 1;
          while (l1 <= r1 && l2 <= r2) {
              arr[i++] = nums[l1] > nums[l2] ? nums[l2++] : nums[l1++];
          }
          while (l1 <= r1) arr[i++] = nums[l1++];
          while (l2 <= r2) arr[i++] = nums[l2++];
          for (l1 = start; l1 <= r2; l1++) {
              nums[l1] = arr[l1 - start];
          }
      }
  }
  ```

+ 