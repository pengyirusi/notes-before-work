<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-鹏懿如斯</title><link>https://www.cnblogs.com/peng8098/</link><description /><language>zh-cn</language><lastBuildDate>Sun, 25 Jul 2021 10:48:22 GMT</lastBuildDate><pubDate>Sun, 25 Jul 2021 10:48:22 GMT</pubDate><ttl>60</ttl><item><title>两个win10实现远程连接</title><link>http://www.cnblogs.com/peng8098/archive/2021/05/07/yuanchenglianjie.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 07 May 2021 05:42:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2021/05/07/yuanchenglianjie.html</guid><description><![CDATA[![](https://img2020.cnblogs.com/blog/1205669/202105/1205669-20210507134138661-1026932012.png)
]]></description></item><item><title>Data Structure and Algorithm - Day 13 - Course End</title><link>http://www.cnblogs.com/peng8098/archive/2021/03/22/algorithm13.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 22 Mar 2021 04:47:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2021/03/22/algorithm13.html</guid><description><![CDATA[+ LRU Cache (least recently used)

  multi-level cache in CPU

  ![image-20210322081926011](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322081926011.png)

  LRU: Hash Table + Double Linked List

  ![image-20210322082414832](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322082414832.png)

  Time complexity: O(1) lookup,  O(1) update/modify

  [其他缓存替换方法](https://en.wikipedia.org/wiki/Cache_replacement_policies)

+ #### [146. LRU Cache](https://leetcode-cn.com/problems/lru-cache/)

  Design a data structure that follows the constraints of a **[Least Recently Used (LRU) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU)**.

  Implement the `LRUCache` class:

  - `LRUCache(int capacity)` Initialize the LRU cache with **positive** size `capacity`.
  - `int get(int key)` Return the value of the `key` if the key exists, otherwise return `-1`.
  - `void put(int key, int value)` Update the value of the `key` if the `key` exists. Otherwise, add the `key-value` pair to the cache. If the number of keys exceeds the `capacity` from this operation, **evict** the least recently used key.

  **Follow up:**
  Could you do `get` and `put` in `O(1)` time complexity?

  **Example 1:**

  ```
  Input
  ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
  [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
  Output
  [null, null, null, 1, null, -1, null, -1, 3, 4]
  
  Explanation
  LRUCache lRUCache = new LRUCache(2);
  lRUCache.put(1, 1); // cache is {1=1}
  lRUCache.put(2, 2); // cache is {1=1, 2=2}
  lRUCache.get(1);    // return 1
  lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
  lRUCache.get(2);    // returns -1 (not found)
  lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
  lRUCache.get(1);    // return -1 (not found)
  lRUCache.get(3);    // return 3
  lRUCache.get(4);    // return 4
  ```

  **Constraints:**

  - `1 <= capacity <= 3000`
  - `0 <= key <= 3000`
  - `0 <= value <= 104`
  - At most `3 * 104` calls will be made to `get` and `put`.

  ```java
  class LRUCache {
      class DLinkedNode {
          int key;
          int value;
          DLinkedNode pre;
          DLinkedNode next;
          public DLinkedNode () {
              
          }
          public DLinkedNode (int key, int value) {
              this.key = key;
              this.value = value;
          }
      }
      
      private Map<Integer, DLinkedNode> cache = new HashMap<>();
      private int size;
      private int cap;
      private DLinkedNode head, tail;
  
      public LRUCache(int capacity) {
          this.size = 0;
          this.cap = capacity;
          head = new DLinkedNode();
          tail = new DLinkedNode();
          head.next = tail;
          tail.pre = head;
      }
  
      public int get(int key) {
          DLinkedNode node = cache.get(key);
          if (node == null) {
              return -1;
          }
          moveToHead(node);
          return node.value;
      }
  
      public void put(int key, int value) {
          DLinkedNode node = cache.get(key);
          if (node == null) {
              DLinkedNode newNode = new DLinkedNode(key, value);
              cache.put(key, newNode);
              addToHead(newNode);
              size++;
              if (size > cap) {
                  DLinkedNode tail = removeTail();
                  cache.remove(tail.key);
                  size--;
              }
          } else {
              node.value = value;
              moveToHead(node);
          }
      }
  
      private void moveToHead(DLinkedNode node) {
          removeNode(node);
          addToHead(node);
      }
  
      private void removeNode(DLinkedNode node) {
          node.pre.next = node.next;
          node.next.pre = node.pre;
      }
  
      private void addToHead(DLinkedNode node) {
          node.pre = head;
          node.next = head.next;
          head.next.pre = node;
          head.next = node;
      }
  
      private DLinkedNode removeTail() {
          DLinkedNode res = tail.pre;
          removeNode(res);
          return res;
      }
  }
  ```

+ Bloom Filter

  套在外层的缓存！

  一个很长的二进制向量和一系列随机映射函数。

  布隆过滤器可以用于检索一个元素是否在一个集合中。

  优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。

  ![image-20210322080759635](Z:\Perpetual-Motion-Machine\打工\春招\简历\image-20210322080759635.png)

  只要有一个映射位是0，元素一定不存在；映射位都是1也不一定存在，存在误差。

  案例：

  1. 比特币网络
  2. 分布式系统（Map-Reduce） - Hadoop、search engine
  3. Redis缓存
  4. 垃圾邮件、评论等的过滤

  Java 实现：[示例 1](https://github.com/lovasoa/bloomfilter/blob/master/src/main/java/BloomFilter.java) [示例 2](https://github.com/Baqend/Orestes-Bloomfilter)

+ Sort

  ![image-20210322090858421](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322090858421.png)

  ![image-20210322090927281](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322090927281.png)

  重点：堆排序，快速排序，归并排序

  归并：先排序左右子数组，然后合并两个有序子数组
  快排：先调配出左右子数组，然后对于左右子数组进行排序

+ #### [1122. Relative Sort Array](https://leetcode-cn.com/problems/relative-sort-array/)

  Given two arrays `arr1` and `arr2`, the elements of `arr2` are distinct, and all elements in `arr2` are also in `arr1`.

  Sort the elements of `arr1` such that the relative ordering of items in `arr1` are the same as in `arr2`. Elements that don't appear in `arr2` should be placed at the end of `arr1` in **ascending** order.

  **Example 1:**

  ```
  Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
  Output: [2,2,2,1,4,3,3,9,6,7,19]
  ```

  **Constraints:**

  - `1 <= arr1.length, arr2.length <= 1000`
  - `0 <= arr1[i], arr2[i] <= 1000`
  - All the elements of `arr2` are **distinct**.
  - Each `arr2[i]` is in `arr1`.

  ```java
  class Solution {
      public int[] relativeSortArray(int[] arr1, int[] arr2) {
          int i = 0;
          for (int i2 = 0; i2 < arr2.length; i2++) {
              for (int i1 = 0; i1 < arr1.length; i1++) {
                  if (arr1[i1] == arr2[i2]) {
                      int t = arr1[i];
                      arr1[i++] = arr1[i1];
                      arr1[i1] = t;
                  }
              }
          }
          Arrays.sort(arr1, i, arr1.length);
          return arr1;
      }
  }
  ```

+ #### [56. Merge Intervals](https://leetcode-cn.com/problems/merge-intervals/)

  Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return *an array of the non-overlapping intervals that cover all the intervals in the input*.

  **Example 1:**

  ```
  Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
  Output: [[1,6],[8,10],[15,18]]
  Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
  ```

  **Example 2:**

  ```
  Input: intervals = [[1,4],[4,5]]
  Output: [[1,5]]
  Explanation: Intervals [1,4] and [4,5] are considered overlapping.
  ```

  **Constraints:**

  - `1 <= intervals.length <= 104`
  - `intervals[i].length == 2`
  - `0 <= starti <= endi <= 104`

  ```java
  class Solution {
      public int[][] merge(int[][] intervals) {
          Deque<int[]> deque = new LinkedList<>();
          Arrays.sort(intervals, (x,y)->(x[1]-y[1]));
          Arrays.sort(intervals, (x,y)->(x[0]-y[0]));
          for (int[] interval : intervals) {
              if (deque.isEmpty()) {
                  deque.addLast(interval);
                  continue;
              }
              int end = deque.peekLast()[1];
              if (interval[0] <= end) {
                  deque.peekLast()[1] = Math.max(end, interval[1]);
              } else {
                  deque.addLast(interval);
              }
          }
          int n = deque.size();
          int[][] res = new int[n][2];
          for (int i = 0; i < n; i++) {
              res[i] = deque.pollFirst();
          }
          return res;
      }
  }
  ```

+ #### [493. Reverse Pairs](https://leetcode-cn.com/problems/reverse-pairs/)

  Given an array `nums`, we call `(i, j)` an ***important reverse pair\*** if `i < j` and `nums[i] > 2*nums[j]`.

  You need to return the number of important reverse pairs in the given array.

  **Example1:**

  ```
  Input: [1,3,2,3,1]
  Output: 2
  ```

  **Example2:**

  ```
  Input: [2,4,3,5,1]
  Output: 3
  ```

  **Note:**

  1. The length of the given array will not exceed `50,000`.
  2. All the numbers in the input array are in the range of 32-bit integer.

  ```java
  class Solution {
      int res = 0;
      public int reversePairs(int[] nums) {
          mergeSort(nums, 0, nums.length - 1);
          return res;
      }
  
      private void mergeSort(int[] nums, int left, int right) {
          if (right <= left) return ;
          int mid = (right - left) / 2 + left;
          mergeSort(nums, left, mid);
          mergeSort(nums, mid + 1, right);
          merge(nums, left, mid, right);
      }
  
      private void merge(int[] nums, int l1, int r1, int r2) {
          // count res
          int p = l1, q = r1 + 1;
          while (p <= r1 && q <= r2) {
              if (nums[p] > (long) nums[q] * 2) {
                  res += r1 - p + 1;
                  q++;
              } else p++;
          }
  
          int[] arr = new int[r2 - l1 + 1];
          int start = l1, i = 0, l2 = r1 + 1;
          while (l1 <= r1 && l2 <= r2) {
              arr[i++] = nums[l1] > nums[l2] ? nums[l2++] : nums[l1++];
          }
          while (l1 <= r1) arr[i++] = nums[l1++];
          while (l2 <= r2) arr[i++] = nums[l2++];
          for (l1 = start; l1 <= r2; l1++) {
              nums[l1] = arr[l1 - start];
          }
      }
  }
  ```
]]></description></item><item><title>Data Structure and Algorithm - Day 12</title><link>http://www.cnblogs.com/peng8098/archive/2021/03/21/algorithm12.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 21 Mar 2021 08:50:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2021/03/21/algorithm12.html</guid><description><![CDATA[+ Advanced Search

  + Pruning

  + Bidirectional Breadth First Search

  + Heuristic search (A* Search)

    ```java
    public class AStar
    {
        public final static int BAR = 1; // 障碍值
        public final static int PATH = 2; // 路径
        public final static int DIRECT_VALUE = 10; // 横竖移动代价
        public final static int OBLIQUE_VALUE = 14; // 斜移动代价
    
        Queue<Node> openList = new PriorityQueue<Node>(); // 优先队列(升序)
        List<Node> closeList = new ArrayList<Node>();
    
        /**
         * 开始算法
         */
        public void start(MapInfo mapInfo)
        {
            if(mapInfo==null) return;
            // clean
            openList.clear();
            closeList.clear();
            // 开始搜索
            openList.add(mapInfo.start);
            moveNodes(mapInfo);
        }
    
        /**
         * 移动当前结点
         */
        private void moveNodes(MapInfo mapInfo)
        {
            while (!openList.isEmpty())
            {
                Node current = openList.poll();
                closeList.add(current);
                addNeighborNodeInOpen(mapInfo,current);
                if (isCoordInClose(mapInfo.end.coord))
                {
                    drawPath(mapInfo.maps, mapInfo.end);
                    break;
                }
            }
        }
    
        /**
         * 在二维数组中绘制路径
         */
        private void drawPath(int[][] maps, Node end)
        {
            if(end==null||maps==null) return;
            System.out.println("总代价：" + end.G);
            while (end != null)
            {
                Coord c = end.coord;
                maps[c.y][c.x] = PATH;
                end = end.parent;
            }
        }
    
        /**
         * 添加所有邻结点到open表
         */
        private void addNeighborNodeInOpen(MapInfo mapInfo,Node current)
        {
            int x = current.coord.x;
            int y = current.coord.y;
            // 左
            addNeighborNodeInOpen(mapInfo,current, x - 1, y, DIRECT_VALUE);
            // 上
            addNeighborNodeInOpen(mapInfo,current, x, y - 1, DIRECT_VALUE);
            // 右
            addNeighborNodeInOpen(mapInfo,current, x + 1, y, DIRECT_VALUE);
            // 下
            addNeighborNodeInOpen(mapInfo,current, x, y + 1, DIRECT_VALUE);
            // 左上
            addNeighborNodeInOpen(mapInfo,current, x - 1, y - 1, OBLIQUE_VALUE);
            // 右上
            addNeighborNodeInOpen(mapInfo,current, x + 1, y - 1, OBLIQUE_VALUE);
            // 右下
            addNeighborNodeInOpen(mapInfo,current, x + 1, y + 1, OBLIQUE_VALUE);
            // 左下
            addNeighborNodeInOpen(mapInfo,current, x - 1, y + 1, OBLIQUE_VALUE);
        }
    
        /**
         * 添加一个邻结点到open表
         */
        private void addNeighborNodeInOpen(MapInfo mapInfo,Node current, int x, int y, int value)
        {
            if (canAddNodeToOpen(mapInfo,x, y))
            {
                Node end=mapInfo.end;
                Coord coord = new Coord(x, y);
                int G = current.G + value; // 计算邻结点的G值
                Node child = findNodeInOpen(coord);
                if (child == null)
                {
                    int H=calcH(end.coord,coord); // 计算H值
                    if(isEndNode(end.coord,coord))
                    {
                        child=end;
                        child.parent=current;
                        child.G=G;
                        child.H=H;
                    }
                    else
                    {
                        child = new Node(coord, current, G, H);
                    }
                    openList.add(child);
                }
                else if (child.G > G)
                {
                    child.G = G;
                    child.parent = current;
                    openList.add(child);
                }
            }
        }
    
        /**
         * 从Open列表中查找结点
         */
        private Node findNodeInOpen(Coord coord)
        {
            if (coord == null || openList.isEmpty()) return null;
            for (Node node : openList)
            {
                if (node.coord.equals(coord))
                {
                    return node;
                }
            }
            return null;
        }
    
    
        /**
         * 计算H的估值：“曼哈顿”法，坐标分别取差值相加
         */
        private int calcH(Coord end,Coord coord)
        {
            return Math.abs(end.x - coord.x)
                    + Math.abs(end.y - coord.y);
        }
    
        /**
         * 判断结点是否是最终结点
         */
        private boolean isEndNode(Coord end,Coord coord)
        {
            return coord != null && end.equals(coord);
        }
    
        /**
         * 判断结点能否放入Open列表
         */
        private boolean canAddNodeToOpen(MapInfo mapInfo,int x, int y)
        {
            // 是否在地图中
            if (x < 0 || x >= mapInfo.width || y < 0 || y >= mapInfo.hight) return false;
            // 判断是否是不可通过的结点
            if (mapInfo.maps[y][x] == BAR) return false;
            // 判断结点是否存在close表
            if (isCoordInClose(x, y)) return false;
    
            return true;
        }
    
        /**
         * 判断坐标是否在close表中
         */
        private boolean isCoordInClose(Coord coord)
        {
            return coord!=null&&isCoordInClose(coord.x, coord.y);
        }
    
        /**
         * 判断坐标是否在close表中
         */
        private boolean isCoordInClose(int x, int y)
        {
            if (closeList.isEmpty()) return false;
            for (Node node : closeList)
            {
                if (node.coord.x == x && node.coord.y == y)
                {
                    return true;
                }
            }
            return false;
        }
    }
    ```

+ #### [36. Valid Sudoku](https://leetcode-cn.com/problems/valid-sudoku/)

  Determine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated **according to the following rules**:

  1. Each row must contain the digits `1-9` without repetition.
  2. Each column must contain the digits `1-9` without repetition.
  3. Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without repetition.

  **Note:**

  - A Sudoku board (partially filled) could be valid but is not necessarily solvable.
  - Only the filled cells need to be validated according to the mentioned rules.

  ```
  Input: board = 
  [["5","3",".",".","7",".",".",".","."]
  ,["6",".",".","1","9","5",".",".","."]
  ,[".","9","8",".",".",".",".","6","."]
  ,["8",".",".",".","6",".",".",".","3"]
  ,["4",".",".","8",".","3",".",".","1"]
  ,["7",".",".",".","2",".",".",".","6"]
  ,[".","6",".",".",".",".","2","8","."]
  ,[".",".",".","4","1","9",".",".","5"]
  ,[".",".",".",".","8",".",".","7","9"]]
  Output: true
  ```

  **Example 2:**

  ```
  Input: board = 
  [["8","3",".",".","7",".",".",".","."]
  ,["6",".",".","1","9","5",".",".","."]
  ,[".","9","8",".",".",".",".","6","."]
  ,["8",".",".",".","6",".",".",".","3"]
  ,["4",".",".","8",".","3",".",".","1"]
  ,["7",".",".",".","2",".",".",".","6"]
  ,[".","6",".",".",".",".","2","8","."]
  ,[".",".",".","4","1","9",".",".","5"]
  ,[".",".",".",".","8",".",".","7","9"]]
  Output: false
  Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
  ```

  **Constraints:**

  - `board.length == 9`
  - `board[i].length == 9`
  - `board[i][j]` is a digit or `'.'`.

  ```java
  class Solution {
      public boolean isValidSudoku(char[][] board) {
          boolean[][] rows = new boolean[9][9];
          boolean[][] cols = new boolean[9][9];
          boolean[][] blocks = new boolean[9][9];
          for (int i = 0; i < 9; i++) {
              for (int j = 0; j < 9; j++) {
                  if (board[i][j] == '.') continue;
                  if (rows[i][board[i][j] - '1']) return false;
                  if (cols[j][board[i][j] - '1']) return false;
                  int block = i/3 * 3 + j/3;
                  if (blocks[block][board[i][j] - '1']) return false;
                  rows[i][board[i][j] - '1'] = true;
                  cols[j][board[i][j] - '1'] = true;
                  blocks[block][board[i][j] - '1'] = true;
              }
          }
          return true;
      }
  }
  ```

+ #### [37. Sudoku Solver](https://leetcode-cn.com/problems/sudoku-solver/)

  Write a program to solve a Sudoku puzzle by filling the empty cells.

  A sudoku solution must satisfy **all of the following rules**:

  1. Each of the digits `1-9` must occur exactly once in each row.
  2. Each of the digits `1-9` must occur exactly once in each column.
  3. Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.

  The `'.'` character indicates empty cells.

  ```
  Input: board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
  Output: [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
  Explanation: The input board is shown above and the only valid solution is shown below:
  ```

  **Constraints:**

  - `board.length == 9`
  - `board[i].length == 9`
  - `board[i][j]` is a digit or `'.'`.
  - It is **guaranteed** that the input board has only one solution.

  ```java
  class Solution {
      boolean[][] rows = new boolean[9][9];
      boolean[][] cols = new boolean[9][9];
      boolean[][] blocks = new boolean[9][9];
      char[] nums = {'1','2','3','4','5','6','7','8','9'};
      char[][] board;
      public void solveSudoku(char[][] board) {
          this.board = board;
          for (int i = 0; i < 9; i++) {
              for (int j = 0; j < 9; j++) {
                  if (board[i][j] == '.') continue;
                  rows[i][board[i][j] - '1'] = true;
                  cols[j][board[i][j] - '1'] = true;
                  blocks[i/3 * 3 + j/3][board[i][j] - '1'] = true;
              }
          }
          dfs(0, 0);
      }
  
      private boolean dfs(int i, int j) {
          if (j == 9){
              i++;
              j = 0;
              if (i == 9) return true;
          }
          if (board[i][j] != '.') {
              return dfs(i, j + 1);
          }
          for (char num : nums) {
              if (rows[i][num - '1'] || cols[j][num - '1'] || blocks[i/3 * 3 + j/3][num - '1']) {
                  continue;
              }
              board[i][j] = num;
              rows[i][num - '1'] = true;
              cols[j][num - '1'] = true;
              blocks[i/3 * 3 + j/3][num - '1'] = true;
              if (dfs(i, j + 1)) return true;
              rows[i][num - '1'] = false;
              cols[j][num - '1'] = false;
              blocks[i/3 * 3 + j/3][num - '1'] = false;
              board[i][j] = '.';
          }
          return false;
      }
  }
  ```

+ #### [1091. Shortest Path in Binary Matrix](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)

  Given an `n x n` binary matrix `grid`, return *the length of the shortest **clear path** in the matrix*. If there is no clear path, return `-1`.

  A **clear path** in a binary matrix is a path from the **top-left** cell (i.e., `(0, 0)`) to the **bottom-right** cell (i.e., `(n - 1, n - 1)`) such that:

  - All the visited cells of the path are `0`.
  - All the adjacent cells of the path are **8-directionally** connected (i.e., they are different and they share an edge or a corner).

  The **length of a clear path** is the number of visited cells of this path.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2021/02/18/example1_1.png)

  ```
  Input: grid = [[0,1],[1,0]]
  Output: 2
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2021/02/18/example2_1.png)

  ```
  Input: grid = [[0,0,0],[1,1,0],[1,1,0]]
  Output: 4
  ```

  **Example 3:**

  ```
  Input: grid = [[1,0,0],[1,1,0],[1,1,0]]
  Output: -1
  ```

  **Constraints:**

  - `n == grid.length`
  - `n == grid[i].length`
  - `1 <= n <= 100`
  - `grid[i][j] is 0 or 1`

  ```java
  class Solution {
      int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};
      public int shortestPathBinaryMatrix(int[][] grid) {
          if (grid[0][0] == 1) return -1;
          Deque<int[]> deque = new LinkedList<>();
          int m = grid.length, n = grid[0].length;
          deque.addLast(new int[]{0,0});
          grid[0][0] = 1;
          int res = 0;
          while (!deque.isEmpty()) {
              int size = deque.size();
              res++;
              while (size-- > 0) {
                  int[] pos = deque.pollFirst();
                  int x = pos[0], y = pos[1];
                  if (x == m - 1 && y == n - 1) {
                      return res;
                  }
                  for (int[] dir : dirs) {
                      int i = x + dir[0], j = y + dir[1];
                      if (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length && grid[i][j] == 0) {
                          deque.addLast(new int[]{i, j});
                          grid[i][j] = 1;
                      } 
                  }
              }
          }
          return -1;
      }
  }
  ```

+ AVL Tree

  ![](https://img2020.cnblogs.com/blog/1205669/202103/1205669-20210321164842029-96194661.png)


+ Red Black Tree

  ![](https://img2020.cnblogs.com/blog/1205669/202103/1205669-20210321164859912-300235445.png)


  vs AVL Tree

  ![](https://img2020.cnblogs.com/blog/1205669/202103/1205669-20210321164916763-2046923632.png)


+ Bit Operation

  ```
  <<: 0011=>0110
  >>: 0110=>0011
  | : 0011|1011=>1011
  & : 0011&1011=>0011
  ~ : 0011=>1100
  ^ : 0011^1011=>1000
  
  x ^ 0 = x
  x ^ (~x) = (~0) = 1s(all one)
  x ^ 1s = ~x
  x ^ x = 0
  ```

  ![](https://img2020.cnblogs.com/blog/1205669/202103/1205669-20210321164929680-1723159938.png)


  apply

  ![](https://img2020.cnblogs.com/blog/1205669/202103/1205669-20210321164937193-1533471935.png)


+ #### [191. Number of 1 Bits](https://leetcode-cn.com/problems/number-of-1-bits/)

  Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)).

  **Note:**

  - Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
  - In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two's_complement). Therefore, in **Example 3**, the input represents the signed integer. `-3`.

  **Example 1:**

  ```
  Input: n = 00000000000000000000000000001011
  Output: 3
  Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
  ```

  **Example 2:**

  ```
  Input: n = 00000000000000000000000010000000
  Output: 1
  Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
  ```

  **Example 3:**

  ```
  Input: n = 11111111111111111111111111111101
  Output: 31
  Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
  ```

  **Constraints:**

  - The input must be a **binary string** of length `32`.

  ```java
  public class Solution {
      public int hammingWeight(int n) {
          int res = 0;
          while (n != 0) {
              res += (n&1) == 1 ? 1 : 0;
              n = n >>> 1;
          }
          return res;
      }
  }
  ```

+ #### [231. Power of Two](https://leetcode-cn.com/problems/power-of-two/)

  Given an integer `n`, return *`true` if it is a power of two. Otherwise, return `false`*.

  An integer `n` is a power of two, if there exists an integer `x` such that `n == 2x`.

  **Example 1:**

  ```
  Input: n = 1
  Output: true
  Explanation: 20 = 1
  ```

  **Example 2:**

  ```
  Input: n = 16
  Output: true
  Explanation: 24 = 16
  ```

  **Example 3:**

  ```
  Input: n = 3
  Output: false
  ```

  **Example 4:**

  ```
  Input: n = 4
  Output: true
  ```

  **Example 5:**

  ```
  Input: n = 5
  Output: false
  ```

  **Constraints:**

  - `-231 <= n <= 231 - 1`

  ```java
  class Solution {
      public boolean isPowerOfTwo(int n) {
          return n > 0 && (n & (n - 1)) == 0;
      }
  }
  ```

+ #### [190. Reverse Bits](https://leetcode-cn.com/problems/reverse-bits/)

  Reverse bits of a given 32 bits unsigned integer.

  **Note:**

  - Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
  - In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two's_complement). Therefore, in **Example 2** above, the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.

  **Follow up**:

  If this function is called many times, how would you optimize it?

  **Example 1:**

  ```
  Input: n = 00000010100101000001111010011100
  Output:    964176192 (00111001011110000010100101000000)
  Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.
  ```

  **Example 2:**

  ```
  Input: n = 11111111111111111111111111111101
  Output:   3221225471 (10111111111111111111111111111111)
  Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.
  ```

  **Constraints:**

  - The input must be a **binary string** of length `32`

  ```java
  public class Solution {
      // you need treat n as an unsigned value
      public int reverseBits(int n) {
          int res = 0;
          for (int i = 0; i < 32; i++) {
              res <<= 1;
              res += n & 1;
              n >>>= 1;
          }
          return res;
      }
  }
  ```

+ #### [338. Counting Bits](https://leetcode-cn.com/problems/counting-bits/)

  Given an integer `num`, return *an array of the number of* `1`*'s in the binary representation of every number in the range* `[0, num]`.

  **Example 1:**

  ```
  Input: num = 2
  Output: [0,1,1]
  Explanation:
  0 --> 0
  1 --> 1
  2 --> 10
  ```

  **Example 2:**

  ```
  Input: num = 5
  Output: [0,1,1,2,1,2]
  Explanation:
  0 --> 0
  1 --> 1
  2 --> 10
  3 --> 11
  4 --> 100
  5 --> 101
  ```

  **Constraints:**

  - `0 <= num <= 105`

  ```java
  // stupid count
  class Solution {
      public int[] countBits(int num) {
          int[] res = new int[num + 1];
          for (int i = 1; i <= num; i++) {
              res[i] = countBit(i);
          }
          return res;
      }
  
      private int countBit(int num) {
          if (num == 0) return 0;
          return 1 + countBit(num & (num - 1));
      }
  }
  
  // DP
  class Solution {
      public int[] countBits(int num) {
          int[] bits = new int[num + 1];
          for (int i = 1; i <= num; i++) {
              bits[i] = bits[i >> 1] + (i & 1);
          }
          return bits;
      }
  }
  ```

  ]]></description></item><item><title>Data Structure and Algorithm - Day 11</title><link>http://www.cnblogs.com/peng8098/archive/2021/03/20/algorithm11.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 20 Mar 2021 08:30:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2021/03/20/algorithm11.html</guid><description><![CDATA[
+ Trie

  ![](https://img2020.cnblogs.com/blog/1205669/202103/1205669-20210320162839065-1614015253.png)


  inner

  ![](https://img2020.cnblogs.com/blog/1205669/202103/1205669-20210320162848190-499258579.png)


+ #### [208. Implement Trie (Prefix Tree)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

  Trie (we pronounce "try") or prefix tree is a tree data structure used to retrieve a key in a strings dataset. There are various applications of this very efficient data structure, such as autocomplete and spellchecker.

  Implement the Trie class:

  - `Trie()` initializes the trie object.
  - `void insert(String word)` inserts the string `word` to the trie.
  - `boolean search(String word)` returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise.
  - `boolean startsWith(String prefix)` returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.

  **Example 1:**

  ```
  Input
  ["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
  [[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
  Output
  [null, null, true, false, true, null, true]
  
  Explanation
  Trie trie = new Trie();
  trie.insert("apple");
  trie.search("apple");   // return True
  trie.search("app");     // return False
  trie.startsWith("app"); // return True
  trie.insert("app");
  trie.search("app");     // return True
  ```

  **Constraints:**

  - `1 <= word.length, prefix.length <= 2000`
  - `word` and `prefix` consist of lowercase English letters.
  - At most `3 * 104` calls will be made to `insert`, `search`, and `startsWith`.

  ```java
  public class Trie {
      private boolean isString = false;
      private Trie[] next = new Trie[26];
  
      public Trie() {
  
      }
  
      public void insert(String word) {
          Trie root = this;
          char[] w = word.toCharArray();
          for (int i = 0; i < w.length; i++) {
              if (root.next[w[i] - 'a'] == null)
                  root.next[w[i] - 'a'] = new Trie();
              root = root.next[w[i] - 'a'];
          }
          root.isString = true;
      }
  
      public boolean search(String word) {
          Trie root = this;
          char[] w = word.toCharArray();
          for (int i = 0; i < w.length; i++) {
              if (root.next[w[i] - 'a'] == null) 
                  return false;
              root = root.next[w[i] - 'a'];
          }
          return root.isString;
      }
      
      public boolean startsWith(String prefix) {
          Trie root = this;
          char[] p = prefix.toCharArray();
          for (int i = 0; i < p.length; i++) {
              if (root.next[p[i] - 'a'] == null)
                  return false;
              root = root.next[p[i] - 'a'];
          }
          return true;
      }
  }
  ```

+ #### [212. Word Search II](https://leetcode-cn.com/problems/word-search-ii/)

  Given an `m x n` `board` of characters and a list of strings `words`, return *all words on the board*.

  Each word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

   

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)

  ```
  Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
  Output: ["eat","oath"]
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)

  ```
  Input: board = [["a","b"],["c","d"]], words = ["abcb"]
  Output: []
  ```

   

  **Constraints:**

  - `m == board.length`
  - `n == board[i].length`
  - `1 <= m, n <= 12`
  - `board[i][j]` is a lowercase English letter.
  - `1 <= words.length <= 3 * 104`
  - `1 <= words[i].length <= 10`
  - `words[i]` consists of lowercase English letters.
  - All the strings of `words` are unique.

  ```java
  class Solution {
      int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};
      Trie trie = new Trie();
      public List<String> findWords(char[][] board, String[] words) {
          for (String word : words) {
              trie.insert(word);
          }
          Set<String> set = new HashSet<>();
          StringBuilder sb = new StringBuilder();
          for (int i = 0; i < board.length; i++) {
              for (int j = 0; j < board[0].length; j++) {
                  dfs(set, sb, board, i, j);
              }
          }
          return new ArrayList<>(set);
      }
  
      private void dfs(Set<String> set, StringBuilder sb, char[][] board, int i, int j) { 
          sb.append(board[i][j]);
          if (!trie.startsWith(sb.toString())) {
              sb.deleteCharAt(sb.length() - 1);
              return ;
          }
          if (trie.search(sb.toString())) {
              set.add(sb.toString());
          }
          char t = board[i][j];
          board[i][j] = '.';
          for (int[] dir : dirs) {
              int x = i + dir[0], y = j + dir[1];
              if (x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] != '.') {
                  dfs(set, sb, board, x, y);
              }
          }
          board[i][j] = t;
          sb.deleteCharAt(sb.length() - 1);
      }
  }
  
  class Trie {...}
  ```

+ Disjoint Set

  ```java
  // Java Template
  class UnionFind {
      int count = 0;
      int[] parent;
  
      public UnionFind(int n) {
          count = n;
          parent = new int[n];
          for (int i = 0; i < n; i++) {
              parent[i] = i;
          }
      }
  
      int find(int p) {
          while (p != parent[p]) {
              p = parent[parent[p]];
          }
          return p;
      }
  
      void union(int p, int q) {
          int rootP = find(p);
          int rootQ = find(q);
          if (rootP != rootQ) {
              parent[rootP] = rootQ;
              count--;
          }
      }
  }
  ```

+ #### [547. Number of Provinces(Friend-Circles)](https://leetcode-cn.com/problems/number-of-provinces/)

  There are `n` cities. Some of them are connected, while some are not. If city `a` is connected directly with city `b`, and city `b` is connected directly with city `c`, then city `a` is connected indirectly with city `c`.

  A **province** is a group of directly or indirectly connected cities and no other cities outside of the group.

  You are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if the `ith` city and the `jth` city are directly connected, and `isConnected[i][j] = 0` otherwise.

  Return *the total number of **provinces***.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg)

  ```
  Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]
  Output: 2
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg)

  ```
  Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]
  Output: 3
  ```

  **Constraints:**

  - `1 <= n <= 200`
  - `n == isConnected.length`
  - `n == isConnected[i].length`
  - `isConnected[i][j]` is `1` or `0`.
  - `isConnected[i][i] == 1`
  - `isConnected[i][j] == isConnected[j][i]`

  ```java
  class Solution {
      public int findCircleNum(int[][] isConnected) {
          int n = isConnected.length;
          UnionFind unionFind = new UnionFind(n);
          for (int i = 0; i < n; i++) {
              for (int j = i + 1; j < n; j++) {
                  if (isConnected[i][j] == 1) {
                      unionFind.union(i, j);
                  }
              }
          }
          return unionFind.count;
      }
  }
  
  class UnionFind {...}
  ```

+ #### [200. Number of Islands](https://leetcode-cn.com/problems/number-of-islands/)

  Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*.

  An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

  **Example 1:**

  ```
  Input: grid = [
    ["1","1","1","1","0"],
    ["1","1","0","1","0"],
    ["1","1","0","0","0"],
    ["0","0","0","0","0"]
  ]
  Output: 1
  ```

  **Example 2:**

  ```
  Input: grid = [
    ["1","1","0","0","0"],
    ["1","1","0","0","0"],
    ["0","0","1","0","0"],
    ["0","0","0","1","1"]
  ]
  Output: 3
  ```

  **Constraints:**

  - `m == grid.length`
  - `n == grid[i].length`
  - `1 <= m, n <= 300`
  - `grid[i][j]` is `'0'` or `'1'`.

  ```java
  class Solution {
      public int numIslands(char[][] grid) {
          int m = grid.length, n = grid[0].length;
          UnionFind unionFind = new UnionFind(m, n);
          int zero = 0;
          for (int i = 0; i < m; i++) {
              for (int j = 0; j < n; j++) {
                  if (grid[i][j] == '0') {
                      zero++;
                      continue;
                  }
                  if (i-1 >= 0 && grid[i-1][j] == '1') {
                      unionFind.union(i*n + j, (i-1)*n + j);
                  }
                  if (j-1 >= 0 && grid[i][j-1] == '1') {
                      unionFind.union(i*n + j, i*n + j - 1);
                  }
                  if (j+1 < n && grid[i][j+1] == '1') {
                      unionFind.union(i*n + j, i*n + j + 1);
                  }
                  if (i+1 < m && grid[i+1][j] == '1') {
                      unionFind.union(i*n + j, (i+1)*n + j);
                  }
              }
          }
          return unionFind.count - zero;
      }
  }
  
  class UnionFind {
      int count = 0;
      int[] parent;
      public UnionFind(int m, int n) {
          count = m * n;
          parent= new int[count];
          for (int i = 0; i < m; i++) {
              for (int j = 0; j < n; j++) {
                  parent[i*n + j] = i*n + j;
              }
          }
      }
  
      int find(int k) {
          while (parent[k] != k) {
              k = parent[parent[k]];
          }
          return k;
      }
  
      void union(int p, int q) {
          int rootP = find(p);
          int rootQ = find(q);
          if (rootP != rootQ) {
              parent[rootP] = rootQ;
              count--;
          }
      }
  }
  ```

+ #### [130. Surrounded Regions](https://leetcode-cn.com/problems/surrounded-regions/)

  Given an `m x n` matrix `board` containing `'X'` and `'O'`, *capture all regions surrounded by* `'X'`.

  A region is **captured** by flipping all `'O'`s into `'X'`s in that surrounded region.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)

  ```
  Input: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
  Output: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
  Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
  ```

  **Example 2:**

  ```
  Input: board = [["X"]]
  Output: [["X"]]
  ```

  **Constraints:**

  - `m == board.length`
  - `n == board[i].length`
  - `1 <= m, n <= 200`
  - `board[i][j]` is `'X'` or `'O'`.

  ```java
  class Solution {
      int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};
      public void solve(char[][] board) {
          int m = board.length, n = board[0].length;
          for (int i = 0; i < m; i++) {
              if (board[i][0] == 'O') {
                  dfs(board, i, 0);
              }
              if (board[i][n-1] == 'O') {
                  dfs(board, i, n-1);
              }
          }
          for (int j = 1; j < n-1; j++) {
              if (board[0][j] == 'O') {
                  dfs(board, 0, j);
              }
              if (board[m-1][j] == 'O') {
                  dfs(board, m-1, j);
              }
          }
          for (int i = 0; i < m; i++) {
              for (int j = 0; j < n; j++) {
                  if (board[i][j] == 'O') board[i][j] = 'X';
              }
          }
          for (int i = 0; i < m; i++) {
              for (int j = 0; j < n; j++) {
                  if (board[i][j] == '.') board[i][j] = 'O';
              }
          }
      }
  
      private void dfs(char[][] board, int i, int j) {
          board[i][j] = '.';
          for (int[] dir : dirs) {
              int x = i + dir[0], y = j + dir[1];
              if (x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] == 'O') {
                  dfs(board, x, y);
              }
          }
      }
  }
  ```

+ #### [213. House Robber II](https://leetcode-cn.com/problems/house-robber-ii/)

  You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

  Given an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.

  **Example 1:**

  ```
  Input: nums = [2,3,2]
  Output: 3
  Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
  ```

  **Example 2:**

  ```
  Input: nums = [1,2,3,1]
  Output: 4
  Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
  Total amount you can rob = 1 + 3 = 4.
  ```

  **Example 3:**

  ```
  Input: nums = [0]
  Output: 0
  ```

  **Constraints:**

  - `1 <= nums.length <= 100`
  - `0 <= nums[i] <= 1000`

  ```java
  class Solution {
      public int rob(int[] nums) {
          if (nums.length == 1) return nums[0];
          if (nums.length == 2) return Math.max(nums[0],nums[1]);
          int a = rob(nums, 0, nums.length - 2);
          int b = rob(nums, 1, nums.length - 1);
          return Math.max(a, b);
      }
  
      private int rob(int[] nums, int l, int r) {
          if (l == r) return nums[0];
          if (l + 1 == r) return Math.max(nums[0],nums[1]);
          int[] dp = new int[r - l + 1];
          dp[0] = nums[l];
          dp[1] = Math.max(nums[l], nums[l+1]);
          for (int i = l+2; i <= r; i++) {
              dp[i-l] = Math.max(dp[i-l-1], dp[i-l-2]+nums[i]);
          }
          return dp[r-l];
      }
  }
  ```

+ #### [121. Best Time to Buy and Sell Stock](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

  You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

  You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

  Return *the maximum profit you can achieve from this transaction*. If you cannot achieve any profit, return `0`.

  **Example 1:**

  ```
  Input: prices = [7,1,5,3,6,4]
  Output: 5
  Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
  Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
  ```

  **Example 2:**

  ```
  Input: prices = [7,6,4,3,1]
  Output: 0
  Explanation: In this case, no transactions are done and the max profit = 0.
  ```

  **Constraints:**

  - `1 <= prices.length <= 105`
  - `0 <= prices[i] <= 104`

  ```java
  class Solution {
      public int maxProfit(int[] prices) {
          int min = prices[0];
          int res = 0;
          for (int i = 1; i < prices.length; i++) {
              res = Math.max(res, prices[i] - min);
              min = Math.min(min, prices[i]);
          }
          return res;
      }
  }
  ```
]]></description></item><item><title>Data Structure and Algorithm - Day 10</title><link>http://www.cnblogs.com/peng8098/archive/2021/03/19/algorithm10.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 19 Mar 2021 12:19:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2021/03/19/algorithm10.html</guid><description><![CDATA[+ new climb stairs

  step: 1 2 3, two adjacent steps cannot be the same.

+ #### [120. Triangle](https://leetcode-cn.com/problems/triangle/)

  Given a `triangle` array, return *the minimum path sum from top to bottom*.

  For each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.

  **Example 1:**

  ```
  Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
  Output: 11
  Explanation: The triangle looks like:
     2
    3 4
   6 5 7
  4 1 8 3
  The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
  ```

  **Example 2:**

  ```
  Input: triangle = [[-10]]
  Output: -10
  ```

  **Constraints:**

  - `1 <= triangle.length <= 200`
  - `triangle[0].length == 1`
  - `triangle[i].length == triangle[i - 1].length + 1`
  - `-104 <= triangle[i][j] <= 104`

  **Follow up:** Could you do this using only `O(n)` extra space, where `n` is the total number of rows in the triangle?

  ```java
  // division: problem(i,j) = min(sub(i+1,j),sub(i+1,j+1)) + a[i,j]
  // dp array: f[i,j]
  // dp equation: f[i][j] = Math.min(f[i+1][j], f[i+1][j+1]) + a[i][j]
  class Solution {
      public int minimumTotal(List<List<Integer>> triangle) {
          int n = triangle.size();
          int[] dp = new int[n];
          for (int i = 0; i < n; i++) {
              dp[i] = triangle.get(n-1).get(i);
          }
          for (int i = n-2; i >= 0; i--) {
              for (int j = 0; j <= i; j++) {
                  dp[j] = triangle.get(i).get(j) + Math.min(dp[j], dp[j+1]);
              }
          }
          return dp[0];
      }
  }
  
  // memo dfs
  ```

+ #### [152. Maximum Product Subarray](https://leetcode-cn.com/problems/maximum-product-subarray/)

  Given an integer array `nums`, find a contiguous non-empty subarray within the array that has the largest product, and return *the product*.

  It is **guaranteed** that the answer will fit in a **32-bit** integer.

  A **subarray** is a contiguous subsequence of the array.

  **Example 1:**

  ```
  Input: nums = [2,3,-2,4]
  Output: 6
  Explanation: [2,3] has the largest product 6.
  ```

  **Example 2:**

  ```
  Input: nums = [-2,0,-1]
  Output: 0
  Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
  ```

  **Constraints:**

  - `1 <= nums.length <= 2 * 104`
  - `-10 <= nums[i] <= 10`

  ```java
  class Solution {
      public int maxProduct(int[] nums) {
          int res = nums[0];
          int min = nums[0], max = nums[0];
          for (int i = 1; i < nums.length; i++) {
              int t = min;
              min = Math.min(Math.min(nums[i], nums[i] * min), nums[i] * max);
              max = Math.max(Math.max(nums[i], nums[i] * max), nums[i] * t);
              res = Math.max(res, max);
          }
          return res;
      }
  }
  ```

+ #### [322. Coin Change](https://leetcode-cn.com/problems/coin-change/)

  You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.

  Return *the fewest number of coins that you need to make up that amount*. If that amount of money cannot be made up by any combination of the coins, return `-1`.

  You may assume that you have an infinite number of each kind of coin.

  **Example 1:**

  ```
  Input: coins = [1,2,5], amount = 11
  Output: 3
  Explanation: 11 = 5 + 5 + 1
  ```

  **Example 2:**

  ```
  Input: coins = [2], amount = 3
  Output: -1
  ```

  **Example 3:**

  ```
  Input: coins = [1], amount = 0
  Output: 0
  ```

  **Example 4:**

  ```
  Input: coins = [1], amount = 1
  Output: 1
  ```

  **Example 5:**

  ```
  Input: coins = [1], amount = 2
  Output: 2
  ```

  **Constraints:**

  - `1 <= coins.length <= 12`
  - `1 <= coins[i] <= 231 - 1`
  - `0 <= amount <= 104`

  ```java
  // recur over time
  class Solution {
      int res = Integer.MAX_VALUE;
      public int coinChange(int[] coins, int amount) {
          bfs(coins, amount, 0);
          return res == Integer.MAX_VALUE ? -1 : res;
      }
  
      private void bfs(int[] coins, int amount, int num) {
          if (amount < 0) return ; 
          if (amount == 0) {
              res = Math.min(res, num);
              return ;
          }
          for (int coin : coins) {
              bfs(coins, amount - coin, num + 1);
          }
      }
  }
  
  // DP
  // subproblems: problem[i] = 1 + min(sub(i-coin1),sub(i-coin2),...)
  // dp array: f(n) = min(f(n-k), fpr k in [1,2,5]) + 1
  // dp equation
  class Solution {
      public int coinChange(int[] coins, int amount) {
          int max = amount + 1;
          int[] dp = new int[amount + 1];
          Arrays.fill(dp, max);
          dp[0] = 0;
          for (int i = 1; i <= amount; i++) {
              for (int coin : coins) {
                  if (coin <= i) {
                      dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                  }
              }
          }
          return dp[amount] > amount ? -1 : dp[amount];
      }
  }
  ```

+ #### [198. House Robber](https://leetcode-cn.com/problems/house-robber/)

  You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

  Given an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.

  **Example 1:**

  ```
  Input: nums = [1,2,3,1]
  Output: 4
  Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
  Total amount you can rob = 1 + 3 = 4.
  ```

  **Example 2:**

  ```
  Input: nums = [2,7,9,3,1]
  Output: 12
  Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
  Total amount you can rob = 2 + 9 + 1 = 12.
  ```

  **Constraints:**

  - `1 <= nums.length <= 100`
  - `0 <= nums[i] <= 400`

  ```java
  class Solution {
      public int rob(int[] nums) {
          if (nums.length == 1) return nums[0];
          nums[1] = Math.max(nums[0], nums[1]);
          for (int i = 2; i < nums.length; i++) {
              nums[i] = Math.max(nums[i] + nums[i-2], nums[i-1]);
          }
          return nums[nums.length - 1];
      }
  }
  
  class Solution {
      public int rob(int[] nums) {
          if (nums.length == 1) return nums[0];
          int[][] dp = new int[nums.length][2];
          dp[0][0] = 0; // not rob
          dp[0][1] = nums[0]; // rob
          for (int i = 1; i < nums.length; i++) {
              dp[i][0] = Math.max(dp[i-1][1], dp[i-1][0]);
              dp[i][1] = dp[i-1][0] + nums[i];
          }
          return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);
      }
  }
  ```
]]></description></item><item><title>Data Structure and Algorithm - Day 09</title><link>http://www.cnblogs.com/peng8098/archive/2021/03/18/algorithm9.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 18 Mar 2021 08:20:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2021/03/18/algorithm9.html</guid><description><![CDATA[+ Binary Search

  premise : 1. monotonicity 2. exist upper and lower bound 3. index accessible

  ```python
  left, right = 0, len(array) - 1
  while left <= right:
      mid = (right - left) / 2 + left
      if array[mid] == target:
          # find the target !
          break or return result
      elif array[mid] < target:
          left = mid + 1
      else
      	right = mid - 1
  ```

+ #### [69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/)

  Given a non-negative integer `x`, compute and return *the square root of* `x`.

  Since the return type is an integer, the decimal digits are **truncated**, and only **the integer part** of the result is returned.

  **Example 1:**

  ```
  Input: x = 4
  Output: 2
  ```

  **Example 2:**

  ```
  Input: x = 8
  Output: 2
  Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.
  ```

  ```java
  class Solution {
      public int mySqrt(int x) {
          if (x == 0 || x == 1) {
              return x;
          }
          int left = 1, right = x;
          while (left <= right) {
              int mid = left + (right - left) / 2;
              if ((long)mid * mid > x) {
                  right = mid - 1;
              } else {
                  left = mid + 1;
              }
          }
          return right;
      }
  }
  ```

  ```java
  // Newton iterative method
  class Solution {
      public int mySqrt(int x) {
          if (x == 0) {
              return 0;
          }
  
          double C = x, x0 = x;
          while (true) {
              double xi = 0.5 * (x0 + C / x0);
              if (Math.abs(x0 - xi) < 1e-7) {
                  break;
              }
              x0 = xi;
          }
          return (int) x0;
      }
  }
  ```

+ #### [33. Search in Rotated Sorted Array](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

  There is an integer array `nums` sorted in ascending order (with **distinct** values).

  Prior to being passed to your function, `nums` is **rotated** at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

  Given the array `nums` **after** the rotation and an integer `target`, return *the index of* `target` *if it is in* `nums`*, or* `-1` *if it is not in* `nums`.

  **Example 1:**

  ```
  Input: nums = [4,5,6,7,0,1,2], target = 0
  Output: 4
  ```

  **Example 2:**

  ```
  Input: nums = [4,5,6,7,0,1,2], target = 3
  Output: -1
  ```

  **Example 3:**

  ```
  Input: nums = [1], target = 0
  Output: -1
  ```

  **Constraints:**

  - `1 <= nums.length <= 5000`
  - `-104 <= nums[i] <= 104`
  - All values of `nums` are **unique**.
  - `nums` is guaranteed to be rotated at some pivot.
  - `-104 <= target <= 104`

  ```java
  class Solution {
      public int search(int[] nums, int target) {
          int left = 0, right = nums.length - 1;
          while (left <= right) {
              int mid = (right - left) / 2 + left;
              if (nums[mid] == target) {
                  return mid;
              } else if (nums[left] <= nums[mid]){ // left is orderly
                  if (target < nums[mid] && target >= nums[left]) {
                      right = mid - 1;
                  } else {
                      left = mid + 1;
                  }
              } else { // right is orderly
                  if (target > nums[mid] && target <= nums[right]){
                      left = mid + 1;
                  } else {
                      right = mid - 1;
                  }
              }
          }
          return -1;
      }
  }
  ```

+ #### [367. Valid Perfect Square](https://leetcode-cn.com/problems/valid-perfect-square/)

  Given a **positive** integer *num*, write a function which returns True if *num* is a perfect square else False.

  **Follow up:** **Do not** use any built-in library function such as `sqrt`.

  **Example 1:**

  ```
  Input: num = 16
  Output: true
  ```

  **Example 2:**

  ```
  Input: num = 14
  Output: false
  ```

  **Constraints:**

  - `1 <= num <= 2^31 - 1`

  ```java
  class Solution {
      public boolean isPerfectSquare(int num) {
          if (num == 0 || num == 1) return true;
          int left = 1, right = num;
          while (left <= right) {
              int mid = (right - left) / 2 + left;
              if ((long) mid * mid == num) {
                  return true;
              } else if ((long) mid * mid > num) {
                  right = mid - 1;
              } else {
                  left = mid + 1;
              }
          }
          return right * right == num;
      }
  }
  ```

+ #### [74. Search a 2D Matrix](https://leetcode-cn.com/problems/search-a-2d-matrix/)

  Write an efficient algorithm that searches for a value in an `m x n` matrix. This matrix has the following properties:

  - Integers in each row are sorted from left to right.
  - The first integer of each row is greater than the last integer of the previous row.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

  ```
  Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
  Output: true
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg)

  ```
  Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
  Output: false
  ```

  **Constraints:**

  - `m == matrix.length`
  - `n == matrix[i].length`
  - `1 <= m, n <= 100`
  - `-104 <= matrix[i][j], target <= 104`

  ```java
  class Solution {
      public boolean searchMatrix(int[][] matrix, int target) {
          if (matrix.length == 0) return false;
          int n = matrix.length, m = matrix[0].length;
          for (int i = 0, j = m - 1; i < n && j >= 0; ) {
              if (matrix[i][j] == target) {
                  return true;
              } else if (matrix[i][j] < target) {
                  i++;
              } else {
                  j--;
              }
          }
          return false;
      }
  }
  ```

+ #### [153. Find Minimum in Rotated Sorted Array](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

  Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:

  - `[4,5,6,7,0,1,2]` if it was rotated `4` times.
  - `[0,1,2,4,5,6,7]` if it was rotated `7` times.

  Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

  Given the sorted rotated array `nums` of **unique** elements, return *the minimum element of this array*.

  **Example 1:**

  ```
  Input: nums = [3,4,5,1,2]
  Output: 1
  Explanation: The original array was [1,2,3,4,5] rotated 3 times.
  ```

  **Example 2:**

  ```
  Input: nums = [4,5,6,7,0,1,2]
  Output: 0
  Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
  ```

  **Example 3:**

  ```
  Input: nums = [11,13,15,17]
  Output: 11
  Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
  ```

  **Constraints:**

  - `n == nums.length`
  - `1 <= n <= 5000`
  - `-5000 <= nums[i] <= 5000`
  - All the integers of `nums` are **unique**.
  - `nums` is sorted and rotated between `1` and `n` times.

  ```java
  class Solution {
      public int findMin(int[] nums) {
          int left = 0, right = nums.length - 1;
          while (left < right) {
              int mid = (right - left) / 2 + left;
              if (nums[left] <= nums[mid]) { // when length == 1, left == mid
                  if (nums[mid] < nums[right]) {
                      return nums[left];
                  } else {
                      left = mid + 1;
                  }
              } else {
                  right = mid;
              }
          }
          return nums[right];
      }
  }
  ```

+ Dynamic Programming

  Simplifying a complicated problem by breaking it down into simpler sub-problems (in a recursive manner)

  bottom up

  divide & conquer + optimal substructure

  has status cache

+ Count the paths

  ![image-20210318104512545](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210318104512545.png)

  Recursion: `dp[i][j] = dp[i + 1][j] + dp[i][j + 1]`

+ #### [1143. Longest Common Subsequence](https://leetcode-cn.com/problems/longest-common-subsequence/)

  Given two strings `text1` and `text2`, return *the length of their longest **common subsequence**.* If there is no **common subsequence**, return `0`.

  A **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

  - For example, `"ace"` is a subsequence of `"abcde"`.

  A **common subsequence** of two strings is a subsequence that is common to both strings.

  **Example 1:**

  ```
  Input: text1 = "abcde", text2 = "ace" 
  Output: 3  
  Explanation: The longest common subsequence is "ace" and its length is 3.
  ```

  **Example 2:**

  ```
  Input: text1 = "abc", text2 = "abc"
  Output: 3
  Explanation: The longest common subsequence is "abc" and its length is 3.
  ```

  **Example 3:**

  ```
  Input: text1 = "abc", text2 = "def"
  Output: 0
  Explanation: There is no such common subsequence, so the result is 0.
  ```

  **Constraints:**

  - `1 <= text1.length, text2.length <= 1000`
  - `text1` and `text2` consist of only lowercase English characters.

  ```java
  class Solution {
      public int longestCommonSubsequence(String text1, String text2) {
          int n = text1.length(), m = text2.length();
          int[][] dp = new int[n + 1][m + 1];
          for (int i = 1; i < n + 1; i++) {
              for (int j = 1; j < m + 1; j++) {
                  if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                      dp[i][j] = dp[i - 1][j - 1] + 1;
                  } else {
                      dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                  }
              }
          }
          return dp[n][m];
      }
  }
  ```

+ #### [62. Unique Paths](https://leetcode-cn.com/problems/unique-paths/)

  A robot is located at the top-left corner of a `m x n` grid (marked 'Start' in the diagram below).

  The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

  How many possible unique paths are there?

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

  ```
  Input: m = 3, n = 7
  Output: 28
  ```

  **Example 2:**

  ```
  Input: m = 3, n = 2
  Output: 3
  Explanation:
  From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
  1. Right -> Down -> Down
  2. Down -> Down -> Right
  3. Down -> Right -> Down
  ```

  **Example 3:**

  ```
  Input: m = 7, n = 3
  Output: 28
  ```

  **Example 4:**

  ```
  Input: m = 3, n = 3
  Output: 6
  ```

  **Constraints:**

  - `1 <= m, n <= 100`
  - It's guaranteed that the answer will be less than or equal to `2 * 109`.

  ```java
  class Solution {
      public int uniquePaths(int m, int n) {
          int[] dp = new int[n];
          Arrays.fill(dp, 1);
          for (int i = 1; i < m; i++) {
              for (int j = 1; j < n; j++) {
                  dp[j] += dp[j - 1];
              }
          }
          return dp[n - 1];
      }
  }
  ```

+ #### [63. Unique Paths II](https://leetcode-cn.com/problems/unique-paths-ii/)

  A robot is located at the top-left corner of a `m x n` grid (marked 'Start' in the diagram below).

  The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

  Now consider if some obstacles are added to the grids. How many unique paths would there be?

  An obstacle and space is marked as `1` and `0` respectively in the grid.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

  ```
  Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
  Output: 2
  Explanation: There is one obstacle in the middle of the 3x3 grid above.
  There are two ways to reach the bottom-right corner:
  1. Right -> Right -> Down -> Down
  2. Down -> Down -> Right -> Right
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)

  ```
  Input: obstacleGrid = [[0,1],[0,0]]
  Output: 1
  ```

  **Constraints:**

  - `m == obstacleGrid.length`
  - `n == obstacleGrid[i].length`
  - `1 <= m, n <= 100`
  - `obstacleGrid[i][j]` is `0` or `1`.

  ```java
  class Solution {
      public int uniquePathsWithObstacles(int[][] obstacleGrid) {
          obstacleGrid[0][0] = obstacleGrid[0][0] == 1 ? 0 : 1;
          for (int i = 1; i < obstacleGrid.length; i++) {
              obstacleGrid[i][0] = obstacleGrid[i][0] == 1 ? 0 : obstacleGrid[i - 1][0];
          }
          for (int j = 1; j < obstacleGrid[0].length; j++) {
              obstacleGrid[0][j] = obstacleGrid[0][j] == 1 ? 0 : obstacleGrid[0][j - 1];
          }
          for (int i = 1; i < obstacleGrid.length; i++) {
              for (int j = 1; j < obstacleGrid[0].length; j++) {
                  obstacleGrid[i][j] = obstacleGrid[i][j] == 1 ? 0 :obstacleGrid[i-1][j] + obstacleGrid[i][j-1];
              }
          }
          return obstacleGrid[obstacleGrid.length - 1][obstacleGrid[0].length - 1];
      }
  }
  ```

+ #### [53. Maximum Subarray](https://leetcode-cn.com/problems/maximum-subarray/)

  Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return *its sum*.

  **Example 1:**

  ```
  Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
  Output: 6
  Explanation: [4,-1,2,1] has the largest sum = 6.
  ```

  **Example 2:**

  ```
  Input: nums = [1]
  Output: 1
  ```

  **Example 3:**

  ```
  Input: nums = [5,4,-1,7,8]
  Output: 23
  ```

   

  **Constraints:**

  - `1 <= nums.length <= 3 * 104`
  - `-105 <= nums[i] <= 105`

  **Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.

  ```java
  class Solution {
      public int maxSubArray(int[] nums) {
          int max = nums[0];
          for (int i = 1; i < nums.length; i++) {
              nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);
              max = Math.max(max, nums[i]);
          }
          return max;
      }
  }
  ```
]]></description></item><item><title>Data Structure and Algorithm - Day 08</title><link>http://www.cnblogs.com/peng8098/archive/2021/03/17/algorithm8.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Wed, 17 Mar 2021 06:17:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2021/03/17/algorithm8.html</guid><description><![CDATA[+ Greedy

  best in present

  The difference between Greedy and Dynamic Programming is that it makes choices on the solutions of each sub-problem and can't rollback. 

  Dynamic Programming saves the previous operation results, and selects the current according to the previous results, and has the function of rollback.

+ #### [455. Assign Cookies](https://leetcode-cn.com/problems/assign-cookies/)

  Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.

  Each child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with; and each cookie `j` has a size `s[j]`. If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`, and the child `i` will be content. Your goal is to maximize the number of your content children and output the maximum number.

  **Example 1:**

  ```
  Input: g = [1,2,3], s = [1,1]
  Output: 1
  Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
  And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
  You need to output 1.
  ```

  **Example 2:**

  ```
  Input: g = [1,2], s = [1,2,3]
  Output: 2
  Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
  You have 3 cookies and their sizes are big enough to gratify all of the children, 
  You need to output 2.
  ```

  **Constraints:**

  - `1 <= g.length <= 3 * 104`
  - `0 <= s.length <= 3 * 104`
  - `1 <= g[i], s[j] <= 231 - 1`

  ```java
  class Solution {
      public int findContentChildren(int[] g, int[] s) {
          int res = 0;
          Arrays.sort(g);
          Arrays.sort(s);
          for (int i = 0, j = 0; i < g.length && j < s.length; j++) {
              if (g[i] <= s[j]) {
                  res++;
                  i++;
              } 
          }
          return res;
      }
  }
  ```

+ #### [122. Best Time to Buy and Sell Stock II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

  You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

  Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

  **Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

  **Example 1:**

  ```
  Input: prices = [7,1,5,3,6,4]
  Output: 7
  Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
  Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
  ```

  **Example 2:**

  ```
  Input: prices = [1,2,3,4,5]
  Output: 4
  Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
  Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.
  ```

  **Example 3:**

  ```
  Input: prices = [7,6,4,3,1]
  Output: 0
  Explanation: In this case, no transaction is done, i.e., max profit = 0.
  ```

  **Constraints:**

  - `1 <= prices.length <= 3 * 104`
  - `0 <= prices[i] <= 104`

  ```java
  class Solution {
      public int maxProfit(int[] prices) {
          int res = 0;
          for (int i = 1; i < prices.length; i++) {
              res += Math.max(0, prices[i] - prices[i - 1]);
          }
          return res;
      }
  }
  ```

+ #### [55. Jump Game](https://leetcode-cn.com/problems/jump-game/)

  Given an array of non-negative integers `nums`, you are initially positioned at the **first index** of the array.

  Each element in the array represents your maximum jump length at that position.

  Determine if you are able to reach the last index.

  **Example 1:**

  ```
  Input: nums = [2,3,1,1,4]
  Output: true
  Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
  ```

  **Example 2:**

  ```
  Input: nums = [3,2,1,0,4]
  Output: false
  Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
  ```

  **Constraints:**

  - `1 <= nums.length <= 3 * 104`
  - `0 <= nums[i] <= 105`

  ```java
  class Solution {
      public boolean canJump(int[] nums) {
          int end = nums.length - 1;
          for (int i = end; i >= 0; i--) {
              if (nums[i] + i >= end) {
                  end = i;
              }
          }
          return end == 0;
      }
  }
  ```

+ #### [45. Jump Game II](https://leetcode-cn.com/problems/jump-game-ii/)

  Given an array of non-negative integers `nums`, you are initially positioned at the first index of the array.

  Each element in the array represents your maximum jump length at that position.

  Your goal is to reach the last index in the minimum number of jumps.

  You can assume that you can always reach the last index.

  **Example 1:**

  ```
  Input: nums = [2,3,1,1,4]
  Output: 2
  Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
  ```

  **Example 2:**

  ```
  Input: nums = [2,3,0,1,4]
  Output: 2
  ```

  **Constraints:**

  - `1 <= nums.length <= 1000`
  - `0 <= nums[i] <= 105`

  ```java
  class Solution {
      public int jump(int[] nums) {
          if (nums.length < 2) return 0;
          int bound = 0;
          int time = 0;
          int end = 0;
          for (int i = 0; i < nums.length; ) {
              time++;
              for (int j = i; j <= bound; j++) {
                  end = Math.max(end, j + nums[j]);
              }
              if (end >= nums.length - 1) break;
              i = bound + 1;
              bound = end;
          }
          return time;
      }
  }
  ```

+ #### [860. Lemonade Change](https://leetcode-cn.com/problems/lemonade-change/)

  At a lemonade stand, each lemonade costs `$5`. 

  Customers are standing in a queue to buy from you, and order one at a time (in the order specified by `bills`).

  Each customer will only buy one lemonade and pay with either a `$5`, `$10`, or `$20` bill. You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.

  Note that you don't have any change in hand at first.

  Return `true` if and only if you can provide every customer with correct change.

  **Example 1:**

  ```
  Input: [5,5,5,10,20]
  Output: true
  Explanation: 
  From the first 3 customers, we collect three $5 bills in order.
  From the fourth customer, we collect a $10 bill and give back a $5.
  From the fifth customer, we give a $10 bill and a $5 bill.
  Since all customers got correct change, we output true.
  ```

  **Example 2:**

  ```
  Input: [5,5,10]
  Output: true
  ```

  **Example 3:**

  ```
  Input: [10,10]
  Output: false
  ```

  **Example 4:**

  ```
  Input: [5,5,10,10,20]
  Output: false
  Explanation: 
  From the first two customers in order, we collect two $5 bills.
  For the next two customers in order, we collect a $10 bill and give back a $5 bill.
  For the last customer, we can't give change of $15 back because we only have two $10 bills.
  Since not every customer received correct change, the answer is false.
  ```

  **Note:**

  - `0 <= bills.length <= 10000`
  - `bills[i]` will be either `5`, `10`, or `20`.

  ```java
  class Solution {
      public boolean lemonadeChange(int[] bills) {
          int[] bucks = new int[2];
          for (int bill : bills) {
              if (bill == 5) {
                  bucks[0]++;
              } else if (bill == 10) {
                  if (bucks[0] == 0) return false;
                  bucks[0]--;
                  bucks[1]++;
              } else if (bucks[1] > 0) {
                  bill -= 10;
                  bucks[1] --;
                  if (bucks[0] == 0) return false;
                  bucks[0]--;
              } else {
                  if (bucks[0] < 3) return false;
                  bucks[0] -= 3;
              }
          }
          return true;
      }
  }
  ```

+ #### [200. Number of Islands](https://leetcode-cn.com/problems/number-of-islands/)

  Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*.

  An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

  **Example 1:**

  ```
  Input: grid = [
    ["1","1","1","1","0"],
    ["1","1","0","1","0"],
    ["1","1","0","0","0"],
    ["0","0","0","0","0"]
  ]
  Output: 1
  ```

  **Example 2:**

  ```
  Input: grid = [
    ["1","1","0","0","0"],
    ["1","1","0","0","0"],
    ["0","0","1","0","0"],
    ["0","0","0","1","1"]
  ]
  Output: 3
  ```

  **Constraints:**

  - `m == grid.length`
  - `n == grid[i].length`
  - `1 <= m, n <= 300`
  - `grid[i][j]` is `'0'` or `'1'`.

  ```java
  class Solution {
      int[][] directs = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
      public int numIslands(char[][] grid) {
          int res = 0;
          int m = grid.length, n = grid[0].length;
          for (int i = 0; i < m; i++) {
              for (int j = 0; j < n; j++) {
                  if (grid[i][j] == '0') continue;
                  res++;
                  sink(grid, i, j);
              }
          }
          return res;
      }
  
      private void sink(char[][] grid, int i, int j) {
          grid[i][j] = '0';
          for (int[] dir : directs) {
              int x = i + dir[0], y = j + dir[1];
              if (in(grid, x, y) && grid[x][y] == '1') {
                  sink(grid, x, y);
              }
          }
      }
  
      private boolean in(char[][] grid, int x, int y) {
          return x >= 0 && y >= 0 && x < grid.length && y < grid[0].length;
      }
  }
  ```

+ #### [874. Walking Robot Simulation](https://leetcode-cn.com/problems/walking-robot-simulation/)

  A robot on an infinite XY-plane starts at point `(0, 0)` and faces north. The robot can receive one of three possible types of `commands`:

  - `-2`: turn left `90` degrees,
  - `-1`: turn right `90` degrees, or
  - `1 <= k <= 9`: move forward `k` units.

  Some of the grid squares are `obstacles`. The `ith` obstacle is at grid point `obstacles[i] = (xi, yi)`.

  If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)

  Return *the maximum Euclidean distance that the robot will be from the origin **squared** (i.e. if the distance is* `5`*, return* `25`*)*.

  **Note:**

  - North means +Y direction.
  - East means +X direction.
  - South means -Y direction.
  - West means -X direction.

  **Example 1:**

  ```
  Input: commands = [4,-1,3], obstacles = []
  Output: 25
  Explanation: The robot starts at (0, 0):
  1. Move north 4 units to (0, 4).
  2. Turn right.
  3. Move east 3 units to (3, 4).
  The furthest point away from the origin is (3, 4), which is 32 + 42 = 25 units away.
  ```

  **Example 2:**

  ```
  Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
  Output: 65
  Explanation: The robot starts at (0, 0):
  1. Move north 4 units to (0, 4).
  2. Turn right.
  3. Move east 1 unit and get blocked by the obstacle at (2, 4), robot is at (1, 4).
  4. Turn left.
  5. Move north 4 units to (1, 8).
  The furthest point away from the origin is (1, 8), which is 12 + 82 = 65 units away.
  ```

  **Constraints:**

  - `1 <= commands.length <= 104`
  - `commands[i]` is one of the values in the list `[-2,-1,1,2,3,4,5,6,7,8,9]`.
  - `0 <= obstacles.length <= 104`
  - `-3 * 104 <= xi, yi <= 3 * 104`
  - The answer is guaranteed to be less than `231`.

  ```java
  class Solution {
      int[][] dirs = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}}; // ->left  <-right
      Set<String> set = new HashSet<>();
      int max = 0;
      public int robotSim(int[] commands, int[][] obstacles) {
          int[] pos = {0, 0};
          for (int[] obstacle : obstacles) {
              set.add(""+obstacle[0]+","+obstacle[1]);
          }
          dfs(pos, 0, commands, 0);
          return max;
      }
  
      private void dfs(int[] pos, int face, int[] commands, int i) {
          if (i == commands.length) return;
          if (commands[i] < 0) {
              face = (face + (commands[i] == -2 ? 1 : 3)) % 4;
              i++;
          } else {
              int[] next = {pos[0] + dirs[face][0], pos[1] + dirs[face][1]};
              if (set.contains(""+next[0]+","+next[1])) {
                  i++;
              } else {
                  commands[i]--;
                  pos[0] = next[0];
                  pos[1] = next[1];
                  max = Math.max(max, pos[0]*pos[0] + pos[1]*pos[1]);
                  if (commands[i] == 0) i++;
              }
          }
          dfs(pos, face, commands, i);
      }
  }
  ```

+ #### [127. Word Ladder](https://leetcode-cn.com/problems/word-ladder/)

  A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words such that:

  - The first word in the sequence is `beginWord`.
  - The last word in the sequence is `endWord`.
  - Only one letter is different between each adjacent pair of words in the sequence.
  - Every word in the sequence is in `wordList`.

  Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return *the **number of words** in the **shortest transformation sequence** from* `beginWord` *to* `endWord`*, or* `0` *if no such sequence exists.*

  **Example 1:**

  ```
  Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
  Output: 5
  Explanation: One shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog" with 5 words.
  ```

  **Example 2:**

  ```
  Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
  Output: 0
  Explanation: The endWord "cog" is not in wordList, therefore there is no possible transformation.
  ```

  **Constraints:**

  - `1 <= beginWord.length <= 10`
  - `endWord.length == beginWord.length`
  - `1 <= wordList.length <= 5000`
  - `wordList[i].length == beginWord.length`
  - `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.
  - `beginWord != endWord`
  - All the strings in `wordList` are **unique**.

  ```java
  class Solution {
      public int ladderLength(String beginWord, String endWord, List<String> wordList) {
          Deque<String> deque = new LinkedList<>();
          deque.addLast(beginWord);
          Set<String> set = new HashSet<>();
          int res = 0;
          while (!deque.isEmpty()) {
              int size = deque.size();
              res++;
              while (size-- > 0) {
                  String s = deque.pollFirst();
                  if (s.equals(endWord)) return res;
                  for (String t : wordList) {
                      if (set.size() == wordList.size()) break;
                      if (set.contains(t)) continue;
                      if (can(s, t)) {
                          deque.addLast(t);
                          set.add(t);
                      }
                  }
              }
          }
          return 0;
      }
      private boolean can(String s, String t) {
          boolean flag = true;
          for (int i = 0; i < s.length(); i++) {
              if (s.charAt(i) != t.charAt(i)) {
                  if (flag) flag = false;
                  else return false;
              }
          }
          return true;
      }
  }
  ```]]></description></item><item><title>Data Structure and Algorithm - Day 07</title><link>http://www.cnblogs.com/peng8098/archive/2021/03/16/algorithm7.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 16 Mar 2021 06:59:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2021/03/16/algorithm7.html</guid><description><![CDATA[+ Division

  find sub-problems, split and merge

  ```python
  def divide_conquer(problem, param1, param2, ...):
      # recursion terminator
      if problem is None:
          print_result
          return
      # prepare data
      data = prepare_data(problem)
      subproblems = split_problem(problem, data)
      # conquer subproblems
      subresult1 = self.divide_conquer(subproblems[0], p1, p2, ...)
      subresult2 = self.divide_conquer(subproblems[1], p1, p2, ...)
      subresult3 = self.divide_conquer(subproblems[2], p1, p2, ...)
      ...
      # process and generate the final result
      result = process_result(subresult1, subresult2, subresult3, ...)
      
      # revert the current level states
  ```

+ BackTracking

+ #### [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

  Implement [pow(*x*, *n*)](http://www.cplusplus.com/reference/valarray/pow/), which calculates *x* raised to the power *n* (i.e. xn).

  **Example 1:**

  ```
  Input: x = 2.00000, n = 10
  Output: 1024.00000
  ```

  **Example 2:**

  ```
  Input: x = 2.10000, n = 3
  Output: 9.26100
  ```

  **Example 3:**

  ```
  Input: x = 2.00000, n = -2
  Output: 0.25000
  Explanation: 2-2 = 1/22 = 1/4 = 0.25
  ```

  **Constraints:**

  - `-100.0 < x < 100.0`
  - `-231 <= n <= 231-1`
  - `-104 <= xn <= 104`

  ```java
  class Solution {
      public double myPow(double x, int n) {
          if (x == 0 || x == 1) return x;
          if (n == 0) return 1;
          long n1 = n;
          if (n1 < 0) {
              x = 1 / x;
              n1 = -n1;
          }
          return divide(x, n1);
      }
  
      private double divide(double x, long n) {
          if (n == 1) return x;
          double subresult = divide(x, n/2);
          return subresult * subresult * (n%2 == 0 ? 1 : x);
      }
  }
  ```

+ #### [78. Subsets](https://leetcode-cn.com/problems/subsets/)

  Given an integer array `nums` of **unique** elements, return *all possible subsets (the power set)*.

  The solution set **must not** contain duplicate subsets. Return the solution in **any order**.

  **Example 1:**

  ```
  Input: nums = [1,2,3]
  Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
  ```

  **Example 2:**

  ```
  Input: nums = [0]
  Output: [[],[0]]
  ```

  **Constraints:**

  - `1 <= nums.length <= 10`
  - `-10 <= nums[i] <= 10`
  - All the numbers of `nums` are **unique**.

  ```java
  class Solution {
      public List<List<Integer>> subsets(int[] nums) {
          List<List<Integer>> res = new ArrayList<>();
          List<Integer> list = new ArrayList<>();
          dfs(res, list, nums, 0);
          return res;
      }
  
      private void dfs(List<List<Integer>> res, List<Integer> list, int[] nums, int number) {
          if (number == nums.length) {
              res.add(new ArrayList<>(list));
              return ;
          }
          // branch1
          dfs(res, list, nums, number + 1);
          // branch2
          list.add(nums[number]);
          dfs(res, list, nums, number + 1);
          list.remove(list.size() - 1);
      }
  }
  ```

  ```java
  class Solution {
      public List<List<Integer>> subsets(int[] nums) {
          List<List<Integer>> res = new ArrayList<>();
          res.add(new ArrayList<>());
          for (int i = 0; i < nums.length; i++) {
              for (int j = 0; j < (int)Math.pow(2, i); j++) {
                  List<Integer> list = new ArrayList<>(res.get(j));
                  list.add(nums[i]);
                  res.add(list);
              }
          }
          return res;
      }
  }
  ```

+ #### [169. Majority Element](https://leetcode-cn.com/problems/majority-element/)

  Given an array `nums` of size `n`, return *the majority element*.

  The majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.

  **Example 1:**

  ```
  Input: nums = [3,2,3]
  Output: 3
  ```

  **Example 2:**

  ```
  Input: nums = [2,2,1,1,1,2,2]
  Output: 2
  ```

  **Constraints:**

  - `n == nums.length`
  - `1 <= n <= 5 * 104`
  - `-231 <= nums[i] <= 231 - 1`

  ```java
  class Solution {
      public int majorityElement(int[] nums) {
          int res = nums[0], quantity = 1;
          for (int i = 1; i < nums.length; i++) {
              if (nums[i] == res) quantity++;
              else if (quantity > 0) quantity--;
              else {
                  res = nums[i];
                  quantity = 1;
              }
          }
          return res;
      }
  }
  ```

  ```java
  class Solution {
      public int majorityElement(int[] nums) {
          Arrays.sort(nums);
          return nums[nums.length / 2];
      }
  }
  ```

  ```java
  // divise for division
  class Solution {
      private int countInRange(int[] nums, int num, int lo, int hi) {
          int count = 0;
          for (int i = lo; i <= hi; i++) {
              if (nums[i] == num) {
                  count++;
              }
          }
          return count;
      }
  
      private int majorityElementRec(int[] nums, int lo, int hi) {
          // base case; 
          // the only element in an array of size 1 is the majority element.
          if (lo == hi) {
              return nums[lo];
          }
  
          // recurse on left and right halves of this slice.
          int mid = (hi - lo) / 2 + lo;
          int left = majorityElementRec(nums, lo, mid);
          int right = majorityElementRec(nums, mid + 1, hi);
  
          // if the two halves agree on the majority element, return it.
          if (left == right) {
              return left;
          }
  
          // otherwise, count each element and return the "winner".
          int leftCount = countInRange(nums, left, lo, hi);
          int rightCount = countInRange(nums, right, lo, hi);
  
          return leftCount > rightCount ? left : right;
      }
  
      public int majorityElement(int[] nums) {
          return majorityElementRec(nums, 0, nums.length - 1);
      }
  }
  ```

+ #### [17. Letter Combinations of a Phone Number](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

  Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.

  A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

  ![img](https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)

  **Example 1:**

  ```
  Input: digits = "23"
  Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
  ```

  **Example 2:**

  ```
  Input: digits = ""
  Output: []
  ```

  **Example 3:**

  ```
  Input: digits = "2"
  Output: ["a","b","c"]
  ```

  **Constraints:**

  - `0 <= digits.length <= 4`
  - `digits[i]` is a digit in the range `['2', '9']`.

  ```java
  class Solution {
      String[] letters = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
      public List<String> letterCombinations(String digits) {
          List<String> res = new ArrayList<>();
          if (digits == null || digits.length() == 0) return res;
          StringBuilder sb = new StringBuilder();
          dfs(res, sb, digits, 0);
          return res;
      }
  
      private void dfs(List<String> res, StringBuilder sb, String digits, int index) {
          if (index == digits.length()) {
              res.add(String.valueOf(sb));
              return ;
          }
          for (char ch : letters[digits.charAt(index) - '0'].toCharArray()) {
              sb.append(ch);
              dfs(res, sb, digits, index + 1);
              sb.deleteCharAt(sb.length() - 1);
          }
      } 
  }
  ```

+ #### [51. N-Queens](https://leetcode-cn.com/problems/n-queens/)

  The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.

  Given an integer `n`, return *all distinct solutions to the **n-queens puzzle***.

  Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

  ```
  Input: n = 4
  Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
  Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above
  ```

  **Example 2:**

  ```
  Input: n = 1
  Output: [["Q"]]
  ```

  **Constraints:**

  - `1 <= n <= 9`

  ```java
  class Solution {
      public List<List<String>> solveNQueens(int n) {
          List<List<String>> res = new ArrayList<>();
          char[][] board = new char[n][n];
          for (int i = 0; i < n; i++) {
              for (int j = 0; j < n; j++) {
                  board[i][j] = '.';
              }
          }
          Set[] sets = new Set[3]; // |:j, \:j-i, /:i+j
          for (int i = 0; i < 3; i++) {
              sets[i] = new HashSet<>();
          }
          dfs(res, board,0, n, sets);
          return res;
      }
  
      private void dfs(List<List<String>> res, char[][] board, int i, int n, Set[] sets) {
          if (i == n) {
              List<String> list = new ArrayList<>();
              for (char[] chs : board) {
                  list.add(String.valueOf(chs));
              }
              res.add(list);
              return ;
          }
          for (int j = 0; j < n; j++) {
              if (sets[0].contains(j) || sets[1].contains(j-i) || sets[2].contains(i+j)) {
                  continue;
              }
              board[i][j] = 'Q';
              sets[0].add(j);
              sets[1].add(j-i);
              sets[2].add(i+j);
              dfs(res, board, i + 1, n, sets);
              board[i][j] = '.';
              sets[0].remove(j);
              sets[1].remove(j-i);
              sets[2].remove(i+j);
          }
      }
  }
  ```

+ dfs & bfs

  ergodic: every node lookup once

  ```python
  # dfs - recursion
  def dfs(node):
      if node in visited:
          # already visited
          return
      
      visited.add(node)
      
      # process current logic
      
      for next_node in node.nexts:
          dfs(next_node)
          
  # dfs - not recursion, use stack
  def dfs(root):
      if root is None:
          return []
      
      visited, stack = [], [root]
      
      while stack:
          node = stack.pop()
          visited.add(node)
          
          # process current node
          
          for next_node in node.nexts:
          	stack.push(next_node)
              
          # other processing work
  ```

  ```python
  # bfs - use queue
  def bfs(graph, start, end)：
  	queue = []
      queue.append(start)
      visited.add(start)
      
      while queue:
          node = queue.pop()
          visited.add(node)
          
          process(node)
          for next_node in node.nexts:
          	queue.push(next_node)
              
          # other processing work
  ```

+ #### [102. Binary Tree Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

  Given the `root` of a binary tree, return *the level order traversal of its nodes' values*. (i.e., from left to right, level by level).

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

  ```
  Input: root = [3,9,20,null,null,15,7]
  Output: [[3],[9,20],[15,7]]
  ```

  **Example 2:**

  ```
  Input: root = [1]
  Output: [[1]]
  ```

  **Example 3:**

  ```
  Input: root = []
  Output: []
  ```

  **Constraints:**

  - The number of nodes in the tree is in the range `[0, 2000]`.
  - `-1000 <= Node.val <= 1000`

  ```java
  // bfs - 1ms
  class Solution {
      public List<List<Integer>> levelOrder(TreeNode root) {
          List<List<Integer>> res = new ArrayList<>();
          if (root == null) return res;
          Deque<TreeNode> queue = new LinkedList<>();
          queue.addLast(root);
          while (!queue.isEmpty()) {
              int size = queue.size();
              List<Integer> list = new LinkedList<>();
              while (size-- > 0) {
                  TreeNode node = queue.pollFirst();
                  list.add(node.val);
                  if (node.left != null) queue.addLast(node.left);
                  if (node.right != null) queue.addLast(node.right);
              }
              res.add(list);
          }
          return res;
      }
  }
  
  // dfs - 0ms
  class Solution {
      public List<List<Integer>> levelOrder(TreeNode root) {
          List<List<Integer>> res = new ArrayList<>();
          if (root == null) return res;
          dfs(res, root, 1);
          return res;
      }
  
      private void dfs(List<List<Integer>> res, TreeNode root, int deep) {
          if (root == null) return ;
          if (deep > res.size()) {
              res.add(new ArrayList<>());
          }
          res.get(deep - 1).add(root.val);
          dfs(res, root.left, deep + 1);
          dfs(res, root.right, deep + 1);
      }
  }
  ```

+ #### [433. Minimum Genetic Mutation](https://leetcode-cn.com/problems/minimum-genetic-mutation/)

  A gene string can be represented by an 8-character long string, with choices from `"A"`, `"C"`, `"G"`, `"T"`.

  Suppose we need to investigate about a mutation (mutation from "start" to "end"), where ONE mutation is defined as ONE single character changed in the gene string.

  For example, `"AACCGGTT"` -> `"AACCGGTA"` is 1 mutation.

  Also, there is a given gene "bank", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.

  Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from "start" to "end". If there is no such a mutation, return -1.

  **Note:**

  1. Starting point is assumed to be valid, so it might not be included in the bank.
  2. If multiple mutations are needed, all mutations during in the sequence must be valid.
  3. You may assume start and end string is not the same.

  **Example 1:**

  ```
  start: "AACCGGTT"
  end:   "AACCGGTA"
  bank: ["AACCGGTA"]
  
  return: 1
  ```

  **Example 2:**

  ```
  start: "AACCGGTT"
  end:   "AAACGGTA"
  bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]
  
  return: 2
  ```

  **Example 3:**

  ```
  start: "AAAAACCC"
  end:   "AACCCCCC"
  bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]
  
  return: 3
  ```

  ```java
  class Solution {
      public int minMutation(String start, String end, String[] bank) {
          int n = bank.length;
          boolean[] visited = new boolean[n];
          int res = 0;
          Deque<String> queue = new LinkedList<>();
          queue.addLast(start);
          while (!queue.isEmpty()) {
              int size = queue.size();
              res++;
              while (size-- > 0) {
                  String s = queue.pollFirst();
                  for (int i = 0; i < n; i++) {
                      if (visited[i]) continue;
                      if (can(s, bank[i])) {
                          if (bank[i].equals(end)) return res;
                          queue.addLast(bank[i]);
                          visited[i] = true;
                      }
                  }
              }
          }
          return -1;
      }
  
      private boolean can(String s, String t) {
          boolean flag = false;
          for (int i = 0; i < 8; i++) {
              if (s.charAt(i) != t.charAt(i)) {
                  if (flag) return false;
                  flag = true;
              }
          }
          return true;
      }
  }
  ```

+ #### [515. Find Largest Value in Each Tree Row](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

  Given the `root` of a binary tree, return *an array of the largest value in each row* of the tree **(0-indexed)**.

   

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg)

  ```
  Input: root = [1,3,2,5,3,null,9]
  Output: [1,3,9]
  ```

  **Example 2:**

  ```
  Input: root = [1,2,3]
  Output: [1,3]
  ```

  **Example 3:**

  ```
  Input: root = [1]
  Output: [1]
  ```

  **Example 4:**

  ```
  Input: root = [1,null,2]
  Output: [1,2]
  ```

  **Example 5:**

  ```
  Input: root = []
  Output: []
  ```

  **Constraints:**

  - The number of nodes in the tree will be in the range `[0, 104]`.
  - `-231 <= Node.val <= 231 - 1`

  ```java
  class Solution {
      public List<Integer> largestValues(TreeNode root) {
          List<Integer> res = new ArrayList<>();
          bfs(res, root, 1);
          return res;
      }
  
      private void bfs(List<Integer> res, TreeNode root, int deep) {
          if (root == null) return ;
          if (deep > res.size()) {
              res.add(root.val);
          } else {
              res.set(deep - 1, Math.max(res.get(deep - 1), root.val));
          }
          bfs(res, root.left, deep + 1);
          bfs(res, root.right, deep + 1);
      }
  }
  ```

+ #### [46. Permutations](https://leetcode-cn.com/problems/permutations/)

  Given an array `nums` of distinct integers, return *all the possible permutations*. You can return the answer in **any order**.

  **Example 1:**

  ```
  Input: nums = [1,2,3]
  Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
  ```

  **Example 2:**

  ```
  Input: nums = [0,1]
  Output: [[0,1],[1,0]]
  ```

  **Example 3:**

  ```
  Input: nums = [1]
  Output: [[1]]
  ```

  **Constraints:**

  - `1 <= nums.length <= 6`
  - `-10 <= nums[i] <= 10`
  - All the integers of `nums` are **unique**.

  ```java
  class Solution {
      public List<List<Integer>> permute(int[] nums) {
          List<List<Integer>> res = new ArrayList<>();
          int n = nums.length;
          boolean[] visited = new boolean[n];
          List<Integer> list = new ArrayList<>();
          dfs(nums, res, list, visited, n);
          return res;
      }
  
      private void dfs(int[] nums, List<List<Integer>> res, List<Integer> list, boolean[] visited, int n) {
          int size = list.size();
          if (size == n) {
              res.add(new ArrayList<>(list));
              return ;
          }
          for (int i = 0; i < n; i++) {
              if (visited[i]) continue;
              list.add(nums[i]);
              visited[i] = true;
              dfs(nums, res, list, visited, n);
              visited[i] = false;
              list.remove(size);
          }
      }
  }
  ```]]></description></item><item><title>Data Structure and Algorithm - Day 06</title><link>http://www.cnblogs.com/peng8098/archive/2021/03/15/algorithm6.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 15 Mar 2021 09:47:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2021/03/15/algorithm6.html</guid><description><![CDATA[+ Recursion

  layer by layer

  ```java
  private xxxx recursion(level, param1, param2, ...) {
      // recursion terminator
      if (level > MAX_LEVEL) {
          process_result;
          return xxx;
      }
      
      // process logic in current level
      process(level, data...);
      
      // drill down
      recursion(level + 1, p1, p2, ...);
      
      // reverse the current level status if needed
  }
  ```

+ #### [70. Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/)

  You are climbing a staircase. It takes `n` steps to reach the top.

  Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?

  **Example 1:**

  ```
  Input: n = 2
  Output: 2
  Explanation: There are two ways to climb to the top.
  1. 1 step + 1 step
  2. 2 steps
  ```

  **Example 2:**

  ```
  Input: n = 3
  Output: 3
  Explanation: There are three ways to climb to the top.
  1. 1 step + 1 step + 1 step
  2. 1 step + 2 steps
  3. 2 steps + 1 step
  ```

  **Constraints:**

  - `1 <= n <= 45`

  ```java
  class Solution {
      public int climbStairs(int n) {
          Map<Integer, Integer> map = new HashMap<>();
          map.put(1, 1);
          map.put(2, 2);
          return helper(map, n);
      }
  
      private int helper(Map<Integer, Integer> map, int n) {
          if (map.containsKey(n)) {
              return map.get(n);
          }
          int nStair = helper(map, n-2) + helper(map, n-1);
          map.put(n, nStair);
          return nStair;
      }
  }
  ```

+ #### [22. Generate Parentheses](https://leetcode-cn.com/problems/generate-parentheses/)

  Given `n` pairs of parentheses, write a function to *generate all combinations of well-formed parentheses*.

  **Example 1:**

  ```
  Input: n = 3
  Output: ["((()))","(()())","(())()","()(())","()()()"]
  ```

  **Example 2:**

  ```
  Input: n = 1
  Output: ["()"]
  ```

  **Constraints:**

  - `1 <= n <= 8`

  ```java
  class Solution {
      public List<String> generateParenthesis(int n) {
          List<String> res = new ArrayList<>();
          helper(res, 0, 0, n*2, "");
          return res;
      }
  
      private void helper(List<String> list, int l, int r, int max, String s) {
          if (l + r == max) {
              list.add(s);
              return ;
          }
          if (l < max / 2) helper(list, l + 1, r, max, s + "(");
          if (l > r) helper(list, l, r + 1, max, s + ")");
      }
  }
  ```

+ #### [98. Validate Binary Search Tree](https://leetcode-cn.com/problems/validate-binary-search-tree/)

  Given the `root` of a binary tree, *determine if it is a valid binary search tree (BST)*.

  A **valid BST** is defined as follows:

  - The left subtree of a node contains only nodes with keys **less than** the node's key.
  - The right subtree of a node contains only nodes with keys **greater than** the node's key.
  - Both the left and right subtrees must also be binary search trees.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

  ```
  Input: root = [2,1,3]
  Output: true
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

  ```
  Input: root = [5,1,4,null,null,3,6]
  Output: false
  Explanation: The root node's value is 5 but its right child's value is 4.
  ```

  **Constraints:**

  - The number of nodes in the tree is in the range `[1, 104]`.
  - `-231 <= Node.val <= 231 - 1`

  ```java
  // inorder
  class Solution {
      private long cur = Long.MIN_VALUE;
      boolean flag = true;
      public boolean isValidBST(TreeNode root) {
          if (root == null) return true;
          if (flag && root.left != null) isValidBST(root.left);
          if (root.val <= cur) flag = false;
          cur = root.val;
          if (flag && root.right != null) isValidBST(root.right);
          return flag;
      }
  }
  ```

  ```java
  // min bound max bound
  class Solution {
      public boolean isValidBST(TreeNode root) {
          if (root == null) return true;
          return recur(root, Long.MIN_VALUE, Long.MAX_VALUE);
      }
  
      private boolean recur(TreeNode root, long min, long max) {
          if (root.val <= min || root.val >= max) {
              return false;
          }
          boolean left = true, right = true;
          if (root.left != null) left = recur(root.left, min, root.val);
          if (root.right != null) right = recur(root.right, root.val, max);
          return left && right;
      }
  }
  ```

+ #### [226. Invert Binary Tree](https://leetcode-cn.com/problems/invert-binary-tree/)

  Given the `root` of a binary tree, invert the tree, and return *its root*.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

  ```
  Input: root = [4,2,7,1,3,6,9]
  Output: [4,7,2,9,6,3,1]
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

  ```
  Input: root = [2,1,3]
  Output: [2,3,1]
  ```

  **Example 3:**

  ```
  Input: root = []
  Output: []
  ```

  **Constraints:**

  - The number of nodes in the tree is in the range `[0, 100]`.
  - `-100 <= Node.val <= 100`

  ```java
  class Solution {
      public TreeNode invertTree(TreeNode root) {
          if (root == null) return null;
          TreeNode left = invertTree(root.left);
          TreeNode right = invertTree(root.right);
          root.left = right;
          root.right = left;
          return root;
      }
  }
  ```

+ #### [104. Maximum Depth of Binary Tree](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

  Given the `root` of a binary tree, return *its maximum depth*.

  A binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

  ```
  Input: root = [3,9,20,null,null,15,7]
  Output: 3
  ```

  **Example 2:**

  ```
  Input: root = [1,null,2]
  Output: 2
  ```

  **Example 3:**

  ```
  Input: root = []
  Output: 0
  ```

  **Example 4:**

  ```
  Input: root = [0]
  Output: 1
  ```

  **Constraints:**

  - The number of nodes in the tree is in the range `[0, 104]`.
  - `-100 <= Node.val <= 100`

  ```java
  class Solution {
      public int maxDepth(TreeNode root) {
          if (root == null) return 0;
          return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
      }
  }
  ```

+ #### [111. Minimum Depth of Binary Tree](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

  Given a binary tree, find its minimum depth.

  The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

  **Note:** A leaf is a node with no children.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

  ```
  Input: root = [3,9,20,null,null,15,7]
  Output: 2
  ```

  **Example 2:**

  ```
  Input: root = [2,null,3,null,4,null,5,null,6]
  Output: 5
  ```

  **Constraints:**

  - The number of nodes in the tree is in the range `[0, 105]`.
  - `-1000 <= Node.val <= 1000`

  ```java
  class Solution {
      public int minDepth(TreeNode root) {
          if (root == null) return 0;
          if (root.left == null && root.right == null) {
              return 1;
          }
          int left = root.left == null ? Integer.MAX_VALUE : minDepth(root.left);
          int right = root.right == null ? Integer.MAX_VALUE : minDepth(root.right);
          return 1 + Math.min(left, right);
      }
  }
  ```

+ #### [236. Lowest Common Ancestor of a Binary Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

  Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

  According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

  ```
  Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
  Output: 3
  Explanation: The LCA of nodes 5 and 1 is 3.
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

  ```
  Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
  Output: 5
  Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
  ```

  **Example 3:**

  ```
  Input: root = [1,2], p = 1, q = 2
  Output: 1
  ```

  **Constraints:**

  - The number of nodes in the tree is in the range `[2, 105]`.
  - `-109 <= Node.val <= 109`
  - All `Node.val` are **unique**.
  - `p != q`
  - `p` and `q` will exist in the tree.

  ```java
  class Solution {
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          if(root == null || root == p || root == q) return root;
          TreeNode left = lowestCommonAncestor(root.left, p, q);
          TreeNode right = lowestCommonAncestor(root.right, p, q);
          if(left == null) return right;
          if(right == null) return left;
          return root;
      }
  }
  ```

+ #### [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

  Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return *the binary tree*.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

  ```
  Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
  Output: [3,9,20,null,null,15,7]
  ```

  **Example 2:**

  ```
  Input: preorder = [-1], inorder = [-1]
  Output: [-1]
  ```

  **Constraints:**

  - `1 <= preorder.length <= 3000`
  - `inorder.length == preorder.length`
  - `-3000 <= preorder[i], inorder[i] <= 3000`
  - `preorder` and `inorder` consist of **unique** values.
  - Each value of `inorder` also appears in `preorder`.
  - `preorder` is **guaranteed** to be the preorder traversal of the tree.
  - `inorder` is **guaranteed** to be the inorder traversal of the tree.

  ```java
  class Solution {
      public TreeNode buildTree(int[] preorder, int[] inorder) {
          int len = preorder.length;
          if (len == 0) return null;
          return recur(preorder, 0, len - 1, inorder, 0, len - 1);
      }
  
      private TreeNode recur(int[] preorder, int pl, int pr, int[] inorder, int il, int ir) {
          if (pl > pr) return null;
          TreeNode root = new TreeNode(preorder[pl]);
          int i = il;
          for ( ; i <= ir; i++) {
              if (preorder[pl] == inorder[i]) {
                  break;
              }
          }
          int leftNums = i - il;
          TreeNode left = recur(preorder, pl + 1, pl + 1 + leftNums - 1, inorder, il, i - 1);
          TreeNode right = recur(preorder, pl + 1 + leftNums, pr, inorder, i + 1, ir);
          root.left = left;
          root.right = right;
          return root;
      }
  }
  ```

+ #### [77. Combinations](https://leetcode-cn.com/problems/combinations/)

  Given two integers *n* and *k*, return all possible combinations of *k* numbers out of 1 ... *n*.

  You may return the answer in **any order**.

  **Example 1:**

  ```
  Input: n = 4, k = 2
  Output:
  [
    [2,4],
    [3,4],
    [2,3],
    [1,2],
    [1,3],
    [1,4],
  ]
  ```

  **Example 2:**

  ```
  Input: n = 1, k = 1
  Output: [[1]]
  ```

  **Constraints:**

  - `1 <= n <= 20`
  - `1 <= k <= n`

  ```java
  class Solution {
      public List<List<Integer>> combine(int n, int k) {
          List<List<Integer>> res = new ArrayList<>();
          List<Integer> list = new ArrayList<>();
          recur(res, n, k, list, 1);
          return res;
      }
  
      private void recur(List<List<Integer>> lists, int n, int k, List<Integer> list, int num) {
          if (list.size() == k) {
              lists.add(new ArrayList(list));
              return ;
          }
          for (int i = num; i <= n; i++) {
              list.add(i);
              recur(lists, n, k, list, i + 1);
              list.remove(list.size() - 1);
          }
      }
  }
  ```]]></description></item><item><title>Data Structure and Algorithm - Day 05</title><link>http://www.cnblogs.com/peng8098/archive/2021/03/14/algorithm5.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 14 Mar 2021 11:50:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2021/03/14/algorithm5.html</guid><description><![CDATA[+ List: one next

  Tree: multi next, no cycle

  Graph: has cycle

+ Binary Search Tree

  left children < root < right children (children! not child!)

  Time Complexity: lookup O(log n), insert O(log n)

+ #### [94. Binary Tree Inorder Traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

  Given the `root` of a binary tree, return *the inorder traversal of its nodes' values*.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

  ```
  Input: root = [1,null,2,3]
  Output: [1,3,2]
  ```

  **Example 2:**

  ```
  Input: root = []
  Output: []
  ```

  **Example 3:**

  ```
  Input: root = [1]
  Output: [1]
  ```

  **Example 4:**

  ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)

  ```
  Input: root = [1,2]
  Output: [2,1]
  ```

  **Example 5:**

  ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

  ```
  Input: root = [1,null,2]
  Output: [1,2]
  ```

  **Constraints:**

  - The number of nodes in the tree is in the range `[0, 100]`.
  - `-100 <= Node.val <= 100`

  ```java
  class Solution {
      public List<Integer> inorderTraversal(TreeNode root) {
          List<Integer> res = new ArrayList<>();
          helper(res, root);
          return res;
      }
  
      private void helper(List<Integer> list, TreeNode root) {
          if (root == null) return ;
          helper(list, root.left);
          list.add(root.val);
          helper(list, root.right);
      }
  }
  ```

+ #### [144. Binary Tree Preorder Traversal](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

  Given the `root` of a binary tree, return *the preorder traversal of its nodes' values*.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

  ```
  Input: root = [1,null,2,3]
  Output: [1,2,3]
  ```

  **Example 2:**

  ```
  Input: root = []
  Output: []
  ```

  **Example 3:**

  ```
  Input: root = [1]
  Output: [1]
  ```

  **Example 4:**

  ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)

  ```
  Input: root = [1,2]
  Output: [1,2]
  ```

  **Example 5:**

  ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

  ```
  Input: root = [1,null,2]
  Output: [1,2]
  ```

  **Constraints:**

  - The number of nodes in the tree is in the range `[0, 100]`.
  - `-100 <= Node.val <= 100`

  ```java
  class Solution {
      public List<Integer> preorderTraversal(TreeNode root) {
          List<Integer> res = new ArrayList<>();
          helper(res, root);
          return res;
      }
  
      private void helper(List<Integer> list, TreeNode root) {
          if (root == null) return ;
          list.add(root.val);
          helper(list, root.left);
          helper(list, root.right);
      }
  }
  ```

+ #### [590. N-ary Tree Postorder Traversal](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)

  Given the `root` of an n-ary tree, return *the postorder traversal of its nodes' values*.

  Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

  ```
  Input: root = [1,null,3,2,4,null,5,6]
  Output: [5,6,3,2,4,1]
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)

  ```
  Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
  Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]
  ```

  **Constraints:**

  - The number of nodes in the tree is in the range `[0, 104]`.
  - `0 <= Node.val <= 104`
  - The height of the n-ary tree is less than or equal to `1000`.

   ```java
  class Solution {
      public List<Integer> postorder(Node root) {
          List<Integer> res = new ArrayList<>();
          helper(res, root);
          return res;
      }
  
      private void helper(List<Integer> list, Node root) {
          if (root == null) return ;
          for (Node child : root.children) {
              helper(list, child);
          }
          list.add(root.val);
      }
  }
   ```

+ #### [589. N-ary Tree Preorder Traversal](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

  Given the `root` of an n-ary tree, return *the preorder traversal of its nodes' values*.

  Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

  ```
  Input: root = [1,null,3,2,4,null,5,6]
  Output: [1,3,5,6,2,4]
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)

  ```
  Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
  Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]
  ```

  **Constraints:**

  - The number of nodes in the tree is in the range `[0, 104]`.
  - `0 <= Node.val <= 104`
  - The height of the n-ary tree is less than or equal to `1000`.

  ```java
  class Solution {
      public List<Integer> preorder(Node root) {
          List<Integer> res = new ArrayList<>();
          helper(root, res);
          return res;
      }
  
      private void helper(Node root, List<Integer> list) {
          if (root == null) return ;
          list.add(root.val);
          for (Node child : root.children) {
              helper(child, list);
          }
      }
  }
  ```

+ #### [429. N-ary Tree Level Order Traversal](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

  Given an n-ary tree, return the *level order* traversal of its nodes' values.

  *Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).*

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

  ```
  Input: root = [1,null,3,2,4,null,5,6]
  Output: [[1],[3,2,4],[5,6]]
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)

  ```
  Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
  Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
  ```

  **Constraints:**

  - The height of the n-ary tree is less than or equal to `1000`
  - The total number of nodes is between `[0, 104]`

  ```java
  class Solution {
      public List<List<Integer>> levelOrder(Node root) {
          List<List<Integer>> res = new ArrayList<>();
          if (root == null) return res;
          Deque<Node> queue = new LinkedList<>();
          queue.addLast(root);
          while (!queue.isEmpty()) {
              List<Integer> list = new ArrayList<>();
              int size = queue.size();
              while (size-- > 0) {
                  Node node = queue.pollFirst();
                  list.add(node.val);
                  for (Node child : node.children) {
                      queue.addLast(child);
                  }
              }
              res.add(list);
          }
          return res;
      }
  }
  ```

+ #### [239. Sliding Window Maximum](https://leetcode-cn.com/problems/sliding-window-maximum/)

  You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

  Return *the max sliding window*.

  **Example 1:**

  ```
  Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
  Output: [3,3,5,5,6,7]
  Explanation: 
  Window position                Max
  ---------------               -----
  [1  3  -1] -3  5  3  6  7       3
   1 [3  -1  -3] 5  3  6  7       3
   1  3 [-1  -3  5] 3  6  7       5
   1  3  -1 [-3  5  3] 6  7       5
   1  3  -1  -3 [5  3  6] 7       6
   1  3  -1  -3  5 [3  6  7]      7
  ```

  **Example 2:**

  ```
  Input: nums = [1], k = 1
  Output: [1]
  ```

  **Example 3:**

  ```
  Input: nums = [1,-1], k = 1
  Output: [1,-1]
  ```

  **Example 4:**

  ```
  Input: nums = [9,11], k = 2
  Output: [11]
  ```

  **Example 5:**

  ```
  Input: nums = [4,-2], k = 2
  Output: [4]
  ```

  **Constraints:**

  - `1 <= nums.length <= 105`
  - `-104 <= nums[i] <= 104`
  - `1 <= k <= nums.length`

  ```java
  class Solution {
      public int[] maxSlidingWindow(int[] nums, int k) {
          int len = nums.length;
          int[] res = new int[len - k + 1];
          Deque<Integer> deque = new LinkedList<>();
          for (int i = 0; i < k; i++) {
              while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                  deque.pollLast();
              }
              deque.addLast(i);
          }
          for (int i = k; i < len; i++) {
              int front = deque.peekFirst();
              res[i - k] = nums[front];
              if (front + k <= i) {
                  deque.pollFirst();
              }
              while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                  deque.pollLast();
              }
              deque.addLast(i);
          }
          res[len - k] = nums[deque.peekFirst()];
          return res;
      }
  }
  ```
]]></description></item><item><title>Data Structure and Algorithm - Day 04</title><link>http://www.cnblogs.com/peng8098/archive/2021/03/13/algorithm4.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 13 Mar 2021 08:49:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2021/03/13/algorithm4.html</guid><description><![CDATA[+ #### [20. Valid Parentheses](https://leetcode-cn.com/problems/valid-parentheses/)

  Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

  An input string is valid if:

  1. Open brackets must be closed by the same type of brackets.
  2. Open brackets must be closed in the correct order.

  **Example 1:**

  ```
  Input: s = "()"
  Output: true
  ```

  **Example 2:**

  ```
  Input: s = "()[]{}"
  Output: true
  ```

  **Example 3:**

  ```
  Input: s = "(]"
  Output: false
  ```

  **Example 4:**

  ```
  Input: s = "([)]"
  Output: false
  ```

  **Example 5:**

  ```
  Input: s = "{[]}"
  Output: true
  ```

  **Constraints:**

  - `1 <= s.length <= 104`
  - `s` consists of parentheses only `'()[]{}'`.

  ```java
  // violence recursion
  class Solution {
      Map<Character, Integer> map = new HashMap<>();
      {
          map.put('(', -3);
          map.put('[', -2);
          map.put('{', -1);
          map.put('}', 1);
          map.put(']', 2);
          map.put(')', 3);
      }
      public boolean isValid(String s) {
          int len = s.length();
          if (len == 0) return true;
          if (len == 1) return false;
          for (int i = 0; i < len - 1; i++) {
              int left = map.get(s.charAt(i));
              int right = map.get(s.charAt(i+1));
              if (left < 0 && left == -right) {
                  return isValid(s.substring(0, i) + s.substring(i+2, len));
              }
          }
          return false;
      }
  }
  ```

  ```java
  // stack
  class Solution {
      public boolean isValid(String s) {
          Stack<Character> stack = new Stack<>();
          Map<Character, Character> map = new HashMap<>();
          map.put('}', '{');
          map.put(']', '[');
          map.put(')', '(');
          for (char c : s.toCharArray()) {
              if (map.containsKey(c)) {
                  if (stack.isEmpty() || stack.peek() != map.get(c)) {
                      return false;
                  }
                  stack.pop();
              } else {
                  stack.push(c);
              }
          }
          return stack.isEmpty();
      }
  }
  ```

+ #### [155. Min Stack](https://leetcode-cn.com/problems/min-stack/)

  Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

  - push(x) -- Push element x onto stack.
  - pop() -- Removes the element on top of the stack.
  - top() -- Get the top element.
  - getMin() -- Retrieve the minimum element in the stack.

  **Example 1:**

  ```
  Input
  ["MinStack","push","push","push","getMin","pop","top","getMin"]
  [[],[-2],[0],[-3],[],[],[],[]]
  
  Output
  [null,null,null,null,-3,null,0,-2]
  
  Explanation
  MinStack minStack = new MinStack();
  minStack.push(-2);
  minStack.push(0);
  minStack.push(-3);
  minStack.getMin(); // return -3
  minStack.pop();
  minStack.top();    // return 0
  minStack.getMin(); // return -2
  ```

  **Constraints:**

  - Methods `pop`, `top` and `getMin` operations will always be called on **non-empty** stacks.

  ```java
  class MinStack {
      Stack<Integer> stack1;
      Stack<Integer> stack2;
      /** initialize your data structure here. */
      public MinStack() {
          stack1 = new Stack<>();
          stack2 = new Stack<>();
      }
      
      public void push(int x) {
          stack1.push(x);
          int min = stack2.isEmpty() || x < stack2.peek() ? x : stack2.peek();
          stack2.push(min);
      }
      
      public void pop() {
          stack1.pop();
          stack2.pop();
      }
      
      public int top() {
          return stack1.peek();
      }
      
      public int getMin() {
          return stack2.peek();
      }
  }
  ```

+ #### [84. Largest Rectangle in Histogram](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

  Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return *the area of the largest rectangle in the histogram*.

   

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

  ```
  Input: heights = [2,1,5,6,2,3]
  Output: 10
  Explanation: The above is a histogram where width of each bar is 1.
  The largest rectangle is shown in the red area, which has an area = 10 units.
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)

  ```
  Input: heights = [2,4]
  Output: 4
  ```

  **Constraints:**

  - `1 <= heights.length <= 105`
  - `0 <= heights[i] <= 104`

  ```java
  // violence O(n^2) overtime
  class Solution {
      public int largestRectangleArea(int[] heights) {
          int len = heights.length;
          int res = 0;
          for (int i = 0; i < len; i++) {
              int minHeight = heights[i];
              for (int j = i; j < len; j++) {
                  minHeight = Math.min(minHeight, heights[j]);
                  res = Math.max((j-i+1)*minHeight, res);
              }
          }
          return res;
      }
  }
  ```

  ```java
  // stack O(n)
  class Solution {
      public int largestRectangleArea(int[] heights) {
          Stack<Integer> stack = new Stack<>();
          stack.push(-1);
          int res = heights[0], len = heights.length;
          // left bound is certain
          for (int i = 0; i < len; i++) {
              while (stack.peek() != -1 && heights[stack.peek()] >= heights[i]) {
                  int area = (i - 1 - stack.peek()) * heights[stack.pop()];
                  res = Math.max(res, area);
              }
              stack.push(i);
          }
          // right bound is certain
          while (stack.peek() != -1) {
              res = Math.max(res, (len - 1 - stack.peek()) * heights[stack.pop()]);
          }
          return res;
      }
  }
  ```

+ #### [641. Design Circular Deque](https://leetcode-cn.com/problems/design-circular-deque/)

  Design your implementation of the circular double-ended queue (deque).

  Your implementation should support following operations:

  - `MyCircularDeque(k)`: Constructor, set the size of the deque to be k.
  - `insertFront()`: Adds an item at the front of Deque. Return true if the operation is successful.
  - `insertLast()`: Adds an item at the rear of Deque. Return true if the operation is successful.
  - `deleteFront()`: Deletes an item from the front of Deque. Return true if the operation is successful.
  - `deleteLast()`: Deletes an item from the rear of Deque. Return true if the operation is successful.
  - `getFront()`: Gets the front item from the Deque. If the deque is empty, return -1.
  - `getRear()`: Gets the last item from Deque. If the deque is empty, return -1.
  - `isEmpty()`: Checks whether Deque is empty or not. 
  - `isFull()`: Checks whether Deque is full or not.

  **Example:**

  ```
  MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3
  circularDeque.insertLast(1);			// return true
  circularDeque.insertLast(2);			// return true
  circularDeque.insertFront(3);			// return true
  circularDeque.insertFront(4);			// return false, the queue is full
  circularDeque.getRear();  			// return 2
  circularDeque.isFull();				// return true
  circularDeque.deleteLast();			// return true
  circularDeque.insertFront(4);			// return true
  circularDeque.getFront();			// return 4
  ```

  **Note:**

  - All values will be in the range of [0, 1000].
  - The number of operations will be in the range of [1, 1000].
  - Please do not use the built-in Deque library.

  ```java
  class MyCircularDeque {
      int cap;
      Deque<Integer> deque;
      /** Initialize your data structure here. Set the size of the deque to be k. */
      public MyCircularDeque(int k) {
          cap = k;
          deque = new LinkedList<>();
      }
      
      /** Adds an item at the front of Deque. Return true if the operation is successful. */
      public boolean insertFront(int value) {
          if (cap == 0) return false;
          deque.addFirst(value);
          cap--;
          return true;
      }
      
      /** Adds an item at the rear of Deque. Return true if the operation is successful. */
      public boolean insertLast(int value) {
          if (cap == 0) return false;
          deque.addLast(value);
          cap--;
          return true;
      }
      
      /** Deletes an item from the front of Deque. Return true if the operation is successful. */
      public boolean deleteFront() {
          if (deque.isEmpty()) return false;
          deque.removeFirst();
          cap++;
          return true;
      }
      
      /** Deletes an item from the rear of Deque. Return true if the operation is successful. */
      public boolean deleteLast() {
          if (deque.isEmpty()) return false;
          deque.removeLast();
          cap++;
          return true;
      }
      
      /** Get the front item from the deque. */
      public int getFront() {
          if (deque.isEmpty()) return -1;
          return deque.peekFirst();
      }
      
      /** Get the last item from the deque. */
      public int getRear() {
          if (deque.isEmpty()) return -1;
          return deque.peekLast();
      }
      
      /** Checks whether the circular deque is empty or not. */
      public boolean isEmpty() {
          return deque.isEmpty();
      }
      
      /** Checks whether the circular deque is full or not. */
      public boolean isFull() {
          return cap == 0;
      }
  }
  ```

+ #### [42. Trapping Rain Water](https://leetcode-cn.com/problems/trapping-rain-water/)

  Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

  ```
  Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
  Output: 6
  Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
  ```

  **Example 2:**

  ```
  Input: height = [4,2,0,3,2,5]
  Output: 9
  ```

  **Constraints:**

  - `n == height.length`
  - `0 <= n <= 3 * 104`
  - `0 <= height[i] <= 105`

  ```java
  class Solution {
      public int trap(int[] height) {
          Stack<Integer> stack = new Stack<>();
          int res = 0;
          for (int i = 0; i < height.length; i++) {
              while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                  int index = stack.pop();
                  if (stack.isEmpty()) break;
                  int h = height[index];
                  res += (i - stack.peek() - 1) * (Math.min(height[i], height[stack.peek()]) - h);
              }
              stack.push(i);
          }
          return res;
      }
  }
  ```

  ```java
  class Solution {
      public int trap(int[] height) {
          if (height.length == 0) return 0;
          int l = height[0], r = height[height.length - 1]; // max of l & r
          int i = 0, j = height.length - 1;
          int res = 0;
          while (i < j) {
              if (l < r) { // right higher, deside by left_max
                  res += l - height[i];
                  i++;
                  l = Math.max(l, height[i]);
              } else {
                  res += r - height[j];
                  j--;
                  r = Math.max(r, height[j]);
              }
          }
          return res;
      }
  }
  ```

+ ]]></description></item><item><title>Data Structure and Algorithm - Day 03</title><link>http://www.cnblogs.com/peng8098/archive/2021/03/12/algorithm3.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 12 Mar 2021 07:06:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2021/03/12/algorithm3.html</guid><description><![CDATA[

+ Stack

  extends class Vector

  ```java
  Stack<T> stack = new Stack<>();
  ```

  API: `empty() peek() pop() push(E item) search(Object o)`

  Recommended in practice:

  ```java
  Deque<T> stack = new ArrayDeque<T>();
  ```

+ Queue

  not a class, is a interface | has many class

  API:

  ![](https://img2020.cnblogs.com/blog/1205669/202103/1205669-20210312150431792-122057343.png)


+ Deque

  announce:`/dek/` | Double-End Queue

  not a class, is a interface | has many class

  API:

  ![](https://img2020.cnblogs.com/blog/1205669/202103/1205669-20210312150452062-936684732.png)


+ Priority Queue

  implements Collection and Queue

  【Time complex】Insert: O(1), Get: O(log n)

  backend：heap / BST - binary search tree / treap

  API:

  ![](https://img2020.cnblogs.com/blog/1205669/202103/1205669-20210312150515292-1262133517.png)


+ Summary of common  data structure operations

  ![](https://img2020.cnblogs.com/blog/1205669/202103/1205669-20210312150526208-575647353.png)

+ #### [26. Remove Duplicates from Sorted Array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

  Given a sorted array *nums*, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each element appears only *once* and returns the new length.

  Do not allocate extra space for another array, you must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.

  **Clarification:**

  Confused why the returned value is an integer but your answer is an array?

  Note that the input array is passed in by **reference**, which means a modification to the input array will be known to the caller as well.

  Internally you can think of this:

  ```
  // nums is passed in by reference. (i.e., without making a copy)
  int len = removeDuplicates(nums);
  
  // any modification to nums in your function would be known by the caller.
  // using the length returned by your function, it prints the first len elements.
  for (int i = 0; i < len; i++) {
      print(nums[i]);
  }
  ```

  **Example 1:**

  ```
  Input: nums = [1,1,2]
  Output: 2, nums = [1,2]
  Explanation: Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the returned length.
  ```

  **Example 2:**

  ```
  Input: nums = [0,0,1,1,1,2,2,3,3,4]
  Output: 5, nums = [0,1,2,3,4]
  Explanation: Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn't matter what values are set beyond the returned length.
  ```

  **Constraints:**

  - `0 <= nums.length <= 3 * 104`
  - `-104 <= nums[i] <= 104`
  - `nums` is sorted in ascending order.

  ```java
  class Solution {
      public int removeDuplicates(int[] nums) {
          int i = 0;
          for (int j = 1; j < nums.length; j++) {
              if (nums[i] != nums[j]) {
                  nums[++i] = nums[j];
              }
          }
          return i + 1;
      }
  }
  ```

+ #### [189. Rotate Array](https://leetcode-cn.com/problems/rotate-array/)

  Given an array, rotate the array to the right by *k* steps, where *k* is non-negative.

  **Follow up:**

  - Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.
  - Could you do it in-place with O(1) extra space?

  **Example 1:**

  ```
  Input: nums = [1,2,3,4,5,6,7], k = 3
  Output: [5,6,7,1,2,3,4]
  Explanation:
  rotate 1 steps to the right: [7,1,2,3,4,5,6]
  rotate 2 steps to the right: [6,7,1,2,3,4,5]
  rotate 3 steps to the right: [5,6,7,1,2,3,4]
  ```

  **Example 2:**

  ```
  Input: nums = [-1,-100,3,99], k = 2
  Output: [3,99,-1,-100]
  Explanation: 
  rotate 1 steps to the right: [99,-1,-100,3]
  rotate 2 steps to the right: [3,99,-1,-100]
  ```

  **Constraints:**

  - `1 <= nums.length <= 2 * 104`
  - `-231 <= nums[i] <= 231 - 1`
  - `0 <= k <= 105`

  ```java
  class Solution {
      public void rotate(int[] nums, int k) {
          int len = nums.length;
          k = k % len;
          reverse(nums, 0, len - 1);
          reverse(nums, 0, k - 1);
          reverse(nums, k, len - 1);
      }
  
      private void reverse(int[] nums, int i, int j) {
          while (i < j) {
              int t = nums[i];
              nums[i] = nums[j];
              nums[j] = t;
              i++;
              j--;
          }
      }
  }
  ```

+ #### [88. Merge Sorted Array](https://leetcode-cn.com/problems/merge-sorted-array/)

  Given two sorted integer arrays `nums1` and `nums2`, merge `nums2` into `nums1` as one sorted array.

  The number of elements initialized in `nums1` and `nums2` are `m` and `n` respectively. You may assume that `nums1` has a size equal to `m + n` such that it has enough space to hold additional elements from `nums2`.

  **Example 1:**

  ```
  Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
  Output: [1,2,2,3,5,6]
  ```

  **Example 2:**

  ```
  Input: nums1 = [1], m = 1, nums2 = [], n = 0
  Output: [1]
  ```

  **Constraints:**

  - `nums1.length == m + n`
  - `nums2.length == n`
  - `0 <= m, n <= 200`
  - `1 <= m + n <= 200`
  - `-109 <= nums1[i], nums2[i] <= 109`

  ```java
  class Solution {
      public void merge(int[] nums1, int m, int[] nums2, int n) {
          int i = m - 1, j = n - 1;
          for (int k = m + n - 1; i >= 0 && j >= 0; k--) {
              nums1[k] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];
          }
          while (j >= 0) nums1[j] = nums2[j--];
      }
  }
  ```

+ #### [66. Plus One](https://leetcode-cn.com/problems/plus-one/)

  Given a **non-empty** array of decimal digits representing a non-negative integer, increment one to the integer.

  The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.

  You may assume the integer does not contain any leading zero, except the number 0 itself.

  **Example 1:**

  ```
  Input: digits = [1,2,3]
  Output: [1,2,4]
  Explanation: The array represents the integer 123.
  ```

  **Example 2:**

  ```
  Input: digits = [4,3,2,1]
  Output: [4,3,2,2]
  Explanation: The array represents the integer 4321.
  ```

  **Example 3:**

  ```
  Input: digits = [0]
  Output: [1]
  ```

  **Constraints:**

  - `1 <= digits.length <= 100`
  - `0 <= digits[i] <= 9`

  ```java
  class Solution {
      public int[] plusOne(int[] digits) {
          int len = digits.length;
          int carry = 1;
          for (int i = len - 1; i >= 0 && carry > 0; i--) {
              int num = digits[i] + 1;
              digits[i] = num % 10;
              carry = num / 10;
          }
          if (carry == 0) return digits;
          int[] res = new int[len + 1];
          res[0] = 1;
          return res;
      }
  }
  ```

+ #### [21. Merge Two Sorted Lists](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

  Merge two sorted linked lists and return it as a **sorted** list. The list should be made by splicing together the nodes of the first two lists.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

  ```
  Input: l1 = [1,2,4], l2 = [1,3,4]
  Output: [1,1,2,3,4,4]
  ```

  **Example 2:**

  ```
  Input: l1 = [], l2 = []
  Output: []
  ```

  **Example 3:**

  ```
  Input: l1 = [], l2 = [0]
  Output: [0]
  ```

  **Constraints:**

  - The number of nodes in both lists is in the range `[0, 50]`.
  - `-100 <= Node.val <= 100`
  - Both `l1` and `l2` are sorted in **non-decreasing** order.

  ```java
  class Solution {
      public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
          ListNode res = new ListNode();
          ListNode cur = res;
          while (l1 != null && l2 != null) {
              if (l1.val < l2.val) {
                  cur.next = l1;
                  l1 = l1.next;
              } else {
                  cur.next = l2;
                  l2 = l2.next;
              }
              cur = cur.next;
          }
          if (l1 != null) cur.next = l1;
          if (l2 != null) cur.next = l2;
          return res.next;
      }
  }
  ```

+ #### [25. Reverse Nodes in k-Group](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

  Given a linked list, reverse the nodes of a linked list *k* at a time and return its modified list.

  *k* is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of *k* then left-out nodes, in the end, should remain as it is.

  **Follow up:**

  - Could you solve the problem in `O(1)` extra memory space?
  - You may not alter the values in the list's nodes, only nodes itself may be changed.

   

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

  ```
  Input: head = [1,2,3,4,5], k = 2
  Output: [2,1,4,3,5]
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

  ```
  Input: head = [1,2,3,4,5], k = 3
  Output: [3,2,1,4,5]
  ```

  **Example 3:**

  ```
  Input: head = [1,2,3,4,5], k = 1
  Output: [1,2,3,4,5]
  ```

  **Example 4:**

  ```
  Input: head = [1], k = 1
  Output: [1]
  ```

  **Constraints:**

  - The number of nodes in the list is in the range `sz`.
  - `1 <= sz <= 5000`
  - `0 <= Node.val <= 1000`
  - `1 <= k <= sz`

  ```java
  class Solution {
      public ListNode reverseKGroup(ListNode head, int k) {
          if (head == null || k == 1) return head;
          ListNode res = new ListNode();
          ListNode cur = res;
          Deque<ListNode> deque = new LinkedList<>();
          while (head != null) {
              for (int i = 0; i < k && head != null; i++) {
                  deque.addLast(head);
                  head = head.next;
              }
              if (deque.size() != k) {
                  cur.next = deque.pollFirst();
                  break;
              }
              while (!deque.isEmpty()) {
                  ListNode node = deque.pollLast();
                  node.next = null;
                  cur.next = node;
                  cur = cur.next;
              }
          }
          return res.next;
      }
  }
  ```
]]></description></item><item><title>Data Structure and Algorithm - Day 02</title><link>http://www.cnblogs.com/peng8098/archive/2021/03/11/algorithm2.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 11 Mar 2021 08:32:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2021/03/11/algorithm2.html</guid><description><![CDATA[+ #### [11. Container With Most Water](https://leetcode-cn.com/problems/container-with-most-water/)

  Given `n` non-negative integers `a1, a2, ..., an` , where each represents a point at coordinate `(i, ai)`. `n` vertical lines are drawn such that the two endpoints of the line `i` is at `(i, ai)` and `(i, 0)`. Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.

  **Notice** that you may not slant the container.

  **Example 1:**

  ![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)

  ```
  Input: height = [1,8,6,2,5,4,8,3,7]
  Output: 49
  Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
  ```

  **Example 2:**

  ```
  Input: height = [1,1]
  Output: 1
  ```

  **Example 3:**

  ```
  Input: height = [4,3,2,1,4]
  Output: 16
  ```

  **Example 4:**

  ```
  Input: height = [1,2,1]
  Output: 2
  ```

  **Constraints:**

  - `n == height.length`
  - `2 <= n <= 105`
  - `0 <= height[i] <= 104`

  ```java
  class Solution {
      public int maxArea(int[] height) {
          int res = 0;
          for (int i = 0, j = height.length - 1; i < j; ) {
              int minHeight = height[i] < height[j] ? height[i++] : height[j--];
              res = Math.max(res, (j - i + 1) * minHeight); //plus 1
          }
          return res;
      }
  }
  ```

+ #### [70. Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/)

  You are climbing a staircase. It takes `n` steps to reach the top.

  Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?

  **Example 1:**

  ```
  Input: n = 2
  Output: 2
  Explanation: There are two ways to climb to the top.
  1. 1 step + 1 step
  2. 2 steps
  ```

  **Example 2:**

  ```
  Input: n = 3
  Output: 3
  Explanation: There are three ways to climb to the top.
  1. 1 step + 1 step + 1 step
  2. 1 step + 2 steps
  3. 2 steps + 1 step
  ```

  **Constraints:**

  - `1 <= n <= 45`

  ```java
  class Solution {
      public int climbStairs(int n) {
          if (n < 4) return n;
          int a = 1, b = 2, c = 3;
          while (n-- > 3) {
              a = b;
              b = c;
              c = a + b;
          }
          return c;
      }
  }
  ```

+ #### [15. 3Sum](https://leetcode-cn.com/problems/3sum/)

  Given an array `nums` of *n* integers, are there elements *a*, *b*, *c* in `nums` such that *a* + *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.

  Notice that the solution set must not contain duplicate triplets.

  **Example 1:**

  ```
  Input: nums = [-1,0,1,2,-1,-4]
  Output: [[-1,-1,2],[-1,0,1]]
  ```

  **Example 2:**

  ```
  Input: nums = []
  Output: []
  ```

  **Example 3:**

  ```
  Input: nums = [0]
  Output: []
  ```

  **Constraints:**

  - `0 <= nums.length <= 3000`
  - `-105 <= nums[i] <= 105`

  ```java
  class Solution {
      public List<List<Integer>> threeSum(int[] nums) {
          List<List<Integer>> res = new ArrayList<>();
          Arrays.sort(nums);
          for (int i = 0; i < nums.length - 2 && nums[i] <= 0; i++) {
              if (i > 0 && nums[i] == nums[i - 1]) continue;
              for (int j = i + 1, k = nums.length - 1; j < k; ) {
                  int sum = nums[j] + nums[k];
                  if (j > i + 1 && nums[j] == nums[j - 1] || sum < -nums[i]) {
                      j++;
                  } else if (k < nums.length - 1 && nums[k] == nums[k + 1] || sum > -nums[i]) {
                      k--;
                  } else {
                      res.add(Arrays.asList(nums[i], nums[j], nums[k]));
                      j++;
                      k--;
                  }
              }
          }
          return res;
      }
  }
  ```

+ #### [141. Linked List Cycle](https://leetcode-cn.com/problems/linked-list-cycle/)

  Given `head`, the head of a linked list, determine if the linked list has a cycle in it.

  There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.

  Return `true` *if there is a cycle in the linked list*. Otherwise, return `false`.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

  ```
  Input: head = [3,2,0,-4], pos = 1
  Output: true
  Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)

  ```
  Input: head = [1,2], pos = 0
  Output: true
  Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
  ```

  **Example 3:**

  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)

  ```
  Input: head = [1], pos = -1
  Output: false
  Explanation: There is no cycle in the linked list.
  ```

  **Constraints:**

  - The number of the nodes in the list is in the range `[0, 104]`.
  - `-105 <= Node.val <= 105`
  - `pos` is `-1` or a **valid index** in the linked-list.

  ```java
  public class Solution {
      public boolean hasCycle(ListNode head) {
          if (head == null || head.next == null) return false; 
          ListNode fast = head.next, slow = head;
          while (fast != null && fast.next != null) {
              if (fast == slow) return true;
              fast = fast.next.next;
              slow = slow.next;
          }
          return false;
      }
  }
  ```

+ #### [142. Linked List Cycle II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

  Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.

  There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.

  **Notice** that you **should not modify** the linked list.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

  ```
  Input: head = [3,2,0,-4], pos = 1
  Output: tail connects to node index 1
  Explanation: There is a cycle in the linked list, where tail connects to the second node.
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)

  ```
  Input: head = [1,2], pos = 0
  Output: tail connects to node index 0
  Explanation: There is a cycle in the linked list, where tail connects to the first node.
  ```

  **Example 3:**

  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)

  ```
  Input: head = [1], pos = -1
  Output: no cycle
  Explanation: There is no cycle in the linked list.
  ```

  **Constraints:**

  - The number of the nodes in the list is in the range `[0, 104]`.
  - `-105 <= Node.val <= 105`
  - `pos` is `-1` or a **valid index** in the linked-list.

  **Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?

  ```java
  public class Solution {
      public ListNode detectCycle(ListNode head) {
          if (head == null || head.next == null) return null;
          ListNode fast = head, slow = head;
          while (fast != null && fast.next != null) {
              fast = fast.next.next;
              slow = slow.next;
              if (fast == slow) {
                  fast = head;
                  while (fast != slow) {
                      fast = fast.next;
                      slow = slow.next;
                  }
                  return fast;
              }
          }
          return null;
      }
  }
  ```

+ #### [206. Reverse Linked List](https://leetcode-cn.com/problems/reverse-linked-list/)

  Given the `head` of a singly linked list, reverse the list, and return *the reversed list*.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

  ```
  Input: head = [1,2,3,4,5]
  Output: [5,4,3,2,1]
  ```

  **Example 2:**

  ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

  ```
  Input: head = [1,2]
  Output: [2,1]
  ```

  **Example 3:**

  ```
  Input: head = []
  Output: []
  ```

  **Constraints:**

  - The number of nodes in the list is the range `[0, 5000]`.
  - `-5000 <= Node.val <= 5000`

  ```java
  class Solution {
      public ListNode reverseList(ListNode head) {
          if (head == null || head.next == null) return head;
          ListNode res = new ListNode();
          while (head != null) {
              ListNode cur = head;
              head = head.next;
              cur.next = res.next;
              res.next = cur;
          }
          return res.next;
      }
  }
  ```

+ #### [24. Swap Nodes in Pairs](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

  Given a linked list, swap every two adjacent nodes and return its head.

  **Example 1:**

  ![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

  ```
  Input: head = [1,2,3,4]
  Output: [2,1,4,3]
  ```

  **Example 2:**

  ```
  Input: head = []
  Output: []
  ```

  **Example 3:**

  ```
  Input: head = [1]
  Output: [1]
  ```

  **Constraints:**

  - The number of nodes in the list is in the range `[0, 100]`.
  - `0 <= Node.val <= 100`

  **Follow up:** Can you solve the problem without modifying the values in the list's nodes? (i.e., Only nodes themselves may be changed.)

  ```java
  class Solution {
      public ListNode swapPairs(ListNode head) {
          if (head == null || head.next == null) return head;
          ListNode res = new ListNode();
          ListNode cur = res;
          while (head != null && head.next != null) {
              ListNode a = head, b = head.next;
              a.next = b.next;
              b.next = a;
              cur.next = b;
              cur = a;
              head = cur.next;
          }
          return res.next;
      }
  }
  ```

  ]]></description></item><item><title>Data Structure and Algorithm - Day 01</title><link>http://www.cnblogs.com/peng8098/archive/2021/03/10/algorithm1.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Wed, 10 Mar 2021 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2021/03/10/algorithm1.html</guid><description><![CDATA[+ Master Theorem

  ![](https://img2020.cnblogs.com/blog/1205669/202103/1205669-20210310194843723-1511765085.png)


+ ArrayList

  When insert or delete an element, ArrayList will create a new Array and execute a System.arraycopy. Doing those constantly will reduce efficiency.

+ SkipList

  space for time | increase dimension

  multi-dimension index | log2n-dimension index

  ![](https://img2020.cnblogs.com/blog/1205669/202103/1205669-20210310194853448-1118718363.png)


  Time complexity: O(log n), Space complexity: O(n)

+ #### [283. Move Zeroes](https://leetcode-cn.com/problems/move-zeroes/)

  Given an array `nums`, write a function to move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.

  **Example:**

  ```
  Input: [0,1,0,3,12]
  Output: [1,3,12,0,0]
  ```

  **Note**:

  1. You must do this **in-place** without making a copy of the array.
  2. Minimize the total number of operations.

  ```java
  class Solution {
      public void moveZeroes(int[] nums) {
          int i = 0;
          for (int j = 0; j < nums.length; j++) {
              if (nums[j] != 0) {
                  swap(nums, i, j);
                  i++;
              }
          }
      }
  
      private void swap(int[] nums, int i, int j) {
          int t = nums[i];
          nums[i] = nums[j];
          nums[j] = t;
      }
  }
  ```

  ]]></description></item><item><title>Thrift在微服务中的使用</title><link>http://www.cnblogs.com/peng8098/archive/2020/11/15/java_33.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 15 Nov 2020 09:32:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/11/15/java_33.html</guid><description><![CDATA[## 什么是RPC

微服务：单个应用程序 -> 一组小型服务

小型服务之间需要通信 -> RPC轻量级通信，像API调用一样easy

![](https://img2020.cnblogs.com/blog/1205669/202011/1205669-20201115173005693-1999489899.png)


微服务优点：

1. 独立缩放，可扩展性强，耦合性低，不相互依赖
2. 独立发布和部署，自己的部署不影响其他的服务
3. 独立开发，独立的技术栈，专注于一个服务
4. 优雅降级
5. 分散治理

## Thrift

### 下载安装Thrift

下载地址：[http://thrift.apache.org/docs/install/debian](http://thrift.apache.org/docs/install/debian)

```
./bootstrap.sh
./configure --with-boost=/usr/local
make
make install
```

### demo

一个简单案例：

1. 编写IDL文件：包含函数名、输入变量的信息
2. 编译生成代码（跨语言通信）：一个接口
3. 服务器重载实现接口
4. 实现服务器和客户端 / 服务端之间相互调用

thrift本质上就是规定一系列协议层层编码解码的rpc架构

![](https://img2020.cnblogs.com/blog/1205669/202011/1205669-20201115173028961-1495725599.png)
]]></description></item><item><title>MySQL 必知必会</title><link>http://www.cnblogs.com/peng8098/archive/2020/09/25/db_03.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 25 Sep 2020 02:20:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/09/25/db_03.html</guid><description><![CDATA[+ 登录

```shell
C:\Program Files\MySQL\MySQL Server 5.7\bin>mysql -u admin -p
Enter password: ****

Server version: 5.7.29
```

+ distinct去重

  ```sql
  select distinct vend_id from products;
  ```

  ```sql
  select distinct vend_id, prod_price from products;
  ```

  distinct 后面跟两项时，必须都不相同，才算不同

+ limit

  ```sql
  select prod_name from products limit 5;
  ```

  返回行数不超过 5

+ offset

  ```sql
  select prod_name from products limit 5 offset 5;
  -- 简写
  select prod_name from products limit 5 , 5;
  ```

  从第 5 行开始（下标从 0 开始算），往后检索 5 行

+ order by

  后跟多个参数时，以前面的为主

  ```sql
  mysql> select prod_id, prod_name, prod_price
      -> from products
      -> order by prod_price, prod_name;
  +---------+---------------------+------------+
  | prod_id | prod_name           | prod_price |
  +---------+---------------------+------------+
  | BNBG02  | Bird bean bag toy   |       3.49 |
  | BNBG01  | Fish bean bag toy   |       3.49 |
  | BNBG03  | Rabbit bean bag toy |       3.49 |
  | RGAN01  | Raggedy Ann         |       4.99 |
  | BR01    | 8 inch teddy bear   |       5.99 |
  | BR02    | 12 inch teddy bear  |       8.99 |
  | RYL01   | King doll           |       9.49 |
  | RYL02   | Queen doll          |       9.49 |
  | BR03    | 18 inch teddy bear  |      11.99 |
  +---------+---------------------+------------+
  ```

  可按 select 字段的顺序简写（排序的字段必须在 select 中）

  ```sql
  select prod_id, prod_name, prod_price from products order by 3, 2;
  ```

  order by 必须在 where 之后

+ desc

  ```sql
  select prod_id, prod_name, prod_price
      -> from products
      -> order by 3 desc, 2;
  ```

  desc 应分别放在要排序的列的后边

  默认是 asc 升序

  排序中默认不区分大小写

+ not 写哪都行

  ```sql
  mysql> select prod_name, prod_price from products
      -> where vend_id not in ('DLL01','BRS01')
      -> order by prod_name;
  mysql> select prod_name, prod_price from products
      -> where not vend_id in ('DLL01','BRS01')
      -> order by prod_name;
  +------------+------------+
  | prod_name  | prod_price |
  +------------+------------+
  | King doll  |       9.49 |
  | Queen doll |       9.49 |
  +------------+------------+
  ```

  ```sql
  mysql> select prod_name, prod_price from products
      -> where not prod_price = 9.49;
  ```

+ 通配符

  %，0~多个任意字符

  ```sql
  mysql> select prod_id, prod_name from products
      -> where prod_name like 'fish%';
  mysql> select prod_id, prod_name from products
      -> where prod_name like '%bean bag%';
  mysql> select prod_id, prod_name from products
      -> where prod_name like 'f%y';
  mysql> select prod_id, prod_name from products
      -> where prod_name like '%'; -- 只有null不被匹配
  ```

  _，1个任意字符

  ```sql
  mysql> select prod_id, prod_name from products
      -> where prod_name like '__ inch teddy bear';
  ```

+ 拼接字段

  ```sql
  select concat(vend_name, ' (', vend_country, ')') from vendors;
  ```

  去空格

  ```sql
  select trim(concat(vend_name, ' (', vend_country, ') ')) from vendors;
  ```

  ltrim，去左空格

  rtrim，去右空格

+ 算术运算符

  `+ - * /`

  ```sql
  mysql> select prod_id, quantity, item_price, quantity*item_price as expanded_price
      -> from orderitems
      -> where order_num = 20008;
  +---------+----------+------------+----------------+
  | prod_id | quantity | item_price | expanded_price |
  +---------+----------+------------+----------------+
  | RGAN01  |        5 |       4.99 |          24.95 |
  | BR03    |        5 |      11.99 |          59.95 |
  | BNBG01  |       10 |       3.49 |          34.90 |
  | BNBG02  |       10 |       3.49 |          34.90 |
  | BNBG03  |       10 |       3.49 |          34.90 |
  +---------+----------+------------+----------------+
  ```

+ 文本处理函数

  upper，转大写，lower，转小写

  ```sql
  mysql> select vend_name, upper(vend_name) as vend_name_upcase
      -> from vendors
      -> order by vend_name;
  ```

  length，字符串长度

  soundex，返回 soundex 值

  ```sql
  mysql> select vend_name, soundex(vend_name) as soundex from vendors;
  +-----------------+---------+
  | vend_name       | soundex |
  +-----------------+---------+
  | Bear Emporium   | B65165  |
  | Bears R Us      | B6262   |
  | Doll House Inc. | D4252   |
  | Fun and Games   | F53252  |
  | Furball Inc.    | F61452  |
  | Jouets et ours  | J32362  |
  +-----------------+---------+
  mysql> select cust_name, cust_contact from customers
      -> where soundex(cust_contact) = soundex('michael green');
  +------------+----------------+
  | cust_name  | cust_contact   |
  +------------+----------------+
  | Kids Place | Michelle Green |
  +------------+----------------+
  ```

  SOUNDEX 是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。

  substring(s, start, n)，start 是起始坐标（从 1 开始算），n 是返回最大字符数

+ 日期时间处理函数

  year，哪一年

  ```sql
  mysql> select order_date from orders where year(order_date) = 2012;
  +---------------------+
  | order_date          |
  +---------------------+
  | 2012-05-01 00:00:00 |
  | 2012-01-12 00:00:00 |
  | 2012-01-30 00:00:00 |
  | 2012-02-03 00:00:00 |
  | 2012-02-08 00:00:00 |
  +---------------------+
  ```

  month，day，hour，minute，second

  ```sql
  select order_date from orders where month(order_date) = 01;
  select order_date from orders where day(order_date) = 01;
  ```

+ 数值处理函数

  | 函数 | 说明                                            |
  | ---- | ----------------------------------------------- |
  | abs  | 返回一个数的绝对值                              |
  | cos  | 返回一个角度的余弦，使用弧度制                  |
  | exp  | 返回一个数的指数值，即自然对数 e 的几次方       |
  | pi   | 返回圆周率                                      |
  | sin  | 返回一个角度的正弦，`select sin(pi()/2);`输出 1 |
  | sqrt | 返回一个数的平方根                              |
  | tan  | 返回一个角度的正切                              |

+ 聚集函数

  | 函数  | 说明                                                         |
  | ----- | ------------------------------------------------------------ |
  | avg   | 返回某列的平均值，忽略列中的 null                            |
  | count | 返回某列的行数，count(*) null 值也算，count(字段) null 值不算 |
  | max   | 返回某列的最大值                                             |
  | min   | 返回某列的最小值                                             |
  | sum   | 返回某列值之和                                               |

  ```sql
  select avg(prod_price) as avg_price from products;
  select max(prod_price) as max_price from products;
  ```

  ```sql
  mysql> select count(*) as num_cust from customers;
  +----------+
  | num_cust |
  +----------+
  |        5 |
  +----------+
  mysql> select count(cust_email) as num_cust from customers;
  +----------+
  | num_cust |
  +----------+
  |        3 |
  +----------+
  ```

  ```sql
  select sum(quantity * item_price) from orderitems;
  ```

  去重放在字段前面

  ```sql
  mysql> select sum(prod_price) from products;
  +-----------------+
  | sum(prod_price) |
  +-----------------+
  |           61.41 |
  +-----------------+
  
  mysql> select sum(distinct prod_price) from products;
  +--------------------------+
  | sum(distinct prod_price) |
  +--------------------------+
  |                    44.94 |
  +--------------------------+
  ```

  组合聚集函数

  ```sql
  mysql> select count(*) as num_items,
      -> min(prod_price) as price_num,
      -> max(prod_price) as price_max,
      -> avg(prod_price) as price_avg
      -> from products;
  +-----------+-----------+-----------+-----------+
  | num_items | price_num | price_max | price_avg |
  +-----------+-----------+-----------+-----------+
  |         9 |      3.49 |     11.99 |  6.823333 |
  +-----------+-----------+-----------+-----------+
  ```

+ 数据分组 group by

  ```sql
  mysql> select vend_id, count(*) as num_prods
      -> from products
      -> group by vend_id;
  +---------+-----------+
  | vend_id | num_prods |
  +---------+-----------+
  | BRS01   |         3 |
  | DLL01   |         4 |
  | FNG01   |         2 |
  +---------+-----------+
  ```

+ 过滤分组

  having，过滤分组，而 where 过滤行，在分组前使用

  ```sql
  mysql> select vend_id, count(*) as num_prods
      -> from products
      -> group by vend_id
      -> having count(*) > 2;
  +---------+-----------+
  | vend_id | num_prods |
  +---------+-----------+
  | BRS01   |         3 |
  | DLL01   |         4 |
  +---------+-----------+
  
  mysql> select vend_id, count(*) as num_prods
      -> from products
      -> where prod_price >= 4
      -> group by vend_id
      -> having count(*) >= 2;
  +---------+-----------+
  | vend_id | num_prods |
  +---------+-----------+
  | BRS01   |         3 |
  | FNG01   |         2 |
  +---------+-----------+
  ```

  order by 排序放在最最后边

  ```sql
  mysql> select order_num, count(*) as items
      -> from orderitems
      -> group by order_num
      -> having count(*) >= 3
      -> order by items, order_num;
  +-----------+-------+
  | order_num | items |
  +-----------+-------+
  |     20006 |     3 |
  |     20009 |     3 |
  |     20007 |     5 |
  |     20008 |     5 |
  +-----------+-------+
  ```

+ select 字句顺序

  | 子句     | 说明               | 是否必须使用         |
  | -------- | ------------------ | -------------------- |
  | select   | 要返回的列或表达式 | ✔                    |
  | from     | 从中检索数据的表   | 从表中选择数据时使用 |
  | where    | 行级过滤           | ✖                    |
  | group by | 分组说明           | 按组计算聚集时使用   |
  | having   | 组级过滤           | ✖                    |
  | order by | 输出排序顺序       | ✖                    |

+ 子查询

  + 列出订购物品 RGAN01 的所有顾客，分开查询，需要三步

  ```sql
  mysql> select order_num from orderitems where prod_id = 'rgan01';
  +-----------+
  | order_num |
  +-----------+
  |     20007 |
  |     20008 |
  +-----------+
  2 rows in set (0.00 sec)
  
  mysql> select cust_id from orders where order_num in ('20007','20008');
  +------------+
  | cust_id    |
  +------------+
  | 1000000004 |
  | 1000000005 |
  +------------+
  2 rows in set (0.00 sec)
  
  mysql> select cust_id, cust_name from customers where cust_id in ('1000000004','1000000005');
  +------------+---------------+
  | cust_id    | cust_name     |
  +------------+---------------+
  | 1000000004 | Fun4All       |
  | 1000000005 | The Toy Store |
  +------------+---------------+
  ```

  嵌套，合起来写

  ```sql
  select cust_id, cust_name from customers where cust_id in (select cust_id from orders where order_num in (select order_num from orderitems where prod_id = 'rgan01'));
  ```

  作为子查询的 SELECT 语句只能查询单个列，企图检索多个列将返回错误

  + 要显示 Customers 表中每个顾客的订单总数

  ```sql
  mysql> select cust_name, (select count(*) from orders where orders.cust_id = customers.cust_id) as orders from customers order by cust_name;
  +---------------+--------+
  | cust_name     | orders |
  +---------------+--------+
  | Fun4All       |      1 |
  | Fun4All       |      1 |
  | Kids Place    |      0 |
  | The Toy Store |      1 |
  | Village Toys  |      2 |
  +---------------+--------+
  ```

  `表名.列名` 区分混淆的列

+ 联结表

  一个联结的例子

  ```sql
  mysql> select vend_name, prod_name, prod_price from vendors, products
      -> where vendors.vend_id = products.vend_id;
  +-----------------+---------------------+------------+
  | vend_name       | prod_name           | prod_price |
  +-----------------+---------------------+------------+
  | Doll House Inc. | Fish bean bag toy   |       3.49 |
  | Doll House Inc. | Bird bean bag toy   |       3.49 |
  | Doll House Inc. | Rabbit bean bag toy |       3.49 |
  | Bears R Us      | 8 inch teddy bear   |       5.99 |
  | Bears R Us      | 12 inch teddy bear  |       8.99 |
  | Bears R Us      | 18 inch teddy bear  |      11.99 |
  | Doll House Inc. | Raggedy Ann         |       4.99 |
  | Fun and Games   | King doll           |       9.49 |
  | Fun and Games   | Queen doll          |       9.49 |
  +-----------------+---------------------+------------+
  ```

  若没有条件，检索出的行数为第一个表的行数乘以第二个表中的行数（笛卡尔积），要使用 where 筛选出正确的

  ```sql
  mysql> select count(*) from vendors;
  +----------+
  | count(*) |
  +----------+
  |        6 |
  +----------+
  
  mysql> select count(*) from products;
  +----------+
  | count(*) |
  +----------+
  |        9 |
  +----------+
  
  mysql> select count(*) from (select vend_name, prod_name, prod_price from vendors, products) as new_table;
  +----------+
  | count(*) |
  +----------+
  |       54 |
  +----------+
  ```

  返回笛卡儿积的联结，也称叉联结（cross join）

+ 内联结

  ```sql
  mysql> select vend_name, prod_name, prod_price
      -> from vendors as v inner join products as p
      -> on v.vend_id = p.vend_id; -- where结果一样
  ```

+ 联结多个表

  ```sql
  mysql> select prod_name, vend_name, prod_price, quantity
      -> from orderitems as o, products as p, vendors as v
      -> where p.vend_id = v.vend_id and o.prod_id = p.prod_id and order_num = 20007;
  +---------------------+-----------------+------------+----------+
  | prod_name           | vend_name       | prod_price | quantity |
  +---------------------+-----------------+------------+----------+
  | 18 inch teddy bear  | Bears R Us      |      11.99 |       50 |
  | Fish bean bag toy   | Doll House Inc. |       3.49 |      100 |
  | Bird bean bag toy   | Doll House Inc. |       3.49 |      100 |
  | Rabbit bean bag toy | Doll House Inc. |       3.49 |      100 |
  | Raggedy Ann         | Doll House Inc. |       4.99 |       50 |
  +---------------------+-----------------+------------+----------+
  ```

  ```sql
  mysql> select cust_name, cust_contact
      -> from customers as c, orders as o, orderitems as oi
      -> where c.cust_id = o.cust_id and oi.order_num = o.order_num and prod_id = 'rgan01';
  +---------------+--------------------+
  | cust_name     | cust_contact       |
  +---------------+--------------------+
  | Fun4All       | Denise L. Stephens |
  | The Toy Store | Kim Howard         |
  +---------------+--------------------+
  ```

+ 自联结（重复用自己）

  找到与 Jim Jones 同一公司的所有顾客

  用子查询

  ```sql
  mysql> select cust_id, cust_name, cust_contact from customers
      -> where cust_name = (select cust_name from customers where cust_contact = 'jim jones');
  +------------+-----------+--------------------+
  | cust_id    | cust_name | cust_contact       |
  +------------+-----------+--------------------+
  | 1000000003 | Fun4All   | Jim Jones          |
  | 1000000004 | Fun4All   | Denise L. Stephens |
  +------------+-----------+--------------------+
  ```

  表联结

  ```sql
  mysql> select c1.cust_id, c1.cust_name, c1.cust_contact
      -> from customers as c1, customers as c2
      -> where c1.cust_name = c2.cust_name and c2.cust_contact = 'jim jones';
  ```

+ 自然联结

  ```sql
  mysql> select c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_price
      -> from customers as c, orders as o, orderitems as oi
      -> where c.cust_id = o.cust_id and oi.order_num = o.order_num and prod_id = 'rgan01';
  ```

+ 外联结

  必须有 left 或 right

  检索所有顾客及每个顾客所下的订单有哪些

  ```sql
  mysql> select customers.cust_id, orders.order_num
      -> from customers inner join orders
      -> on customers.cust_id = orders.cust_id;
  +------------+-----------+
  | cust_id    | order_num |
  +------------+-----------+
  | 1000000001 |     20005 |
  | 1000000001 |     20009 |
  | 1000000003 |     20006 |
  | 1000000004 |     20007 |
  | 1000000005 |     20008 |
  +------------+-----------+
  
  mysql> select c.cust_id, o.order_num
      -> from customers as c left outer join orders as o
      -> on c.cust_id = o.cust_id;
  +------------+-----------+
  | cust_id    | order_num |
  +------------+-----------+
  | 1000000001 |     20005 |
  | 1000000001 |     20009 |
  | 1000000002 |      NULL |
  | 1000000003 |     20006 |
  | 1000000004 |     20007 |
  | 1000000005 |     20008 |
  +------------+-----------+
  
  mysql> select c.cust_id, o.order_num
      -> from customers as c right outer join orders as o
      -> on c.cust_id = o.cust_id;
  +------------+-----------+
  | cust_id    | order_num |
  +------------+-----------+
  | 1000000001 |     20005 |
  | 1000000001 |     20009 |
  | 1000000003 |     20006 |
  | 1000000004 |     20007 |
  | 1000000005 |     20008 |
  +------------+-----------+
  ```

+ 聚集函数 + 联结

  检索所有顾客及每个顾客所下的订单数

  ```sql
  mysql> select c.cust_id, count(o.order_num) as num_order
      -> from customers as c inner join orders as o
      -> on c.cust_id = o.cust_id
      -> group by c.cust_id;
  +------------+-----------+
  | cust_id    | num_order |
  +------------+-----------+
  | 1000000001 |         2 |
  | 1000000003 |         1 |
  | 1000000004 |         1 |
  | 1000000005 |         1 |
  +------------+-----------+
  
  mysql> select c.cust_id, count(o.order_num) as num_order
      -> from customers as c left outer join orders as o
      -> on c.cust_id = o.cust_id
      -> group by c.cust_id;
  +------------+-----------+
  | cust_id    | num_order |
  +------------+-----------+
  | 1000000001 |         2 |
  | 1000000002 |         0 |
  | 1000000003 |         1 |
  | 1000000004 |         1 |
  | 1000000005 |         1 |
  +------------+-----------+
  ```

+ 什么时候使用联结

  + 注意所使用的联结类型。一般我们使用内联结，但使用外联结也有效
  + 关于确切的联结语法，应该查看具体的文档，看相应的 DBMS 支持何种语法
  + 保证使用正确的联结条件（不管采用哪种语法），否则会返回不正确的数据。
  + 应该总是提供联结条件，否则会得出笛卡儿积
  + 在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前分别测试每个联结。这会使故障排除更为简单

+ 组合查询

  同一个表

  ```sql
  mysql> select cust_name, cust_contact, cust_email
      -> from customers
      -> where cust_state in ('il','in','mi')
      -> union
      -> select cust_name, cust_contact, cust_email
      -> from customers
      -> where cust_name = 'fun4all';
      -> order by cust_name, cust_contact;
  ```

  相当于

  ```sql
  mysql> select cust_name, cust_contact, cust_email from customers
      -> where cust_state in ('il','in','mi') or cust_name = 'fun4all';
  ```

  union 可自动去重，不想去重可用 union all

  union 规则

  + UNION 必须由两条或两条以上的 SELECT 语句组成，语句之间用关键字UNION 分隔（因此，如果组合四条SELECT语句，将要使用三个UNION关键字）
  + UNION 中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）
  + 列数据类型必须兼容：类型不必完全相同，但必须是 DBMS 可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）

+ 数据插入

  直接按字段顺序，不建议使用

  ```sql
  mysql> insert into customers
      -> values('1000000006','toy land','123 street','Beijing','BJ','102249','China',null,null);
  ```

  把字段写上，前后对应插入

  ```sql
  mysql> insert into customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)
      -> values('1000000006','toy land','123 street','Beijing','BJ','102249','China');
  ```

  insert 还存在另一种形式，可以利用它将 select 语句的结果插入表中

  如，把另一表中的顾客列合并到 customers 表中

  ```sql
  mysql> insert into customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)
      -> select cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country
      -> from custnew;
  ```

+ 表复制

  ```sql
  mysql> create table custcopy as
      -> select * from customers;
  ```

+ 更新数据

  ```sql
  mysql> update customers
      -> set cust_email = 'kim@thetoystore.com'
      -> where cust_id = '1000000005';
  ```

  set 中若有多个字段，用逗号隔开

  删除某行的某个值，可以把它 set 成 null，表示空，不用 where 即可删除一列

+ 删除数据

  删除一行

  ```sql
  mysql> delete from customers
      -> where cust_id = '1000000006';
  ```

  若没有 where 将删除所有行

  ```sql
  mysql> delete from custcopy;
  Query OK, 6 rows affected (0.01 sec)
  ```

  或者使用 truncate，速度更快

  ```sql
  mysql> truncate table custcopy;
  ```

  联通表结构一块删除

  ```sql
  mysql> drop table custcopy;
  ```

+ 创建表

  ```sql
  mysql> create table t1(
      -> id	char(10)	not null,
      -> name	char(10),
      -> age	integer		default 18
      -> );
  ```

+ 更新表

  增加一列

  ```sql
  mysql> alter table t1
      -> add tel char(20);
  ```

  删除一列

  ```sql
  mysql> alter table t1
      -> drop column tel;
  ```

  删除表

  ```sql
  mysql> drop table t1;
  ```

  重命名表

  ```sql
  mysql> rename table os to orders;
  ```

+ 创建视图

  create view 接 select

  本质就是存下一个 select 的查询结果，方便以后使用

  ```sql
  mysql> create view productcustomers as
      -> select cust_name, cust_contact, prod_id
      -> from customers as c, orders as o, orderitems as oi
      -> where c.cust_id = o.cust_id and oi.order_num = o.order_num;
  ```

  ```sql
  mysql> select cust_name, cust_contact
      -> from productcustomers
      -> where prod_id = 'rgan01'
      -> order by cust_name; -- 不建议在这排序
  +---------------+--------------------+
  | cust_name     | cust_contact       |
  +---------------+--------------------+
  | Fun4All       | Denise L. Stephens |
  | The Toy Store | Kim Howard         |
  +---------------+--------------------+
  ```

  ```sql
  mysql> create view vendorlocations as
      -> select concat(vend_name, ' (', vend_country, ')') as vend_title
      -> from vendors;
  ```

  ```sql
  mysql> select * from vendorlocations;
  +-------------------------+
  | vend_title              |
  +-------------------------+
  | Bear Emporium (USA)     |
  | Bears R Us (USA)        |
  | Doll House Inc. (USA)   |
  | Fun and Games (England) |
  | Furball Inc. (USA)      |
  | Jouets et ours (France) |
  +-------------------------+
  ```

+ 视图过滤

  只看有 email 的用户

  ```sql
  mysql> create view customeremaillist as
      -> select cust_id, cust_name, cust_email from customers
      -> where cust_email is not null;
  
  mysql> select * from customeremaillist;
  +------------+---------------+-----------------------+
  | cust_id    | cust_name     | cust_email            |
  +------------+---------------+-----------------------+
  | 1000000001 | Village Toys  | sales@villagetoys.com |
  | 1000000003 | Fun4All       | jjones@fun4all.com    |
  | 1000000004 | Fun4All       | dstephens@fun4all.com |
  | 1000000005 | The Toy Store | kim@thetoystore.com   |
  +------------+---------------+-----------------------+
  ```

+ 事务

  开启事务首先要关闭自动提交，`set autocommit = 0;`

  ```sql
  mysql> start transaction;
  mysql> update acount
      -> set money = money - 500
      -> where name = 'a';
  mysql> update acount
      -> set money = money + 500
      -> where name = 'b';
  mysql> commit;
  ```

+ 回滚

  ```sql
  mysql> delete from acount where name = 'a';
  mysql> select * from acount;
  +------+-------+
  | name | money |
  +------+-------+
  | b    |  1500 |
  +------+-------+
  mysql> rollback;
  mysql> select * from acount;
  +------+-------+
  | name | money |
  +------+-------+
  | a    |   500 |
  | b    |  1500 |
  +------+-------+
  ```

+ 保留点

  savepoint，返回的点

  ```sql
  mysql> savepoint delete1;
  
  mysql> delete from acount where name = 'a';
  mysql> delete from acount where name = 'b';
  
  mysql> select * from acount;
  Empty set (0.00 sec)
  
  mysql> rollback; -- 或者使用 rollback to delete1;
  
  mysql> select * from acount;
  +------+-------+
  | name | money |
  +------+-------+
  | a    |   500 |
  | b    |  1500 |
  +------+-------+
  ```

  在事务中也一样使用

+ 添加主键

  + 创建时添加 primary key

  + 后来添加

  ```sql
  mysql> alter table acount
      -> add primary key(name);
  ```

+ 添加索引

  ```sql
  mysql> create index name_idx
      -> on acount(name);
  ```

+ Bye

  ```sql
  mysql> quit;
  Bye
  ```]]></description></item><item><title>IDEA 内使用 git</title><link>http://www.cnblogs.com/peng8098/archive/2020/09/21/java_32.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 21 Sep 2020 01:01:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/09/21/java_32.html</guid><description><![CDATA[+ 安装

  官网下载exe，一路默认，安装到d盘

  ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921085451095-148429977.png)


+ IDEA配置git

  + 配置路径

    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921085510964-931614130.png)


  + 登录账号

    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921085533600-1767344477.png)


    443错误，ping不过去

    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921085551259-1580891667.png)


    大概是网络被封，需用代理，命令如下

    ```
    git config --global http.proxy http://proxyuser:proxypwd@proxy.server.com:8080
    ```

    - change proxyuser to your proxy user
    - change proxypwd to your proxy password
    - change proxy.server.com to the URL of your proxy server
    - change 8080 to the proxy port configured on your proxy server

    代理设置为172.16.13.171:8080，修改之后，连接成功

    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921085617352-1998142339.png)


    一些命令

    ```
    git config --global http.proxy  查询代理
    git config --global --unset http.proxy  取消代理
    git config --global http.proxy http:172.16.13.171:8080 设置代理
    git config --global https.proxy http:172.16.13.171:8080
    ```

+ pull项目

  + checkout

    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921085640184-1097306294.png)


  + 输入项目参数，就克隆how2j这个吧

    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921085655127-560758354.png)


+ 创建项目

  + 新建仓库

    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921085714417-1668389008.png)


    输入仓库名

    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921085811499-1921867177.png)



    得到github地址

    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921085824842-1050834056.png)


  + 在IDEA新建一个项目

    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921085841398-911266247.png)


  + 建立本地仓库

    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921085856281-1253798245.png)


  + 将项目加入本地仓库

    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921085933920-1596441525.png)



  + 提交项目

    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921085951884-17354263.png)


    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921090011524-977957135.png)


    将remote换成github之前仓库地址：https://github.com/pengyirusi/helloworld.git

    ![](https://img2020.cnblogs.com/blog/1205669/202009/1205669-20200921090030169-1580943709.png)


    最后点push就可以了

+ IDEA提交和更新

  + 提交改动（本地 -> github）：CTRL + K
  + 更新（github -> 本地）：CTRL + T]]></description></item><item><title>分布式锁</title><link>http://www.cnblogs.com/peng8098/archive/2020/08/22/java_31.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 22 Aug 2020 03:02:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/08/22/java_31.html</guid><description><![CDATA[+ 线程安全问题：多线程，共享资源，非原子性操作；同一时间，同一资源

+ i++不是原子性操作，是一组操作，三步操作

  1.从主存读值
  2.+1操作
  3.刷写到内存

A B 都想执行i++

A 获取CPU资源 时间片形式

A 2ms	B 5ms

会导致数据更新出问题

![](https://img2020.cnblogs.com/blog/1205669/202008/1205669-20200822105927764-290289402.png)


解决：synchronized

各种悲观锁：多线程并行=>单线程串行

A没用完不让B用

sync：堆，线程共享区，锁对象，int count = 0; 默认互斥量为0

lock：AQS volatile static int state = 0; 默认互斥量也为0

可见，互斥量 int

```java
//单机锁互斥原理
if (count/state == 0){
    count/state = 1;//获取锁成功
    //一顿操作
    count/state = 0;
    //唤醒别人
} else {
    //获取锁失败，挂起线程并加入队列等待
}
```

### 分布式锁

获取锁：相同目录创建一个文件夹，`mkdir /usr/lock/`

释放锁：`rm -rf /usr/lock/`

只有一个线程能成功在一个路径创建这个文件夹，其他线程等待

![](https://img2020.cnblogs.com/blog/1205669/202008/1205669-20200822105948836-454031917.png)


redis实现

只有一个线程能 set 成功，f 为 true

finally，即使中间断了也会释放锁，但是断电了还是执行不了，所以要给锁加一个 timeout 过期时间，过时间自动删除了

![](https://img2020.cnblogs.com/blog/1205669/202008/1205669-20200822110008992-1909521904.png)


图中第 4 行执行后断电，第 5 行没有执行，一直占用锁怎么办

```java
//写到一行了，具有原子性
Boolean f = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, lockValue, timeout);
```

业务时间超过锁的 timeout 时间咋办（ABC问题）

给锁加上唯一标识，自己上的锁只有自己能解开，具体操作：

```java
String lockValue = UUID.randomUUID.toString();
```

但是业务还是跑不完啊，怎么办（AB问题）

开子线程（守护线程）续命，监视到主线程死了/业务结束了，结束自己；主线程死了：锁 timeout 释放 / 业务结束了：finally 释放锁

![](https://img2020.cnblogs.com/blog/1205669/202008/1205669-20200822110034800-1887951725.png)


守护线程：

![](https://img2020.cnblogs.com/blog/1205669/202008/1205669-20200822110048057-1592002059.png)


主从架构锁失效

redis 高性能 电商：

zookeeper 高稳定 金融：主服务器知道你想上锁后，把这个消息发给从服务器，从服务器有一半以上都知道你上锁了，上锁才能成功（分布式锁，投票上锁？）

分布式锁基于单机锁推导，悲观锁

![](https://img2020.cnblogs.com/blog/1205669/202008/1205669-20200822110103544-1547228956.png)



redisson用法

并发那么高，分布式锁性能得多慢，怎么解决

1.降低锁粒度，多余的业务别放锁里啊，不同的对象别用一个锁啊，加了不同业务的独立 id

![](https://img2020.cnblogs.com/blog/1205669/202008/1205669-20200822110127022-1975891695.png)


2.分段容器，每个数据做分段，甚至细到每个数据，每个数据的每个字段，整体架构优化
]]></description></item><item><title>剑指offer的超时怪</title><link>http://www.cnblogs.com/peng8098/archive/2020/08/08/leetcode17.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 08 Aug 2020 11:17:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/08/08/leetcode17.html</guid><description><![CDATA[## 超时的题

**easy 6 min，medium 12 min，hard 18 min**

#### [剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

#### [剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

#### [剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)（看视频）

#### [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

#### [剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

#### [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

#### [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

#### [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

#### [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)（听课）

#### [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)



## 注意点

1. basecase：null，length为0，size为0，等等]]></description></item><item><title>LeetCode 图</title><link>http://www.cnblogs.com/peng8098/archive/2020/08/04/leetcode16.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 04 Aug 2020 04:43:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/08/04/leetcode16.html</guid><description><![CDATA[## 基础部分

#### [785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)

中等

给定一个无向图`graph`，当这个图为二分图时返回`true`。

如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。

`graph`将会以邻接表方式给出，`graph[i]`表示图中与节点`i`相连的所有节点。每个节点都是一个在`0`到`graph.length-1`之间的整数。这图中没有自环和平行边： `graph[i]` 中不存在`i`，并且`graph[i]`中没有重复的值。

```
示例 1:
输入: [[1,3], [0,2], [1,3], [0,2]]
输出: true
解释: 
无向图如下:
0----1
|    |
|    |
3----2
我们可以将节点分成两组: {0, 2} 和 {1, 3}。
示例 2:
输入: [[1,2,3], [0,2], [0,1,3], [0,2]]
输出: false
解释: 
无向图如下:
0----1
| \  |
|  \ |
3----2
我们不能将节点分割成两个独立的子集。
```

**注意:**

- `graph` 的长度范围为 `[1, 100]`。
- `graph[i]` 中的元素的范围为 `[0, graph.length - 1]`。
- `graph[i]` 不会包含 `i` 或者有重复的值。
- 图是无向的: 如果`j` 在 `graph[i]`里边, 那么 `i` 也会在 `graph[j]`里边。

```java
class Solution {
    public boolean isBipartite(int[][] graph) {
        //set: 0未上色，1和-1两种颜色
        int[] set = new int[graph.length];
        for (int node = 0; node < graph.length; node++){
            if (set[node] != 0) continue;
            if (!dfs(graph,node,1,set) && !dfs(graph,node,-1,set))
                return false;
        }
        return true;
    }
    
    private boolean dfs(int[][] graph, int node, int color, int[] set){
        if (set[node] != 0) return set[node] == color;
        set[node] = color;
        for (int point : graph[node]){
            if (!dfs(graph, point, -color, set)){
                set[node] = 0; //发现color不行，擦去，后边再试-color
                return false;
            }
        }
        return true;
    }
}
```

#### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

中等

你这个学期必须选修 `numCourse` 门课程，记为 `0` 到 `numCourse-1` 。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：`[0,1]`

给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？

**示例 1:**

```
输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
```

**示例 2:**

```
输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
```

**提示：**

1. 输入的先决条件是由 **边缘列表** 表示的图形，而不是 邻接矩阵 。详情请参见[图的表示法](http://blog.csdn.net/woaidapaopao/article/details/51732947)。
2. 你可以假定输入的先决条件中没有重复的边。
3. `1 <= numCourses <= 10^5`

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = new List[numCourses];//建图
        for (int i = 0; i < numCourses; i++){
            graph[i] = new ArrayList<>();
        }
        int[] inDegree = new int[numCourses];
        for (int[] pre : prerequisites){
            graph[pre[1]].add(pre[0]); //统计后置课程
            inDegree[pre[0]]++; //统计入度
        }
        Queue<Integer> queue = new LinkedList<>();
        for (int course = 0; course < numCourses; course++){ //直接能学的先学了
            if (inDegree[course] == 0) queue.add(course);
        }
        int learned = 0; //学习的课程数
        while (!queue.isEmpty()){
            int cur = queue.poll();
            learned++;
            for (int back : graph[cur]){
                inDegree[back]--; //后置课程入度-1
                if (inDegree[back] == 0){
                    queue.add(back);
                }
            }
        }
        return learned >= numCourses;
    }
}
```

#### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

中等

现在你总共有 *n* 门课需要选，记为 `0` 到 `n-1`。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: `[0,1]`

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

**示例 1:**

```
输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
```

**示例 2:**

```
输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
```

**说明:**

1. 输入的先决条件是由**边缘列表**表示的图形，而不是邻接矩阵。详情请参见[图的表示法](http://blog.csdn.net/woaidapaopao/article/details/51732947)。
2. 你可以假定输入的先决条件中没有重复的边。

**提示:**

1. 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。
2. [通过 DFS 进行拓扑排序](https://www.coursera.org/specializations/algorithms) - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。
3. 拓扑排序也可以通过 [BFS](https://baike.baidu.com/item/宽度优先搜索/5224802?fr=aladdin&fromid=2148012&fromtitle=广度优先搜索) 完成。

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = new List[numCourses];
        for (int i = 0; i < numCourses; i++){
            graph[i] = new ArrayList<>();
        }
        int[] inDegree = new int[numCourses];
        for (int[] pre : prerequisites){
            graph[pre[1]].add(pre[0]);
            inDegree[pre[0]]++;
        }
        Queue<Integer> queue = new LinkedList<>();
        for (int course = 0; course < numCourses; course++){
            if (inDegree[course] == 0) queue.add(course);
        }
        int[] res = new int[numCourses];
        int index = 0;
        while (!queue.isEmpty()){
            int cur = queue.poll();
            res[index++] = cur;
            for (int back : graph[cur]){
                inDegree[back]--;
                if (inDegree[back] == 0)
                    queue.add(back);
            }
        }
        return index == numCourses ? res : new int[]{};
    }
}
```

#### [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

中等

在本问题中, 树指的是一个连通且无环的**无向**图。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以`边`组成的二维数组。每一个`边`的元素是一对`[u, v]` ，满足 `u < v`，表示连接顶点`u` 和`v`的**无向**图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 `[u, v]` 应满足相同的格式 `u < v`。

**示例 1：**

```
输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3
```

**示例 2：**

```
输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3
```

**注意:**

- 输入的二维数组大小在 3 到 1000。
- 二维数组中的整数在1到N之间，其中N是输入数组的大小。

```java
class Solution {
    class DSU {
        int[] root; //点连接的根
        int[] size; //连接集的大小
        
        public DSU(int n){
            root = new int[n];
            size = new int[n];
            
            for (int i = 0; i < n; i++)
                root[i] = i; //初始化，根就是自己
        }
        
        public int find(int x){ //寻找根+递归更新根
            if (root[x] != x){
                root[x] = find(root[x]);
            }
            return root[x];
        }
        
        public boolean union(int x, int y){
            int rootX = find(x);
            int rootY = find(y);
            if (rootX == rootY) return false; //根一样=>在一个集里，连接失败
            if (size[rootX] < size[rootY]){ //小集并到大集上
                root[rootX] = rootY; //更新根
                size[rootY]++; //更新后代数大小
            }else {
                root[rootY] = root[rootX];
                size[rootX]++;
            }
            return true;
        }
    }
    
    public int[] findRedundantConnection(int[][] edges) {
        int n = edges.length;
        DSU dsu = new DSU(n+1);
        for (int[] e : edges){
            if (!dsu.union(e[0],e[1])) return e;
        }
        return new int[]{};
    }
}
```

## 频率排序

269，928，839，743]]></description></item><item><title>LeetCode 位运算</title><link>http://www.cnblogs.com/peng8098/archive/2020/08/04/leetcode15.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 04 Aug 2020 04:09:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/08/04/leetcode15.html</guid><description><![CDATA[## 基础部分

**基本原理** 

0s 表示一串 0，1s 表示一串 1。

```
x ^ 0s = x      x & 0s = 0      x | 0s = x
x ^ 1s = ~x     x & 1s = x      x | 1s = 1s
x ^ x = 0       x & x = x       x | x = x
```

利用 x ^ 1s = \~x 的特点，可以将一个数的位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。

```
1^1^2 = 2
```

利用 x & 0s = 0 和 x & 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。

```
01011011 &
00111100
--------
00011000
```

利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。

```
01011011 |
00111100
--------
01111111
```

**位与运算技巧** 

n&(n-1) 去除 n 的位级表示中最低的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。

```
01011011 &
01011010
--------
01011010
```

n&(-n) 得到 n 的位级表示中最低的那一位 1。-n 得到 n 的反码加 1，也就是 -n=\~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。

```
10110100 &
01001100
--------
00000100
```

n-(n&(-n)) 则可以去除 n 的位级表示中最低的那一位 1，和 n&(n-1) 效果一样。

**移位运算** 

\>\> n 为算术右移，相当于除以 2n，例如 -7 \>\> 2 = -2。

```
11111111111111111111111111111001  >> 2
--------
11111111111111111111111111111110
```

\>\>\> n 为无符号右移，左边会补上 0。例如 -7 \>\>\> 2 = 1073741822。

```
11111111111111111111111111111001  >>> 2
--------
00111111111111111111111111111111
```

<< n 为算术左移，相当于乘以 2n。-7 << 2 = -28。

```
11111111111111111111111111111001  << 2
--------
11111111111111111111111111100100
```

**mask 计算** 

要获取 111111111，将 0 取反即可，\~0。

要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1<<(i-1) 。例如 1<<4 得到只有第 5 位为 1 的 mask ：00010000。

要得到 1 到 i 位为 1 的 mask，(1<<i)-1 即可，例如将 (1<<4)-1 = 00010000-1 = 00001111。

要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 \~((1<<i)-1)。

**Java 中的位操作**  

```html
static int Integer.bitCount();           // 统计 1 的数量
static int Integer.highestOneBit();      // 获得最高位
static String toBinaryString(int i);     // 转换为二进制表示的字符串
```

**不使用额外变量交换两个数**

```java
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

#### [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

简单

两个整数之间的[汉明距离](https://baike.baidu.com/item/汉明距离)指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 `x` 和 `y`，计算它们之间的汉明距离。

**注意：**
0 ≤ `x`, `y` < 231.

**示例:**

```
输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

上面的箭头指出了对应二进制位不同的位置。
```

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int res = 0, a = (int)Math.pow(2,30);
        while (a > 0){
            if ((x&a)!=(y&a)) res++;
            a >>= 1;
        }
        return res;
    }
}
```

```java
class Solution {
    public int hammingDistance(int x, int y) {
        return Integer.bitCount(x ^ y);
    }
}
```

#### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

简单

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**

```
输入: [2,2,1]
输出: 1
```

**示例 2:**

```
输入: [4,1,2,1,2]
输出: 4
```

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for (int num : nums) res ^= num;
        return res;
    }
}
```

#### [268. 缺失数字](https://leetcode-cn.com/problems/missing-number/)

简单

给定一个包含 `0, 1, 2, ..., n` 中 *n* 个数的序列，找出 0 .. *n* 中没有出现在序列中的那个数。

**示例 1:**

```
输入: [3,0,1]
输出: 2
```

**示例 2:**

```
输入: [9,6,4,2,3,5,7,0,1]
输出: 8
```

**说明:**
你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?

```java
class Solution {
    public int missingNumber(int[] nums) {
        int res = nums.length;
        for (int i = 0; i < nums.length; i++){
            res ^= i ^ nums[i]; //res += i - nums[i];
        }
        return res;
    }
}
```

#### [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)

中等

给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

**示例 :**

```
输入: [1,2,1,3,2,5]
输出: [3,5]
```

**注意：**

1. 结果输出的顺序并不重要，对于上面的例子， `[5, 3]` 也是正确答案。
2. 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int mask = 0;
        for (int num : nums) mask ^= num;
        int a = 1;
        while ((mask & a) == 0) a <<= 1;
        int x = 0, y = 0;
        for (int num : nums){
            if ((num & a) == 0){
                x ^= num;
            }else {
                y ^= num;
            }
        }
        return new int[]{x, y};
    }
}
```

#### [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

简单

颠倒给定的 32 位无符号整数的二进制位。

**示例 1：**

```
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```

**示例 2：**

```
输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
```

**提示：**

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用[二进制补码](https://baike.baidu.com/item/二进制补码/5295284)记法来表示有符号整数。因此，在上面的 **示例 2** 中，输入表示有符号整数 `-3`，输出表示有符号整数 `-1073741825`。

 ```java
public class Solution {
    public int reverseBits(int n) {
        int res = 0;
        for (int i = 0; i < 32; i++){
            res <<= 1;
            res += n & 1;
            n >>>= 1;
        }
        return res;
    }
}
 ```

#### [231. 2的幂](https://leetcode-cn.com/problems/power-of-two/)

简单

给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && Integer.bitCount(n) == 1;
        // return n > 0 && (n & (n - 1)) == 0;
    }
}
```

#### [342. 4的幂](https://leetcode-cn.com/problems/power-of-four/)

简单

给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。

```java
class Solution {
    public boolean isPowerOfFour(int num) {
        if (num < 0 || Integer.bitCount(num) != 1) return false;
        int res = 0;
        while (num > 0){
            if ((num & 1) == 1) res++;
            num >>= 2;
        }
        return res == 1;
    }
}
```

#### [693. 交替位二进制数](https://leetcode-cn.com/problems/binary-number-with-alternating-bits/)

简单

给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。

**示例 1:**

```
输入: 5
输出: True
解释:
5的二进制数是: 101
```

**示例 2:**

```
输入: 7
输出: False
解释:
7的二进制数是: 111
```

**示例 3:**

```
输入: 11
输出: False
解释:
11的二进制数是: 1011
```

 **示例 4:**

```
输入: 10
输出: True
解释:
10的二进制数是: 1010
```

```java
class Solution {
    public boolean hasAlternatingBits(int n) {
        int high = Integer.highestOneBit(n);
        return helper(n, high, 1);
    }
    
    private boolean helper(int n, int high, int bit){
        if (high == 0) return true;
        int digit = (n&high) > 0 ? 1 : 0;
        if (digit == bit) return helper(n, high>>1, bit^1);
        return false;
    }
}
```

#### [476. 数字的补数](https://leetcode-cn.com/problems/number-complement/)

简单

给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。

**示例 1:**

```
输入: 5
输出: 2
解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
```

**示例 2:**

```
输入: 1
输出: 0
解释: 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。
```

**注意:**

1. 给定的整数保证在 32 位带符号整数的范围内。
2. 你可以假定二进制数不包含前导零位。

```java
class Solution {
    public int findComplement(int num) {
        int high = Integer.highestOneBit(num);
        while (high > 0){
            num ^= high;
            high >>= 1;
        }
        return num;
    }
}
```

#### [371. 两整数之和](https://leetcode-cn.com/problems/sum-of-two-integers/)

简单

**不使用**运算符 `+` 和 `-` ，计算两整数 `a` 、`b` 之和。

**示例 1:**

```
输入: a = 1, b = 2
输出: 3
```

**示例 2:**

```
输入: a = -2, b = 3
输出: 1
```

```java
class Solution {
    public int getSum(int a, int b) {
        int res = a;
        while (b != 0){
            res = a ^ b;
            b = (a & b) << 1;
            a = res;
        }
        return res;
    }
}
```

#### [318. 最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)

中等

给定一个字符串数组 `words`，找到 `length(word[i]) * length(word[j])` 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。

**示例 1:**

```
输入: ["abcw","baz","foo","bar","xtfn","abcdef"]
输出: 16 
解释: 这两个单词为 "abcw", "xtfn"。
```

**示例 2:**

```
输入: ["a","ab","abc","d","cd","bcd","abcd"]
输出: 4 
解释: 这两个单词为 "ab", "cd"。
```

**示例 3:**

```
输入: ["a","aa","aaa","aaaa"]
输出: 0 
解释: 不存在这样的两个单词。
```

```java
class Solution { // 朴素方法，368ms
    public int maxProduct(String[] words) {
        Set<Character> set = new HashSet<>();
        int res = 0;
        for (int i = 0; i < words.length-1; i++){
            for (char ch : words[i].toCharArray()) set.add(ch);
            for (int j = i+1; j < words.length; j++){
                boolean can = true;
                for(char ch : words[j].toCharArray()){
                    if (set.contains(ch)){
                        can = false;
                        break;
                    }
                }
                if (can) res = Math.max(res,words[i].length()*words[j].length());
            }
            set.clear();
        }
        return res;
    }
}
```

```java
class Solution { // 24<32，所以可以用二进制位存字母，8ms
    public int maxProduct(String[] words) {
        int len = words.length;
        int[] nums = new int[len];
        for (int i = 0; i < len; i++){
            int fill = 0;
            for (char ch : words[i].toCharArray())
                fill |= 1 << (ch - 'a');
            nums[i] = fill;
        }
        int res = 0;
        for (int i = 0; i < len-1; i++)
            for (int j = i+1; j < len; j++)
                if ((nums[i] & nums[j]) == 0)
                    res = Math.max(res,words[i].length()*words[j].length());
        return res;
    }
}
```

#### [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

中等

给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。

**示例 1:**

```
输入: 2
输出: [0,1,1]
```

**示例 2:**

```
输入: 5
输出: [0,1,1,2,1,2]
```

**进阶:**

- 给出时间复杂度为**O(n\*sizeof(integer))**的解答非常容易。但你可以在线性时间**O(n)**内用一趟扫描做到吗？
- 要求算法的空间复杂度为**O(n)**。
- 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 **__builtin_popcount**）来执行此操作。

```java
class Solution {
    public int[] countBits(int num) {
        int[] res = new int[num+1];
        for (int i = 1; i <= num; i++)
            res[i] = res[i&(i-1)] + 1; //res[i] = Integer.bitCount(i);
        return res;
    }
}
```

## 频率排序

411，393，260，898，421]]></description></item><item><title>LeetCode 数组</title><link>http://www.cnblogs.com/peng8098/archive/2020/08/03/leetcode14.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 03 Aug 2020 09:15:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/08/03/leetcode14.html</guid><description><![CDATA[## 基础部分

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

简单

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例:**

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        if (nums == null || nums.length < 2) return;
        int i = 0, len = nums.length, j, tmp;
        while (i < len){
            while (i < len && nums[i] != 0) i++;
            j = i + 1;
            while (j < len && nums[j] == 0) j++;
            if (j >= len) break;
            tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
    }
}
```

#### [566. 重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/)

简单

在MATLAB中，有一个非常有用的函数 `reshape`，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。

给出一个由二维数组表示的矩阵，以及两个正整数`r`和`c`，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的**行遍历顺序**填充。

如果具有给定参数的`reshape`操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

**示例 1:**

```
输入: 
nums = 
[[1,2],
 [3,4]]
r = 1, c = 4
输出: 
[[1,2,3,4]]
解释:
行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。
```

**示例 2:**

```
输入: 
nums = 
[[1,2],
 [3,4]]
r = 2, c = 4
输出: 
[[1,2],
 [3,4]]
解释:
没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。
```

**注意：**

1. 给定矩阵的宽和高范围在 [1, 100]。
2. 给定的 r 和 c 都是正数。

```java
class Solution {
    public int[][] matrixReshape(int[][] nums, int r, int c) {
        int m = nums.length;
        int n = nums[0].length;
        if (m * n != r * c) return nums;
        int[][] res= new int[r][c];
        for (int i = 0; i < r; i++){
            for (int j = 0; j < c; j++){
                int index = i * c + j;
                res[i][j] = nums[index/n][index%n];
            }
        }
        return res;
    }
}
```

#### [485. 最大连续1的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)

简单

给定一个二进制数组， 计算其中最大连续1的个数。

**示例 1:**

```
输入: [1,1,0,1,1,1]
输出: 3
解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.
```

**注意：**

- 输入的数组只包含 `0` 和`1`。
- 输入数组的长度是正整数，且不超过 10,000。

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int res = nums[0];
        for (int i = 1; i < nums.length; i++){
            if (nums[i] == 1) {
                nums[i] = nums[i-1] + 1;
                if (nums[i] > res) res = nums[i];
            }
        }
        return res;
    }
}
```

#### [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

中等

编写一个高效的算法来搜索 *m* x *n* 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

**示例:**

现有矩阵 matrix 如下：

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

给定 target = `5`，返回 `true`。

给定 target = `20`，返回 `false`。

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix.length == 0 || matrix[0].length == 0) return false;
        int row = matrix.length;
        int i = 0, j = matrix[0].length - 1;
        while (i < row && j >= 0){
            if (matrix[i][j] == target) return true;
            else if (matrix[i][j] > target) j--;
            else i++;
        }
        return false;
    }
}
```

#### [378. 有序矩阵中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)

中等

给定一个 *`n x n`* 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。
请注意，它是排序后的第 `k` 小元素，而不是第 `k` 个不同的元素。

**示例：**

```
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
```

**提示：**
你可以假设 k 的值永远是有效的，`1 ≤ k ≤ n^2 `。

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        int[] res = new int[n*n];
        for (int i = 0; i < n; i++){
            for (int j = 0; j < n; j++){
                res[i*n+j] = matrix[i][j];
            }
        }
        Arrays.sort(res);
        return res[k-1];
    }
}
```

#### [645. 错误的集合](https://leetcode-cn.com/problems/set-mismatch/)

简单

集合 `S` 包含从1到 `n` 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。

给定一个数组 `nums` 代表了集合 `S` 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

**示例 1:**

```
输入: nums = [1,2,2,4]
输出: [2,3]
```

**注意:**

1. 给定数组的长度范围是 [2, 10000]。
2. 给定的数组是无序的。

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int[] map = new int[nums.length+1];
        for (int num : nums) map[num]++;
        int[] res = new int[2];
        for (int i = 1; i < map.length; i++){
            if (map[i] == 1) continue;
            else if (map[i] == 2) res[0] = i;
            else res[1] = i;
        }
        return res;
    }
}
```

#### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

中等

给定一个包含 *n* + 1 个整数的数组 *nums*，其数字都在 1 到 *n* 之间（包括 1 和 *n*），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

**示例 1:**

```
输入: [1,3,4,2,2]
输出: 2
```

**示例 2:**

```
输入: [3,1,3,4,2]
输出: 3
```

**说明：**

1. **不能**更改原数组（假设数组是只读的）。
2. 只能使用额外的 *O*(1) 的空间。
3. 时间复杂度小于 *O*(*n*2) 。
4. 数组中只有一个重复的数字，但它可能不止重复出现一次。

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int[] map = new int[nums.length];
        for (int num : nums){
            map[num]++;
            if (map[num] == 2) return num;
        }
        return 0;
    }
}
```

#### [667. 优美的排列 II](https://leetcode-cn.com/problems/beautiful-arrangement-ii/)

中等

给定两个整数 `n` 和 `k`，你需要实现一个数组，这个数组包含从 `1` 到 `n` 的 `n` 个不同整数，同时满足以下条件：

① 如果这个数组是 [a1, a2, a3, ... , an] ，那么数组 [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] 中应该有且仅有 k 个不同整数；.

② 如果存在多种答案，你只需实现并返回其中任意一种.

**示例 1:**

```
输入: n = 3, k = 1
输出: [1, 2, 3]
解释: [1, 2, 3] 包含 3 个范围在 1-3 的不同整数， 并且 [1, 1] 中有且仅有 1 个不同整数 : 1
```

**示例 2:**

```
输入: n = 3, k = 2
输出: [1, 3, 2]
解释: [1, 3, 2] 包含 3 个范围在 1-3 的不同整数， 并且 [2, 1] 中有且仅有 2 个不同整数: 1 和 2
```

**提示:**

1.  `n` 和 `k` 满足条件 1 <= k < n <= 10^4.

```java
class Solution {
    public int[] constructArray(int n, int k) {
        int[] res = new int[n];
        for (int i = 0; i < n; i++) res[i] = i + 1;
        int i = 1;
        while (--k > 0) reverse(res,i++,n-1);
        return res;
    }
    
    private void reverse(int[] nums,int l,int r){
        int tmp;
        while (l < r){
            tmp = nums[l];
            nums[l] = nums[r];
            nums[r] = tmp;
            l++;
            r--;
        }
    }
}
```

#### [697. 数组的度](https://leetcode-cn.com/problems/degree-of-an-array/)

简单

给定一个非空且只包含非负数的整数数组 `nums`, 数组的度的定义是指数组里任一元素出现频数的最大值。

你的任务是找到与 `nums` 拥有相同大小的度的最短连续子数组，返回其长度。

**示例 1:**

```
输入: [1, 2, 2, 3, 1]
输出: 2
解释: 
输入数组的度是2，因为元素1和2的出现频数最大，均为2.
连续子数组里面拥有相同度的有如下所示:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组[2, 2]的长度为2，所以返回2.
```

**示例 2:**

```
输入: [1,2,2,3,1,4,2]
输出: 6
```

**注意:**

- `nums.length` 在1到50,000区间范围内。
- `nums[i]` 是一个在0到49,999范围内的整数。

```java
class Solution {
    public int findShortestSubArray(int[] nums) {
        Map<Integer,Integer> map = new HashMap<>();
        for (int num : nums)
            map.put(num,map.getOrDefault(num,0)+1);
        List<Integer> maxs = new ArrayList<>();
        int maxcount = 0;
        for (Integer key : map.keySet()){
            maxcount = Math.max(maxcount,map.get(key));
        }
        if (maxcount < 2) return maxcount;
        for (Integer key : map.keySet()){
            if (map.get(key) == maxcount) maxs.add(key);
        }
        int res = nums.length;
        for (Integer max : maxs){
            int i = 0, j = nums.length-1;
            while (nums[i] != max) i++;
            while (nums[j] != max) j--;
            res = Math.min(res,j-i+1);
        }
        return res;
    }
}
```

#### [766. 托普利茨矩阵](https://leetcode-cn.com/problems/toeplitz-matrix/)

简单

如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 **托普利茨矩阵** 。

给定一个 `M x N` 的矩阵，当且仅当它是*托普利茨矩阵*时返回 `True`。

**示例 1:**

```
输入: 
matrix = [
  [1,2,3,4],
  [5,1,2,3],
  [9,5,1,2]
]
输出: True
解释:
在上述矩阵中, 其对角线为:
"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]"。
各条对角线上的所有元素均相同, 因此答案是True。
```

**示例 2:**

```
输入:
matrix = [
  [1,2],
  [2,2]
]
输出: False
解释: 
对角线"[1, 2]"上的元素不同。
```

**说明:**

1.  `matrix` 是一个包含整数的二维数组。
2. `matrix` 的行数和列数均在 `[1, 20]`范围内。
3. `matrix[i][j]` 包含的整数在 `[0, 99]`范围内。

```java
class Solution {
    public boolean isToeplitzMatrix(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        for (int i = 1; i < m; i++){
            for (int j = 1; j < n; j++){
                if (matrix[i][j] != matrix[i-1][j-1])
                    return false;
            }
        }
        return true;
    }
}
```

#### [565. 数组嵌套](https://leetcode-cn.com/problems/array-nesting/)

中等

索引从`0`开始长度为`N`的数组`A`，包含`0`到`N - 1`的所有整数。找到最大的集合`S`并返回其大小，其中 `S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }`且遵守以下的规则。

假设选择索引为`i`的元素`A[i]`为`S`的第一个元素，`S`的下一个元素应该是`A[A[i]]`，之后是`A[A[A[i]]]...` 以此类推，不断添加直到`S`出现重复的元素。

**示例 1:**

```
输入: A = [5,4,0,3,1,6,2]
输出: 4
解释: 
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

其中一种最长的 S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
```

**提示：**

1. `N`是`[1, 20,000]`之间的整数。
2. `A`中不含有重复的元素。
3. `A`中的元素大小在`[0, N-1]`之间。

```java
class Solution {
    public int arrayNesting(int[] nums) {
        Set<Integer> set = new HashSet<>();
        int res = 1;
        for (int i = 0; i < nums.length; i++){
            if (set.contains(i)) continue;
            int index = i, count = 0;
            do {
                set.add(index);
                index = nums[index];
                count++;
            }while (index != i);
            res = Math.max(res, count);
        }
        return res;
    }
}
```

#### [769. 最多能完成排序的块](https://leetcode-cn.com/problems/max-chunks-to-make-sorted/)

中等

数组`arr`是`[0, 1, ..., arr.length - 1]`的一种排列，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。

我们最多能将数组分成多少块？

**示例 1:**

```
输入: arr = [4,3,2,1,0]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。
```

**示例 2:**

```
输入: arr = [1,0,2,3,4]
输出: 4
解释:
我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。
```

**注意:**

- `arr` 的长度在 `[1, 10]` 之间。
- `arr[i]`是 `[0, 1, ..., arr.length - 1]`的一种排列。

```java
class Solution {
    public int maxChunksToSorted(int[] arr) {
        int res = 0, max = 0;
        for (int i = 0; i < arr.length; i++){
            max = Math.max(arr[i], max);
            if (max == i) res++; //当前最大值==当前坐标
        }
        return res;
    }
}
```

## 频率排序

768，1，945，42，4，1014，85，15，1040，548，918，53，442，45，974，782，54，769，644，713，723，718，873，11，128，714，381，1074，121，56，33，88，123，509，695，84，665，717]]></description></item><item><title>LeetCode 字符串</title><link>http://www.cnblogs.com/peng8098/archive/2020/08/03/leetcode13.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 03 Aug 2020 04:19:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/08/03/leetcode13.html</guid><description><![CDATA[## 基础部分

#### [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

简单

给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2:**

```
输入: s = "rat", t = "car"
输出: false
```

**说明:**
你可以假设字符串只包含小写字母。

**进阶:**
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] map = new int[26];
        for (char c : s.toCharArray()) map[c-'a']++;
        for (char c : t.toCharArray()) map[c-'a']--;
        for (int count : map) if (count != 0) return false;
        return true;
    }
}
```

#### [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)

简单

给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 `"Aa"` 不能当做一个回文字符串。

**注意:**
假设字符串的长度不会超过 1010。

**示例 1:**

```
输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

```java
class Solution {
    public int longestPalindrome(String s) {
        int[] letters = new int[52];
        for (char c : s.toCharArray()){
            if (c <= 'Z') letters[c-'A']++;
            else letters[c-'a'+26]++;
        }
        int res = 0, odd = 0;
        for (int num : letters){
            if (num % 2 == 1) odd = 1;
            res += num / 2 * 2;
        }
        return res + odd;
    }
}
```

#### [205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)

简单

给定两个字符串 ***s*** 和 ***t\***，判断它们是否是同构的。

如果 ***s*** 中的字符可以被替换得到 ***t\*** ，那么这两个字符串是同构的。

所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。

**示例 1:**

```
输入: s = "egg", t = "add"
输出: true
```

**示例 2:**

```
输入: s = "foo", t = "bar"
输出: false
```

**示例 3:**

```
输入: s = "paper", t = "title"
输出: true
```

**说明:**
你可以假设 ***s*** 和 ***t*** 具有相同的长度。

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        int len = s.length();
        Map<Character,Character> map1 = new HashMap<>();
        Map<Character,Character> map2 = new HashMap<>();
        for (int i = 0; i < len; i++){
            char ch1 = s.charAt(i);
            char ch2 = t.charAt(i);
            if (map1.containsKey(ch1)){
                if (map1.get(ch1) != ch2) return false;
            }else if (map2.containsKey(ch2)){
                if (map2.get(ch2) != ch1) return false;
            }else {
                map1.put(ch1, ch2);
                map2.put(ch2, ch1);
            }
        }
        return true;
    }
}
```

#### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

中等

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。

**示例 1:**

```
输入: "abc"
输出: 3
解释: 三个回文子串: "a", "b", "c".
```

**示例 2:**

```
输入: "aaa"
输出: 6
说明: 6个回文子串: "a", "a", "a", "aa", "aa", "aaa".
```

**注意:**

1. 输入的字符串长度不会超过1000。

```java
class Solution { //O(n^3)
    public int countSubstrings(String s) {
        int len = s.length();
        int res = 0;
        for (int i = 0; i < len; i++){
            for (int j = i+1; j <= len; j++){
                if (is(s.substring(i, j))) res++;
            }
        }
        return res;
    }
    
    private boolean is(String s){
        int l = s.length();
        for (int i = 0; i < l/2; i++){
            if (s.charAt(i) != s.charAt(l-i-1))
                return false;
        }
        return true;
    }
}
```

```java
class Solution { //O(n^2)，从里向外的双指针
    int res = 0;
    public int countSubstrings(String s) {
        if (s == null || s.length() == 0) return 0;
        int len = s.length();
        for (int i = 0; i < len; i++){
            helper(s, i, i, len);
            helper(s, i, i+1, len);
        }
        return res;
    }
    
    private void helper(String s, int l, int r, int len){
        while (l >= 0 && r < len && s.charAt(l) == s.charAt(r)){
            res++;
            l--;
            r++;
        }
    }
}
```

#### [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

简单

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**示例 1:**

```
输入: 121
输出: true
```

**示例 2:**

```
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3:**

```
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```

```java
class Solution {
    public boolean isPalindrome(int x) {
        String s = String.valueOf(x);
        for (int i = 0; i < s.length()/2; i++){
            if (s.charAt(i) != s.charAt(s.length()-i-1))
                return false;
        }
        return true;
    }
}
```

#### [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)

简单

给定一个字符串 `s`，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

**示例 1 :**

```
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
```

**示例 2 :**

```
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
```

**注意：**

- `s.length` 在1到50,000之间。
- `s` 只包含“0”或“1”字符。

```java
class Solution {
    int res = 0;
    public int countBinarySubstrings(String s) {
        if (s == null || s.length() == 0) return 0;
        char[] chars = s.toCharArray();
        int len = chars.length;
        for (int i = 0; i < len-1; i++){
            if (chars[i] != chars[i+1])
                helper(chars, i, i+1, len); 
        }
        return res;
    }
    
    private void helper(char[] chars, int l, int r, int len){
        char left = chars[l];
        char right = chars[r];
        do {
            res++;
            l--;
            r++; 
        }while (l >= 0 && r < len && chars[l] == left && chars[r] == right);
    }
}
```

## 频率排序

72，5，3，93，468，415，583，556，555，165，214，385，833，536，10，1106，1096，761，564，271，159，722，336，539，97，443，91，758，76，22，227]]></description></item><item><title>LeetCode 哈希表</title><link>http://www.cnblogs.com/peng8098/archive/2020/08/03/leetcode12.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 03 Aug 2020 02:14:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/08/03/leetcode12.html</guid><description><![CDATA[## 基础部分

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

简单

给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

**示例:**

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++){
            if (map.containsKey(target-nums[i])){
                return new int[]{map.get(target-nums[i]), i};
            }else {
                map.put(nums[i], i);
            }
        }
        return new int[]{};
    }
}
```

#### [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

难度简单275

给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

**示例 1:**

```
输入: [1,2,3,1]
输出: true
```

**示例 2:**

```
输入: [1,2,3,4]
输出: false
```

**示例 3:**

```
输入: [1,1,1,3,3,4,3,2,4,2]
输出: true
```

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num : nums){
            if (set.contains(num)) return true;
            set.add(num);
        }
        return false;
    }
}
```

#### [594. 最长和谐子序列](https://leetcode-cn.com/problems/longest-harmonious-subsequence/)

简单

和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。

现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。

**示例 1:**

```
输入: [1,3,2,2,5,2,3,7]
输出: 5
原因: 最长的和谐数组是：[3,2,2,2,3].
```

```java
class Solution {
    public int findLHS(int[] nums) {
        Map<Integer,Integer> map = new TreeMap<>();
        for (int num : nums)
            map.put(num, map.getOrDefault(num,0)+1);
        List<Integer> list = new ArrayList<>();
        for (int key : map.keySet()) list.add(key);
        int res = 0;
        for (int i = 1; i < list.size(); i++){
            res = Math.max(res,list.get(i)-list.get(i-1)==1 ? map.get(list.get(i)) + map.get(list.get(i-1)) : 0);
        }
        return res;
    }
}
```

#### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

困难

给定一个未排序的整数数组，找出最长连续序列的长度。

要求算法的时间复杂度为 *O(n)*。

**示例:**

```
输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num : nums) set.add(num);
        int res = 0;
        for (Integer num : set){
            if (set.contains(num+1)) continue;
            int number = num - 1, len = 1;
            while (set.contains(number)){
                len++;
                number--;
            }
            res = Math.max(res, len);
        }
        return res;
    }
}
```

## 频率排序

711，1044，3，726，85，149，535，974，718，381，37，159，336，648，692，594，325，939，76，204，694
]]></description></item><item><title>LeetCode 栈和队列</title><link>http://www.cnblogs.com/peng8098/archive/2020/08/02/leetcode11.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 02 Aug 2020 12:37:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/08/02/leetcode11.html</guid><description><![CDATA[## 基础部分

#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

简单

使用栈实现队列的下列操作：

- push(x) -- 将一个元素放入队列的尾部。
- pop() -- 从队列首部移除元素。
- peek() -- 返回队列首部的元素。
- empty() -- 返回队列是否为空。

**示例:**

```
MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);  
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false
```

**说明:**

- 你只能使用标准的栈操作 -- 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。

```java
class MyQueue {
    Stack<Integer> stack1;
    Stack<Integer> stack2;

    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }

    public void push(int x) {
        while (!stack2.isEmpty()){
            stack1.push(stack2.pop());
        }
        stack1.push(x);
    }
    
    public int pop() {
        while (!stack1.isEmpty()){
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }
    
    public int peek() {
        while (!stack1.isEmpty()){
            stack2.push(stack1.pop());
        }
        return stack2.peek();
    }
    
    public boolean empty() {
        return stack1.isEmpty() && stack2.isEmpty();
    }
}
```

#### [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

简单

使用队列实现栈的下列操作：

- push(x) -- 元素 x 入栈
- pop() -- 移除栈顶元素
- top() -- 获取栈顶元素
- empty() -- 返回栈是否为空

**注意:**

- 你只能使用队列的基本操作-- 也就是 `push to back`, `peek/pop from front`, `size`, 和 `is empty` 这些操作是合法的。
- 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
- 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

```java
class MyStack {
    Queue<Integer> queue1;
    Queue<Integer> queue2;

    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }
    
    public void push(int x) {
        queue1.add(x);
    }
    
    public int pop() {
        while (queue1.size()>1){
            queue2.add(queue1.poll());
        }
        int ans = queue1.poll();
        Queue<Integer> tmp = queue1;
        queue1 = queue2;
        queue2 = tmp;
        return ans;
    }
    
    public int top() {
        while (queue1.size()>1){
            queue2.add(queue1.poll());
        }
        int ans = queue1.peek();
        queue2.add(queue1.poll());
        Queue<Integer> tmp = queue1;
        queue1 = queue2;
        queue2 = tmp;
        return ans;
    }

    public boolean empty() {
        return queue1.isEmpty();
    }
}
```

#### [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

简单

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

- `push(x)` —— 将元素 x 推入栈中。
- `pop()` —— 删除栈顶的元素。
- `top()` —— 获取栈顶元素。
- `getMin()` —— 检索栈中的最小元素。

**示例:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**提示：**

- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用。

```java
class MinStack { // 7ms
    Stack<Integer> stack;
    Stack<Integer> minstack;
    int min;

    public MinStack() {
        stack = new Stack<>();
        minstack = new Stack<>();
        min = Integer.MAX_VALUE;
    }
    
    public void push(int x) {
        stack.push(x);
        if (x < min) min = x;
        minstack.push(min);
    }
    
    public void pop() {
        stack.pop();
        minstack.pop();
        min = minstack.isEmpty() ? Integer.MAX_VALUE : minstack.peek();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minstack.peek();
    }
}
```

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

简单

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

**示例 1:**

```
输入: "()"
输出: true
```

**示例 2:**

```
输入: "()[]{}"
输出: true
```

**示例 3:**

```
输入: "(]"
输出: false
```

**示例 4:**

```
输入: "([)]"
输出: false
```

**示例 5:**

```
输入: "{[]}"
输出: true
```

```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()){
            if (c == '(' || c == '[' || c == '{'){
                stack.push(c);
            }else if (c == ')'){
                if (stack.isEmpty() || stack.pop() != '(') return false;
            }else if (c == ']'){
                if (stack.isEmpty() || stack.pop() != '[') return false;
            }else {
                if (stack.isEmpty() || stack.pop() != '{') return false;
            }
        }
        return stack.isEmpty();
    }
}
```

#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

中等

请根据每日 `气温` 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。

**提示：**`气温` 列表长度的范围是 `[1, 30000]`。每个气温的值的均为华氏度，都是在 `[30, 100]` 范围内的整数。

[**动画演示**](https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/)

```java
class IndexAndNum{
    int index;
    int num;
    public IndexAndNum(int index,int num){
        this.index = index;
        this.num = num;
    }
}
class Solution {
    public int[] dailyTemperatures(int[] T) {
        int n = T.length;
        int[] res = new int[n];
        Stack<IndexAndNum> stack = new Stack<>();
        stack.push(new IndexAndNum(0, T[0]));
        for (int i = 1; i < n; i++){
            while (!stack.isEmpty() && T[i] > stack.peek().num){
                int index = stack.pop().index;
                res[index] = i - index;
            }
            stack.push(new IndexAndNum(i, T[i]));
        }
        return res;
    }
}
```

#### [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

中等

给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

**示例 1:**

```
输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

**注意:** 输入数组的长度不会超过 10000。

```java
class IndexAndNum{
    int index;
    int num;
    public IndexAndNum(int index,int num){
        this.index = index;
        this.num = num;
    }
}
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];
        Arrays.fill(res, -1);
        Stack<IndexAndNum> stack = new Stack<>();
        int i, j;
        for (j = 0; j < 2*n; j++){ //两轮循环
            i = j % n;
            while (!stack.isEmpty() && nums[i] > stack.peek().num){
                int index = stack.pop().index;
                res[index] = nums[i];
            }
            stack.push(new IndexAndNum(i, nums[i]));
        }
        return res;
    }
}
```

## 频率排序

394，42，726，316，85，975，385，862，402，84，456]]></description></item><item><title>Leetcode 树</title><link>http://www.cnblogs.com/peng8098/archive/2020/08/02/leetcode10.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 02 Aug 2020 09:23:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/08/02/leetcode10.html</guid><description><![CDATA[## 基础部分

### 递归

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

简单

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

#### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

简单

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过1。

**示例 1:**

给定二叉树 `[3,9,20,null,null,15,7]`

```
    3
   / \
  9  20
    /  \
   15   7
```

返回 `true` 。

**示例 2:**

给定二叉树 `[1,2,2,3,3,null,null,4,4]`

```
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```

返回 `false` 。

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        return Math.abs(maxDepth(root.left)-maxDepth(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
    }

    private int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

#### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

简单

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

**注意：**两结点之间的路径长度是以它们之间边的数目表示。

```java
class Solution {
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left) + maxDepth(root.right),Math.max(diameterOfBinaryTree(root.left),diameterOfBinaryTree(root.right)));   
    }

    private int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

简单

翻转一棵二叉树。

**示例：**

输入：

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

输出：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;
        TreeNode tmp = invertTree(root.left);
        root.left = invertTree(root.right);
        root.right = tmp;
        return root;
    }
}
```

#### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

简单

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则**不为** NULL 的节点将直接作为新二叉树的节点。

**示例 1:**

```
输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

**注意:** 合并必须从两个树的根节点开始。

```java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null && t2 == null) return null;
        if (t1 == null) return t2;
        if (t2 == null) return t1;
        TreeNode root = new TreeNode();
        root.val += (t1 == null ? 0 : t1.val) + (t2 == null ? 0 : t2.val);
        root.left = mergeTrees(t1.left,t2.left);
        root.right = mergeTrees(t1.right,t2.right);
        return root;
    }
}
```

#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

简单

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

**说明:** 叶子节点是指没有子节点的节点。

**示例:** 
给定如下二叉树，以及目标和 `sum = 22`，

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```

返回 `true`, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`。

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) return false;
        if (root.left == null && root.right == null) return sum == root.val;
        return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);
    }
}
```

#### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

中等

给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

**示例：**

```
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
```

```java
class Solution {
    public int pathSum(TreeNode root, int sum) {
        if (root == null) return 0;
        return helper(root,sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    }

    private int helper(TreeNode root, int target){
        if (root == null) return 0;
        return (root.val == target ? 1 : 0) + helper(root.left, target-root.val) + helper(root.right, target-root.val);
    }
}
```

#### [572. 另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

简单

给定两个非空二叉树 **s** 和 **t**，检验 **s** 中是否包含和 **t** 具有相同结构和节点值的子树。**s** 的一个子树包括 **s** 的一个节点和这个节点的所有子孙。**s** 也可以看做它自身的一棵子树。

**示例 1:**
给定的树 s:

```
     3
    / \
   4   5
  / \
 1   2
```

给定的树 t：

```
   4 
  / \
 1   2
```

返回 **true**，因为 t 与 s 的一个子树拥有相同的结构和节点值。

**示例 2:**
给定的树 s：

```
     3
    / \
   4   5
  / \
 1   2
    /
   0
```

给定的树 t：

```
   4
  / \
 1   2
```

返回 **false**。

```java
class Solution {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        if (t == null) return true;
        if (s == null) return false;
        return isSameTree(s,t) || isSubtree(s.left,t) || isSubtree(s.right,t);
    }

    private boolean isSameTree(TreeNode s, TreeNode t){
        if (s == null && t == null) return true;
        if (s == null || t == null) return false;
        return s.val == t.val && isSameTree(s.left,t.left) && isSameTree(s.right,t.right);
    }
}
```

#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

难度简单

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

**进阶：**

你可以运用递归和迭代两种方法解决这个问题吗？

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null || (root.left == null && root.right == null)) return true;
        if (root.left == null || root.right == null) return false;
        return isMirrorTree(root.left,root.right);
    }

    private boolean isMirrorTree(TreeNode s, TreeNode t){
        if (s == null && t == null) return true;
        if (s == null || t == null) return false;
        return s.val == t.val && isMirrorTree(s.left,t.right) && isMirrorTree(s.right,t.left);
    }
}
```

#### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

简单

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

给定二叉树 `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最小深度  2.

```java
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        if (root.left == null && root.right == null) return 1;
        int l = root.left == null ? Integer.MAX_VALUE : minDepth(root.left);
        int r = root.right == null ? Integer.MAX_VALUE : minDepth(root.right);
        return 1 + Math.min(l, r);
    }
}
```

#### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

简单

计算给定二叉树的所有左叶子之和。

**示例：**

```
    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        return (root.left != null && isLeaf(root.left) ? root.left.val : 0) + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
    }

    private boolean isLeaf(TreeNode root){
        return root.left == null && root.right == null;
    }
}
```

#### [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)

简单

给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

**注意**：两个节点之间的路径长度由它们之间的边数表示。

**示例 1:**

输入:

```
              5
             / \
            4   5
           / \   \
          1   1   5
```

输出:

```
2
```

**示例 2:**

输入:

```
              1
             / \
            4   5
           / \   \
          4   4   5
```

输出:

```
2
```

**注意:** 给定的二叉树不超过10000个结点。 树的高度不超过1000。

```java
class Solution {
    int res = 0;
    public int longestUnivaluePath(TreeNode root) {
        longestPath(root);
        return res;
    }

    private int longestPath(TreeNode root){
        if (root == null) return 0;
        int resOflr = 0;
        int left = longestPath(root.left);
        int right = longestPath(root.right);
        if (root.left != null && root.val == root.left.val && root.right != null && root.right.val == root.val)
            res = Math.max(left + right + 2, res); //左中右
        if (root.left != null && root.val == root.left.val) //上中左
            resOflr = left + 1;
        if (root.right != null && root.right.val == root.val) //上中右
            resOflr = Math.max(resOflr, right + 1);
        res = Math.max(res, resOflr);
        return resOflr;
    }
}
```

#### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

中等

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

**示例 1:**

```
输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
```

**示例 2:**

```
输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
```

```java
class Solution {
    public int rob(TreeNode root) {
        return helper(root, true);
    }

    private int helper(TreeNode root, boolean canStealRoot){
        if (root == null) return 0;
        if (canStealRoot) return Math.max(helper(root.left, true) + helper(root.right, true), root.val + helper(root.left, false) + helper(root.right, false));
        else return helper(root.left, true) + helper(root.right, true);
    }
}
```

#### [671. 二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

简单

给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 `2` 或 `0`。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。

给出这样的一个二叉树，你需要输出所有节点中的**第二小的值。**如果第二小的值不存在的话，输出 -1 **。**

**示例 1:**

```
输入: 
    2
   / \
  2   5
     / \
    5   7

输出: 5
说明: 最小的值是 2 ，第二小的值是 5 。
```

**示例 2:**

```
输入: 
    2
   / \
  2   2

输出: -1
说明: 最小的值是 2, 但是不存在第二小的值。
```

```java
class Solution {
    long[] res;
    public int findSecondMinimumValue(TreeNode root) {
        res = new long[2];
        res[0] = Long.MAX_VALUE;
        res[1] = Long.MAX_VALUE;
        helper(root);
        return res[1]==Long.MAX_VALUE ? -1 : (int) res[1];
    }

    private void helper(TreeNode root){
        if (root.left != null) helper(root.left);
        long num = (long) root.val;
        if (num < res[0]){
            res[1] = res[0];
            res[0] = num;
        }else if (num != res[0] && num < res[1]){
            res[1] = num;
        }
        if (root.right != null) helper(root.right);
    }
}
```

### 层次遍历

#### [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

简单

给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。

**示例 1：**

```
输入：
    3
   / \
  9  20
    /  \
   15   7
输出：[3, 14.5, 11]
解释：
第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。
```

**提示：**

- 节点值的范围在32位有符号整数范围内。

```java
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> res = new LinkedList<>();
        if (root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()){
            int size = queue.size();
            double sum = 0;
            for (int i = 0; i < size; i++){
                TreeNode node = queue.poll();
                sum += node.val;
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
            }
            res.add(sum / size);
        }
        return res;
    }
}
```

#### [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

中等

给定一个二叉树，在树的最后一行找到最左边的值。

**示例 1:**

```
输入:

    2
   / \
  1   3

输出:
1
```

**示例 2:**

```
输入:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

输出:
7
```

**注意:** 您可以假设树（即给定的根节点）不为 **NULL**。

```java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int res = root.val;
        while (!queue.isEmpty()){
            int size = queue.size();
            boolean updated = false;
            for (int i = 0; i < size; i++){
                TreeNode node = queue.poll();
                if (node.left != null) {
                    if (!updated){ //更新完给个标记
                        res = node.left.val;
                        updated = true;
                    }
                    queue.add(node.left);
                }
                if (node.right != null) {
                    if (!updated){
                        res = node.right.val;
                        updated = true;
                    }
                    queue.add(node.right);
                }
            }
        }
        return res;
    }
}
```

```java
class Solution { //从右往左遍历就完事了
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            root = queue.poll();
            if (root.right != null) queue.add(root.right);
            if (root.left != null) queue.add(root.left);
        }
        return root.val;
    }
}
```

### 前中后序遍历

#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

中等

给定一个二叉树，返回它的 *前序* 遍历。

 **示例:**

```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
```

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

```java
class Solution { //递归
    List<Integer> res = new LinkedList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root != null) helper(root);
        return res;
    }

    private void helper(TreeNode root){
        res.add(root.val);
        if (root.left != null) helper(root.left);
        if (root.right != null) helper(root.right);
    }
}
```

```java
class Solution { //迭代
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (root == null) return res;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            res.add(node.val);
            if (node.right != null) stack.push(node.right);
            if (node.left != null) stack.push(node.left);     
        }
        return res;
    }
}
```

#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

困难

给定一个二叉树，返回它的 *后序* 遍历。

**示例:**

```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
```

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (root == null) return res;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.peek();
            if (node.left == null && node.right == null){
                node = stack.pop();
                res.add(node.val);
                node = null;
                continue;
            }
            if (node.right != null) {
                stack.push(node.right);
                node.right = null;
            }
            if (node.left != null) {
                stack.push(node.left);
                node.left = null;
            }
        }
        return res;
    }
}
```

```java
//后序：左右中     前序先遍历右：中右左，再反过来
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node == null) continue;
        res.add(node.val);
        stack.push(node.left);
        stack.push(node.right);
    }
    Collections.reverse(res);
    return res;
}
```

#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

中等

给定一个二叉树，返回它的*中序* 遍历。

**示例:**

```
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
```

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) return res;
        Deque<TreeNode> stack = new ArrayDeque<>();
        while (!stack.isEmpty() || root != null){
            while (root != null){
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            res.add(root.val);
            root = root.right;
        }
        return res;
    }
}
```

### BST

#### [669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

简单

给定一个二叉搜索树，同时给定最小边界`L` 和最大边界 `R`。通过修剪二叉搜索树，使得所有节点的值在`[L, R]`中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

**示例 1:**

```
输入: 
    1
   / \
  0   2

  L = 1
  R = 2

输出: 
    1
      \
       2
```

**示例 2:**

```
输入: 
    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

输出: 
      3
     / 
   2   
  /
 1
```

```java
class Solution { //迭代，磨磨唧唧，0ms
    public TreeNode trimBST(TreeNode root, int L, int R) {
        if (root == null) return null;
        if (root.val < L) return trimBST(root.right, L, R);
        if (root.val > R) return trimBST(root.left, L, R);
        TreeNode p = root;
        while (p != null && p.left != null){
            if (p.left.val >= L){
                p = p.left;
            }else {
                TreeNode q = p;
                p = p.left;
                while (p != null && p.val < L){
                    p = p.right;
                }
                q.left = p;
            }
        }
        p = root;
        while (p != null && p.right != null){
            if (p.right.val <= R){
                p = p.right;
            }else {
                TreeNode q = p;
                p = p.right;
                while (p != null && p.val > R){
                    p = p.left;
                }
                q.right = p;
            }
        }
        return root;
    }
}
```

```java
class Solution { //递归
    public TreeNode trimBST(TreeNode root, int L, int R) {
        if (root == null) return null;
        if (root.val < L) return trimBST(root.right, L, R);
        if (root.val > R) return trimBST(root.left, L, R);
        TreeNode left = trimBST(root.left, L, R);
        TreeNode right = trimBST(root.right, L, R);
        root.left = left;
        root.right = right;
        return root;
    }
}
```

#### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

中等

给定一个二叉搜索树，编写一个函数 `kthSmallest` 来查找其中第 **k** 个最小的元素。

**说明：**
你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

**示例 1:**

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 1
```

**示例 2:**

```
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 3
```

**进阶：**
如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 `kthSmallest` 函数？

```java
class Solution {
    int res;
    int count = 0;
    int k;
    public int kthSmallest(TreeNode root, int k) {
        this.k = k;
        helper(root);
        return res;
    }

    private void helper(TreeNode root){
        if (root == null || count >= k) return;
        helper(root.left);
        count++;
        if (count == k) res = root.val;
        helper(root.right);
    }
}
```

#### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

简单

给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

**例如：**

```
输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13
```

**注意：**本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同

```java
class Solution {
    int a = 0;
    public TreeNode convertBST(TreeNode root) {
        if (root == null) return null;
        convertBST(root.right);
        a += root.val;
        root.val = a;
        convertBST(root.left);
        return root;
    }
}
```

#### [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

简单

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

![](https://img2020.cnblogs.com/blog/1205669/202008/1205669-20200802172242439-1753133294.png)


**示例 1:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

**示例 2:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (p.val < root.val && q.val < root.val) 
            return lowestCommonAncestor(root.left, p, q);
        else if (p.val > root.val && q.val > root.val) 
            return lowestCommonAncestor(root.right, p, q);
        else return root;
    }
}
```

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

中等

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

![](https://img2020.cnblogs.com/blog/1205669/202008/1205669-20200802172304936-559259589.png)


**示例 1:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

**示例 2:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉树中。

```java
class Solution { // 递归，2452ms
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (contain(root.left,p) && contain(root.left,q)) 
            return lowestCommonAncestor(root.left,p,q);
        if (contain(root.right,p) && contain(root.right,q))
            return lowestCommonAncestor(root.right,p,q);
        return root;
    }
    
    private boolean contain(TreeNode root, TreeNode p){
        if (root == null) return false;
        if (root.val == p.val) return true;
        return contain(root.left, p) || contain(root.right, p);
    }
}
```

```java
class Solution { // 8ms
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left == null) return right;
        if (right == null) return left;
        return root;
    }
}
```

#### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

简单

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1。

**示例:**

```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums.length == 0) return null;
        return helper(nums,0,nums.length-1);
    }

    private TreeNode helper(int[] nums, int low, int high){
        if (low > high) return null;
        int mid = low + (high - low) / 2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = helper(nums, low, mid-1);
        node.right = helper(nums, mid+1, high);
        return node;
    }
}
```

#### [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

中等

给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1。

**示例:**

```
给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

```java
class Solution { // 链表=>数组，变成上一题了，1ms
    public TreeNode sortedListToBST(ListNode head) {
        if (head == null) return null;
        int len = 0;
        ListNode p = head;
        while (p != null) {
            len++;
            p = p.next;
        }
        int[] nums = new int[len];
        int index = 0;
        while (head != null) {
            nums[index++] = head.val;
            head = head.next;
        }
        return helper(nums, 0, len-1);
    }

    private TreeNode helper(int[] nums, int low, int high){
        if (low > high) return null;
        int mid = low + (high - low) / 2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = helper(nums, low, mid-1);
        node.right = helper(nums, mid+1, high);
        return node;
    }
}
```

```java
class Solution { // 2ms，List没有array快
    public TreeNode sortedListToBST(ListNode head) {
        if (head == null) return null;
        List<Integer> list = new ArrayList<>();
        while (head != null) {
            list.add(head.val);
            head = head.next;
        }
        return helper(list, 0, list.size()-1);
    }

    private TreeNode helper(List<Integer> list, int low, int high){
        if (low > high) return null;
        int mid = low + (high - low) / 2;
        TreeNode node = new TreeNode(list.get(mid));
        node.left = helper(list, low, mid-1);
        node.right = helper(list, mid+1, high);
        return node;
    }
}
```

```java
class Solution { // 0ms
   public TreeNode sortedListToBST(ListNode head) {
        if (head == null) return null;
        return helper(head, null);
    }

    private TreeNode helper(ListNode head, ListNode tail) {
        if (head == tail) return null;
        // 快慢指针找中点
        ListNode slow = head;
        ListNode fast = head;
        while (fast != tail && fast.next != tail) {
            slow = slow.next;
            fast = fast.next.next;
        }
        TreeNode root = new TreeNode(slow.val);
        root.left = helper(head, slow);
        root.right = helper(slow.next, tail);
        return root;
    }
}
```

#### [653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

简单

给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。

**案例 1:**

```
输入: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

输出: True
```

**案例 2:**

```
输入: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 28

输出: False
```

```java
class Solution { // 3ms
    HashSet<Integer> set = new HashSet<>();
    public boolean findTarget(TreeNode root, int k) {
        if (root == null) return false;
        if (set.contains(root.val)) return true;
        set.add(k-root.val);
        return findTarget(root.left, k) || findTarget(root.right, k);
    }
}
```

#### [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

简单

给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

**示例：**

```
输入：

   1
    \
     3
    /
   2

输出：
1

解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
```

**提示：**

- 树中至少有 2 个节点。
- 本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同

```java
class Solution {
    int res = Integer.MAX_VALUE;
    int restore = -1;
    public int getMinimumDifference(TreeNode root) {
        if (root == null) return 0;
        if (root.left != null) getMinimumDifference(root.left);
        if (restore == -1) restore = root.val;
        else {
            res = Math.min(res, root.val - restore);
            restore = root.val;
        }   
        if (root.right != null) getMinimumDifference(root.right);
        return res;
    }
}
```

#### [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

简单

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树

例如：
给定 BST `[1,null,2,2]`,

```
   1
    \
     2
    /
   2
```

`返回[2]`.

**提示**：如果众数超过1个，不需考虑输出顺序

**进阶：**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

```java
class Solution { // 0ms
    List<Integer> res = new ArrayList<>();
    long restore = Long.MAX_VALUE;
    int count = 0;
    int maxCount = 0;
    public int[] findMode(TreeNode root) {
        if (root == null) return new int[]{};
        helper(root);
        if (count > maxCount){
            res.clear();
            res.add((int) restore);
        }else if (count == maxCount){
            res.add((int) restore);
        }
        int[] result = new int[res.size()];
        for (int i = 0; i < result.length; i++){
            result[i] = res.get(i);
        }
        return result;
    }
    
    private void helper(TreeNode root){
        if (root == null) return;
        helper(root.left);
        if (root.val != restore){
            if (count > maxCount){
                res.clear();
                res.add((int) restore);
                maxCount = count;
            }else if (count == maxCount){
                res.add((int) restore);
            }
            restore = (int) root.val;
            count = 1;
        }else {
            count++;
        }
        helper(root.right);
    }
}
```

### Trie

#### [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

中等

实现一个 Trie (前缀树)，包含 `insert`, `search`, 和 `startsWith` 这三个操作。

**示例:**

```
Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // 返回 true
trie.search("app");     // 返回 false
trie.startsWith("app"); // 返回 true
trie.insert("app");   
trie.search("app");     // 返回 true
```

**说明:**

- 你可以假设所有的输入都是由小写字母 `a-z` 构成的。
- 保证所有输入均为非空字符串。

```java
public class Trie {
    public class TrieNode{
        public int path;
        public int end;
        public HashMap<Character, TrieNode> next;

        public TrieNode(){
            path = 0;
            end = 0;
            next = new HashMap<>();
        }
    }

    private TrieNode root;
    public Trie(){
        root = new TrieNode();
    }

    public void insert(String word){
        if(word == null || word.equals(""))  return ;
        TrieNode node = root;
        for(int i = 0; i<word.length(); i++){
            char ch = word.charAt(i);
            if(!node.next.containsKey(ch)) {
                node.next.put(ch,new TrieNode());
            }
            node = node.next.get(ch);
            node.path++;
        }
        node.end++;
    }

    public boolean search(String word){
        if(word == null || word.equals("")) return false;
        TrieNode node = root;
        for(int i = 0; i<word.length(); i++){
            char ch = word.charAt(i);
            if(!node.next.containsKey(ch)) return false;
            node = node.next.get(ch);
        }
        if(node.end == 0) return false;
        return true;
    }
    public boolean startsWith(String word){
        if(word == null || word.equals("")) return false;
        TrieNode node = root;
        for(int i = 0; i<word.length(); i++){
            char ch = word.charAt(i);
            if(!node.next.containsKey(ch)) return false;
            node = node.next.get(ch);
        }
        return true;
    }
}
```
## 频率排序

333，426，199，834，124，536，449，663，863，297，889，543]]></description></item><item><title>LeetCode 链表</title><link>http://www.cnblogs.com/peng8098/archive/2020/08/01/leetcode09.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 01 Aug 2020 10:35:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/08/01/leetcode09.html</guid><description><![CDATA[## 基础部分

#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

简单

编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表**：**

![](https://img2020.cnblogs.com/blog/1205669/202008/1205669-20200801183333541-1693303077.png)


在节点 c1 开始相交。

**示例 1：**

![](https://img2020.cnblogs.com/blog/1205669/202008/1205669-20200801183400165-2137853023.png)


```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**

![](https://img2020.cnblogs.com/blog/1205669/202008/1205669-20200801183417578-1061226495.png)


```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

![](https://img2020.cnblogs.com/blog/1205669/202008/1205669-20200801183435075-1265452882.png)


```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```

**注意：**

- 如果两个链表没有交点，返回 `null`.
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(*n*) 时间复杂度，且仅用 O(*1*) 内存。

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) return null;
        ListNode p = headA, q = headB;
        int loop = 2;
        while (loop > 0){
            if (p == q) return q;
            p = p.next;
            q = q.next;
            if (p == null) {
                p = headB;
                loop--;
            }
            if (q == null) q = headA;
        }
        return null;
    }
}
```

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) return null;
        ListNode p = headA, q = headB;
        while (p != q){ //都是null，就第二圈都到头了，省了计算loop的时间
            p = p == null ? headB : p.next;
            q = q == null ? headA : q.next;
        }
        return p;
    }
}
```

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

简单

反转一个单链表。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**进阶:**
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode res = new ListNode(0);
        while (head != null){
            ListNode p = head;
            head = head.next;
            p.next = res.next;
            res.next = p; 
        }
        return res.next;
    }
}
```

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

简单

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例：**

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode res = new ListNode(0);
        ListNode cur = res;
        while (l1 != null && l2 != null){
            if (l1.val < l2.val){
                cur.next = l1;
                l1 = l1.next;
            }else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        while (l1 != null){
            cur.next = l1;
            cur = cur.next;
            l1 = l1.next;
        }
        while (l2 != null){
            cur.next = l2;
            cur = cur.next;
            l2 = l2.next;
        }
        return res.next;
    }
}
```

#### [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

简单

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

**示例 1:**

```
输入: 1->1->2
输出: 1->2
```

**示例 2:**

```
输入: 1->1->2->3->3
输出: 1->2->3
```

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) return head;
        ListNode cur = head;
        while (cur.next != null){
            if (cur.val == cur.next.val){
                cur.next = cur.next.next;
            }else {
                cur = cur.next;
            }
        }
        return head;
    }
}
```

#### [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

中等

给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```

**说明：**

给定的 *n* 保证是有效的。

**进阶：**

你能尝试使用一趟扫描实现吗？

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if (head == null) return null;
        ListNode first = head, second = head;
        while (n-- > 0) first = first.next;
        if (first == null) return head.next;
        while (first.next != null){
            first = first.next;
            second = second.next;
        }
        second.next = second.next.next;
        return head;
    }
}
```

#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

中等

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

**示例:**

```
给定 1->2->3->4, 你应该返回 2->1->4->3.
```

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode ans = new ListNode(0);
        ListNode pre = ans;
        pre.next = head;
        ListNode l, r;
        while (pre.next != null && pre.next.next != null){
            l = pre.next;
            r = l.next;
            l.next = r.next;
            pre.next = r;
            r.next = l;
            pre = l;
        }
        return ans.next;
    }
}
```

#### [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)

中等

给你两个 **非空** 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

**进阶：**

如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。

**示例：**

```
输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 8 -> 0 -> 7
```

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        StringBuilder a = new StringBuilder();
        StringBuilder b = new StringBuilder();
        ListNode cur1 = l1, cur2 = l2;
        while(cur1 != null){
            a.append(cur1.val);
            cur1 = cur1.next;
        }
        while(cur2 != null){
            b.append(cur2.val);
            cur2 = cur2.next;
        }
        StringBuilder sum = new StringBuilder();
        int la = a.length();
        int lb = b.length();
        int len = la > lb ? la : lb;
        int carry = 0;
        for (int i = 0; i < len; i++){
            carry += la-i-1 < 0 ? 0 : a.charAt(la-i-1)-'0';
            carry += lb-i-1 < 0 ? 0 : b.charAt(lb-i-1)-'0';
            sum.append(carry%10);
            carry /= 10;
        }
        if (carry > 0) sum.append(carry);
        sum.reverse();
        
        ListNode res = new ListNode(0);
        ListNode cur = res;
        for (char c : sum.toString().toCharArray()){
            ListNode node = new ListNode(c-'0');
            cur.next = node;
            cur = cur.next;
        }
        return res.next;
    }
}
```

#### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

简单

请判断一个链表是否为回文链表。

**示例 1:**

```
输入: 1->2
输出: false
```

**示例 2:**

```
输入: 1->2->2->1
输出: true
```

**进阶：**
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        List<Integer> list = new ArrayList<>();
        while (head != null){
            list.add(head.val);
            head = head.next;
        }
        int len = list.size();
        for (int i = 0; i < len/2; i++){
            if (list.get(i).intValue() != list.get(len-i-1).intValue()) {
                //list里是对象，不是基本数据类型，不能直接用==判断
                //也可以写成：!Objects.equals(list.get(i), list.get(len-i-1))
                return false;
            }
        }
        return true;
    }
}
```

#### [725. 分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts/)

中等

给定一个头结点为 `root` 的链表, 编写一个函数以将链表分隔为 `k` 个连续的部分。

每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。

这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。

返回一个符合上述规则的链表的列表。

举例： 1->2->3->4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]

**示例 1：**

```
输入: 
root = [1, 2, 3], k = 5
输出: [[1],[2],[3],[],[]]
解释:
输入输出各部分都应该是链表，而不是数组。
例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。
第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。
最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。
```

**示例 2：**

```
输入: 
root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
解释:
输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。
```

**提示:**

- `root` 的长度范围： `[0, 1000]`.
- 输入的每个节点的大小范围：`[0, 999]`.
- `k` 的取值范围： `[1, 50]`.

```java
class Solution {
    public ListNode[] splitListToParts(ListNode root, int k) {
        ListNode cur = root;
        int N = 0; //统计数量
        while (cur != null) {
            cur = cur.next;
            N++;
        }
        int width = N / k;
        int rem = N % k; //前面链表长度多一个的数量

        ListNode[] ans = new ListNode[k];
        cur = root;
        for (int i = 0; i < k; ++i) {
            ListNode head = new ListNode(0), write = head;
            for (int j = 0; j < width + (i < rem ? 1 : 0); ++j) {
                write.next = new ListNode(cur.val);
                write = write.next;
                if (cur != null) cur = cur.next;
            }
            ans[i] = head.next;
        }
        return ans;
    }
}
```

#### [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

中等

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

**示例 1:**

```
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
```

**示例 2:**

```
输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
```

**说明:**

- 应当保持奇数节点和偶数节点的相对顺序。
- 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。

```java
class Solution {
    public ListNode oddEvenList(ListNode head) {
        ListNode odd = new ListNode(0);
        ListNode p = odd;
        ListNode even = new ListNode(0);
        ListNode q = even;
        while (head != null){
            p.next = head;
            head = head.next;
            p = p.next;
            p.next = null;
            if (head == null) break;
            q.next = head;
            head = head.next;
            q = q.next;
            q.next = null;
        }
        p.next = even.next;
        return odd.next;
    }
}
```

## 频率排序

92，426，2，25，143，23，148，379]]></description></item><item><title>LeetCode 数学</title><link>http://www.cnblogs.com/peng8098/archive/2020/08/01/leetcode08.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 01 Aug 2020 06:58:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/08/01/leetcode08.html</guid><description><![CDATA[## 基础部分

#### [204. 计数质数](https://leetcode-cn.com/problems/count-primes/)

简单

统计所有小于非负整数 *n* 的质数的数量。

**示例:**

```
输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```

```java
class Solution {
    public int countPrimes(int n) {
        if (n < 2) return 0;
        boolean[] dp = new boolean[n];
        int res = 0;
        for (int i = 2; i < n; i++)
            if (!dp[i]) {
                res++;
                for (int j = 2; i*j < n; j++){
                    dp[i*j] = true;
                }
            }
        return res;
    }
}
```

#### [504. 七进制数](https://leetcode-cn.com/problems/base-7/)

简单

给定一个整数，将其转化为7进制，并以字符串形式输出。

**示例 1:**

```
输入: 100
输出: "202"
```

**示例 2:**

```
输入: -7
输出: "-10"
```

**注意:** 输入范围是 [-1e7, 1e7] 。

```java
class Solution {
    public String convertToBase7(int num) {
        if (num == 0) return "0";
        String sign = "";
        if (num < 0){
            num = - num;
            sign += "-";
        }
        StringBuilder ans = new StringBuilder();
        while (num > 0){
            int add = num % 7;
            ans.append(add);
            num /= 7;
        }
        return sign + String.valueOf(ans.reverse());
    }
}
```

#### [405. 数字转换为十六进制数](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/)

简单

给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 [补码运算](https://baike.baidu.com/item/补码/6854613?fr=aladdin) 方法。

**注意:**

1. 十六进制中所有字母(`a-f`)都必须是小写。
2. 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符`'0'`来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
3. 给定的数确保在32位有符号整数范围内。
4. **不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。**

**示例 1：**

```
输入:
26

输出:
"1a"
```

**示例 2：**

```
输入:
-1

输出:
"ffffffff"
```

```java
class Solution {
    public String toHex(int num) {
        char[] digits = new char[16]; //字典
        for (int i = 0; i < 10; i++)
            digits[i] = (char) (i + (int)'0') ;
        for (int i = 10; i < 16; i++)
            digits[i] = (char) (i - 10 + (int)'a');
        int a = 15;
        StringBuilder sb = new StringBuilder();
        while (num != 0){
            int add = num & a;
            num = num >>> 4;
            sb.append(digits[add]);
        }
        return sb.length()==0 ? "0" : sb.reverse().toString();
    }
}
```

#### [168. Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)

简单

给定一个正整数，返回它在 Excel 表中相对应的列名称。

例如，

```
    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
    ...
```

**示例 1:**

```
输入: 1
输出: "A"
```

**示例 2:**

```
输入: 28
输出: "AB"
```

**示例 3:**

```
输入: 701
输出: "ZY"
```

```java
class Solution {
    public String convertToTitle(int n) {
        char[] letters = new char[26];
        for (int i = 0; i < 26; i++)
            letters[i] = (char)(i+(int)'A');
        StringBuilder res = new StringBuilder();
        while (n != 0){
            n--; //※※※，从1开始算的，而不是从0开始，所以要减1
            int add = (n) % 26;
            n = n / 26;
            res.append(letters[add]);
        }
        return res.reverse().toString();
    }
}
```

#### [172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

简单

给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

**示例 1:**

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```

**示例 2:**

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

```java
class Solution {
    public int trailingZeroes(int n) {
        int res = 0;
        while (n != 0){
            n /= 5; //每乘一个5加一个量级
            res += n;
        }
        return res;
    }
}
```

#### [67. 二进制求和](https://leetcode-cn.com/problems/add-binary/)

简单

给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 **非空** 字符串且只包含数字 `1` 和 `0`。

**示例 1:**

```
输入: a = "11", b = "1"
输出: "100"
```

**示例 2:**

```
输入: a = "1010", b = "1011"
输出: "10101"
```

**提示：**

- 每个字符串仅由字符 `'0'` 或 `'1'` 组成。
- `1 <= a.length, b.length <= 10^4`
- 字符串如果不是 `"0"` ，就都不含前导零。

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder res = new StringBuilder();
        int la = a.length();
        int lb = b.length();
        int len = Math.max(la,lb), carry = 0;
        for (int i = 0; i < len; i++){
            carry += la-1-i < 0 ? 0 : (int)a.charAt(la-1-i)-'0';
            carry += lb-1-i < 0 ? 0 : (int)b.charAt(lb-1-i)-'0';
            res.append(carry%2);
            carry /= 2;
        }
        if (carry == 1) res.append(carry);
        return res.reverse().toString();
    }
}
```

```java
//自带函数
return Integer.toBinaryString(Integer.parseInt(a, 2) + Integer.parseInt(b, 2));
```

#### [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)

简单

给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和。

**注意：**

1. `num1` 和`num2` 的长度都小于 5100.
2. `num1` 和`num2` 都只包含数字 `0-9`.
3. `num1` 和`num2` 都不包含任何前导零。
4. **你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。**

```java
class Solution {
    public String addStrings(String num1, String num2) {
        int la = num1.length(), lb = num2.length();
        int len = la > lb ? la : lb, carry = 0;
        StringBuilder res = new StringBuilder();
        for (int i = 0; i < len; i++){
            carry += la-1-i < 0 ? 0 : (int)num1.charAt(la-1-i) - '0';
            carry += lb-1-i < 0 ? 0 : (int)num2.charAt(lb-1-i) - '0';
            res.append(carry%10);
            carry /= 10;
        }
        if (carry > 0) res.append(carry);
        return res.reverse().toString();
    }
}
```

#### [462. 最少移动次数使数组元素相等 II](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/)

中等

给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。

**例如:**

```
输入:
[1,2,3]

输出:
2

说明：
只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： 

[1,2,3]  =>  [2,2,3]  =>  [2,2,2]
```

```java
class Solution { //全排序，4ms
    public int minMoves2(int[] nums) {
        Arrays.sort(nums); //可以减治，找中位数，懒得写了
        int res = 0;
        int mid = nums[nums.length/2];
        for (int num : nums){
            res += Math.abs(mid-num);
        }
        return res;
    }
}
```

```java
class Solution { //快排，更慢了，73ms
    public int minMoves2(int[] nums) {
        if (nums.length < 2) return 0;
        int res = 0;
        int mid = helper(nums,0,nums.length-1,nums.length/2);
        for (int num : nums)
            res += Math.abs(mid-num);
        return res;
    }

    private int helper(int[] nums, int l, int r, int correct){
        if (l == r) return nums[r];
        int first = nums[l];
        int i = l;
        int j = r + 1;
        while (i < j){
            do{
                i++;
            }while (i < r && nums[i] < first);
            do{
                j--;
            }while (l < j && nums[j] > first);
            if (i >= j) break;
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
        int tmp = nums[l];
        nums[l] = nums[j];
        nums[j] = tmp;
        if (j == correct) return nums[j];
        else if (j < correct) return helper(nums, j+1, r, correct);
        else return helper(nums, l, j-1, correct);
    }
}
```

#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

简单

给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数**大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1:**

```
输入: [3,2,3]
输出: 3
```

**示例 2:**

```
输入: [2,2,1,1,1,2,2]
输出: 2
```

```java
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length/2];
    }
}
```

```java
class Solution {
    public int majorityElement(int[] nums) {
        int count = 1, cur = nums[0];
        for (int i = 1; i < nums.length; i++){
            if (cur == nums[i]) count++;
            else if (count > 0) count--;
            else {
                cur = nums[i];
                count = 1;
            }
        }
        return cur;
    }
}
```

#### [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

简单

给定一个正整数 *num*，编写一个函数，如果 *num* 是一个完全平方数，则返回 True，否则返回 False。

**说明：**不要使用任何内置的库函数，如 `sqrt`。

**示例 1：**

```
输入：16
输出：True
```

**示例 2：**

```
输入：14
输出：False
```

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        long a = 0;
        for (int i = 1; i < num+1; i++){
            a = i * i;
            if (a >= num) break;
        }
        return a == num;
    }
}
```

#### [326. 3的幂](https://leetcode-cn.com/problems/power-of-three/)

简单

给定一个整数，写一个函数来判断它是否是 3 的幂次方。

**示例 1:**

```
输入: 27
输出: true
```

**示例 2:**

```
输入: 0
输出: false
```

**示例 3:**

```
输入: 9
输出: true
```

**示例 4:**

```
输入: 45
输出: false
```

**进阶：**
你能不使用循环或者递归来完成本题吗？

```java
class Solution {
    public boolean isPowerOfThree(int n) {
        while (n > 1) {
            if (n%3 != 0) break;
            n /= 3;
        }
        return n == 1;
    }
}
```

#### [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

中等

给你一个长度为 *n* 的整数数组 `nums`，其中 *n* > 1，返回输出数组 `output` ，其中 `output[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

**示例:**

```
输入: [1,2,3,4]
输出: [24,12,8,6]
```

**提示：**题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。

**说明:** 请**不要使用除法，**且在 O(*n*) 时间复杂度内完成此题。

**进阶：**
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组**不被视为**额外空间。）

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int len = nums.length;
        int[] l = new int[len];
        int[] r = new int[len];
        l[0] = 1;
        for (int i = 1; i < len; i++) l[i] = l[i-1] * nums[i-1];
        r[len-1] = 1;
        for (int i = len-2; i >= 0; i--) r[i] = r[i+1] * nums[i+1];
        for (int i = 0; i < len; i++) l[i] *= r[i];
        return l;
    }
}
```

#### [628. 三个数的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-three-numbers/)

简单

给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。

**示例 1:**

```
输入: [1,2,3]
输出: 6
```

**示例 2:**

```
输入: [1,2,3,4]
输出: 24
```

**注意:**

1. 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。
2. 输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。

```java
class Solution {
    public int maximumProduct(int[] nums) {
        Arrays.sort(nums);
        int len = nums.length;
        int a = nums[len-1] * nums[len-2] * nums[len-3];
        int b = nums[0] * nums[1] * nums[len-1];
        return a > b ? a : b;
    }
}
```

## 频率排序

892，829，887，233，869，805，458，2，1121，423，483，469，149，365，640，535，782，1012，754，885，7，593，9，753，400]]></description></item><item><title>LeetCode 动态规划</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/31/leetcode07.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 31 Jul 2020 09:14:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/31/leetcode07.html</guid><description><![CDATA[## 基础部分

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

简单

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

````java
class Solution {
    public int climbStairs(int n) {
        if (n < 4)  return n;
        int[] res = new int[n];
        res[0] = 1;
        res[1] = 2;
        for (int i = 2; i < n; i++)
            res[i] = res[i-1] + res[i-2];
        return res[n-1];
    }
}
````

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

简单

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

```java
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 0) return 0;
        if (len == 1) return nums[0];
        int[] arr = new int[len];
        arr[0] = nums[0];
        arr[1] = Math.max(arr[0],nums[1]);
        for (int i = 2; i < len; i++) {
            if (arr[i-2] + nums[i] > arr[i-1]){
                arr[i] = arr[i-2] + nums[i];
            }else {
                arr[i] = arr[i-1];
            }
        }
        return Math.max(arr[len-1],arr[len-2]);
    }
}
```

#### [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

中等

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈，**这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你**在不触动警报装置的情况下，**能够偷窃到的最高金额。

**示例 1:**

```
输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2:**

```
输入: [1,2,3,1]
输出: 4
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

```java
class Solution { //正反各偷一遍，取最大值
    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 0) return 0;
        if (len == 1) return nums[0];
        if (len == 2) return Math.max(nums[0],nums[1]);
        int a = helper(nums);
        int tmp;
        for (int i = 0; i < len/2; i++) {
            tmp = nums[i];
            nums[i] = nums[len-i-1];
            nums[len-i-1] = tmp;
        }
        int b = helper(nums);
        return a > b ? a : b;
    }
    public int helper(int[] nums) {
        int len = nums.length;
        int[] arr = new int[len];
        boolean[] robed = new boolean[len];
        arr[0] = nums[0];
        robed[0] = true;
        if (nums[0] > nums[1]){
            arr[1] = nums[0];
        }else {
            arr[1] = nums[1];
            robed[0] = false;
            robed[1] = true;
        }
        for (int i = 2; i < len-1; i++) {
            if (arr[i-2] + nums[i] > arr[i-1]){
                robed[i-2] = true;
                robed[i-1] = false;
                robed[i] = true;
                arr[i] = arr[i-2] + nums[i];
            }else {
                arr[i] = arr[i-1];
            }
        }
        int ans = Math.max(arr[len-2],arr[len-3]);
        if (!robed[0] && !robed[len-2])
            ans += nums[len-1];
        return ans;
    }
}
```

#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

中等

给定一个包含非负整数的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例:**

```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];
        for (int i = 1; i < m; i++)
            dp[i][0] = dp[i-1][0] + grid[i][0];
        for (int i = 1; i < n; i++)
            dp[0][i] = dp[0][i-1] + grid[0][i];
        for (int i = 1; i < m; i++)
            for (int j = 1; j < n; j++)
                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j],dp[i][j-1]);
        return dp[m-1][n-1];
    }
}
```

#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

中等

一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200731171359512-2000179220.png)


例如，上图是一个7 x 3 的网格。有多少可能的路径？

**示例 1:**

```
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

**示例 2:**

```
输入: m = 7, n = 3
输出: 28
```

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 10 ^ 9`

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int i = 1; i < n; i++) dp[0][i] = 1;
        for (int i = 1; i < m; i++)
            for (int j = 1; j < n; j++)
                dp[i][j] = dp[i-1][j]+ dp[i][j-1];
        return dp[m-1][n-1];
    }
}
```

#### [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

简单

给定一个整数数组  *nums*，求出数组从索引 *i* 到 *j* (*i* ≤ *j*) 范围内元素的总和，包含 *i, j* 两点。

**示例：**

```
给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
```

**说明:**

1. 你可以假设数组不可变。
2. 会多次调用 *sumRange* 方法。

```java
class NumArray {
    int len;
    int[] nums;

    public NumArray(int[] nums) {
        this.nums = nums;
        len = nums.length;
    }

    public int sumRange(int i, int j) {
        int[] dp = new int[j-i+1];
        dp[0] = nums[i];
        for (int index = 1; index < dp.length; index++)
            dp[index] += dp[index-1] + nums[index+i];
        return dp[dp.length-1];
    }
}
```

#### [413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)

中等

如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。

例如，以下数列为等差数列:

```
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
```

以下数列不是等差数列。

```
1, 1, 2, 5, 7
```

数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。

如果满足以下条件，则称子数组(P, Q)为等差数组：

元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q 。

函数要返回数组 A 中所有为等差数组的子数组个数。

**示例:**

```
A = [1, 2, 3, 4]

返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。
```

```java
class Solution { //子数组的元素是连续的，那也太简单了
    public int numberOfArithmeticSlices(int[] A) {
        int len = A.length;
        int[] dp = new int[len];
        int res = 0;
        for (int i = 2; i < len; i++) {
            if (A[i]+A[i-2] == A[i-1]+A[i-1]){
                dp[i] = dp[i-1] + 1;
                res += dp[i];
            }
        }
        return res;
    }
}
```

#### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

中等

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

**示例 1:**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

**说明:** 你可以假设 *n* 不小于 2 且不大于 58。

```java
class Solution { //强行dp
    public int integerBreak(int n) {
        int[] dp = new int[n+5];
        dp[2] = 1;
        dp[3] = 2;
        dp[4] = 4;
        dp[5] = 6;
        dp[6] = 9;
        for (int i = 7; i < n+1; i++) {
            dp[i] = dp[i-3] * 3;
        }
        return dp[n];
    }
}
```

#### [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

中等

给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。

**示例 1:**

```
输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
```

**示例 2:**

```
输入: n = 13
输出: 2
解释: 13 = 4 + 9.
```

```java
class Solution { //麻烦了，垃圾
    public int numSquares(int n) {
        int[] dp = new int[n+1];
        for (int i = 1; i < n + 1; i++) {
            int a = (int) Math.sqrt(i);
            if (a*a == i) {
                dp[i] = 1;
            } else {
                int fill = Integer.MAX_VALUE;
                for (int l = 1,r = i-1;l <= r;l++,r--){ //双指针找最小
                    if (dp[l]+dp[r] < fill){
                        fill = dp[l]+dp[r];
                        if (fill == 2) break;
                    }
                }
                dp[i] = fill;
            }
        }
        return dp[n];
    }
}
```

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1]; // 默认初始化值都为0
        for (int i = 1; i <= n; i++) {
            dp[i] = i; // 最坏的情况就是每次+1
            for (int j = 1; i - j * j >= 0; j++) {
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程
            }
        }
        return dp[n];
    }
}
```

#### [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

中等

一条包含字母 `A-Z` 的消息通过以下方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

给定一个只包含数字的**非空**字符串，请计算解码方法的总数。

**示例 1:**

```
输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2:**

```
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

```java
class Solution {
    public int numDecodings(String s) {
        char[] chars = s.toCharArray();
        int len = chars.length;
        if (len == 0 || s.charAt(0)=='0') return 0;
        int[] nums = new int[len];
        for (int i = 0; i < len; i++) nums[i] = chars[i] - '0';
        for (int i = 1; i < len; i++)
            if (nums[i] == 0 && (nums[i-1] == 0 || nums[i-1] > 2)) return 0;
        int[] dp = new int[len+1];
        dp[0] = 1;
        int n1 = 0, n2 = 1, n3 = 1;
        for (int i = 1; i < len; i++) {
            int num = nums[i-1]*10+nums[i];
            if (nums[i] == 0){
                dp[i-1] = 1;
                dp[i] = 1;
                dp[i+1] = 1;
                i++;
                n1 = 0;
                n2 = 1;
                n3 = 1;
            }else if (num > 0 && num < 27){
                n1 = n2;
                n2 = n3;
                n3 = n1 + n2;
                dp[i] = n3;
            }else {
                n1 = 0;
                n2 = 1;
                n3 = 1;
                dp[i] = 1;
            }
        }
        int res = 1;
        for (int i = 1; i < len; i++)
            if (dp[i] >= dp[i+1]) res *= dp[i];
        return res;
    }
}
```

#### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

中等

给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

**说明:**

- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
- 你算法的时间复杂度应该为 O(*n2*) 。

**进阶:** 你能将算法的时间复杂度降低到 O(*n* log *n*) 吗?

```java
class Solution { //O(n^2)
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len < 2) return len;
        int[] dp = new int[len];
        int res = 1;
        dp[0] = 1;
        for (int i = 1; i < len; i++) {
            int fill = 1;
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i])
                    fill = Math.max(fill,dp[j]+1);
            }
            dp[i] = fill;
            res = Math.max(res,fill);
        }
        return res;
    }
}
```

#### [646. 最长数对链](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/)

中等

给出 `n` 个数对。 在每一个数对中，第一个数字总是比第二个数字小。

现在，我们定义一种跟随关系，当且仅当 `b < c` 时，数对`(c, d)` 才可以跟在 `(a, b)` 后面。我们用这种形式来构造一个数对链。

给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。

**示例 :**

```
输入: [[1,2], [2,3], [3,4]]
输出: 2
解释: 最长的数对链是 [1,2] -> [3,4]
```

**注意：**

1. 给出数对的个数在 [1, 1000] 范围内。

```java
class Solution {
    public int findLongestChain(int[][] pairs) {
        Arrays.sort(pairs,(a,b)->(a[0]-b[0]));
        int[] dp = new int[pairs.length];
        dp[0] = 1;
        int res = 1;
        for (int i = 1; i < dp.length; i++) {
            int fill = 1;
            for (int j = 0; j < i; j++) {
                if (pairs[j][1] < pairs[i][0]){
                    fill = Math.max(fill,dp[j]+1);
                }
            }
            dp[i] = fill;
            if (fill > res) res = fill;
        }
        return res;
    }
}
```

#### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

中等

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

**示例 1:**

```
输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。
```

**示例 2:**

```
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
```

**示例 3:**

```
输入: [1,2,3,4,5,6,7,8,9]
输出: 2
```

**进阶:**
你能否用 O(*n*) 时间复杂度完成此题?

```java
class Solution { //真丶O(n)
    public int wiggleMaxLength(int[] nums) {
        
        if (nums.length < 2) return nums.length;

        //去掉前面重复的数字
        int cur = 0;
        while (nums[cur] == nums[cur+1] && cur < nums.length-2) cur++;
        int[] arr = new int[nums.length-cur];
        int len = arr.length;
        System.arraycopy(nums, cur, arr, 0, len);
        
        if (len < 2) return len;
        
        int[] dp = new int[len];
        int max = 0, min = 0; //存峰/谷的index
        dp[0] = 1;
        boolean toFindBig = arr[1] > arr[0];
        for (int i = 1; i < len; i++) {
            if (toFindBig){ //找更大的
                if (arr[i] > arr[min]){ //比谷底大，找到了更大的
                    dp[i] = dp[min] + 1;
                    max = i; //更新峰顶
                    toFindBig = false; //找完大的，该找小的了
                }else {
                    dp[i] = dp[min]; //没找到，谷底降低
                    min = i;
                }
            }else { //找更小的
                if (arr[i] < arr[max]){
                    dp[i] = dp[max] + 1;
                    toFindBig = true;
                    min = i;
                }else {
                    dp[i] = dp[max];
                    max = i;
                }
            }
        }
        return dp[len-1];
    }
}
```

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

中等

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

一个字符串的 *子序列* 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

**示例 1:**

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。
```

**示例 2:**

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。
```

**示例 3:**

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。
```

**提示:**

- `1 <= text1.length <= 1000`
- `1 <= text2.length <= 1000`
- 输入的字符串只含有小写英文字符。

```java
class Solution { //递归，超时了
    public int longestCommonSubsequence(String text1, String text2) {
        int l1 = text1.length();
        int l2 = text2.length();
        if (l1 == 0 || l2 == 0) return 0;
        if (text1.charAt(l1-1) == text2.charAt(l2-1)){
            return longestCommonSubsequence(text1.substring(0,l1-1), text2.substring(0,l2-1)) + 1;
        }else {
            int a = longestCommonSubsequence(text1, text2.substring(0,l2-1));
            int b = longestCommonSubsequence(text1.substring(0,l1-1), text2);
            return a > b ? a : b;
        }
    }
}
```

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        char[] chars1 = text1.toCharArray();
        char[] chars2 = text2.toCharArray();
        int l1 = chars1.length;
        int l2 = chars2.length;
        int[][] dp = new int[l1+1][l2+1]; //加半圈0，省着处理越界，很麻烦
        for (int i = 1; i < l1+1; i++) {
            for (int j = 1; j < l2+1; j++) {
                if (chars1[i-1] == chars2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else {
                    dp[i][j] = max3(dp[i-1][j-1],dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[l1][l2];
    }

    private int max3(int i, int i1, int i2) {
        int ans = i;
        if (i1 > ans) ans = i1;
        if (i2 > ans) ans = i2;
        return ans;
    }
}
```

#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

中等

给定一个**只包含正整数**的**非空**数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**注意:**

1. 每个数组中的元素不会超过 100
2. 数组的大小不会超过 200

**示例 1:**

```
输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
```

**示例 2:**

```
输入: [1, 2, 3, 5]

输出: false

解释: 数组不能分割成两个元素和相等的子集.
```

```java
class Solution { //回溯法，1ms
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) sum += num;
        if (sum % 2 == 1) return false;
        sum /= 2;
        return helper(nums,sum,0);
    }

    private boolean helper(int[] nums, int target, int index){
        if (target == 0) return true;
        if (index == nums.length || target < 0) return false;
        if (helper(nums, target-nums[index], index+1))
            return true; //有一种成了就返回true
        int j = index + 1;
        while (j < nums.length && nums[index] == nums[j]) j++;
        return helper(nums , target, j); //换个开头
    }
}
```

```java
class Solution { //DP，13ms
    boolean result = false;
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) sum += num;
        if (sum % 2 == 1) return false;
        sum /= 2;
        boolean[] dp = new boolean[sum+1];
        dp[0] = true;
        for (int num : nums){
            for (int i = sum; i > 0; i--){
                if (i >= num){
                    dp[i] = dp[i] || dp[i-num];
                }
            }
            if (dp[sum]) return true;
        }
        return false;
    }
}
```

#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

中等

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 `+` 和 `-`。对于数组中的任意一个整数，你都可以从 `+` 或 `-`中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

**示例：**

```
输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
解释：

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
```

**提示：**

- 数组非空，且长度不会超过 20 。
- 初始的数组的和不会超过 1000 。
- 保证返回的最终结果能被 32 位整数存下。

```java
class Solution { //回溯法，573ms
    int res = 0;
    public int findTargetSumWays(int[] nums, int S) {
        helper(nums,0,S);
        return res;
    }

    private void helper(int[] nums, int index, int target){
        if (index == nums.length){
            if (target == 0) res++;
            return;
        }
        helper(nums, index+1, target+nums[index]);
        helper(nums, index+1, target-nums[index]);
    }
}
```

```java
class Solution { //DP，13ms
    public int findTargetSumWays(int[] nums, int S) {
        int sum = 0;
        for (int num : nums) sum += num;
        if (sum < S) return 0;
        int[][] dp = new int[nums.length][sum * 2 + 1];
        for (int i = 0; i < sum*2+1; i++){
            if (nums[0] == i-sum || -nums[0] == i-sum){
                dp[0][i] = 1;
            }
        }
        for (int i = 1; i < nums.length; i++){
            for (int j = 0; j < dp[0].length; j++){
                int a = j-nums[i] >= 0 ? dp[i-1][j-nums[i]] : 0;
                int b = j+nums[i] < dp[0].length ? dp[i-1][j+nums[i]] : 0;
                dp[i][j] = a + b;
            }
        }
        int k = nums[0] == 0 ? 2 : 1; //第一位是0，+-两种情况，少算一半
        return dp[nums.length-1][S + sum] * k;
    }
}
```

#### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

中等

在计算机界中，我们总是追求用有限的资源获取最大的收益。

现在，假设你分别支配着 **m** 个 `0` 和 **n** 个 `1`。另外，还有一个仅包含 `0` 和 `1` 字符串的数组。

你的任务是使用给定的 **m** 个 `0` 和 **n** 个 `1` ，找到能拼出存在于数组中的字符串的最大数量。每个 `0` 和 `1` 至多被使用**一次**。

**注意:**

1. 给定 `0` 和 `1` 的数量都不会超过 `100`。
2. 给定字符串数组的长度不会超过 `600`。

**示例 1:**

```
输入: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
输出: 4

解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 "10","0001","1","0" 。
```

**示例 2:**

```
输入: Array = {"10", "0", "1"}, m = 1, n = 1
输出: 2

解释: 你可以拼出 "10"，但之后就没有剩余数字了。更好的选择是拼出 "0" 和 "1" 。
```

```java
class Solution { //回溯法，超时了
    private int res = 0;
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] arr01 = generate(strs);
        helper(arr01,0,m,n,0);
        return res;
    }

    private void helper(int[][] arr01, int index, int m, int n, int count) {
        boolean no = m < 0 || n < 0;
        if (no || index >= arr01.length){
            if (no) count--;
            if (count > res) res = count;
            return;
        }
        helper(arr01,index+1,m-arr01[index][0],n-arr01[index][1],count+1);
        int j = index+1;
        while (j < arr01.length && arr01[j][0] == arr01[index][0] && arr01[j][1] == arr01[index][1]) j++;
        helper(arr01,index+1,m,n,count);
    }

    private int[][] generate(String[] strs) {
        int len = strs.length;
        int[][] arr01 = new int[len][2];
        for (int i = 0; i < len; i++) {
            arr01[i] = strTo01(strs[i]);
        }
        return arr01;
    }

    private int[] strTo01(String str) {
        int zero = 0;
        int one = 0;
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '0') zero++;
            else one++;
        }
        return new int[]{zero,one};
    }
}
```

```java
class Solution { //DP，38ms
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m+1][n+1];
        for (String str : strs){
            int x = 0;
            int y = 0;
            for (int i = 0; i < str.length(); i++) {
                if (str.charAt(i) == '0') x++;
                else y++;
            }
            for (int i = m; i >= x; i--){ //倒着来
                for (int j = n; j >= y; j--){
                    dp[i][j] = Math.max(dp[i-x][j-y]+1,dp[i][j]);
                }
            }
        }
        return dp[m][n];
    }
}
```

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

中等

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

**示例 1:**

```
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```

**示例 2:**

```
输入: coins = [2], amount = 3
输出: -1
```

**说明**:
你可以认为每种硬币的数量是无限的。

```java
public class Solution { //抄了答案
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1); //记住这个函数
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) { //想起 丑数 那道题
                if (i - coin >= 0 && dp[i - coin] != amount + 1) {
                    //后面布尔的意思：前面那个都不能表示，更别说这个了
                    dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
                }
            }
        }
        return dp[amount] == amount + 1 ? -1 : dp[amount];
    }
}
```

#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

中等

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

**示例 1:**

```
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**示例 2:**

```
输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。
```

**示例 3:**

```
输入: amount = 10, coins = [10] 
输出: 1
```

**注意**:

你可以假设：

- 0 <= amount (总金额) <= 5000
- 1 <= coin (硬币面额) <= 5000
- 硬币种类不超过 500 种
- 结果符合 32 位符号整数

```java
class Solution { //超时的回溯法
    Set<List<Integer>> set = new HashSet<>();
    List<Integer> list = new ArrayList<>();
    public int change(int amount, int[] coins) {
        helper(amount,coins);
        return set.size();
    }

    private void helper(int amount, int[] coins){
        if (amount == 0) set.add(sort(list));
        if (amount <= 0) return;
        for (int num : coins) {
            list.add(num);
            helper(amount - num, coins);
            list.remove(list.size()-1);
        }
    }

    private List<Integer> sort(List<Integer> list) {
        List<Integer> ans = new ArrayList<>(list);
        Collections.sort(ans);
        return ans;
    }
}
```

```java
class Solution { //DP
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount+1];
        dp[0] = 1;
        for (int coin : coins){
            for (int i = 1; i < amount+1; i++){
                if (i >= coin) dp[i] += dp[i-coin];
            }
        }
        return dp[amount];
    }
}
```

#### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

中等

给定一个**非空**字符串 *s* 和一个包含**非空**单词列表的字典 *wordDict*，判定 *s* 是否可以被空格拆分为一个或多个在字典中出现的单词。

**说明：**

- 拆分时可以重复使用字典中的单词。
- 你可以假设字典中没有重复的单词。

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

```java
class Solution { //10ms
    public boolean wordBreak(String s, List<String> wordDict) {
        int len = s.length();
        boolean[] dp = new boolean[len+1];
        Set<String> set = new HashSet<>(wordDict);
        dp[0] = true;
        for (int l = 0; l < len; l++)
            for (int r = l+1; r <= len; r++)
                if (dp[l] && set.contains(s.substring(l,r)))
                    dp[r] = true;
        return dp[len];
    }
}
```

```java
class Solution { //5ms
    public boolean wordBreak(String s, List<String> wordDict) {
        int len = s.length();
        boolean[] dp = new boolean[len+1];
        dp[0] = true;
        for (int l = 0; l < len; l++){
            if (!dp[l]) continue;
            for (String word : wordDict){
                int r = l + word.length();
                if (r <= len && s.substring(l,r).equals(word)){
                    dp[r] = true;
                }
            }
        } 
        return dp[len];
    }
}
```

#### [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

中等

给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

**示例:**

```
nums = [1, 2, 3]
target = 4

所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。
```

**进阶：**
如果给定的数组中含有负数会怎么样？
问题会产生什么变化？
我们需要在题目中添加什么限制来允许负数的出现？

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int n = nums.length;
        int[] dp = new int[target+1];
        dp[0] = 1;
        for (int i = 1; i < target+1; i++){
            for (int num : nums){
                if (i >= num){
                    dp[i] += dp[i-num];
                }
            }
        }
        return dp[target];
    }
}
```

#### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

中等

给定一个整数数组，其中第 *i* 个元素代表了第 *i* 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**示例:**

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n < 2) return 0;
        int[][] dp = new int[n][2];
        dp[0][1] = - prices[0];
        for (int i = 1; i < n; i++){
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], (i >= 2 ? dp[i-2][0] : 0) - prices[i]);
        }
        return Math.max(dp[n-1][0],dp[n-1][1]);
    }
}
```

#### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

中等

给定一个整数数组 `prices`，其中第 `i` 个元素代表了第 `i` 天的股票价格 ；非负整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**示例 1:**

```
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```

```java
class Solution { //手续费分开交，36ms
    public int maxProfit(int[] prices, int fee) {
        int n = prices.length;
        double[][] dp = new double[n][2];
        double feeForOne = 0.5 * fee;
        dp[0][1] = 0.0 - prices[0] - feeForOne;
        for (int i = 1; i < n; i++){
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i]-feeForOne);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i]-feeForOne);
        }
        return (int)Math.max(dp[n-1][0],dp[n-1][1]);
    }
}
```

```java
class Solution { //卖的时候交，28ms
    public int maxProfit(int[] prices, int fee) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        dp[0][1] = - prices[0];
        for (int i = 1; i < n; i++){
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i]-fee);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i]);
        }
        return Math.max(dp[n-1][0],dp[n-1][1]);
    }
}
```

#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

困难

给定一个数组，它的第 *i* 个元素是一支给定的股票在第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 *两笔* 交易。

**注意:** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1] 
输出: 0 
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。
```

```java
class Solution { //不是通解，下道题通解
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) return 0;

        int len = prices.length;
        int[] left = new int[len]; //从左往右更新最小值
        int[] right = new int[len]; //从右往左更新最大值
        left[0] = prices[0];
        right[len-1] = prices[len-1];
        for (int i = 1; i < len; i++)
            left[i] = Math.min(left[i-1],prices[i]);
        for (int i = len-2; i >= 0; i--)
            right[i] = Math.max(right[i+1],prices[i]);

        for (int i = 0; i < len; i++){
            left[i] = prices[i] - left[i]; //之前买入，今天卖出的最大利润
            right[i] = right[i] - prices[i]; //今天买入，之后卖出的最大利润
        }

        for (int i = 1; i < len; i++)
            left[i] = Math.max(left[i],left[i-1]); //前半部分的最大利润
        for (int i = len-2; i >= 0; i--)
            right[i] = Math.max(right[i],right[i+1]); //后半部分的最大利润

        int ans = 0;
        for (int i = 0; i < len; i++)
            ans = Math.max(left[i] + right[i], ans);
        return ans;
    }
}
```

#### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

困难

给定一个数组，它的第 *i* 个元素是一支给定的股票在第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。

**注意:** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [2,4,1], k = 2
输出: 2
解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**示例 2:**

```
输入: [3,2,6,5,0,3], k = 2
输出: 7
解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int n = prices.length;
        if (n < 2 || k < 1) return 0;
        if (k > n/2) return maxProfitII(prices); //k不起约束作用了
        int[][] dp = new int[k][2]; //0买 1卖
        for (int i = 0; i < k; i ++){
            dp[i][0] = Integer.MIN_VALUE;
        }
        for (int price : prices){
            dp[0][0] = Math.max(dp[0][0], - price);
            dp[0][1] = Math.max(dp[0][1], dp[0][0] + price);
            for (int i = 1; i < k; i ++){
                dp[i][0] = Math.max(dp[i][0], dp[i-1][1] - price); //第i-1次买了之后，才能买第i次
                dp[i][1] = Math.max(dp[i][1], dp[i][0] + price);
            }
        }
        return dp[k-1][1];
    }

    private int maxProfitII(int [] prices){
        int ans = 0;
        for (int i = 1; i < prices.length; i++){
            if (prices[i] > prices[i-1])
                ans += prices[i] - prices[i-1];
        }
        return ans;
    }
}
```

#### [583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

中等

给定两个单词 *word1* 和 *word2*，找到使得 *word1* 和 *word2* 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

**示例：**

```
输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
```

**提示：**

1. 给定单词的长度不超过500。
2. 给定单词中的字符只含有小写字母。

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        if (m == 0) return n;
        if (n == 0) return m;
        int[][] dp = new int[m+1][n+1];
        for (int i = 1; i < m + 1; i++){
            for (int j = 1; j < n + 1; j++){
                if (word1.charAt(i-1) == word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j]);
                }
            }
        }
        return m + n - dp[m][n] * 2;
    }
}
```

#### [650. 只有两个键的键盘](https://leetcode-cn.com/problems/2-keys-keyboard/)

中等

最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：

1. `Copy All` (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
2. `Paste` (粘贴) : 你可以粘贴你**上一次**复制的字符。

给定一个数字 `n` 。你需要使用最少的操作次数，在记事本中打印出**恰好** `n` 个 'A'。输出能够打印出 `n` 个 'A' 的最少操作次数。

**示例 1:**

```
输入: 3
输出: 3
解释:
最初, 我们只有一个字符 'A'。
第 1 步, 我们使用 Copy All 操作。
第 2 步, 我们使用 Paste 操作来获得 'AA'。
第 3 步, 我们使用 Paste 操作来获得 'AAA'。
```

**说明:**

1. `n` 的取值范围是 [1, 1000] 。

```java
class Solution {
    public int minSteps(int n) {
        int[] dp = new int[n+1];
        for (int i = 2; i < n+1; i++) dp[i] = i;
        for (int i = 2; i < (n+1)/2; i++){
            int k = 2;
            dp[k * i] = dp[i] + 2;
            k++;
            while (k * i < n+1){
                dp[k*i] = dp[(k-1)*i] + 1;
                k++;
            }
        }
        return dp[n];
    }
}
```

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

困难

给你两个单词 *word1* 和 *word2*，请你计算出将 *word1* 转换成 *word2* 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

1. 插入一个字符
2. 删除一个字符
3. 替换一个字符

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        char[] chars1 = word1.toCharArray();
        char[] chars2 = word2.toCharArray();
        int[][] dp = new int[m+1][n+1];
        for (int i = m-1; i >= 0; i--)
            dp[i][n] = dp[i+1][n] + 1; //只删除
        for (int i = n-1; i >= 0; i--)
            dp[m][i] = dp[m][i+1] + 1; //只删除
        for (int i = m-1; i >= 0; i--){
            for (int j = n-1; j >= 0; j--){
                if (chars1[i] == chars2[j]) {
                    dp[i][j] = dp[i+1][j+1]; //相同则缩小子问题
                }else{
                    dp[i][j] = 1 + Math.min(dp[i+1][j],Math.min(dp[i+1][j+1],dp[i][j+1]));
                }
            }
        }
        return dp[0][0];
    }
}
```

## 频率排序

903，552，546，410，943，471，466，887，5，85，920，300，486，53，818，1024，312，639，354，464，975，871，321，741，847，718，673，1147，70，10，361，873，983，1092，714，1074，1012，121，898，698，97，44，688，801，91，221，838，403]]></description></item><item><title>一个通用方法团灭 6 道股票问题</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/31/13409788.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 31 Jul 2020 07:08:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/31/13409788.html</guid><description><![CDATA[<div class="css-1jiyb8u-ContentContainer e1ak08xt0"><div class="e1ak08xt1 css-hlonu5-StyledRenderedMarkdown"><p>原文链接：</p>
<p>https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-w-5/</p>
<p>很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。</p>
<p>这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。</p>
<p>先随便抽出一道题，看看别人的解法：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
    <span class="hljs-keyword">if</span>(prices.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> s1=-prices[<span class="hljs-number">0</span>],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;
        
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;prices.size();++i) {            
        s1 = max(s1, -prices[i]);
        s2 = max(s2, s1+prices[i]);
        s3 = max(s3, s2-prices[i]);
        s4 = max(s4, s3+prices[i]);
    }
    <span class="hljs-keyword">return</span> max(<span class="hljs-number">0</span>,s4);
}
</code></pre>
<p>能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。</p>
<p>本文就来告诉你这个框架，然后带着你一道一道秒杀。</p>
<p>这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。</p>
<p>第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。</p>
<p><strong>PS：我认真写了 100 多篇题解，手把手带你刷力扣，全部发布在 <a href="https://labuladong.gitbook.io/algo/" target="_blank">LeetCode刷题套路</a>，持续更新</strong>。建议收藏，<strong>先按照我的文章顺序刷题</strong>，掌握各种算法套路后投再入题海就如鱼得水了。</p>
<h3>一、穷举框架</h3>
<p>首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。</p>
<p>递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。</p>
<p>而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code><span class="hljs-keyword">for</span> 状态<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> 状态<span class="hljs-number">1</span>的所有取值：
    <span class="hljs-keyword">for</span> 状态<span class="hljs-number">2</span> <span class="hljs-keyword">in</span> 状态<span class="hljs-number">2</span>的所有取值：
        <span class="hljs-keyword">for</span> ...
            dp[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...] = 择优(选择<span class="hljs-number">1</span>，选择<span class="hljs-number">2.</span>..)
</code></pre>
<p>比如说这个问题，<strong>每天都有三种「选择」</strong>：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。</p>
<p>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。<strong>这个问题的「状态」有三个</strong>，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code>dp[i][k][<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>]
<span class="hljs-number">0</span> &lt;= i &lt;= n<span class="hljs-number">-1</span>, <span class="hljs-number">1</span> &lt;= k &lt;= K
n 为天数，大 K 为最多交易数
此问题共 n × K × <span class="hljs-number">2</span> 种状态，全部穷举就能搞定。

<span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt;= i &lt; n:
    <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> &lt;= k &lt;= K:
        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>}:
            dp[i][k][s] = max(buy, sell, rest)
</code></pre>
<p>而且我们可以用自然语言描述出每一个状态的含义，比如说 <code>dp[3][2][1]</code> 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 <code>dp[2][3][0]</code> 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？</p>
<p>我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p>
<p>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。</p>
<h3>二、状态转移框架</h3>
<p>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。</p>
<p align="center"><img src="https://pic.leetcode-cn.com/c4eb5f0aa4daf7bef4b3b8af95129bb7394ec58e1ba7b191d9104bbd8ff1ccb3-40198bf2f6894018328b250b772b4a17724a983f99ba359b798a289733bffcbc-file_1559885188422-1.png" alt="40198bf2f6894018328b250b772b4a17724a983f99ba359b798a289733bffcbc-file_1559885188422-1.png" width="350" onerror="this.src='data:image/svg+xml,%3Csvg height=\'150\' viewBox=\'0 0 150 150\' width=\'150\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cpath d=\'m2465 2286.42347-18.95363-18.92555-50.0112 43.79935-24.62708-24.5906-33.41155 24.5906-22.99654-17.22567v-73.0716c0-2.20914 1.79086-4 4-4h142c2.20914 0 4 1.79086 4 4zm-122-25.59081c5.52285 0 10-4.47052 10-9.98518 0-5.51467-4.47715-9.98519-10-9.98519s-10 4.47052-10 9.98519c0 5.51466 4.47715 9.98518 10 9.98518zm122 40.89296v61.27438c0 2.20914-1.79086 4-4 4h-142c-2.20914 0-4-1.79086-4-4v-53.62625l22.99654 17.22567 33.41155-24.5906 24.62708 24.5906 50.0112-43.79935z\' fill=\'%23eee\' fill-rule=\'evenodd\' transform=\'translate(-2315 -2217)\'/%3E%3C/svg%3E'; "></p>
<p>通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code>dp[i][k][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>] + prices[i])
              max(   选择 rest  ,           选择 sell      )

解释：今天我没有持有股票，有两种可能：
要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。

dp[i][k][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i])
              max(   选择 rest  ,           选择 buy         )

解释：今天我持有着股票，有两种可能：
要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。
</code></pre>
<p>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。</p>
<p>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。<strong>如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了</strong>。不过还差最后一点点，就是定义 base case，即最简单的情况。</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code>dp[<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>
解释：因为 i 是从 <span class="hljs-number">0</span> 开始的，所以 i = <span class="hljs-number">-1</span> 意味着还没有开始，这时候的利润当然是 <span class="hljs-number">0</span> 。
dp[<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>] = -infinity
解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>
解释：因为 k 是从 <span class="hljs-number">1</span> 开始的，所以 k = <span class="hljs-number">0</span> 意味着根本不允许交易，这时候利润当然是 <span class="hljs-number">0</span> 。
dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -infinity
解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。
</code></pre>
<p>把上面的状态转移方程总结一下：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code>base case：
dp[<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>
dp[<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>] = dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -infinity

状态转移方程：
dp[i][k][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>] + prices[i])
dp[i][k][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i])
</code></pre>
<p>读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。</p>
<h3>三、秒杀题目</h3>
<p><strong>第一题，k = 1</strong></p>
<p>直接套状态转移方程，根据 base case，可以做一些化简：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code>dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i])
dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - prices[i]) 
            = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i])
解释：k = <span class="hljs-number">0</span> 的 base case，所以 dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>。

现在发现 k 都是 <span class="hljs-number">1</span>，不会改变，即 k 对状态转移已经没有影响了。
可以进行进一步化简去掉所有 k：
dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i])
dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], -prices[i])
</code></pre>
<p>直接写出代码：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code><span class="hljs-keyword">int</span> n = prices.length;
<span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">2</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);
    dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);
}
<span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
</code></pre>
<p>显然 <code>i = 0</code> 时 <code>dp[i-1]</code> 是不合法的。这是因为我们没有对 <code>i</code> 的 base case 进行处理。可以这样处理：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) {
        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 解释：</span>
        <span class="hljs-comment">//   dp[i][0] </span>
        <span class="hljs-comment">// = max(dp[-1][0], dp[-1][1] + prices[i])</span>
        <span class="hljs-comment">// = max(0, -infinity + prices[i]) = 0</span>
        dp[i][<span class="hljs-number">1</span>] = -prices[i];
        <span class="hljs-comment">//解释：</span>
        <span class="hljs-comment">//   dp[i][1] </span>
        <span class="hljs-comment">// = max(dp[-1][1], dp[-1][0] - prices[i])</span>
        <span class="hljs-comment">// = max(-infinity, 0 - prices[i]) </span>
        <span class="hljs-comment">// = -prices[i]</span>
        <span class="hljs-keyword">continue</span>;
    }
    dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);
    dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);
}
<span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
</code></pre>
<p>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code><span class="hljs-comment">// k == 1</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>{
    <span class="hljs-keyword">int</span> n = prices.length;
    <span class="hljs-comment">// base case: dp[-1][0] = 0, dp[-1][1] = -infinity</span>
    <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>, dp_i_1 = Integer.MIN_VALUE;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-comment">// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span>
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        <span class="hljs-comment">// dp[i][1] = max(dp[i-1][1], -prices[i])</span>
        dp_i_1 = Math.max(dp_i_1, -prices[i]);
    }
    <span class="hljs-keyword">return</span> dp_i_0;
}
</code></pre>
<p>两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。</p>
<p><strong>第二题，k = +infinity</strong></p>
<p>如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code>dp[i][k][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>] + prices[i])
dp[i][k][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i])
            = max(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>] - prices[i])

我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i])
dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i])
</code></pre>
<p>直接翻译成代码：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_inf</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>{
    <span class="hljs-keyword">int</span> n = prices.length;
    <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>, dp_i_1 = Integer.MIN_VALUE;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> temp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);
    }
    <span class="hljs-keyword">return</span> dp_i_0;
}
</code></pre>
<p><strong>第三题，k = +infinity with cooldown</strong></p>
<p>每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code>dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">0</span>] = max(dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">0</span>], dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">1</span>] + prices[i])
dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">1</span>] = max(dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">1</span>], dp[<span class="hljs-string">i-2</span>][<span class="hljs-symbol">0</span>] - prices[i])
解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。
</code></pre>
<p>翻译成代码：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_with_cool</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>{
    <span class="hljs-keyword">int</span> n = prices.length;
    <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>, dp_i_1 = Integer.MIN_VALUE;
    <span class="hljs-keyword">int</span> dp_pre_0 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 代表 dp[i-2][0]</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> temp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);
        dp_pre_0 = temp;
    }
    <span class="hljs-keyword">return</span> dp_i_0;
}
</code></pre>
<p><strong>第四题，k = +infinity with fee</strong></p>
<p>每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code>dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">0</span>] = max(dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">0</span>], dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">1</span>] + prices[i])
dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">1</span>] = max(dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">1</span>], dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">0</span>] - prices[i] - fee)
解释：相当于买入股票的价格升高了。
在第一个式子里减也是一样的，相当于卖出股票的价格减小了。
</code></pre>
<p>直接翻译成代码：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_with_fee</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>{
    <span class="hljs-keyword">int</span> n = prices.length;
    <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>, dp_i_1 = Integer.MIN_VALUE;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> temp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);
    }
    <span class="hljs-keyword">return</span> dp_i_0;
}
</code></pre>
<p><strong>第五题，k = 2</strong></p>
<p>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。</p>
<p>这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code>原始的动态转移方程，没有可化简的地方
dp[i][k][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i])
dp[i][k][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i])
</code></pre>
<p>按照之前的代码，我们可能想当然这样写代码（错误的）：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code><span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span>;
<span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) { <span class="hljs-comment">/* 处理一下 base case*/</span> }
    dp[i][k][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i]);
    dp[i][k][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);
}
<span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>];
</code></pre>
<p>为什么错误？我这不是照着状态转移方程写的吗？</p>
<p>还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code><span class="hljs-keyword">int</span> max_k = <span class="hljs-number">2</span>;
<span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][max_k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = max_k; k &gt;= <span class="hljs-number">1</span>; k--) {
        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) { <span class="hljs-comment">/*处理 base case */</span> }
        dp[i][k][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i]);
        dp[i][k][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);
    }
}
<span class="hljs-comment">// 穷举了 n × max_k × 2 个状态，正确。</span>
<span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][max_k][<span class="hljs-number">0</span>];
</code></pre>
<p>如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。</p>
<p>这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code>dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] + prices[i])
dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i])
dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i])
dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i])

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>{
    <span class="hljs-keyword">int</span> dp_i10 = <span class="hljs-number">0</span>, dp_i11 = Integer.MIN_VALUE;
    <span class="hljs-keyword">int</span> dp_i20 = <span class="hljs-number">0</span>, dp_i21 = Integer.MIN_VALUE;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> price : prices) {
        dp_i20 = Math.max(dp_i20, dp_i21 + price);
        dp_i21 = Math.max(dp_i21, dp_i10 - price);
        dp_i10 = Math.max(dp_i10, dp_i11 + price);
        dp_i11 = Math.max(dp_i11, -price);
    }
    <span class="hljs-keyword">return</span> dp_i20;
}
</code></pre>
<p>有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。</p>
<p><strong>第六题，k = any integer</strong></p>
<p>有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？</p>
<p>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。</p>
<p>直接把之前的代码重用：</p>
<pre><button class="md-btn-copy" title="复制代码"><i></i></button><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_any</span><span class="hljs-params">(<span class="hljs-keyword">int</span> max_k, <span class="hljs-keyword">int</span>[] prices)</span> </span>{
    <span class="hljs-keyword">int</span> n = prices.length;
    <span class="hljs-keyword">if</span> (max_k &gt; n / <span class="hljs-number">2</span>) 
        <span class="hljs-keyword">return</span> maxProfit_k_inf(prices);

    <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][max_k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) 
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = max_k; k &gt;= <span class="hljs-number">1</span>; k--) {
            <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) { <span class="hljs-comment">/* 处理 base case */</span> }
            dp[i][k][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i]);
            dp[i][k][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);     
        }
    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][max_k][<span class="hljs-number">0</span>];
}
</code></pre>
<p>至此，6 道题目通过一个状态转移方程全部解决。</p>
<h3>四、最后总结</h3>
<p>本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。</p>
<p>关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？</p>
<p>具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。</p>
<p>所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。</p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/" target="_blank">买卖股票的最佳时机</a></p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank">买卖股票的最佳时机 II</a></p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank">买卖股票的最佳时机 III</a></p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank">买卖股票的最佳时机 IV</a></p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank">最佳买卖股票时机含冷冻期</a></p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank">买卖股票的最佳时机含手续费</a></p>
<p>最后，点击我的头像可以查看更多详细题解，希望读者多多点赞，让我感受到你的认可～</p>
<p>PS：<strong>我的所有算法文章都已经上传到了 Github 仓库</strong>：<a href="https://github.com/labuladong/fucking-algorithm" target="_blank"><strong>fucking-algorithm</strong></a>，共 60 多篇，绝对精品，肯定让你收获满满，<strong>求个 star 不过分吧</strong>～</p>
<p>PPS：我最近精心制作了一份电子书《labuladong的算法小抄》，分为「动态规划」「数据结构」「算法思维」「高频面试」四个章节，目录如下，限时开放下载，如有需要可扫码到我的公众号 <strong>labuladong</strong> 后台回复关键词「pdf」下载。</p>
<p><strong>推荐阅读：</strong></p>
<p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia" target="_blank">动态规划设计方法：归纳思想</a></p>
<p><a href="https://leetcode-cn.com/problems/stone-game/solution/jie-jue-bo-yi-wen-ti-de-dong-tai-gui-hua-tong-yong/" target="_blank">动态规划方法解决博弈问题</a></p>
<p><a href="https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/" target="_blank">腾讯面试题详解：编辑距离</a></p>
</div></div>]]></description></item><item><title>Leetcode 搜索（BFS DFS 回溯）</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/29/leetcode06.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Wed, 29 Jul 2020 02:29:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/29/leetcode06.html</guid><description><![CDATA[## 基础部分

### BFS

#### [1091. 二进制矩阵中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)

中等

在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。

一条从左上角到右下角、长度为 `k` 的畅通路径，由满足下述条件的单元格 `C_1, C_2, ..., C_k` 组成：

- 相邻单元格 `C_i` 和 `C_{i+1}` 在八个方向之一上连通（此时，`C_i` 和 `C_{i+1}` 不同且共享边或角）
- `C_1` 位于 `(0, 0)`（即，值为 `grid[0][0]`）
- `C_k` 位于 `(N-1, N-1)`（即，值为 `grid[N-1][N-1]`）
- 如果 `C_i` 位于 `(r, c)`，则 `grid[r][c]` 为空（即，`grid[r][c] == 0`）

返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。

**示例 1：**

```
输入：[[0,1],[1,0]]

输出：2
```

**示例 2：**

```
输入：[[0,0,0],[1,1,0],[1,1,0]]

输出：4
```

**提示：**

1. `1 <= grid.length == grid[0].length <= 100`
2. `grid[i][j]` 为 `0` 或 `1`

```java
import java.util.ArrayDeque;
import java.util.Queue;

class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
        if (grid[0][0] == 1 || grid[grid.length-1][grid[0].length-1] == 1) return -1;
        Queue<int[]> queue = new ArrayDeque<>();
        queue.add(new int[]{0,0});
        grid[0][0] = 1;
        int res = 0;
        while (!queue.isEmpty()){
            res++;
            int len = queue.size();
            while (len-- > 0){
                int[] zuobiao = queue.poll();
                int i = zuobiao[0];
                int j = zuobiao[1];
                if(i==grid.length-1 && j==grid[0].length-1) return res;
                if (i > 0 && grid[i-1][j] == 0){ //上
                    queue.add(new int[]{i-1,j});
                    grid[i-1][j] = 1;
                }
                if (i > 0 && j > 0  && grid[i-1][j-1] == 0){ //左上
                    queue.add(new int[]{i-1,j-1});
                    grid[i-1][j-1] = 1;
                }
                if (i > 0 && j < grid[0].length-1 && grid[i-1][j+1] == 0){ //右上
                    queue.add(new int[]{i-1,j+1});
                    grid[i-1][j+1] = 1;
                }
                if (i < grid.length-1 && grid[i+1][j] == 0){ //下
                    queue.add(new int[]{i+1,j});
                    grid[i+1][j] = 1;
                }
                if (i < grid.length-1 && j > 0 && grid[i+1][j-1] == 0){  //左下
                    queue.add(new int[]{i+1,j-1});
                    grid[i+1][j-1] = 1;
                }
                if (i < grid.length-1 && j < grid[0].length-1 && grid[i+1][j+1] == 0){ //右下
                    queue.add(new int[]{i+1,j+1});
                    grid[i+1][j+1] = 1;
                }
                if (j > 0 && grid[i][j-1] == 0){ //左
                    queue.add(new int[]{i,j-1});
                    grid[i][j-1] = 1;
                }
                if (j < grid[0].length-1 && grid[i][j+1] == 0){ //右
                    queue.add(new int[]{i,j+1});
                    grid[i][j+1] = 1;
                }
            }
        }
        return -1;
    }
}
```

#### [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

中等

给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。

**示例 1:**

```
输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
```

**示例 2:**

```
输入: n = 13
输出: 2
解释: 13 = 4 + 9.
```

```java
class Solution { //很意外：12 ms, 在所有 Java 提交中击败了94.28%的用户
    public static int numSquares(int n) {
        List<Integer> arr = new ArrayList<>();
        Queue<Integer> queue = new ArrayDeque<>();
        for (int i = 1; ; i++){
            long a = i*i;
            if (a == n) return 1;
            if (a > n) break;
            arr.add((int) a);
            queue.add((int) a);
        }
        if (ij(arr,n)) return 2;
        int res = 0;
        while (!queue.isEmpty()){
            res++;
            int size = queue.size();
            while (size-- > 0){
                int num = queue.poll();
                if (num == n) return res;
                if (ij(arr,n-num)) return res+2;
                else {
                    for (Integer i : arr) {
                        queue.add(i+num);
                    }
                }
            }
        }
        return 1;
    }

    private static boolean ij(List<Integer> arr, int n) { 
        //双指针查找，答案基本不会大于4，所以这样省不少时间
        int i = 0;
        int j = arr.size() - 1;
        while (i <= j){
            int x = arr.get(i);
            int y = arr.get(j);
            if (x + y == n) return true;
            if (x + y > n) j--;
            else i++;
        }
        return false;
    }
}
```

#### [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)

中等

给定两个单词（*beginWord* 和 *endWord*）和一个字典，找到从 *beginWord* 到 *endWord* 的最短转换序列的长度。转换需遵循如下规则：

1. 每次转换只能改变一个字母。
2. 转换过程中的中间单词必须是字典中的单词。

**说明:**

- 如果不存在这样的转换序列，返回 0。
- 所有单词具有相同的长度。
- 所有单词只由小写字母组成。
- 字典中不存在重复的单词。
- 你可以假设 *beginWord* 和 *endWord* 是非空的，且二者不相同。

**示例 1:**

```
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出: 5

解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。
```

**示例 2:**

```
输入:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

输出: 0

解释: endWord "cog" 不在字典中，所以无法进行转换。
```

```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        if (!wordList.contains(endWord)) return 0;
        Queue<String> queue = new ArrayDeque<>();
        queue.add(beginWord);
        int res = 1;
        while (!queue.isEmpty()){
            int size = queue.size();
            res++;
            while (size-- > 0){
                String str = queue.poll();
                if (canTran(str,endWord)) return res;
                for (int i = wordList.size()-1; i >= 0; i--) {
                    if (canTran(str,wordList.get(i))){
                        queue.add(wordList.get(i));
                        wordList.remove(i);
                    }
                }
            }
        }
        return 0;
    }

    private boolean canTran(String s1,String s2){
        boolean can = true;
        for (int i = 0; i < s1.length(); i++) {
            if (s1.charAt(i)!=s2.charAt(i)){
                if (can) can = false;
                else return false;
            }
        }
        return true;
    }
}
```

### DFS

#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

中等

给定一个包含了一些 `0` 和 `1` 的非空二维数组 `grid` 。

一个 **岛屿** 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在水平或者竖直方向上相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 `0` 。)

**示例 1:**

```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```

对于上面这个给定矩阵应返回 `6`。注意答案不应该是 `11` ，因为岛屿只能包含水平或垂直的四个方向的 `1` 。

**示例 2:**

```
[[0,0,0,0,0,0,0,0]]
```

对于上面这个给定的矩阵, 返回 `0`。

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int row = grid.length;
        int column = grid[0].length;
        int res = 0;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < column; j++) {
                if (grid[i][j] == 1) {
                    Stack<int[]> stack = new Stack<>();
                    stack.push(new int[]{i,j});
                    int S = 0;
                    while (!stack.isEmpty()){
                        int[] point = stack.pop();
                        int x = point[0];
                        int y = point[1];
                        if (grid[x][y] == 1) {
                            S++;
                            grid[x][y] = 0;
                        }else continue;
                        if (x > 0 && grid[x-1][y] == 1) stack.push(new int[]{x-1,y});
                        if (x < row-1 && grid[x+1][y] == 1) stack.push(new int[]{x+1,y});
                        if (y > 0 && grid[x][y-1] == 1) stack.push(new int[]{x,y-1});
                        if (y < column-1 && grid[x][y+1] == 1) stack.push(new int[]{x,y+1});
                    }
                    res = res > S ? res : S;
                }
            }
        }
        return res;
    }
}
```

#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

中等

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1:**

```
输入:
[
['1','1','1','1','0'],
['1','1','0','1','0'],
['1','1','0','0','0'],
['0','0','0','0','0']
]
输出: 1
```

**示例 2:**

```
输入:
[
['1','1','0','0','0'],
['1','1','0','0','0'],
['0','0','1','0','0'],
['0','0','0','1','1']
]
输出: 3
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。
```

```java
class Solution {
    public int numIslands(char[][] grid) {
        int res = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1'){
                    res++;
                    dfs(i,j,grid);
                }
            }
        }
        return res;
    }

    private void dfs(int i, int j, char[][] grid) {
        grid[i][j] = '0';
        if (i > 0 && grid[i-1][j] == '1') dfs(i-1,j,grid);
        if (i < grid.length-1 && grid[i+1][j] == '1') dfs(i+1,j,grid);
        if (j > 0 && grid[i][j-1] == '1') dfs(i,j-1,grid);
        if (j < grid[0].length-1 && grid[i][j+1] == '1') dfs(i,j+1,grid);
    }
}
```

#### [547. 朋友圈](https://leetcode-cn.com/problems/friend-circles/)

中等

班上有 **N** 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个 **N \* N** 的矩阵 **M**，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生**互为**朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

**示例 1:**

```
输入: 
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出: 2 
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回2。
```

**示例 2:**

```
输入: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出: 1
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。
```

**注意：**

1. N 在[1,200]的范围内。
2. 对于所有学生，有M[i][i] = 1。
3. 如果有M[i][j] = 1，则有M[j][i] = 1。

```java
class Solution {
    public int findCircleNum(int[][] M) {
        int n = M.length;
        int res = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (M[i][j] == 1){
                    M[i][j] = 0;
                    M[j][i] = 0;
                    res++;
                    dfs(j,M);
                }
            }
        }
        return res;
    }

    private void dfs(int j, int[][] M) {
        for (int i = 0; i < M.length; i++) {
            if (M[i][j] == 1) {
                M[i][j] = 0;
                M[j][i] = 0;
                dfs(i,M);
            }
        }
    }
}
```

#### [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

中等

给定一个二维的矩阵，包含 `'X'` 和 `'O'`（**字母 O**）。

找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。

**示例:**

```
X X X X
X O O X
X X O X
X O X X
```

运行你的函数后，矩阵变为：

```
X X X X
X X X X
X X X X
X O X X
```

**解释:**

被围绕的区间不会存在于边界上，换句话说，任何边界上的 `'O'` 都不会被填充为 `'X'`。 任何不在边界上，或不与边界上的 `'O'` 相连的 `'O'` 最终都会被填充为 `'X'`。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。

```java
class Solution {
    List<int[]> list = new ArrayList<>();
    boolean[][] visited;

    public void solve(char[][] board) {
        if (board.length == 0) return;
        visited = new boolean[board.length][board[0].length];
        for (int i= 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (board[i][j] == 'X' || visited[i][j]) continue;
                dfs(i,j,board);
                boolean flag = true;
                for (int[] ints : list) {
                    if (ints[0] == 0 || ints[0] == board.length-1 || ints[1] == 0 || ints[1] == board[0].length-1){
                        flag = false;
                        break;
                    }
                }
                if (flag){
                    for (int[] ints : list) {
                        board[ints[0]][ints[1]] = 'X';
                    }
                }
                list.clear();
            }
        }
    }

    private void dfs(int i, int j, char[][] board) {
        if (visited[i][j]) return;
        visited[i][j] = true;
        list.add(new int[]{i,j});
        if (i > 0 && board[i-1][j] == 'O') dfs(i-1,j,board);
        if (i < board.length-1 && board[i+1][j] == 'O') dfs(i+1,j,board);
        if (j > 0 && board[i][j-1] == 'O') dfs(i,j-1,board);
        if (j < board[0].length-1 && board[i][j+1] == 'O') dfs(i,j+1,board);
    }
}
```

#### [417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)

中等

给定一个 `m x n` 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。

规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。

请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。

**提示：**

1. 输出坐标的顺序不重要
2. *m* 和 *n* 都小于150

**示例：**

```
给定下面的 5x5 矩阵:

  太平洋 ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋

返回:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).
```

```java
public class Solution {
    private static int[][] dires = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    private int m, n;
    private int[][] matrix;

    public List<List<Integer>> pacificAtlantic(int[][] matrix) {
        List<List<Integer>> res = new ArrayList<>();
        m = matrix.length;
        if (m == 0) return res;
        n = matrix[0].length;
        if (n == 0) return res;
        this.matrix = matrix;
        boolean[][] canReachP = new boolean[m][n];
        boolean[][] canReachA = new boolean[m][n];
        for (int i = 0; i < n; i++) {
            dfs(0, i, canReachP);
            dfs(m - 1, i, canReachA);
        }
        for (int i = 0; i < m; i++) {
            dfs(i, 0, canReachP);
            dfs(i, n - 1, canReachA);
        }
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(canReachA[i][j] && canReachP[i][j]){
                    List<Integer> temp = new ArrayList<>();
                    temp.add(i);
                    temp.add(j);
                    res.add(temp);
                }
            }
        }
        return res;
    }

    //换一种思路，从边界往里面走，只能走到比自己更高或者等高的地方。
    //边界能走到的地方，就是能流入对应海洋的地方。
    private void dfs(int x, int y, boolean[][] canReach) {
        canReach[x][y] = true;
        for (int i = 0; i < 4; i++) {
            int newX = x + dires[i][0];
            int newY = y + dires[i][1];
            if (isIn(newX, newY) && matrix[x][y] <= matrix[newX][newY] && !canReach[newX][newY]) {
                dfs(newX, newY, canReach);
            }
        }
    }

    private boolean isIn(int x, int y) {
        return x >= 0 && x < m && y >= 0 && y < n;
    }
}
```

### 回溯法

#### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

中等

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200729102718087-1213724887.png)


**示例:**

```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

**说明:**
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

```java
class Solution {
    String[] strings = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    List<String> result = new ArrayList<>();

    public List<String> letterCombinations(String digits) {
        char[] ds = digits.toCharArray();
        if (ds.length == 0) return result;
        StringBuilder sb = new StringBuilder();
        backtrack(sb,ds,0);
        return result;
    }

    private void backtrack(StringBuilder sb, char[] ds, int index) {
        if (sb.length() == ds.length){
            result.add(sb.toString());return;
        }
        char[] chs = strings[ds[index] - '0'].toCharArray();
        for (int i = 0; i < chs.length; i++) {
            sb.append(chs[i]);
            backtrack(sb,ds,index+1);
            sb.deleteCharAt(sb.length()-1);
        }
    }
}
```

#### [93. 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

中等

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 `'.' `分隔。

**示例:**

```
输入: "25525511135"
输出: ["255.255.11.135", "255.255.111.35"]
```

```java
class Solution {
    List<String> result = new ArrayList<>();
    int len; //一直能复用

    public List<String> restoreIpAddresses(String s) {
        len = s.length();
        if (len <= 12) helper(s,0,"",0);
        return result;
    }

    private void helper(String ip, int index, String restore, int count) {
        if (count == 4 && index == len) result.add(restore);
        if (count >= 4) return;
        for (int i = 1; i < 4; i++) {
            if (index + i > len) break;
            String s = ip.substring(index,index+i);
            if (i > 1 && s.charAt(0) == '0' || Integer.parseInt(s) > 255)
                break; //i即s的长度
            helper(ip, index+i, restore + s + (count < 3 ? "." : "" ), count+1);
        }
    }
}
```

#### [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

中等

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例:**

```
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false
```

**提示：**

- `board` 和 `word` 中只包含大写和小写英文字母。
- `1 <= board.length <= 200`
- `1 <= board[i].length <= 200`
- `1 <= word.length <= 10^3`

```java
class Solution {
    int m;
    int n;
    int[][] directions = {{-1,0},{1,0},{0,-1},{0,1}};
    boolean res = false;
    public boolean exist(char[][] board, String word) {
        this.m = board.length;
        this.n = board[0].length;
        if (word.length() > m * n) return false;
        boolean[][] visited = new boolean[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (word.charAt(0) == board[i][j]) backtrack(board,visited,word,i,j,0);
                if (res) break;
            }
        }
        return res;
    }

    private void backtrack(char[][] board,boolean[][] visited,String word,int i,int j,int index) {
        if (!visited[i][j] && board[i][j] == word.charAt(index)){
            if (index == word.length()-1) {
                res = true;return;
            }
            visited[i][j] = true;
            for (int k = 0; k < 4; k++) {
                int x = i + directions[k][0];
                int y = j + directions[k][1];
                if (isIn(x,y) && !visited[x][y] && board[x][y] == word.charAt(index+1)){
                    backtrack(board,visited,word,x,y,index+1);
                    if (res) return; //有满足的了，赶紧结束递归
                }
            }
            visited[i][j] = false; //回溯
        }
    }

    private boolean isIn(int i,int j){
        return !(i < 0 || j < 0 || i >= m || j >= n);
    }
}
```

#### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

简单

给定一个二叉树，返回所有从根节点到叶子节点的路径。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```

```java
class Solution {
    List<String> result = new ArrayList<>();

    public List<String> binaryTreePaths(TreeNode root) {
        if (root == null) return result;
        StringBuilder sb = new StringBuilder();
        helper(root,sb);
        return result;
    }

    private void helper(TreeNode root, StringBuilder sb) {
        if (root == null) return;
        String str = "" + root.val + "->";
        sb.append(str);
        if (root.left == null && root.right == null)
            result.add(sb.toString().substring(0,sb.length()-2));
        else {
            helper(root.left,sb);
            helper(root.right,sb);
        }
        sb.delete(sb.length()-str.length(),sb.length());
    }
}
```

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

中等

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

**示例:**

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

```java
class Solution {
    List<List<Integer>> result = new LinkedList<>();
    List<Integer> restore = new LinkedList<>();

    public List<List<Integer>> permute(int[] nums) {
        helper(nums);
        return result;
    }

    private void helper(int[] nums) {
        if (nums.length == restore.size()) {
            result.add(new LinkedList<>(restore)); //必须要初始化※
            //result.add(restore); //错的
            return;
        }
        for (int num : nums) {
            if (restore.contains(num)) continue;
            restore.add(num);
            helper(nums);
            restore.remove(restore.size() - 1);
        }
    }
}
```

#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

中等

给定一个可包含重复数字的序列，返回所有不重复的全排列。

**示例:**

```
输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

```java
class Solution {
    Set<List<Integer>> result = new HashSet<>();
    List<Integer> restore = new LinkedList<>();
    Set<Integer> set = new HashSet<>();

    public List<List<Integer>> permuteUnique(int[] nums) {
        helper(nums);
        return new ArrayList<>(result);
    }

    private void helper(int[] nums) {
        if (nums.length == restore.size()) {
            result.add(new LinkedList<>(restore));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            if (set.contains(i)) continue;
            restore.add(num);
            set.add(i);
            helper(nums);
            restore.remove(restore.size() - 1);
            set.remove(i);
        }
    }
}
```

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

中等

给定两个整数 *n* 和 *k*，返回 1 ... *n* 中所有可能的 *k* 个数的组合。

**示例:**

```
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> restore = new ArrayList<>();
    Set<Integer> set = new HashSet<>();

    public List<List<Integer>> combine(int n, int k) {
        helper(n,k,0);
        return result;
    }

    private void helper(int n, int k, int count) {
        if (count == k){
            result.add(new ArrayList<>(restore));
            return;
        }
        for (int i = 1; i <= n; i++) {
            if (set.contains(i) || count > 0 && restore.get(count-1) > i) continue;
            restore.add(i);
            set.add(i);
            helper(n,k,count+1);
            restore.remove(count);
            set.remove(i);
        }
    }
}
```

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

中等

给定一个**无重复元素**的数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的数字可以无限制重复被选取。

**说明：**

- 所有数字（包括 `target`）都是正整数。
- 解集不能包含重复的组合。 

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
```

**示例 2：**

```
输入：candidates = [2,3,5], target = 8,
所求解集为：
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```

**提示：**

- `1 <= candidates.length <= 30`
- `1 <= candidates[i] <= 200`
- `candidate` 中的每个元素都是独一无二的。
- `1 <= target <= 500`

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> restore = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        helper(candidates,target);
        return result;
    }

    private void helper(int[] candidates, int target) {
        if (target == 0) {
            result.add(new ArrayList<>(restore));
            return;
        }
        for (int i : candidates) {
            if (target-i < 0) break;
            if (!restore.isEmpty() && i < restore.get(restore.size()-1)) continue;
            restore.add(i);
            helper(candidates, target - i);
            restore.remove(restore.size()-1);
        }
    }
}
```

#### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

中等

给定一个数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用一次。

**说明：**

- 所有数字（包括目标数）都是正整数。
- 解集不能包含重复的组合。 

**示例 1:**

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```

**示例 2:**

```
输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
```

```java
class Solution {
    Set<List<Integer>> result = new HashSet<>();
    List<Integer> restore = new ArrayList<>();
    Set<Integer> set = new HashSet<>();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        helper(candidates,target);
        return new ArrayList<>(result);
    }

    private void helper(int[] candidates, int target) {
        if (target == 0) {
            result.add(new ArrayList<>(restore));
            return;
        }
        for (int i = 0; i < candidates.length; i++) {
            int num = candidates[i];
            if (target - num < 0) break;
            if (set.contains(i) || !restore.isEmpty() && num < restore.get(restore.size() - 1))continue;
            restore.add(num);
            set.add(i);
            helper(candidates, target - num);
            restore.remove(restore.size() - 1);
            set.remove(i);
        }
    }
}
```

#### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

中等

找出所有相加之和为 ***n*** 的 ***k\*** 个数的组合***。\***组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

**说明：**

- 所有数字都是正整数。
- 解集不能包含重复的组合。 

**示例 1:**

```
输入: k = 3, n = 7
输出: [[1,2,4]]
```

**示例 2:**

```
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
```

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> restore = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        helper(n,k,0);
        return result;
    }

    private void helper(int n, int k, int count) {
        if (count == k && n == 0) result.add(new ArrayList<>(restore));
        if (count >= k) return;
        int i = restore.isEmpty() ? 1 : restore.get(restore.size()-1)+1;
        for (; i <= 9; i++) {
            restore.add(i);
            helper(n-i,k,count+1);
            restore.remove(restore.size()-1);
        }
    }
}
```

#### [78. 子集](https://leetcode-cn.com/problems/subsets/)

中等

给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集）。

**说明：**解集不能包含重复的子集。

**示例:**

```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> restore = new ArrayList<>();

    public List<List<Integer>> subsets(int[] nums) {
        Arrays.sort(nums);
        helper(nums);
        return result;
    }

    private void helper(int[] nums) {
        result.add(new ArrayList<>(restore));
        if (restore.size() == nums.length) return;
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            if (!restore.isEmpty() && restore.get(restore.size()-1) >= num) continue;
            restore.add(num);
            helper(nums);
            restore.remove(restore.size()-1);
        }
    }
}
```

#### [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

中等

给定一个可能包含重复元素的整数数组 ***nums***，返回该数组所有可能的子集（幂集）。

**说明：**解集不能包含重复的子集。

**示例:**

```
输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
```

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> restore = new ArrayList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        help(nums, 0);
        return result;
    }

    private void help(int[] nums, int index) {
        if (!result.contains(restore)) result.add(new ArrayList<>(restore));
        if (index == nums.length) return;
        for (int i = index; i < nums.length; i++) {
            restore.add(nums[i]);
            help(nums, i+1);
            restore.remove(restore.size()-1);
        }
    }
}
```

#### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

中等

给定一个字符串 *s*，将 *s* 分割成一些子串，使每个子串都是回文串。

返回 *s* 所有可能的分割方案。

**示例:**

```
输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]
```

```java
class Solution {
    List<List<String>> result = new ArrayList<>();
    List<String> restore = new ArrayList<>();

    public List<List<String>> partition(String s) {
        helper(s,0,s.length());
        return result;
    }

    private void helper(String s,int index, int end) {
        if (index == end) {
            result.add(new ArrayList<>(restore));
            return;
        }
        for (int i = index+1; i <= end; i++) {
            String substring = s.substring(index, i);
            if (isPalindrome(substring)){
                restore.add(substring);
                helper(s,i,end);
                restore.remove(restore.size()-1);
            }
        }
    }

    private boolean isPalindrome(String str){
        int len = str.length();
        for (int i = 0; i < len/2; i++) {
            if (str.charAt(i) != str.charAt(len-i-1))
                return false;
        }
        return true;
    }
}
```

#### [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

困难

编写一个程序，通过已填充的空格来解决数独问题。

一个数独的解法需**遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

空白格用 `'.'` 表示。

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200729102812060-430141797.png)


一个数独。

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200729102834730-286517726.png)


答案被标成红色。

**Note:**

- 给定的数独序列只包含数字 `1-9` 和字符 `'.'` 。
- 你可以假设给定的数独只有唯一解。
- 给定数独永远是 `9x9` 形式的。

```java
class Solution {
    Set<Character>[] sets1 = new HashSet[9]; //横向
    Set<Character>[] sets2 = new HashSet[9]; //竖向
    Set<Character>[] sets3 = new HashSet[9]; //块

    public Solution() {
        for (int i = 0; i < 9; i++) {
            sets1[i] = new HashSet<>();
            sets2[i] = new HashSet<>();
            sets3[i] = new HashSet<>();
        }
    }

    public void solveSudoku(char[][] board) {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == '.') continue;
                sets1[i].add(board[i][j]);
                sets2[j].add(board[i][j]);
                sets3[i/3*3 + j/3].add(board[i][j]);
            }
        }
        helper(board,0,0);
    }

    private boolean helper(char[][] board,int i,int j) {
        if (j == 9){
            i++;
            j = 0;
            if (i == 9) return true; //全部填完了
        }
        if (board[i][j] == '.') {
            int block = i/3*3 + j/3;
            for (int num = 1; num <= 9; num++) {
                char ch = (char)('0'+num);
                if (sets1[i].contains(ch) || sets2[j].contains(ch) || sets3[block].contains(ch)) continue;
                board[i][j] = ch;
                sets1[i].add(ch);
                sets2[j].add(ch);
                sets3[block].add(ch);
                if (helper(board,i,j+1)) return true; //填对了，后边就不用变回'.'了
                board[i][j] = '.';
                sets1[i].remove(ch);
                sets2[j].remove(ch);
                sets3[block].remove(ch);
            }
        }else {
            return helper(board, i, j+1);
        }
        return false; //没找到能匹配的数
    }
}
```

#### [51. N皇后](https://leetcode-cn.com/problems/n-queens/)

困难

*n* 皇后问题研究的是如何将 *n* 个皇后放置在 *n*×*n* 的棋盘上，并且使皇后彼此之间不能相互攻击。

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200729102903792-1862190414.png)


上图为 8 皇后问题的一种解法。

给定一个整数 *n*，返回所有不同的 *n* 皇后问题的解决方案。

每一种解法包含一个明确的 *n* 皇后问题的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

**示例:**

```
输入: 4
输出: [
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]
解释: 4 皇后问题存在两个不同的解法。
```

```java
class Solution {
    List<List<String>> result = new ArrayList<>();
    char[][] board;

    public List<List<String>> solveNQueens(int n) {
        board = new char[n][n];
        init(board);
        helper(0,n);
        return result;
    }

    private void helper(int rowIndex, int colIndex) {
        if (rowIndex == board.length) {
            result.add(new ArrayList<>(generate(board)));
            return;
        }
        for (int i = 0; i < colIndex; i++) {
            if (canfill(rowIndex,i)){
                board[rowIndex][i] = 'Q';
                helper(rowIndex+1, colIndex);
                board[rowIndex][i] = '.';
            }
        }
    }

    private boolean canfill(int x, int y) {
        for (int i = x-1,j = y;i >=0;i--)
            if (board[i][j] == 'Q') return false;
        for (int i = x-1,j = y-1;i >=0 && j >= 0;i--,j--)
            if (board[i][j] == 'Q') return false;
        for (int i = x-1,j = y+1;i >=0 && j <= board.length-1;i--,j++)
            if (board[i][j] == 'Q') return false;
        return true;
    }

    private List<String> generate(char[][] board) {
        List<String> rows = new ArrayList<>();
        for (int i = 0; i < board.length; i++)
            rows.add(new String(board[i]));
        return rows;
    }

    private void init(char[][] board) {
        for (int i = 0; i < board.length; i++)
            for (int j = 0; j < board.length; j++)
                board[i][j] = '.';
    }
}
```

## 频率排序

广度：913,815,407,1036,864,199,505,847,200,994,773,863,743

深度：546,679,711,928,394,329,199,834,505,124,488,200,839,364,863,695,753,743,694

回溯：411,93,46,10,37,51,44,22]]></description></item><item><title>LeetCode 分治</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/27/leetcode05.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 27 Jul 2020 06:12:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/27/leetcode05.html</guid><description><![CDATA[## 基础部分

#### [241. 为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)

中等

给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 `+`, `-` 以及 `*` 。

**示例 1:**

```
输入: "2-1-1"
输出: [0, 2]
解释: 
((2-1)-1) = 0 
(2-(1-1)) = 2
```

**示例 2:**

```
输入: "2*3-4*5"
输出: [-34, -14, -10, -10, 10]
解释: 
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
```

```java
class Solution {
    public List<Integer> diffWaysToCompute(String input) {
        List<Integer> res = new LinkedList<>();
        for (int i = 0; i < input.length(); i++) {
            int c = input.charAt(i);
            if (c == '+' || c == '-' || c == '*'){ //有符号，则分治
                List<Integer> left = diffWaysToCompute(input.substring(0,i));
                List<Integer> right = diffWaysToCompute(input.substring(i+1));
                for (Integer l : left) {
                    for (Integer r : right) {
                        if (c == '+'){
                            res.add(l + r);
                        }else if (c == '-'){
                            res.add(l - r);
                        }else 
                            res.add(l * r);
                    }
                }
            }
        }
        if (res.size() == 0) //无符号，直接返回结果
            res.add(Integer.parseInt(input));
        return res;
    }
}
```

#### [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

中等

给定一个整数 *n*，生成所有由 1 ... *n* 为节点所组成的 **二叉搜索树** 。

**示例：**

```
输入：3
输出：
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释：
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

**提示：**

- `0 <= n <= 8`

```java
class Solution {
    public List<TreeNode> generateTrees(int first, int n) {
        List<TreeNode> res = new ArrayList<>();
        if (n < first) {
            res.add(null);
            return res;
        }
        TreeNode[] treeNodes = new TreeNode[n - first + 1];
        for (int i = 0; i < treeNodes.length; i++) {
            List<TreeNode> lefts = generateTrees(first, i+first-1);
            List<TreeNode> rights = generateTrees(i+first+1,n);
            for (TreeNode left : lefts) { //不同的排列组合
                for (TreeNode right : rights) {
                    TreeNode node = new TreeNode(i+first);
                    node.left = left;
                    node.right = right;
                    res.add(node);
                }
            }
        }
        return res;
    }

    public List<TreeNode> generateTrees(int n) {
        if (n == 0) return new ArrayList<>();
        return generateTrees(1,n);
    }
}
```

## 频率排序

903,4,426,53,312,23,215]]></description></item><item><title>高校校园卡，300打一年，非学生也能办理！</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/27/xiaoyuanka.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 27 Jul 2020 02:56:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/27/xiaoyuanka.html</guid><description><![CDATA[+ 原价 **48/月** 的沃派套餐，现只要 **300/年**，扫码即可下单，下单可返利 **40元** 现金
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200727104249215-14879632.png)

+ 流量、通话、短信全国使用，**全国各地都可以办理**

+ 校园卡用户**不止**学生，人人都可办理，看到即是赚到

+ 每月套餐内容：
1. 国内时长 **200**分钟
2. 全国流量 **10**GB + **20**GB
3. 免费短信 **10**条

+ 套餐外
1. 国内通话 **0.1**元/分钟
2. 国内短信 **0.1**元/条
3. 全国流量 **0.1元/MB**累计至3元，不再收费，直至1GB，按**3元/GB**收费

+ 更多信息请扫码了解
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200727104249215-14879632.png)
]]></description></item><item><title>LeetCode 二分法</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/27/leetcode04.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 27 Jul 2020 02:31:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/27/leetcode04.html</guid><description><![CDATA[## 基础部分

#### [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

简单

实现 `int sqrt(int x)` 函数。

计算并返回 *x* 的平方根，其中 *x* 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

**示例 1:**

```
输入: 4
输出: 2
```

**示例 2:**

```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
```

```java
class Solution {
    public static int mySqrt(int x) {
        if (x >= 2147395600) return 46340; //乘积不能超过int
        int l = 0, r = x > 46340 ? 46340 : x;
        int mid = l + (r-l)/2;
        while (true){
            int a = mid * mid;
            if (a == x || a < x && a + mid + mid + 1 > x) break;
            else if (a < x) l = mid + 1;
            else r = mid - 1;
            mid = l + (r-l)/2;
        }
        return mid;
    }
}
```

#### [744. 寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)

简单

给你一个排序后的字符列表 `letters` ，列表中只包含小写英文字母。另给出一个目标字母 `target`，请你寻找在这一有序列表里比目标字母大的最小字母。

在比较时，字母是依序循环出现的。举个例子：

- 如果目标字母 `target = 'z'` 并且字符列表为 `letters = ['a', 'b']`，则答案返回 `'a'`

**示例：**

```
输入:
letters = ["c", "f", "j"]
target = "a"
输出: "c"

输入:
letters = ["c", "f", "j"]
target = "c"
输出: "f"

输入:
letters = ["c", "f", "j"]
target = "d"
输出: "f"

输入:
letters = ["c", "f", "j"]
target = "g"
输出: "j"

输入:
letters = ["c", "f", "j"]
target = "j"
输出: "c"

输入:
letters = ["c", "f", "j"]
target = "k"
输出: "c"
```

**提示：**

1. `letters`长度范围在`[2, 10000]`区间内。
2. `letters` 仅由小写字母组成，最少包含两个不同的字母。
3. 目标字母`target` 是一个小写字母。

```java
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        int l = 0;
        int r = letters.length - 1;
        while (l <= r){
            int mid = (l+r)/2;
            if (letters[r] < target) break;
            if (letters[mid] > target) r = mid - 1;
            else l = mid + 1;
        }
        return r+1 < letters.length ? letters[r+1] : letters[0];
    }
}
```

#### [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

中等

给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。

**示例 1:**

```
输入: [1,1,2,3,3,4,4,8,8]
输出: 2
```

**示例 2:**

```
输入: [3,3,7,7,10,11,11]
输出: 10
```

**注意:** 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int l = 0, r = nums.length - 1;
        int mid = (l+r)/2;
        while (l <= r){
            if (mid > 0 && nums[mid] == nums[mid-1]){
                if ((r-mid)%2 == 0) r = mid - 2;
                else l = mid + 1;
            }else if (mid < nums.length-1 && nums[mid] == nums[mid+1]){
                if ((r-mid)%2 == 0) l = mid + 2;
                else r = mid - 1;
            }else break;
            mid = (l+r)/2;
        }
        return nums[mid];
    }
}
```

#### [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

简单

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 `n` 个版本 `[1, 2, ..., n]`，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 `bool isBadVersion(version)` 接口来判断版本号 `version` 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

**示例:**

```
给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -> false
调用 isBadVersion(5) -> true
调用 isBadVersion(4) -> true

所以，4 是第一个错误的版本。 
```

```java
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int l = 1, r = n;
        int mid = l + (r-l)/2;
        while (l < r){
            if (isBadVersion(mid)) r = mid-1;
            else l = mid+1;
            mid = l + (r-l)/2; //(l+r)/2容易超过int最大值
        }
        return isBadVersion(mid) ? mid : mid+1;
    }
}
```

#### [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

中等

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

**示例 1:**

```
输入: [3,4,5,1,2]
输出: 1
```

**示例 2:**

```
输入: [4,5,6,7,0,1,2]
输出: 0
```

```java
class Solution {
    public int findMin(int[] nums) {
        int l = 0, r = nums.length-1;
        int mid = l + (r-l)/2;
        while (l < r){
            if (nums[mid] > nums[r]) l = mid + 1;
            else if (nums[mid] < nums[l]) 
                r = mid; //mid有可能是答案，所以不能 mid-1
            else if (nums[mid] == nums[r]) r--;
            else return nums[l]; //l->r是升序的
            mid = l + (r-l)/2;
        }
        return nums[mid];
    }
}
```

#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

中等

给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 *O*(log *n*) 级别。

如果数组中不存在目标值，返回 `[-1, -1]`。

**示例 1:**

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
```

**示例 2:**

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0) return new int[]{-1,-1};
        
        int l = 0, r = nums.length - 1;
        int mid = l + (r-l)/2;
        while (l < r){
            if (nums[mid] == target) break;
            else if (nums[mid] > target) r = mid - 1;
            else l = mid + 1;
            mid = l + (r-l)/2;
        }
        if (nums[mid] != target) return new int[]{-1,-1};
        
        l = 0;
        r = mid;
        int i = l + (r-l)/2;
        while (l < r){
            if (nums[i] == target) r = i - 1;
            else l = i + 1;
            i = l + (r-l)/2;
        }
        i = nums[i] == target ? i : i+1;
        
        l = mid;
        r = nums.length - 1;
        int j = l + (r-l)/2;
        while (l < r){
            if (nums[j] == target) l = j + 1;
            else r = j - 1;
            j = l + (r-l)/2;
        }
        j = nums[j] == target ? j : j-1;
        
        return new int[]{i,j};
    }
}
```

## 频率排序

668,410,1044,887,4,300,483,658,354,911,644,862,793,718,378,1095,33,497]]></description></item><item><title>LeetCode 贪心</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/25/leetcode03.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 25 Jul 2020 06:52:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/25/leetcode03.html</guid><description><![CDATA[## 基础部分

#### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

简单

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**注意：**

你可以假设胃口值为正。
一个小朋友最多只能拥有一块饼干。

**示例 1:**

```
输入: [1,2,3], [1,1]

输出: 1

解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

**示例 2:**

```
输入: [1,2], [1,2,3]

输出: 2

解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int res = 0;
        int i = g.length-1;
        int j = s.length-1;
        while (i >= 0 && j >=0){
            if (s[j] >= g[i]){ //满足了拿去吃
                res++;
                j--;
            }
            i--;
        }
        return res;
    }
}
```

#### [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

中等

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

**注意:**

1. 可以认为区间的终点总是大于它的起点。
2. 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

**示例 1:**

```
输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**示例 2:**

```
输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

**示例 3:**

```
输入: [ [1,2], [2,3] ]

输出: 0

解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        int len = intervals.length;
        if (len < 2) return 0;
        Arrays.sort(intervals,(a,b)->(a[0]-b[0])); //以第一位升序排列
        List<int[]> list = new LinkedList<>();
        list.add(intervals[0]);
        for (int i = 0; i < intervals.length; i++) {
            int tail = list.get(list.size()-1)[1];
            if (tail > intervals[i][0]){
                if (tail > intervals[i][1]) //留尾巴短的，后边不易重叠
                    list.get(list.size()-1)[1] = intervals[i][1];
            }else list.add(intervals[i]);
        }
        return len - list.size();
    }
}
```

#### [452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

中等

在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。

一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

**Example:**

```
输入:
[[10,16], [2,8], [1,6], [7,12]]

输出:
2

解释:
对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。
```

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        if (points.length < 2) return points.length;
        Arrays.sort(points,(a,b)->(a[0]-b[0]));
        int res = 0;
        int i = 0;
        while (i < points.length){
            res++;
            int last = points[i][1];
            do {
                i++;
                if (i < points.length && points[i][1] < last) 
                    last = points[i][1]; //整体的尾巴往前才能都中
            }while (i < points.length && points[i][0] <= last);
        }
        return res;
    }
}
```

#### [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

中等

假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对`(h, k)`表示，其中`h`是这个人的身高，`k`是排在这个人前面且身高大于或等于`h`的人数。 编写一个算法来重建这个队列。

**注意：**
总人数少于1100人。

**示例**

```
输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people,(a,b)->a[1]-b[1]); //第二位正序
        Arrays.sort(people,(a,b)->b[0]-a[0]); //第一位倒序
        for (int i = 0; i < people.length; i++)
            if (people[i][1] != i) { //people[i][1]：该去的位置
                int j = i;
                int[] tmp = people[j];
                while (j != tmp[1]) { //tmp很关键，因为i和j都变化了，必须tmp
                    people[j] = people[j - 1];
                    j--;
                }
                people[j] = tmp;
            }
        return people;
    }
}
```

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

简单

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

```java
class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        int prof = 0;
        for (int i = 1; i < prices.length; i++) {
            int minus = prices[i] - prices[i-1];
            prof += minus;
            if (prof < 0) prof = 0; //负收益还不如不买
            else if (prof > res) res = prof;
        }
        return res;
    }
}
```

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

简单

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1**

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

- `1 <= prices.length <= 3 * 10 ^ 4`
- `0 <= prices[i] <= 10 ^ 4`

```java
class Solution {
    public int maxProfit(int[] prices) {
        int prof = 0;
        for (int i = 1; i < prices.length; i++) {
            int minus = prices[i] - prices[i-1];
            prof += minus > 0 ? minus : 0;
        }
        return prof;
    }
}
```

#### [605. 种花问题](https://leetcode-cn.com/problems/can-place-flowers/)

简单

假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 **n** 。能否在不打破种植规则的情况下种入 **n** 朵花？能则返回True，不能则返回False。

**示例 1:**

```
输入: flowerbed = [1,0,0,0,1], n = 1
输出: True
```

**示例 2:**

```
输入: flowerbed = [1,0,0,0,1], n = 2
输出: False
```

**注意:**

1. 数组内已种好的花不会违反种植规则。
2. 输入的数组长度范围为 [1, 20000]。
3. **n** 是非负整数，且不会超过输入数组的大小。

```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int k = 0;
        for (int i = 0; i < flowerbed.length && k<n; i++) {
            if (flowerbed[i] == 0){
                if (i+1 == flowerbed.length || flowerbed[i+1] == 0){
                    flowerbed[i] = 1;
                    k++;
                    i++; //下一个地方肯定不能种，跳过
                }
            }else {
                i++; //下一个地方肯定不能种，跳过
            }
        }
        return k >= n;
    }
}
```

#### [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

简单

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

你可以认为 **s** 和 **t** 中仅包含英文小写字母。字符串 **t** 可能会很长（长度 ~= 500,000），而 **s** 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**示例 1:**
**s** = `"abc"`, **t** = `"ahbgdc"`

返回 `true`.

**示例 2:**
**s** = `"axc"`, **t** = `"ahbgdc"`

返回 `false`.

**后续挑战** **:**

如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        char[] schars = s.toCharArray();
        char[] tchars = t.toCharArray();
        int i, j;
        for (i = 0,j = 0; i < schars.length; i++) {
            while (j < tchars.length && tchars[j] != schars[i]) j++;
            if (j >= tchars.length) break;
            j++;
        }
        return i == schars.length;
    }
}
```

#### [665. 非递减数列](https://leetcode-cn.com/problems/non-decreasing-array/)

简单

给你一个长度为 `n` 的整数数组，请你判断在 **最多** 改变 `1` 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的： 对于数组中所有的 `i` `(0 <= i <= n-2)`，总满足 `nums[i] <= nums[i + 1]`。

**示例 1:**

```
输入: nums = [4,2,3]
输出: true
解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。
```

**示例 2:**

```
输入: nums = [4,2,1]
输出: false
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。
```

**说明：**

- `1 <= n <= 10 ^ 4`
- `- 10 ^ 5 <= nums[i] <= 10 ^ 5`

```java
class Solution {
    public boolean checkPossibility(int[] nums) {
        int fix = 0;
        for (int i = 1; i < nums.length && fix <= 1; i++){
            if (nums[i] < nums[i-1]){
                fix++;
                if (i-2 >= 0 && nums[i]<nums[i-2]){ //突然有个数字小了
                    nums[i]=nums[i-1];
                }else { //前边的数字小了
                    nums[i-1]=nums[i];
                }
            }
        }
        return fix <= 1;
    }
}
```

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

简单

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例:**

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**进阶:**

如果你已经实现复杂度为 O(*n*) 的解法，尝试使用更为精妙的分治法求解。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = Integer.MIN_VALUE;
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            res = res > sum ? res : sum;
            sum = sum < 0 ? 0 : sum;
        }
        return res;
    }
}
```

#### [763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/)

中等

字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。

**示例 1：**

```
输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
```

**提示：**

- `S`的长度在`[1, 500]`之间。
- `S`只包含小写字母 `'a'` 到 `'z'` 。

```java
class Solution {
    public List<Integer> partitionLabels(String S) {
        char[] chars = S.toCharArray();
        Map<Character,Integer> map = new HashMap<>();
        for (int i = 0; i < chars.length; i++) {
            map.put(chars[i],i);
        }
        List<Integer> list = new LinkedList<>();
        int max = 0;
        int i = 0;
        int j = 0;
        while (j < chars.length){
            max = Math.max(max,map.get(chars[j]));
            if (j++ == max) {
                list.add(j-i);
                i = j;
            }
        }
        return list;
    }
}
```

## 频率排序

#### [135. 分发糖果](https://leetcode-cn.com/problems/candy/)

困难

老师想给孩子们分发糖果，有 *N* 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

- 每个孩子至少分配到 1 个糖果。
- 相邻的孩子中，评分高的孩子必须获得更多的糖果。

那么这样下来，老师至少需要准备多少颗糖果呢？

**示例 1:**

```
输入: [1,0,2]
输出: 5
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。
```

**示例 2:**

```
输入: [1,2,2]
输出: 4
解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
```

```java
class Solution {
    public int candy(int[] ratings) {
        int len = ratings.length;
        int[] res = new int[len];
        res[0] = 1;
        for (int i = 1; i < len; i++) {
            if (ratings[i] == ratings[i-1]) res[i] = 1;
            else if (ratings[i] > ratings[i-1]) res[i] = res[i-1]+1;
            else { //发现前面的孩子给少了
                res[i] = 1;
                int j = i;
                do {
                    j--;
                    if (res[j] <= res[j+1]){
                        res[j] = res[j+1] + 1;
                    }else {
                        break;
                    }
                }while (j > 0 && ratings[j] < ratings[j-1]);
            }
        }
        int candys = 0;
        for (int candy : res) candys += candy;
        return candys;
    }
}
```

#### [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/) ※

困难

给你一个仅包含小写字母的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

**示例 1:**

```
输入: "bcabc"
输出: "abc"
```

**示例 2:**

```
输入: "cbacdcbc"
输出: "acdb"
```

 ```java
public class Solution {
    public String removeDuplicateLetters(String s) {
        int[] cnt = new int[26];
        int pos = 0;
        for (int i = 0; i < s.length(); i++) //字母出现次数的字典
            cnt[s.charAt(i) - 'a']++;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) < s.charAt(pos)) pos = i; //后边的比pos的字典顺序小
            if (--cnt[s.charAt(i) - 'a'] == 0) break; //字典里减没了，pos可以放第一位
        }
        return s.length() == 0 ? "" : s.charAt(pos) + 
                removeDuplicateLetters(s.substring(pos + 1) //递归
                .replaceAll("" + s.charAt(pos), "") //这个字符统计完了，全部去掉
        ); 
    }
}
 ```

#### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

困难

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

**示例:**

```
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**说明:**

假设你总是可以到达数组的最后一个位置。

```java
class Solution {
    public int jump(int[] nums) {
        int res = 0;
        for (int i = nums.length - 1; i > 0; ) {
            int pos = i - 1;
            for (int j = 0; j < i; j++)
                if (nums[j] >= i-j) pos = Math.min(pos,j);
            res++;
            i = pos;
        }
        return res;
    }
}
```

#### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

中等

给定一个整数数组 `prices`，其中第 `i` 个元素代表了第 `i` 天的股票价格 ；非负整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**示例 1:**

```
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```

**注意:**

- `0 < prices.length <= 50000`.
- `0 < prices[i] < 50000`.
- `0 <= fee < 50000`.

```java
//未通过，不知道为什么
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int sum = 0;
        int[] profs = new int[prices.length-1];
        for (int i = 0; i < profs.length; i++)
            profs[i] = prices[i+1] - prices[i];
        int prof = 0;
        int drop = 0;
        for (int i = 0; i < profs.length; i++) {
            if (prof == 0 && profs[i] < 0) continue;
            if (profs[i] < 0){
                drop += profs[i];
                if (drop <= -fee) { //赔fee块钱，还不如交管理费卖了
                    if (prof > fee) sum += prof-fee;
                    drop = 0;
                    prof = 0;
                }
            }else {
                prof += drop + profs[i];
                drop = 0;
            }
        }
        sum += prof > fee ? prof - fee : 0; //最后一波没加上
        return sum;
    }
}
```

#### [402. 移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)

中等

给定一个以字符串表示的非负整数 *num*，移除这个数中的 *k* 位数字，使得剩下的数字最小。

**注意:**

- *num* 的长度小于 10002 且 ≥ *k。*
- *num* 不会包含任何前导零。

**示例 1 :**

```
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
```

**示例 2 :**

```
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

示例 **3 :**

```
输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
```

```java
class Solution {
    public String removeKdigits(String num, int k) {
        LinkedList<Character> stack = new LinkedList<>();

        for(char digit : num.toCharArray()) {
            while(!stack.isEmpty() && k > 0 && stack.peekLast() > digit) {
                //stack不为空，k大于0，前面的数大于后面的数
                stack.removeLast(); //去掉前面的数
                k -= 1; //去掉一次少一次机会
            }
            stack.addLast(digit);
        }
        
        for(int i=0; i<k; ++i) stack.removeLast(); //还有机会没用完
        
        StringBuilder res = new StringBuilder();
        while (stack.peekFirst() == '0') stack.pollFirst();
        for (Character c : stack) res.append(c);

        return res.length() > 0 ? res.toString() : "0";
    }
}
```

#### [1029. 两地调度](https://leetcode-cn.com/problems/two-city-scheduling/)

简单

公司计划面试 `2N` 人。第 `i` 人飞往 `A` 市的费用为 `costs[i][0]`，飞往 `B` 市的费用为 `costs[i][1]`。

返回将每个人都飞到某座城市的最低费用，要求每个城市都有 `N` 人抵达**。**

**示例：**

```
输入：[[10,20],[30,200],[400,50],[30,20]]
输出：110
解释：
第一个人去 A 市，费用为 10。
第二个人去 A 市，费用为 30。
第三个人去 B 市，费用为 50。
第四个人去 B 市，费用为 20。

最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。
```

**提示：**

1. `1 <= costs.length <= 100`
2. `costs.length` 为偶数
3. `1 <= costs[i][0], costs[i][1] <= 1000`

```java
class Solution {
    public int twoCitySchedCost(int[][] costs) {
        int potA = costs.length/2;
        int potB = costs.length/2;
        Arrays.sort(costs,(x, y)->Math.abs(y[0]-y[1])-Math.abs(x[0]-x[1])); //相差越多权重越高,，权重高的人先挑
        int res = 0;
        for (int i = 0; i < costs.length; i++) {
            int a = costs[i][0];
            int b = costs[i][1];
            if (a < b) {
                if (potA-- > 0) res += a;
                else res += b;
            } else {
                if (potB-- > 0) res += b;
                else res += a;
            }
        }
        return res;
    }
}
```

```java
//官方的，(A地-B地)的升序，这么简单吗，凭什么
class Solution {
    public int twoCitySchedCost(int[][] costs) {
        Arrays.sort(costs,(a,b)->a[0]-a[1]-b[0]+b[1]);
        int total = 0;
        int n = costs.length / 2;
        for (int i = 0; i < n; ++i) total += costs[i][0] + costs[i + n][1];
        return total;
    }
}
```
]]></description></item><item><title>LeetCode 排序</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/24/leetcode02.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 24 Jul 2020 03:21:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/24/leetcode02.html</guid><description><![CDATA[## 基础部分

#### [912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

中等

给你一个整数数组 `nums`，请你将该数组升序排列。

**示例 1：**

```
输入：nums = [5,2,3,1]
输出：[1,2,3,5]
```

**示例 2：**

```
输入：nums = [5,1,1,2,0,0]
输出：[0,0,1,1,2,5]
```

**提示：**

1. `1 <= nums.length <= 50000`
2. `-50000 <= nums[i] <= 50000`

```java
class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums,0,nums.length-1);
        return nums;
    }

    private void quickSort(int[] nums, int l, int r) {
        if (l >= r) return;
        int mid = pattern(nums,l,r);
        if (mid != l){
            int tmp = nums[mid];
            nums[mid] = nums[l];
            nums[l] = tmp;
        }
        quickSort(nums,l,mid-1);
        quickSort(nums,mid+1,r);
    }

    private int pattern(int[] nums, int l, int r) {
        int first = nums[l];
        int i = l;
        int j = r + 1;
        while (i < j){
            do { //先判断后加，会多加一个，所以 do..while
                i++;
            }while (nums[i] < first && i < r);
            do {
                j--;
            }while (nums[j] > first && j > l);
            if (i >= j) break; //弄多了就换回来了，所以检查一下
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
        return j;
    }
}
```

#### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

中等

在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例 1:**

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**说明:**

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

```java
//减治的快排
class Solution {
    public int findKthLargest(int[] nums, int k){
        quickSort(nums,k-1,0,nums.length-1);
        return nums[k-1];
    }

    private void quickSort(int[] nums, int index, int l, int r) {
        if (l >= r) return;
        int mid = pattern(nums,l,r);
        if (mid != l){
            int tmp = nums[mid];
            nums[mid] = nums[l];
            nums[l] = tmp;
        }
        if (mid > index) quickSort(nums,index,l,mid-1);
        else quickSort(nums,index,mid+1,r);
    }

    private int pattern(int[] nums, int l, int r) {
        int first = nums[l];
        int i = l;
        int j = r + 1;
        while (i < j){
            do {
                i++;
            }while (nums[i] > first && i < r);
            do {
                j--;
            }while (nums[j] < first && j > l);
            if (i >= j) break;
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
        return j;
    }
}
```

```java
//堆排序：建立k大小的小根堆，堆顶即为所求
class Solution {
    public int findKthLargest(int[] nums, int k){ //O(n*logk)
        //PriorityQueue 优先级队列，底层是二叉堆
        //(n1,n2)->n1-n2 小根堆
        PriorityQueue<Integer> heap = new PriorityQueue<>((n1,n2)->n1-n2);
        for (int num : nums) {
            heap.add(num); //O(logk)
            if (heap.size() > k) heap.poll(); //O(logk)
        }
        return heap.poll();
    }
}
```

#### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

中等

给定一个非空的整数数组，返回其中出现频率前 ***k\*** 高的元素。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

**提示：**

- 你可以假设给定的 *k* 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
- 你的算法的时间复杂度**必须**优于 O(*n* log *n*) , *n* 是数组的大小。
- 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
- 你可以按任意顺序返回答案。

```java
// 设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。
// 把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> map = new HashMap<>();
        for (int num : nums)
            map.put(num,map.getOrDefault(num,0)+1); //数字频数哈希表
        List<Integer>[] buckets = new LinkedList[nums.length+1];
        for (Integer num : map.keySet()){
            int freq = map.get(num);
            if (buckets[freq] == null) //没初始化=>没有内存=>没法add
                buckets[freq] = new LinkedList<>();
            buckets[freq].add(num); //放到对应频数的桶里
        }
        int[] res = new int[k];
        int index = 0;
        for (int i = buckets.length-1; i > 0 && index < k; i--) {
            if (buckets[i] == null) continue;
            for (Integer num : buckets[i])
                res[index++] = num;
        }
        return res;
    }
}
```

#### [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

中等

给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

**示例 1:**

```
输入:
"tree"

输出:
"eert"

解释:
'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```

**示例 2:**

```
输入:
"cccaaa"

输出:
"cccaaa"

解释:
'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。
注意"cacaca"是不正确的，因为相同的字母必须放在一起。
```

**示例 3:**

```
输入:
"Aabb"

输出:
"bbAa"

解释:
此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。
注意'A'和'a'被认为是两种不同的字符。
```

```java
class Solution {
    public String frequencySort(String s) {
        char[] chars = s.toCharArray();
        Map<Character,Integer> map = new HashMap<>();
        for (char aChar : chars)
            map.put(aChar,map.getOrDefault(aChar,0)+1);
        List<Character>[] buckets = new LinkedList[chars.length+1];
        for (Character c : map.keySet()) {
            int freq = map.get(c);
            if (buckets[freq] == null) buckets[freq] = new LinkedList<>();
            buckets[freq].add(c);
        }
        StringBuilder res = new StringBuilder();
        for (int i = buckets.length - 1; i > 0; i--) {
            if (buckets[i] == null) continue;
            for (Character c : buckets[i]) {
                for (int j = 0; j < i; j++) res.append(c);
                if (res.length() == chars.length) break;
            }
        }
        return res.toString();
    }
}
```

#### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

中等

给定一个包含红色、白色和蓝色，一共 *n* 个元素的数组，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**注意:**
不能使用代码库中的排序函数来解决这道题。

**示例:**

```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

**进阶：**

- 一个直观的解决方案是使用计数排序的两趟扫描算法。
  首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
- 你能想出一个仅使用常数空间的一趟扫描算法吗？

```java
// 0跟head换，head++；2跟tail换，tail--
// 换就完事了，判断一样费时间
// 注意：跟tail换时指针不往前走，因为不知道换个啥回来
class Solution {
    public void sortColors(int[] nums) {
        int head = 0, curr = 0;
        int tail = nums.length - 1;
        int tmp;
        while (curr <= tail) {
            if (nums[curr] == 0) {
                tmp = nums[head];
                nums[head++] = nums[curr];
                nums[curr++] = tmp;
            }
            else if (nums[curr] == 2) {
                tmp = nums[curr];
                nums[curr] = nums[tail];
                nums[tail--] = tmp;
            }
            else curr++;
        }
    }
}
```

## 频率排序

#### [853. 车队](https://leetcode-cn.com/problems/car-fleet/)

中等

`N` 辆车沿着一条车道驶向位于 `target` 英里之外的共同目的地。

每辆车 `i` 以恒定的速度 `speed[i]` （英里/小时），从初始位置 `position[i]` （英里） 沿车道驶向目的地。

一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车以相同的速度紧接着行驶。

此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。

*车队* 是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。

即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。

会有多少车队到达目的地?

**示例：**

```
输入：target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
输出：3
解释：
从 10 和 8 开始的车会组成一个车队，它们在 12 处相遇。
从 0 处开始的车无法追上其它车，所以它自己就是一个车队。
从 5 和 3 开始的车会组成一个车队，它们在 6 处相遇。
请注意，在到达目的地之前没有其它车会遇到这些车队，所以答案是 3。
```


**提示：**

1. `0 <= N <= 10 ^ 4`
2. `0 < target <= 10 ^ 6`
3. `0 < speed[i] <= 10 ^ 6`
4. `0 <= position[i] < target`
5. 所有车的初始位置各不相同。

```java
class Car{ //用类来整合比别的数据结构舒服
    int position;
    double time;

    public Car(int position, double time) {
        this.position = position;
        this.time = time;
    }
}
class Solution {
    public int carFleet(int target, int[] position, int[] speed) {
        int len = position.length;
        Car[] cars = new Car[len];
        for (int i = 0; i < len; i++)
            cars[i] = new Car(position[i],(double)(target-position[i])/speed[i]);
        Arrays.sort(cars,(x,y)->(y.position-x.position)); //按位置的降序
        int res = 0;
        for (int i = 0; i < len; i++) {
            res++;
            double head = cars[i].time;
            while (i < len && cars[i].time <= head) i++; //在我后边的，用时小于等于我的，才能追上我，和我同步到达
            i--; //for自带自增，会多加一次，所以减回来
        }
        return res;
    }
}
```

#### [179. 最大数](https://leetcode-cn.com/problems/largest-number/)

中等

给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。

**示例 1:**

```
输入: [10,2]
输出: 210
```

**示例 2:**

```
输入: [3,30,34,5,9]
输出: 9534330
```

**说明:** 输出结果可能非常大，所以你需要返回一个字符串而不是整数。

```java
class Solution {
    public String largestNumber(int[] nums) {
        //这样写会报错，基本数据类型都不能这么些，所以后边先把int[]转成了String[]
        //Arrays.sort(nums,(x,y) -> (String.valueOf(y)+String.valueOf(x)).compareTo(String.valueOf(x)+String.valueOf(y));
        String[] strs = new String[nums.length];
        for(int i = 0; i < nums.length; i++)
            strs[i] = String.valueOf(nums[i]);
        Arrays.sort(strs, (x, y) -> (y + x).compareTo(x + y));
        StringBuilder res = new StringBuilder();
        for(String s : strs)
            res.append(s);
        return res.toString();
    }
}
```

#### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

中等

在 *O*(*n* log *n*) 时间复杂度和常数级空间复杂度下，对链表进行排序。

**示例 1:**

```
输入: 4->2->1->3
输出: 1->2->3->4
```

**示例 2:**

```
输入: -1->5->3->4->0
输出: -1->0->3->4->5
```

```java
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) 
            return head; //递归到头只有head了，这时候开始merge
        ListNode slow = head, fast = head.next;
        while (fast != null && fast.next != null){ //二分链表
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode head2 = slow.next;
        slow.next = null;
        return merge(sortList(head),sortList(head2)); //递归合并
    }

    private ListNode merge(ListNode a,ListNode b) { //合并有序链表
        ListNode node = new ListNode(0);
        ListNode p = node;
        while (a != null && b != null){
            if (a.val < b.val){
                p.next = a;
                a = a.next;
            }else {
                p.next = b;
                b = b.next;
            }
            p = p.next;
        }
        p.next = a != null ? a : b;
        return node.next;
    }
}
```

#### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

中等

给出一个区间的集合，请合并所有重叠的区间。

**示例 1:**

```
输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2:**

```
输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length < 2) return intervals;
        Arrays.sort(intervals,(a,b)->(a[0]-b[0]));
        List<int[]> list = new LinkedList<>();
        list.add(intervals[0]);
        for (int i = 1; i < intervals.length; i++) {
            int tail = list.get(list.size()-1)[1];
            if (intervals[i][0] > tail){
                list.add(intervals[i]);
            }else if (intervals[i][1] > tail){
                list.get(list.size()-1)[1] = intervals[i][1];
            }
        }
        int len = list.size();
        int[][] res = new int[len][2];
        for (int i = 0; i < len; i++) {
            res[i] = list.get(i);
        }
        return res;
    }
}
```]]></description></item><item><title>LeetCode 双指针</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/22/leetcode01.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Wed, 22 Jul 2020 08:43:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/22/leetcode01.html</guid><description><![CDATA[## 基础部分

#### [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

简单

给定一个已按照***升序排列\*** 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2*。*

**说明:**

- 返回的下标值（index1 和 index2）不是从零开始的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例:**

```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int i = 0;
        int j = numbers.length - 1;
        while (i < j){
            if (numbers[i]+numbers[j] < target){
                i++;
            }else if (numbers[i]+numbers[j] > target){
                j--;
            }else {
                return new int[]{i+1,j+1};
            }
        }
        return new int[]{};
    }
}
```

#### [633. 平方数之和](https://leetcode-cn.com/problems/sum-of-square-numbers/)

简单

给定一个非负整数 `c` ，你要判断是否存在两个整数 `a` 和 `b`，使得 a2 + b2 = c。

**示例1:**

```
输入: 5
输出: True
解释: 1 * 1 + 2 * 2 = 5
```

**示例2:**

```
输入: 3
输出: False
```

```java
class Solution {
    public boolean judgeSquareSum(int c) {
        int i = 0;
        int j = (int)Math.sqrt(c);
        while (i <= j){
            if (i*i+j*j < c){
                i++;
            }else if (i*i+j*j > c){
                j--;
            }else return true;
        }
        return false;
    }
}
```

#### [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

简单

编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

**示例 1:**

```
输入: "hello"
输出: "holle"
```

**示例 2:**

```
输入: "leetcode"
输出: "leotcede"
```

**说明:**
元音字母不包含字母"y"。

```java
class Solution {
    public String reverseVowels(String s) {
        char[] chars = s.toCharArray();
        int i = 0;
        int j = chars.length - 1;
        Set<Character> set = new HashSet<>();
        set.add('a');
        set.add('e');
        set.add('i');
        set.add('o');
        set.add('u');
        set.add('A');
        set.add('E');
        set.add('I');
        set.add('O');
        set.add('U');
        while (i < j){
            while (i < j && !set.contains(chars[i])) i++;
            while (i < j && !set.contains(chars[j])) j--;
            if (chars[i] != chars[j]){
                char tmp = chars[i];
                chars[i] = chars[j];
                chars[j] = tmp;
            }
            i++;
            j--;
        }
        return String.valueOf(chars);
    }
}
```

#### [680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)

简单

给定一个非空字符串 `s`，**最多**删除一个字符。判断是否能成为回文字符串。

**示例 1:**

```
输入: "aba"
输出: True
```

**示例 2:**

```
输入: "abca"
输出: True
解释: 你可以删除c字符。
```

**注意:**

1. 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。

```java
class Solution {
    public boolean validPalindrome(String s) {
        char[] chars = s.toCharArray();
        int i = 0;
        int j = chars.length - 1;
        while (i < j){
            if (chars[i] == chars[j]){
                i++;
                j--;
            }else return helper(chars,i+1,j) || helper(chars,i,j-1);
        }
        return true;
    }

    private boolean helper(char[] chars, int i, int j) {
        while (i < j){
            if (chars[i] != chars[j]) return false;
            i++;
            j--;
        }
        return true;
    }
}
```

#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

简单

给你两个有序整数数组 *nums1* 和 *nums2*，请你将 *nums2* 合并到 *nums1* 中*，*使 *nums1* 成为一个有序数组。

**说明:**

- 初始化 *nums1* 和 *nums2* 的元素数量分别为 *m* 和 *n* 。
- 你可以假设 *nums1* 有足够的空间（空间大小大于或等于 *m + n*）来保存 *nums2* 中的元素。

**示例:**

```
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        if (n==0) return;
        int i = 0;
        int j = 0;
        while (i < m){
            if (nums1[i] > nums2[j]){
                int tmp = nums1[i];
                nums1[i] = nums2[j];
                nums2[j] = tmp;
                for (int k = 0; k < n-1; k++) {
                    if (nums2[k] > nums2[k+1]){
                        tmp = nums2[k];
                        nums2[k] = nums2[k+1];
                        nums2[k+1] = tmp;
                    }else break;
                }
            }
            i++;
        }
        while (j < n) nums1[i++] = nums2[j++];
    }
}
```

#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

简单

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。

**示例 1：**

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200722163748547-1746836563.png)


**示例 2：**

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200722163803908-2087647472.png)


**示例 3：**

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200722163815795-1712532162.png)


**进阶：**

你能用 *O(1)*（即，常量）内存解决此问题吗？

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        ListNode quick = head;
        while (quick != null && quick.next != null){
            slow = slow.next;
            quick = quick.next.next;
            if (quick == slow) return true;
        }
        return false;
    }
}
```

#### [524. 通过删除字母匹配到字典里最长单词](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)

中等

给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。

**示例 1:**

```
输入:
s = "abpcplea", d = ["ale","apple","monkey","plea"]

输出: 
"apple"
```

**示例 2:**

```
输入:
s = "abpcplea", d = ["a","b","c"]

输出: 
"a"
```

**说明:**

1. 所有输入的字符串只包含小写字母。
2. 字典的大小不会超过 1000。
3. 所有输入的字符串长度不会超过 1000。

```java
class Solution {
    public String findLongestWord(String s, List<String> d) {
        StringBuilder res = new StringBuilder();
        char[] chars = s.toCharArray();
        for (String s1 : d) {
            char[] chs = s1.toCharArray();
            int j = 0;
            for (int i = 0; i < chars.length && j < chs.length; i++)
                if (chars[i] == chs[j]) j++;
            if (j == chs.length && chs.length > res.length()) //长度更长的
                res.delete(0, res.length()).append(s1);
            else if (j == chs.length && chs.length == res.length() && String.valueOf(chs).compareTo(String.valueOf(res)) < 0) //长度相同的，取字典前面的
                res.delete(0, res.length()).append(s1);
        }
        return res.toString();
    }
}
```

## 频率排序

#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

困难

给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200722163845099-1816214531.png)


上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 **感谢 Marcos** 贡献此图。

**示例:**

```
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

```java
class Solution {
    public int trap(int[] height) {
        int res = 0;
        int i = 0;
        int j = height.length - 1;
        int l = 0; // 左侧最大值
        int r = 0; // 右侧最大值
        while (i <= j){ // = 很关键
            if (l < r){
                if (height[i] < l) res += l - height[i];
                else l = height[i];
                i++;
            }else {
                if (height[j] < r) res += r - height[j];
                else r = height[j];
                j--;
            }
        }
        return res;
    }
}
```

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

中等

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        char[] chars = s.toCharArray();
        int i = 0;
        int j = 0;
        int res = 0;
        int len = 0;
        while (i < chars.length && j < chars.length){
            if (!set.contains(chars[j])){
                set.add(chars[j]);
                len++;
                if (res < len) res = len;
            }else {
                while (chars[i] != chars[j]){
                    set.remove(chars[i]);
                    i++;
                }
                len = j - i; //去掉前面之后的新长度，肯定比max小，不用管
                i++;
            }
            j++;
        }
        return res;
    }
}
```

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

中等

给你一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？请你找出所有满足条件且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例：**

```
给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> lists = new LinkedList<>();
        Set<List<Integer>> sets = new HashSet<>();
        Arrays.sort(nums);
        for (int i = 0; i < nums.length - 2; i++) {
            if (i != 0 && nums[i-1] == nums[i]) continue; //去点重复的
            int j = i + 1;
            int k = nums.length - 1;
            while (j < k){
                if (nums[i] + nums[j] + nums[k] == 0){
                    sets.add(Arrays.asList(nums[i],nums[j],nums[k]));
                    j++;
                    k--;
                }else if (nums[i] + nums[j] + nums[k] < 0) j++;
                else k--;
            }
        }
        lists.addAll(sets);
        return lists;
    }
}

```

#### [763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/)

中等

字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。

**示例 1：**

```
输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
```

**提示：**

- `S`的长度在`[1, 500]`之间。
- `S`只包含小写字母 `'a'` 到 `'z'` 。

```java
class Solution {
    public List<Integer> partitionLabels(String S) {
        List<Integer> list = new LinkedList<>();
        char[] chars = S.toCharArray();
        int[] letters = new int[26];
        for (int i = 0; i < chars.length; i++)
            letters[chars[i]-'a'] = i; //记录最右
        int i = 0;
        int j = 0;
        int max = 0;
        while (j < chars.length) {
            do {
                max = Math.max(max,letters[chars[j]-'a']);
                j++;
            }while (j <= max); //知道j超过max一位
            list.add(j-i);
            i = j;
        }
        return list;
    }
}
```

#### [845. 数组中的最长山脉](https://leetcode-cn.com/problems/longest-mountain-in-array/)

中等

我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “山脉”：

- `B.length >= 3`
- 存在 `0 < i < B.length - 1` 使得 `B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]`

（注意：B 可以是 A 的任意子数组，包括整个数组 A。）

给出一个整数数组 `A`，返回最长 “山脉” 的长度。

如果不含有 “山脉” 则返回 `0`。

**示例 1：**

```
输入：[2,1,4,7,3,2,5]
输出：5
解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。
```

**示例 2：**

```
输入：[2,2,2]
输出：0
解释：不含 “山脉”。
```

**提示：**

1. `0 <= A.length <= 10000`
2. `0 <= A[i] <= 10000`

```java
class Solution {
    public int longestMountain(int[] A) {
        if (A.length < 3) return 0;
        int[] arr = new int[A.length-1];
        for (int i = 0; i < arr.length; i++) {
            if (A[i] > A[i+1])arr[i] = -1; //下坡
            else if (A[i] < A[i+1]) arr[i] = 1; //上坡
            else arr[i] = 0; //平
        }
        int max = 0;
        int i;
        int j = 0;
        while (j < arr.length){ //山脉=[1,1,-1,-1]
            while (j < arr.length && arr[j]!=1) j++;
            i = j;
            while (j < arr.length && arr[j]==1) j++;
            if (j >=arr.length || arr[j]==0) continue;
            while (j < arr.length && arr[j]==-1) j++;
            max = Math.max(max,j-i+1); //取最大
        }
        return max;
    }
}
```

#### [713. 乘积小于K的子数组](https://leetcode-cn.com/problems/subarray-product-less-than-k/)

难度中等143

给定一个正整数数组 `nums`。

找出该数组内乘积小于 `k` 的连续的子数组的个数。

**示例 1:**

```
输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。
```

**说明:**

- `0 < nums.length <= 50000`
- `0 < nums[i] < 1000`
- `0 <= k < 10^6`

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        if (k <= 1) return 0;
        int res = 0;
        int mul = 1;
        int left = 0;
        for (int right = 0; right < nums.length; right++) {
            mul *= nums[right];
            while (mul >= k) mul /= nums[left++];
            res += right - left + 1; //※※※很关键
            // [1,2,3,4,5] 25
            // 1,2,3,4都成了，以4结尾的其他的都能成，所以直接res加4-1+1=4
        }
        return res;
    }
}
```

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

难度中等1653

给你 *n* 个非负整数 *a*1，*a*2，...，*a*n，每个数代表坐标中的一个点 (*i*, *ai*) 。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 (*i*, *ai*) 和 (*i*, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器，且 *n* 的值至少为 2。

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200722163918801-1105566923.png)


图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

**示例：**

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49
```

```java
class Solution {
    public int maxArea(int[] height) {
        int res = 0;
        int i = 0;
        int j = height.length - 1;
        while (i < j){ //谁短谁动
            if (height[i] < height[j]){
                res = Math.max(res,(j-i)*height[i]);
                i++;
            }else {
                res = Math.max(res,(j-i)*height[j]);
                j--;
            }
        }
        return res;
    }
}
```

#### [1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)

中等

给定一个由若干 `0` 和 `1` 组成的数组 `A`，我们最多可以将 `K` 个值从 0 变成 1 。

返回仅包含 1 的最长（连续）子数组的长度。

**示例 1：**

```
输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释： 
[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
```

**示例 2：**

```
输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。
```

**提示：**

1. `1 <= A.length <= 20000`
2. `0 <= K <= A.length`
3. `A[i]` 为 `0` 或 `1` 

```java
class Solution {
    public int longestOnes(int[] A, int K) {
        int res = 0;
        for (int i = 0; i < A.length; i++) {
            if (i > 0 && A[i-1] == 1) continue; //前一个是1，这个点肯定统计过了
            if (i + K < A.length && A[i] == 0 && A[i+K] == 0) continue; //K步之内到不了1或者最后一位，没必要算
            int chance = K;
            int j = i;
            for (; j < A.length; j++) {
                if (A[j] != 1) {
                    if (chance == 0) break;
                    chance--;
                }
            }
            res = Math.max(res,j-i);
        }
        return res;
    }
}
```

#### [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

中等

给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```

**说明：**

给定的 *n* 保证是有效的。

**进阶：**

你能尝试使用一趟扫描实现吗？

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode first = head;
        ListNode second = head;
        while (n-->0) first = first.next;
        if (first == null)
            return head.next; //n是链表长度，删掉头结点
        while (first.next != null){
            first = first.next;
            second = second.next;
        }
        ListNode p = second.next.next;
        second.next = p;
        return head;
    }
}
```

#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

困难

给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。

**示例：**

```
输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
```

**说明：**

- 如果 S 中不存这样的子串，则返回空字符串 `""`。
- 如果 S 中存在这样的子串，我们保证它是唯一的答案

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200722164217689-1576337738.gif)


```java
class Solution {
    public static String minWindow(String s, String t) {
        int[] map = new int[256]; //char 256个
        char[] tchars = t.toCharArray();
        for (int i = 0; i < tchars.length; i++)
            map[tchars[i]]++; //模拟的字典
        int l = 0;
        int r = -1;
        char[] chars = s.toCharArray();
        int begin = -1,end = chars.length; //结果的两头坐标
        while (l < chars.length && r < chars.length){ //O(S)
            boolean flag = true; //判断是否都出现全了
            for (char tchar : tchars) { //O(T)
                if (map[tchar] > 0){ // 有一个大于0就不行,说明差东西
                    flag = false;
                    break;
                }
            }
            if (flag){
                if (end - begin > r - l){
                    begin = l;
                    end = r;
                }
                map[chars[l]]++;
                l++;
            }else {
                if (++r >= chars.length) break;
                map[chars[r]]--;
            }
        }
        return begin == -1 ? "" : s.substring(begin,end+1);
    }
}
```

#### [838. 推多米诺](https://leetcode-cn.com/problems/push-dominoes/)

中等

一行中有 `N` 张多米诺骨牌，我们将每张多米诺骨牌垂直竖立。

在开始时，我们同时把一些多米诺骨牌向左或向右推。

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200722164020294-1309869682.png)


每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。

同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。

如果同时有多米诺骨牌落在一张垂直竖立的多米诺骨牌的两边，由于受力平衡， 该骨牌仍然保持不变。

就这个问题而言，我们会认为正在下降的多米诺骨牌不会对其它正在下降或已经下降的多米诺骨牌施加额外的力。

给定表示初始状态的字符串 "S" 。如果第 i 张多米诺骨牌被推向左边，则 `S[i] = 'L'`；如果第 i 张多米诺骨牌被推向右边，则 `S[i] = 'R'`；如果第 i 张多米诺骨牌没有被推动，则 `S[i] = '.'`。

返回表示最终状态的字符串。

**示例** **1**：

```
输入：".L.R...LR..L.."
输出："LL.RR.LLRRLL.."
```

**示例** **2**：

```
输入："RR.L"
输出："RR.L"
说明：第一张多米诺骨牌没有给第二张施加额外的力。
```

**提示：**

1. `0 <= N <= 10^5`
2. 表示多米诺骨牌状态的字符串只含有 `'L'`，`'R'`; 以及 `'.'`;

```java
class Solution {
    public String pushDominoes(String dominoes) {
        StringBuilder sb = new StringBuilder();
        char[] chars = dominoes.toCharArray();
        int len = chars.length;
        double[] d1 = new double[len];
        double[] d2 = new double[len];
        for (int i = 0; i < len; i++) {
            if (chars[i] == 'L'){
                d1[i] = -1;
            }else if (chars[i] == 'R'){
                d1[i] = 1;
            }else {
                if (i == 0) d1[i] = 0;
                else d1[i] = d1[i-1] > 0 ? d1[i-1] / 2 : 0;
                //离得越远，影响越小，所以减半
            }
        }
        for (int i = len - 1; i >= 0; i--) {
            if (chars[i] == 'L'){
                d2[i] = -1;
            }else if (chars[i] == 'R'){
                d2[i] = 1;
            }else {
                if (i == len-1) d2[i] = 0;
                else d2[i] = d2[i+1] <0 ? d2[i+1] / 2 : 0;
            }
        }
        for (int i = 0; i < len; i++) {
            if (d1[i] + d2[i] > 0){
                sb.append('R');
            }else if (d1[i] + d2[i] < 0){
                sb.append('L');
            }else {
                sb.append('.');
            }
        }
        return sb.toString();
    }
}
```
]]></description></item><item><title>八大排序算法 Java实现</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/14/java_30.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 14 Jul 2020 09:09:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/14/java_30.html</guid><description><![CDATA[### 一、插入排序

稳定排序

**模板**

```java
class Sort {
    public static <AnyTpye extends Comparable<? super AnyTpye>> void insertionSort(AnyTpye[] a){ //Comparable可以比较的数或对象
        int j;
        for (int p =1;p < a.length;p++){ //默认a[0]是有序的，所以从1开始
            AnyTpye tmp = a[p]; //暂存要插入的p号元素
            //把p号元素从本身开始往前比较，直到比前一个数大，终止循环，可以插入
            for (j = p;j>0 && tmp.compareTo(a[j-1])<0;j--) 
                a[j] = a[j-1];
            a[j] = tmp;
        }
    }
}
```

**应用**

```java
import java.util.Arrays;

class Sort{
    public static void insertionSort(int[] a){
        int j;
        for (int p = 1; p < a.length; p++) {
            int tmp = a[p];
            for (j = p;j>0 && tmp<a[j-1];j--){
                a[j] = a[j-1];
            }
            a[j] = tmp;
        }
    }

    public static void main(String[] args) {
        int[] nums = {8,34,64,51,32,21};
        insertionSort(nums);
        System.out.println(Arrays.toString(nums));
    }
}
```

**分析**

时间复杂度`O(N^2)`

N个互异数的数组的平均逆序数是`N(N-1)/4`

通过交换相邻元素进行排序的任何算法平均都需要`Ω(N^2)`时间

### 二、希尔排序

非稳定排序

**模板**

```java
class Sort{
    public static <AnyTpye extends Comparable<? super AnyTpye>> void shellSort(AnyTpye[] a){
        int j;
        //在不同的gap上用插入排序
        for (int gap = a.length/2;gap > 0;gap /= 2)
            for (int i = gap;i < a.length;i++){
                AnyTpye tmp = a[i];
                for (j = i;j>=gap && tmp.compareTo(a[j-gap])<0;j -= gap)
                    a[j] = a[j-gap];
                a[j] = tmp;
            }
    }
}
```

**应用**

```java
import java.util.Arrays;

class Sort{
    public static void shellSort(int[] a){
        int j;
        for (int gap = a.length/2;gap > 0;gap /= 2){
            for (int i = gap;i < a.length;i++){
                int tmp = a[i];
                for (j = i;j >= gap && tmp < a[j-gap];j -= gap){
                    a[j] = a[j-gap];
                }
                a[j] = tmp;
            }
        }
    }

    public static void main(String[] args) {
        int[] nums = {8,34,64,51,32,21};
        shellSort(nums);
        System.out.println(Arrays.toString(nums));
    }
}
```

**分析**

使用希尔增量（`{1,4,8...,2^k}`）的希尔排序，最坏时间复杂度`O(N^2)`

使用 Hibbard 增量（`{1,3,7,...2^k-1}`）的希尔排序，最坏时间复杂度`O(N^1.5)`，它跟希尔增量的区别在于相邻增量没有公因数

最优的增量序列：`{1,5,19,41,109,...,9*(4^k-2^k)+1,4^i-3*2^i+1,...}`

### 三、选择排序

```java
import java.util.Arrays;

class Sort{
    private static void chooseSort(int[] nums){
        for (int i = 0; i < nums.length-1; i++) {
            int k = i;
            for (int j = i+1; j < nums.length; j++) {
                if (nums[k] > nums[j]) k = j; //选出最小数的角标
            }
            if (k!=i){ //最小的不是自己则需要拿到前面
                int tmp = nums[i];
                nums[i] = nums[k];
                nums[k] = tmp;
            }
        }
    }

    public static void main(String[] args) {
        int[] nums = {8,34,64,51,32,21};
        chooseSort(nums);
        System.out.println(Arrays.toString(nums));
    }
}
```

### 四、堆排序

完全二叉树，第 i 个结点为例，左孩子为 2i+1，右孩子为 2i+2

```java
public class HeapSort {
    public static void main(String[] args) {
//        int[] arr = {5, 1, 7, 3, 1, 6, 9, 4};
        int[] arr = {16, 7, 3, 20, 17, 8};

        heapSort(arr);

        for (int i : arr) {
            System.out.print(i + " ");
        }
    }


    //创建堆 
    private static void heapSort(int[] arr) {
        //创建堆
        for (int i = (arr.length - 1) / 2; i >= 0; i--) {
            //从第一个非叶子结点从下至上，从右至左调整结构
            adjustHeap(arr, i, arr.length);
        }

        //调整堆结构+交换堆顶元素与末尾元素
        for (int i = arr.length - 1; i > 0; i--) {
            //将堆顶元素与末尾元素进行交换
            int temp = arr[i];
            arr[i] = arr[0];
            arr[0] = temp;

            //重新对堆进行调整，调前i个就行了
            adjustHeap(arr, 0, i);
        }
    }

    //调整堆
    private static void adjustHeap(int[] arr, int parent, int length) {
        //将temp作为父节点
        int temp = arr[parent];
        //左孩子
        int lChild = 2 * parent + 1;

        while (lChild < length) {
            //右孩子
            int rChild = lChild + 1;
            // 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点
            if (rChild < length && arr[lChild] < arr[rChild]) {
                lChild++;
            }

            // 如果父结点的值已经大于孩子结点的值，则直接结束
            if (temp >= arr[lChild]) {
                break;
            }

            // 把孩子结点的值赋给父结点
            arr[parent] = arr[lChild];

            //选取孩子结点的左孩子结点,继续向下筛选
            parent = lChild;
            lChild = 2 * lChild + 1;
        }
        arr[parent] = temp;
    }
}
```

### 五、冒泡排序

```java
import java.util.Arrays;

class Sort{
    private static void chooseSort(int[] nums){
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < nums.length - i - 1; j++) {
                if (nums[j] > nums[j+1]){
                    int tmp = nums[j];
                    nums[j] = nums[j+1];
                    nums[j+1] = tmp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] nums = {8,34,64,51,32,21};
        chooseSort(nums);
        System.out.println(Arrays.toString(nums));
    }
}
```

### 六、快速排序

```java
import java.util.Arrays;

class Sort{
    private static void quickSort(int[] nums){
        quickSort(nums, 0, nums.length - 1);
    }

    private static void quickSort(int[] nums, int l, int r) {
        if (l >= r) return;
        int index = helper(nums,l,r);
        quickSort(nums,l,index-1);
        quickSort(nums,index+1,r);
    }

    private static int helper(int[] nums,int l,int r){
        int i = l;
        int j = r;
        int x = nums[i];
        while (i < j){
            while (i < j && nums[j] >= x){
                j--;
            }
            if (i < j){
                nums[i] = nums[j];
            }
            while (i < j && nums[i] <= x){
                i++;
            }
            if (i < j){
                nums[j] = nums[i];
            }
        }
        nums[i] = x;
        return i;
    }

    public static void main(String[] args) {
        int[] nums = {8,34,64,51,32,21};
        quickSort(nums);
        System.out.println(Arrays.toString(nums));
    }
}
```

### 七、归并排序

```java
import java.util.Arrays;

class Sort{
    private static void mergeSort(int[] nums){
        mergeSort(nums,0,nums.length-1);
    }

    private static void mergeSort(int[] nums, int left, int right) {
        if (left < right){
            int center = (left + right) / 2;
            mergeSort(nums,left,center); //递归调用
            mergeSort(nums,center+1,right);
            merge(nums,left,center,right); //连接两个有序数组
        }
    }

    private static void merge(int[] nums, int left, int center, int right) {
        int[] tmpNums = new int[nums.length];
        int mid = center + 1; //后边数组的开始
        int third = left;
        int tmp = left; //留到最后拷贝数组用
        while (left <= center && mid <= right){
            if (nums[left] <= nums[mid]){
                tmpNums[third++] = nums[left++];
            }else {
                tmpNums[third++] = nums[mid++];
            }
        }
        while (mid <= right){
            tmpNums[third++] = nums[mid++];
        }
        while (left <= center){
            tmpNums[third++] = nums[left++];
        }
        while (tmp <= right){
            nums[tmp] = tmpNums[tmp++];
        }
    }
    
    public static void main(String[] args) {
        int[] nums = {8,34,64,51,32,21};
        mergeSort(nums);
        System.out.println(Arrays.toString(nums));
    }
}
```

### 八、基排序

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200714170842943-1766924375.gif)


```java
public class RadixSort {
    public static void main(String[] args) {
        int[] arr = {63, 157, 189, 51, 101, 47, 141, 121, 157, 156,
                194, 117, 98, 139, 67, 133, 181, 12, 28, 0, 109};

        radixSort(arr);

        System.out.println(Arrays.toString(arr));
    }

    private static void radixSort(int[] arr) {
        //待排序列最大值
        int max = arr[0];
        int exp;//指数

        //计算最大值，确定最高位数
        for (int anArr : arr) {
            if (anArr > max) {
                max = anArr;
            }
        }

        //从个位开始，对数组进行排序
        for (exp = 1; max / exp > 0; exp *= 10) {
            //存储待排元素的临时数组
            int[] temp = new int[arr.length];
            //分桶个数
            int[] buckets = new int[10];

            //将数据出现的次数存储在buckets中
            for (int value : arr) {
                //(value / exp) % 10 :value的最底位(个位)
                buckets[(value / exp) % 10]++;
            }

            //更改buckets[i]，
            for (int i = 1; i < 10; i++) {
                buckets[i] += buckets[i - 1];
            }

            //将数据存储到临时数组temp中
            for (int i = arr.length - 1; i >= 0; i--) {
                temp[buckets[(arr[i] / exp) % 10] - 1] = arr[i];
                buckets[(arr[i] / exp) % 10]--;
            }

            //将有序元素temp赋给arr
            System.arraycopy(temp, 0, arr, 0, arr.length);
        }

    }
}
```
]]></description></item><item><title>JVM原理 GC算法</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/12/java_29.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 12 Jul 2020 04:12:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/12/java_29.html</guid><description><![CDATA[![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120340079-489288914.png)


1. JVM的位置

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120359832-1529334133.png)


2. JVM的体系结构

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120411755-880164691.png)


   所谓JVM调优就是调 方法区 和 堆

3. 类加载器

   作用：加载 Class 文件

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120428373-139551127.png)


![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120440859-976198654.png)


   3.1 虚拟机自带的加载器

   3.2 启动类（根）加载器

   3.3 扩展类加载器

   3.4 应用程序加载类

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120453263-474480991.png)


4. 双亲委派机制

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120508021-1094584224.png)


   作用：保证安全

   java程序往上找，BOOT( rt.jar 优先执行 ) => EXC  => APP，找不到才执行自己的方法

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120534609-1176408101.png)


5. 沙箱安全机制

   字节码校验器(bytecode verifier)：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存
   保护。但并不是所有的类文件都会经过字节码校验，比如核心类。

   JRE = { 类加载器 => 字节码校验器 => 解释器 }

6. Native

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120550829-1380631856.png)


   本地方法栈通过JNI连接本地方法接口，本地方法接口调用本地方法库

7. PC寄存器

   程序计数器：Program Counter Register
   每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向像一条指令的地址， 也即将要执行的指令代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计

8. 方法区

   方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间
   **静态变量 static、常量 final、类信息 Class（构造方法、接口定义）、运行时的 常量池 存在方法区中，但是实例变量存在堆内存中，和方法区无关**

9. 栈

   main 先执行，最后结束

   栈：栈内存,主管程序的运行，生命周期和线程同步

   线程结束，栈内存也就是释放，对于栈来说，不存在垃圾回收问题

   栈：8大基本类型 + 对象引用 + 实例的方法

   栈运行原理：栈帧

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120611226-163710291.png)


   栈满了：StackOverFlowError 是错误，不是异常

   栈 + 堆 + 方法区：交互关系

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120619531-1884043014.png)


10. 三种JVM

    + Sun公司 HotSpot
    + Bea公司 JRockit
    + IBM公司 J9

11. 堆 Heap

    一个JVM只有一个堆内存，堆内存的大小是可以调节的

    类加载器读取了类文件后，把什么放到堆中？类，方法，常量，变量 ~ 保存所有引用类型的真实变量

    三个区域：

    + 新生区（伊甸园区 Eden，幸存区0区，幸存区1区）
    + 养老区
    + 永久区

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120641021-2015376698.png)


    GC垃圾回收，主要是在伊甸园区和养老区

    假设内存满了，OOM，堆内存不够

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120657809-121141899.png)


    在JDK8以后，永久存储区改了名字（元空间）

12. 新生区

    + 类：诞生和成长的地方，甚至死亡
    + 伊甸园区：所有的对象都是在伊甸园区new出来的
    + 幸存者区（0, 1）：

13. 老年区

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120720338-1162720439.png)


    经过研究，99%的对象都是临时对象

14. 永久区

    这个区域常驻内存的。用来存放JDK自身携带的Class对象。Interface元数据，存储的是ava运行时的一些环境或类信息，这个区域不存在垃圾回收！关闭虚拟机，就会释放这个区域的内存

    一个启动类加载了大量的第三方jar包，tomcat部署了太多的应用，大量动态生成的反射类。一旦不断地被加载，知道内存满，就会出现OOM

    + jdk 1.6 之前：永久代，常量池在方法区中
    + jdk 1.7：永久代，但是慢慢地退化了，去永久代，常量池在堆中
    + jdk 1.8 之后：无永久代，常量池在元空间

15. 堆内存调优

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120732105-1761754802.png)


    手动调节堆内存

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120742848-311070810.png)


    ```
    OOM之后怎么解决
    1.扩大堆内存空间，看结果
    -Xms1024m -Xmx1024m -XX:+PrintGCDetails
    2.还不行说明代码有问题，导致内存出问题
    ```

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120802959-1242096697.png)


    幸存0区1区，即from区to区

    Heap内存 = Young + Old，Metaspace元空间，不在堆里

    JVM总内存 = Heap + Metaspace，Metaspace增大后会占用更多空间，导致Heap内存减少，Metaspace大到把Heap空间挤没时，报错OOM

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120821988-966711769.png)

    Young满了执行GC，一部分消除，一部分进入Old，Old也满了执行FullGC，一部分消除，一部分进入Metaspace

    在一个项目中，突然出现OOM故障，如何排除 ~ 研究为什么出错

    + 能够看到代码第几行出错：内存快照分析工具，MAT（Eclipse），Jprofiler
    + Dubug，一行行分析代码

    MAT，Jprofiler 作用：

    + 分析Dump内存文件，快速定位内存泄漏
    + 获得堆中的数据
    + 获得大的对象
    + . . .

    IDEA安装插件

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120836815-772800933.png)


    官网下载

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120849466-1280914396.png)


    9.2版本的注册码

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120905135-1322362451.png)


    如果堆溢出了，丢出文件，可以用JProfiler打开它，查看内存信息，找出问题

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120925417-1903643722.png)


    一般式

    ```java
    -Xms //设置初始化内存分配大小，默认1/64
    -Xmx //设置最大内存分配大小，默认1/4
    -XX:+PrintGCDetails //打印GC清理信息
    -XX:+HeapDumpOnOutOfMemoryError //OOM dump，别的错误同理
    ```

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120943127-1182552593.png)


    比如这个内存占了89%，这个 ArrayList 肯定有问题啊

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712120955035-1948956048.png)


16. GC 垃圾回收算法

    GC的作用区域：堆 和 方法区（属于堆）

    + 新生代
    + 幸存区（from，to）
    + 老年区

    GC两种类型：轻GC（普通的GC），重GC（全局GC）

    题目：

    + JVM的内存模型和分区~详细到每个区放什么？
    + 堆里面的分区有哪些? Eden，from，to，老年区，说说他们的特点？
    + GC的算法有哪些？标记清除算法，标记整理，复制算法，引用计数法，怎么用的？
    + 轻GC和重GC分别在什么时候发生？

    **引用计数法**：太low了，不高效，不常用

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712121009548-1254116352.png)


    **复制算法**：新生代主要用到的算法

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712121023668-1684644035.png)


    幸存的对象来到幸存区时，会选择空的to区，然后把from区的对象复制到to区，from变成空的to区，原来的to区变成from区；这样可以承上启下，不会卡死

    每次GC之后，Eden是空的，to是空的，GC15次之后还活着，进入下一阶段，老年区

    + 好处：没有内存的碎片
    + 坏处：浪费了内存空间，一半空间永远是空的

    复制算法最佳使用场景：对象存活度较低的时候，新生区~

    **标记清除算法**：

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712121033245-677124867.png)


    + 优点：不需要额外的空间
    + 缺点：两次扫描，浪费时间，会产生内存碎片

    **标记压缩算法**：再优化，解决了内存碎片

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712121042170-1836059805.png)


    + 缺点：又多一次扫描，还有移动成本

    **标记清除压缩**：先标记清除几次，再进行压缩

17. GC 总结

    内存效率：复制算法 > 标记清除算法 > 标记压缩算法（时间复杂度）

    内存整齐度：复制算法 = 标记压缩算法 > 标记清除算法

    内存利用率：标记压缩算法 = 标记清除算法 > 复制算法

    GC ~ 分代收集算法

18. JMM 

    java memory model ~ java内存模型

    作用：缓存一致性协议， 用于定义数据读写的规则（遵守，找到这个规则）。

    JMM定义了线程工作内存和主内存之间的抽象关系：线程之间的共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存(Local Memory)

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712121055277-1065260012.png)


    解决共享对象可见性这个问题：volilate，立即改主存，让别人拿到新的数据

    JMM：抽象理论信息

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712121114140-1035443204.png)


    volilate关键字：解决一致性的
]]></description></item><item><title>Springboot 整合Redis</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/12/java_28.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 12 Jul 2020 02:59:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/12/java_28.html</guid><description><![CDATA[

导入依赖 => 配置连接 => 测试

依赖

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

源码分析：

```java
	@Bean
	//不存在才生效=>我们可以自己定义一个redisTemplate替换这个默认的
	@ConditionalOnMissingBean(name = {"redisTemplate"})
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {
        //默认的RedisTemplate，没有过多的设置，redis对象都是需要序列化的
        //两个泛型都是Object类型，使用时需要进行强制转换
        RedisTemplate template = new RedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }

    @Bean
    @ConditionalOnMissingBean //String是redis最常使用的，所以单独提出来一个bean
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {
        StringRedisTemplate template = new StringRedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }
```

配置：

```yaml
# SpringBoot 所有的配置类，都有一个自动配置类:RedisAutoConfiguration
# 自动配置类都会绑定一个 properties:RedisProperties

spring:
  redis:
    host: 127.0.0.1
    port: 6379
# lettuce.xxx SpringBoot2.x使用这个才能生效
# jedis.xxx
```

测试

```java
@SpringBootTest
class RedisSpringbootApplicationTests {

   @Autowired
   private RedisTemplate redisTemplate;

   @Test
   void contextLoads() {
      /*
      //redisTemplate 操作不同的数据类型，api和我们的指令是一样的
      //opsForValue().xxx 操作字符串,类似String
      //opsForList().xxx 操作List,类似List
      //opsForSet()
      //opsForHash()
      //等等各种数据结构
      String s = redisTemplate.opsForValue().toString();

      //获取redis的链接对象
      //除了基本的操作,我们常用的方法都可以直接通过redisTemplate操作,比如事务,和基本的CRUD
      RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();
      connection.flushDb();
      connection.flushAll();
      */

      redisTemplate.opsForValue().set("mykey","你好,Redis!");
      System.out.println(redisTemplate.opsForValue().get("mykey"));
   }
}
```

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712105806700-1982436861.png)


![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712105820775-2041824064.png)


```java
	@Test
	public void test() throws JsonProcessingException {
		//开发中一般都使用json来传递对象
		User user = new User("peng", 25);
		//所有的对象都需要序列化
		String jsonUser = new ObjectMapper().writeValueAsString(user);
		redisTemplate.opsForValue().set("user",jsonUser);
		System.out.println(redisTemplate.opsForValue().get("user"));
	}
```

一般在pojo中序列化

```java
public class User implements Serializable{
    private String name;
    private int age;
}
```

我们编写一个自己的redisTemplate，com.peng.config.RedisConfig.java

```java
@Configuration
public class RedisConfig {

    //编写我们自己的 redisTemplate，一个固定的模板
    @Bean
    @SuppressWarnings("all")
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory){
        //我们我了自己开发方便，一般直接使用<String,Object>类型
        RedisTemplate<String,Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);

        //配置具体的序列化方式，这里是json
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);

        //String的序列化
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();

        //key采用String的序列化方式
        template.setKeySerializer(stringRedisSerializer);

        //hash的key也采用String的序列化方式
        template.setHashKeySerializer(stringRedisSerializer);

        //value的序列化方式采用json
        template.setValueSerializer(jackson2JsonRedisSerializer);

        //hash的value的序列化方式采用json
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        
        template.afterPropertiesSet();
        return template;
    }
}
```

自己封装的redis工具

```java
@Component
public class RedisUtil {
    @Autowired
    private RedisTemplate<String,Object> redisTemplate;

    //==============Common===============

    //缓存失效时间
    public boolean expire(String key, long time){
        try {
            if (time > 0){
                redisTemplate.expire(key,time, TimeUnit.SECONDS);
            }
            return true;
        }catch (Exception e){
            e.printStackTrace();
            return false;
        }
    }

    //根据key获取过期时间
    public long getExpire(String key){
        return redisTemplate.getExpire(key,TimeUnit.SECONDS);
    }

    //判断key是否存在
    public boolean hasKey(String key){
        try {
            return redisTemplate.hasKey(key);
        }catch (Exception e){
            e.printStackTrace();
            return false;
        }
    }

    //删除存缓
    public void del(String... key){
        if (key != null && key.length > 0){
            if (key.length == 1){
                redisTemplate.delete(key[0]);
            }else{
                redisTemplate.delete(Arrays.asList(key));
            }
        }
    }

    //普通缓存获取
    public Object get(String key){
        return key == null ? null : redisTemplate.opsForValue().get(key);
    }

    //普通存缓放入
    public boolean set(String key,Object value){
        try {
            redisTemplate.opsForValue().set(key,value);
            return true;
        }catch (Exception e){
            e.printStackTrace();
            return false;
        }
    }

    //普通存缓放入并设置时间
    public boolean set(String key,Object value,long time){
        try {
            if (time > 0){
                redisTemplate.opsForValue().set(key,value,time,TimeUnit.SECONDS);
            }else {
                set(key, value);
            }
            return true;
        }catch (Exception e){
            e.printStackTrace();
            return false;
        }
    }

    //递增
    public long incr(String key,long delta){
        if (delta < 0){
            throw new RuntimeException("递增因子必须大于0");
        }
        return redisTemplate.opsForValue().increment(key, delta);
    }

    //递减
    public long decr(String key,long delta){
        if (delta < 0){
            throw new RuntimeException("递减因子必须大于0");
        }
        return redisTemplate.opsForValue().increment(key, -delta);
    }

    //==============Map===============

    //==============Set===============

}
```

**redis**

NoSQL，键值对存储

**应用**

UserController.java

```java
@GetMapper("/getUser")
@ResponseBody
public Object getUser(){
    if (redisUtil.hasKey("user")){ //如果redis里有就从redis里返回
        return redisUtil.get("user");
    }
    RedisUtil redisUtil = new RedisUtil();
    userJson = redisUtil.get("user");
    return userJson;
}
```]]></description></item><item><title>Shiro</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/12/java_27.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 12 Jul 2020 02:12:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/12/java_27.html</guid><description><![CDATA[**简介**

● Apache Shiro是一个Java的安全(权限)框架。
● Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境， 也可以用在JavaEE环境。
● Shiro可以完成，认证，授权，加密，会话管理，Web集成，缓存等。
● 下载地址: http://shiro.apache.org/

**功能**

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712100959295-2109023765.png)


**架构**（外部）

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712101016716-1561680391.png)


**架构**（内部）

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712101044554-271208923.png)


快速开始步骤

1. 导入依赖
2. 配置文件
3. helloworld

resources.log4j.properties

```properties
log4j.rootLogger=INFO, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n

# General Apache libraries
log4j.logger.org.apache=WARN

# Spring
log4j.logger.org.springframework=WARN

# Default Shiro logging
log4j.logger.org.apache.shiro=INFO

# Disable verbose logging
log4j.logger.org.apache.shiro.util.ThreadContext=WARN
log4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN
```

resources.shiro.ini

```ini
[users]
# user 'root' with password 'secret' and the 'admin' role
root = secret, admin
# user 'guest' with the password 'guest' and the 'guest' role
guest = guest, guest
# user 'presidentskroob' with password '12345' ("That's the same combination on
# my luggage!!!" ;)), and role 'president'
presidentskroob = 12345, president
# user 'darkhelmet' with password 'ludicrousspeed' and roles 'darklord' and 'schwartz'
darkhelmet = ludicrousspeed, darklord, schwartz
# user 'lonestarr' with password 'vespa' and roles 'goodguy' and 'schwartz'
lonestarr = vespa, goodguy, schwartz

# -----------------------------------------------------------------------------
# Roles with assigned permissions
# 
# Each line conforms to the format defined in the
# org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc
# -----------------------------------------------------------------------------
[roles]
# 'admin' role has all permissions, indicated by the wildcard '*'
admin = *
# The 'schwartz' role can do anything (*) with any lightsaber:
schwartz = lightsaber:*
# The 'goodguy' role is allowed to 'drive' (action) the winnebago (type) with
# license plate 'eagle5' (instance specific id)
goodguy = winnebago:drive:eagle5
```

官方例子 Quickstart.java

```java
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.*;
import org.apache.shiro.ini.IniSecurityManagerFactory;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.session.Session;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.lang.util.Factory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Quickstart {

    private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);

    public static void main(String[] args) {

        Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:shiro.ini");
        SecurityManager securityManager = factory.getInstance();
        SecurityUtils.setSecurityManager(securityManager);

        // 获取当前的用户对象
        Subject currentUser = SecurityUtils.getSubject();

        //通过当前用户拿到 Session
        Session session = currentUser.getSession();
        session.setAttribute("someKey", "aValue");
        String value = (String) session.getAttribute("someKey");
        if (value.equals("aValue")) {
            log.info("Subject=>session[" + value + "]");
        }

        //判断当前的用户是否被认证
        if (!currentUser.isAuthenticated()) {

            //Token：令牌，没有获取，随机
            UsernamePasswordToken token = new UsernamePasswordToken("lonestarr", "vespa");
            token.setRememberMe(true); //设置记住我
            try {
                currentUser.login(token);
            } catch (UnknownAccountException uae) { //用户名错误
                log.info("There is no user with username of " + token.getPrincipal());
            } catch (IncorrectCredentialsException ice) { //密码错误
                log.info("Password for account " + token.getPrincipal() + " was incorrect!");
            } catch (LockedAccountException lae) { //用户被锁定
                log.info("The account for username " + token.getPrincipal() + " is locked.  " +
                        "Please contact your administrator to unlock it.");
            }
            // ... catch more exceptions here (maybe custom ones specific to your application?
            catch (AuthenticationException ae) { //认证错误，是以上所以错误的父类
                //unexpected condition?  error?
            }
        }

        //say who they are:
        //print their identifying principal (in this case, a username):
        log.info("User [" + currentUser.getPrincipal() + "] logged in successfully.");

        //test a role:
        if (currentUser.hasRole("schwartz")) {
            log.info("May the Schwartz be with you!");
        } else {
            log.info("Hello, mere mortal.");
        }

        //粗粒度的
        //test a typed permission (not instance-level)
        if (currentUser.isPermitted("lightsaber:wield")) {
            log.info("You may use a lightsaber ring.  Use it wisely.");
        } else {
            log.info("Sorry, lightsaber rings are for schwartz masters only.");
        }

        //细粒度
        //a (very powerful) Instance Level permission:
        if (currentUser.isPermitted("winnebago:drive:eagle5")) {
            log.info("You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'.  " +
                    "Here are the keys - have fun!");
        } else {
            log.info("Sorry, you aren't allowed to drive the 'eagle5' winnebago!");
        }

        //注销
        //all done - log out!
        currentUser.logout();

        //结束
        System.exit(0);
    }
}
```

重点的几个函数
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712101125647-1084363282.png)
]]></description></item><item><title>SpringSecurity</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/12/java_26.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 12 Jul 2020 00:47:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/12/java_26.html</guid><description><![CDATA[### Spring Security(安全)

不是功能性需求

设计之初考虑

框架：shiro、Spring Security，功能类似

认证，授权

+ 功能权限
+ 访问权限
+ 菜单权限
+ ...拦截器，过滤器：大量源生代码

MVC - SPRING - BOOT - 框架思想

导入thymeleaf依赖

```xml
		<dependency>
			<groupId>org.thymeleaf</groupId>
			<artifactId>thymeleaf-spring5</artifactId>
			<version>3.0.11.RELEASE</version>
			<scope>compile</scope>
		</dependency>
		<dependency>
			<groupId>org.thymeleaf.extras</groupId>
			<artifactId>thymeleaf-extras-java8time</artifactId>
			<version>3.0.4.RELEASE</version>
			<scope>compile</scope>
		</dependency>
```

com.peng.controller.RouterController.java 搭建环境

```java
package com.peng.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class RouterController {

    @RequestMapping({"","/","/index"})
    public String index(){
        return "index";
    }

    @RequestMapping("toLogin")
    public String toLogin(){
        return "views/login";
    }

    @RequestMapping("/level1/{id}")
    public String level1(@PathVariable("id") int id){
        return "views/level1/"+id;
    }

    @RequestMapping("/level2/{id}")
    public String level2(@PathVariable("id") int id){
        return "views/level2/"+id;
    }

    @RequestMapping("/level3/{id}")
    public String level3(@PathVariable("id") int id){
        return "views/level3/"+id;
    }
}
```

谁都能看见的界面，明显不合理

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712084600455-36091397.png)


AOP：切面编程

**整合 Spring Security**

记住几个类:

+ WebSecurityConfigurerAdapter: 自定义Security策略
+ AuthenticationManagerBuilder: 自定义认证策略
+ @EnableWebSecurity: 开启WebSecurity模式 ，@Enablexxxx 开启某个功能

Spring Security的两个主要目标是“认证"和"授权”(访问控制)
“认证”(Authentication)
"授权”(Authorization)
这个概念是通用的，而不是只在Spring Security中存在。

导入依赖

```xml
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
```

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200712084617117-1991525880.png)

com.peng.config.SecurityConfig.java 横向添加认证和授权

```java
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

//AOP : 拦截器！
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    //链式编程
    //授权
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //首页所有人可以访问，功能页只对应有权限的人才能访问
        //请求授权的规则
        http.authorizeRequests()
                .antMatchers("/").permitAll()
                .antMatchers("/level1/**").hasRole("vip1")
                .antMatchers("/level2/**").hasRole("vip2")
                .antMatchers("/level3/**").hasRole("vip3");

        //没有权限默认跳到登录页面，需要开启登录页面
        // 为什么能进入 /login !
        http.formLogin().loginPage("/toLogin").loginProcessingUrl("/login"); //走定制的登录页

        //防止网站攻击 get post
        http.csrf().disable(); //关闭csrf功能

        //注销，跳回首页
        http.logout().logoutSuccessUrl("/");

        //开启记住我功能 cookie 默认保存两周
        http.rememberMe();
    }

    //认证
    //密码编码：PasswordEncoder
    //在Spring Security 5.0+ 新增了很多的加密方法
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {

        //这些数据正常应该从数据库中读取
        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
                .withUser("peng").password(new BCryptPasswordEncoder().encode("123")).roles("vip2","vip3")
                .and().withUser("root").password(new BCryptPasswordEncoder().encode("123")).roles("vip1","vip2","vip3")
                .and().withUser("guest").password(new BCryptPasswordEncoder().encode("123")).roles("vip1");

        /*数据库中读取
        auth.jdbcAuthentication()
                .dataSource(datadataSource)
                .withDefaultSchema()
                .withUser(users.username("peng").password("123").roles("vip2"))
                ...........;
                */
    }
}
```

thymeleaf 里控制安全，先导包

```xml
		<!--security-thymeleaf整合包-->
		<dependency>
			<groupId>org.thymeleaf.extras</groupId>
			<artifactId>thymeleaf-extras-springsecurity4</artifactId>
			<version>3.0.4.RELEASE</version>
		</dependency>
```

导入命名空间

```xml
xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity4"
```

动态显示 登陆 和 注销

```html
<!--登录注销-->
<div class="right menu">
    <!--如果未登录，显示登录界面-->
    <div sec:authorize="!isAuthenticated()">
        <a class="item" th:href="@{/toLogin}">
            <i class="address card icon"></i> 登录
        </a>
    </div>

    <!--如果登录：用户名，注销-->
    <div sec:authorize="isAuthenticated()">
        <a class="item">
            用户名：<span sec:authentication="name"></span>
        </a>
    </div>
    <div sec:authorize="isAuthenticated()">
        <a class="item" th:href="@{/logout}">
            <i class="sign-out icon"></i> 注销
        </a>
    </div>

</div>
```

动态显示菜单

```html
<div class="column" sec:authorize="hasRole('vip1')">
    <div ............/></div>
<div class="column" sec:authorize="hasRole('vip2')">
	<div ............/></div>
<div class="column" sec:authorize="hasRole('vip3')">
    <div ............/></div>
```
]]></description></item><item><title>Springboot 整合Druid</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/11/java_25.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 11 Jul 2020 14:16:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/11/java_25.html</guid><description><![CDATA[导入依赖

```xml
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>druid</artifactId>
	<version>1.1.21</version>
</dependency>
```

配置

```yaml
spring:
  datasource:
    username: admin
    password: 8098
    # 如果时区报错了，加一个时区的配置：serverTimezone=UTC
    url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&characterEncoding=utf8&useSSL=false
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    # druid专有配置
    initial-size: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true

    #配置监控统计拦载的filters，stat: 监控统计、Log4j: 日志记录、wall:防御sql注入
    #如果允许时报错java.lang.ClassNotFoundException: org.apache.Log4j.Priority
    #则导入Log4j依赖即可，Maven 地址: https://mvnrepository. com/artifact/Log4j/Log4j
    filters: stat,wall,1og4j
    maxPoolPreparedStatementPerConnectionSize: 20
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
```

导入一个功能，以 log4j 为例

```xml
<dependency>
	<groupId>log4j</groupId>
	<artifactId>log4j</artifactId>
	<version>1.2.17</version>
</dependency>
```

后台监控

```java
package com.peng.config;

import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.support.http.StatViewServlet;
import com.alibaba.druid.support.http.WebStatFilter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.servlet.Filter;
import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
public class DruidConfig {

    @ConfigurationProperties(prefix = "spring.datasource")
    @Bean
    public DataSource druidDataSource(){
        return new DruidDataSource();
    }

    //后台监控：web.xml，ServletRegis trationBean
    //因为SpringBoot内置了servlet容器，所以没有web.xmL
    @Bean
    public ServletRegistrationBean statViewServlet(){
        //固定写法
        ServletRegistrationBean<StatViewServlet> bean = new ServletRegistrationBean<>(new StatViewServlet(), "/druid/*");

        //后台需要有人登录
        HashMap<String, String> initParameters = new HashMap<>();

        //增加配置
        initParameters.put("loginUsername","admin"); //登录的key是固定的
        initParameters.put("loginPassword","123456");

        //允许谁可以访问
        initParameters.put("allow",""); //为空代表谁都能访问

        //禁止谁访问 initParameters.put("peng","192.168.1.120");

        bean.setInitParameters(initParameters);
        return bean;
    }

    //filter 过滤器
    @Bean
    public FilterRegistrationBean webStatFilter(){
        FilterRegistrationBean<Filter> bean = new FilterRegistrationBean<>();

        bean.setFilter(new WebStatFilter());

        //过滤哪些请求
        Map<String,String> initParameters = new HashMap<>();

        //这些东西不进行统计
        initParameters.put("exclustions","*.js,*.css,/druid/**");
        bean.setInitParameters(initParameters);
        return bean;
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711221614618-1532821661.png)
]]></description></item><item><title>Springboot 整合JDBC</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/11/java_24.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 11 Jul 2020 13:21:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/11/java_24.html</guid><description><![CDATA[配置数据库

```yaml
spring:
  datasource:
    username: admin
    password: 8098
    # 如果时区报错了，加一个时区的配置：serverTimezone=UTC
    url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&characterEncoding=utf8&useSSL=false
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
```

测试类，传统方法与数据库建立连接

```java
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest
public class Spring04DataApplicationTest {

    //自动按照yaml导入数据库资源
    @Autowired
    DataSource dataSource;

    @Test
    public void contextLoads() throws Exception {
        //查看一下默认的数据源
        System.out.println(dataSource.getClass());

        //获得数据库连接
        Connection connection = dataSource.getConnection();

        //xxxxTemplateC Springboot已经配置好模板bean，拿来即用CRUD

        //可以进行各种操作了
        Statement statement = connection.createStatement();
        ResultSet resultSet = statement.executeQuery("SELECT * FROM mybatis.student");
        while (resultSet.next()){ //是个链表
            System.out.println("id="+resultSet.getObject("id"));
            System.out.println("tid="+resultSet.getObject("tid"));
            System.out.println("name="+resultSet.getObject("name"));
            System.out.println("=============================");
        }

        //关闭
        resultSet.close();
        statement.close();
        connection.close();
    }
}
```

JDBCController

```java
package com.peng.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
public class JDBCController {

    @Autowired
    JdbcTemplate jdbcTemplate; //JdbcTemplate类里，啥都有！

    @GetMapping("/userlist")
    //查询数据库的所有信息
    public List<Map<String,Object>> userList(){
        String sql = "select * from user";
        List<Map<String, Object>> list_maps = jdbcTemplate.queryForList(sql);
        return list_maps;
    }

    //增
    @GetMapping("adduser")
    public String addUser(){
        String sql = "insert into mybatis.user(id,name,pwd) values(4,'peng',8098)";
        jdbcTemplate.update(sql);
        return "update-ok";
    }

    //改
    @GetMapping("/updateuser/{id}")
    public String updateUser(@PathVariable("id") int id){
        String sql = "UPDATE mybatis.user set name=?,pwd=? WHERE id="+id;

        //封装
        Object[] objects = new Object[2];
        objects[0] = "peng2";
        objects[1] = "123456";
        jdbcTemplate.update(sql,objects);
        return "update-ok";
    }

    //删
    @GetMapping("/deleteuser/{id}")
    public String deleteUser(@PathVariable("id") int id){
        String sql = "DELETE FROM mybatis.user WHERE id=?";
        jdbcTemplate.update(sql,id);
        return "delete-ok";
    }
}
```
]]></description></item><item><title>Springboot 员工管理系统</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/11/java_23.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 11 Jul 2020 09:12:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/11/java_23.html</guid><description><![CDATA[#### 准备工作

将资源放到对应的文件夹

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711170851562-1699132125.png)


java 模拟数据库

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711170902958-2046983784.png)


Department.java 部门实体类

```java
//部门表
@Data
@NoArgsConstructor //无参构造器
@AllArgsConstructor //有参构造器
public class Department {

    private Integer id;
    private String departmentName;
}
```

Employee.java 员工实体类

```java
//员工表
@Data
@NoArgsConstructor
public class Employee {

    private Integer id;
    private String lastName;
    private String email;
    private Integer gender; //0:女 1:难
    private Department department;
    private Date birth;

    public Employee(Integer id, String lastName, String email, Integer gender, Department department) {
        this.id = id;
        this.lastName = lastName;
        this.email = email;
        this.gender = gender;
        this.department = department;
        //默认的创建日期！
        this.birth = new Date();
    }
}
```

DepartmentDao.java

```java
//部门dao
@Repository
public class DepartmentDao {

    //模拟数据库中的数据
    private static Map<Integer,Department> departments = null;
    static {
        //创建部门表
        departments = new HashMap<Integer,Department>();

        departments.put(101,new Department(101,"教学部"));
        departments.put(102,new Department(102,"市场部"));
        departments.put(103,new Department(103,"教研部"));
        departments.put(104,new Department(104,"运营部"));
        departments.put(105,new Department(105,"后勤部"));
    }

    //获得所有部门信息
    public Collection<Department> getDepartments(){
        return departments.values();
    }

    //通过id得到部门
    public Department getDepartmentById(Integer id){
        return departments.get(id);
    }
}
```

EmployeeDao.java

```java
//员工dao
@Repository
public class EmployeeDao {
    //模拟数据库中的数据
    private static Map<Integer,Employee> employees = null;
    //员工有所属的部门
    @Autowired
    private DepartmentDao departmentDao;
    static {
        //创建部门表
        employees = new HashMap<Integer,Employee>();

        employees.put(101,new Employee(1001,"AA","A6131313@qq.com",1,new Department(101,"教学部")));
        employees.put(102,new Employee(1002,"BB","B6131313@qq.com",0,new Department(102,"市场部")));
        employees.put(103,new Employee(1003,"CC","C6131313@qq.com",1,new Department(103,"教研部")));
        employees.put(104,new Employee(1004,"DD","D4234524@qq.com",0,new Department(104,"运营部")));
        employees.put(105,new Employee(1005,"EE","E6131313@qq.com",1,new Department(105,"后勤部")));
    }

    //===增删改查===

    //主键自增
    private static Integer initId = 1006;
    //增加一个员工
    public void add(Employee employee){
        if (employee.getId()==null){
            employee.setId(initId++);
        }

        employee.setDepartment(departmentDao.getDepartmentById(employee.getDepartment().getId()));

        employees.put(employee.getId(),employee);
    }

    //查询全部员工信息
    public Collection<Employee> getAll(){
        return employees.values();
    }

    //通过id查询员工
    public Employee getEmployeeById(Integer id){
        return employees.get(id);
    }

    //通过id删除员工
    public void delete(Integer id){
        employees.remove(id);
    }
}
```

#### 首页实现

注意点：

1. 所有页面的静态资源都需要使用 `thymeleaf `接管
2. url：`@{}`

com.peng.config/MyMvcConfig.java 配置主页

```java
@Configuration
public class MyConfig implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/").setViewName("index");
        registry.addViewController("/index.html").setViewName("index");
    }
}
```

#### 页面国际化

注意点：

1. 我们需要配置 i18n 文件
2. 我们如果需要在项目中进行按钮自动切换，我们需要自定义一个组件 `LocaleResolver`
3. 记得将自己写的组件配置到spring容器 `@Bean`
4. `#{}`

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711170932595-874439700.png)


利用 bundle 可视化可同时配置几个文件，并在 application.yaml 配置

```yaml
#我们的配置文件放在的真实位置
spring:
  messages:
    basename: i18n.login
```

首页按钮链接改成 thymeleaf 的语法

```html
<a class="btn btn-sm" th:href="@{/index.html(l='zh_CN')}">中文</a>
<a class="btn btn-sm" th:href="@{/index.html(l='en_US')}">English</a>
```

MyLocaleResolver.java 自己写的地区解析器

```java
public class MyLocaleResolver implements LocaleResolver {

    //解析请求
    @Override
    public Locale resolveLocale(HttpServletRequest httpServletRequest) {

        //获取请求中的语言参数链接
        String language = httpServletRequest.getParameter("l");
        Locale locale = Locale.getDefault(); //如果没有就使用默认的

        //如果请求的链接携带了国际化的参数
        if (! StringUtils.isEmpty(language)){
            //zh_CN
            String[] split = language.split("_");
            //国家,地区
            locale = new Locale(split[0], split[1]);
        }
        return locale;
    }

    //这里用不上，但不实现接口中这个类会报错
    @Override
    public void setLocale(HttpServletRequest httpServletRequest, @Nullable HttpServletResponse httpServletResponse, @Nullable Locale locale) { }
}
```

在 com.peng.config/MyConfig.java 配置文件中注册bean

```java
 	//自定义的国际化组件放到bean中生效
    @Bean
    public LocaleResolver localeResolver(){
        return new MyLocaleResolver();
    }
```

测试结果

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711170957419-1494132569.png)
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711171011727-323422746.png)


#### 实现登录功能

LoginController.java 登录控制器
@RequestParam：将请求参数绑定到你控制器的方法参数上（是springmvc中接收普通参数的注解）

```java
@Controller
public class LoginController {
    @RequestMapping("/user/login")
    public String login(
            @RequestParam("username") String username,
            @RequestParam("password") String password,
            Model model){
        //具体的业务
        if (!StringUtils.isEmpty(username) && "123456".equals(password)){
            return "dashboard";
        }else {
            //告诉用户，登录失败
            model.addAttribute("msg","用户名或密码错误");
            return "index";
        }
    }
}
```

对应的 index.html 主页中插入提醒

```html
<p style="color: red" th:text="${msg}" th:if="${not #strings.isEmpty(msg)}"></p>
```

#### 登录拦截器

```java
public class LoginHandlerInterceptor implements HandlerInterceptor {

    //返回布尔值，是否放行
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //在陆成功之后，应该有用户的sessoin
        Object loginUser = request.getSession().getAttribute("loginUser");

        if (loginUser==null){ //没有登录
            request.setAttribute("msg","没有权限，请先登录");
            request.getRequestDispatcher("/index.html").forward(request,response);
            return false;
        }else {
            return true;
        }
    }
}
```

#### 展示员工列表

1. 提取公共页面
   1. `th: fragment="si debar"`
   2. `th: replace="~{ commons/ commons : : topbar}"`
   3. 如果要传递参数，可以直接使用 () 传参，接收判断即可
2. 列表循环展示

EmployeeController.java 员工控制器

```java
@Controller
public class EmployeeController {

    @Autowired
    EmployeeDao employeeDao;

    @RequestMapping("emps")
    public String list(Model model){
        Collection<Employee> employees = employeeDao.getAll();
        model.addAttribute("emps",employees);
        return "emp/list";
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711171049357-1640231271.png)



#### 添加员工实现

1. 按钮提交
2. 跳转到添加页面
3. 添加员工成功
4. 返回首页

EmployeeController.java 员工控制器，添加两个方法

```java
    @GetMapping("/emp")
    public String toAddpage(Model model){
        //查出所有部门的信息
        Collection<Department> departments = departmentDao.getDepartments();
        model.addAttribute("departments",departments);
        return "emp/add";
    }

    @PostMapping("/emp")
    public String addEmp(Employee employee){
        System.out.println("save => "+employee);
        //调川底层业务方法保存员工信息
        employeeDao.add(employee);
        return "redirect:emps";
    }
```

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711171108065-926167297.png)


#### 修改员工实现

EmployeeController.java 员工控制器，又添加两个方法

```java
	//去员工的修改页面
    @GetMapping("/emp/{id}")
    public String toUpdateEmp(@PathVariable("id")Integer id,Model model){
        //查出原来的数据
        Employee employee = employeeDao.getEmployeeById(id);
        model.addAttribute("emp",employee);
        //查出所有部门的信息
        Collection<Department> departments = departmentDao.getDepartments();
        model.addAttribute("departments",departments);
        return "emp/update";
    }

    @PostMapping("/updateEmp")
    public String updateEmp(Employee employee){
        employeeDao.add(employee); //修改
        return "redirect:/emps";
    }
```

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711171127964-1205611644.png)


#### 删除员工实现

EmployeeController.java 员工控制器，又添了一个方法

```java
	//删除员工
    @GetMapping("/delemp/{id}")
    public String deleteEmp(@PathVariable("id")Integer id){
        employeeDao.delete(id);
        return "redirect:/emps";
    }
```

#### 注销

在 LoginController 里添加该函数

```java
	//注销
    @RequestMapping("/user/logout")
    public String logout(HttpSession session){
        session.invalidate();
        return "redirect:/index.html";
    }
```

#### 404

新建一个error文件夹，放一个 404.html 即可，500 也同理

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711171144674-57712470.png)

#### 写网站步骤

1. 前端搞定，页面长什么样子，数据
2. 设计数据库（数据库设计 难点！）
3. 前端让他能够自动运行，独立化工程
4. 数据接口如何对接：json，对象 all in one！
5. 前后端联调测试

+ 注意点

  1. 有一套自己熟悉的后台模板：工作必要，推荐x- admin

  2. 前端界面：至少自己能够通过前端框架，组合出来一个网站页面

     index，about，blog，post，user

  3. 让这个网站能够独立运行]]></description></item><item><title>SpringBoot Web开发</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/11/java_22.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 11 Jul 2020 08:36:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/11/java_22.html</guid><description><![CDATA[### SpringBoot Web开发

jar：webapp！

自动装配：创建应用，选择模块

springboot到底帮我们配置了什么？我们能不能进行修改？能修改哪些东西？能不能扩展？

+ xxxAutoConfiguration.. 向容器中自动配置组件
+ xxxProperties：自动配置类，装配配置文件中自定义的一些内容

要解决的问题

+ 导入静态资源 html css
+ 首页
+ jsp，模板引擎 Thymeleaf
+ 装备扩展 SpringMVC
+ 增删改查
+ 拦截器
+ 国际化

#### 静态资源

WebMvcAutoConfiguration.java

```java
public void addResourceHandlers(ResourceHandlerRegistry registry) {
	if (!this.resourceProperties.isAddMappings()) {
		logger.debug("Default resource handling disabled");
		return;
	}
	Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
	CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
	if (!registry.hasMappingForPattern("/webjars/**")) {
		customizeResourceHandlerRegistration(registry.addResourceHandler("/webjars/**")
.addResourceLocations("classpath:/META-INF/resources/webjars/").setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
	}
	String staticPathPattern = this.mvcProperties.getStaticPathPattern();
	if (!registry.hasMappingForPattern(staticPathPattern)) {
		customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern).addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
	}
}
```

+ 第一种方法：添加webjars依赖拿到静态资源

```xml
<dependency>
	<groupId>org.webjars</groupId>
	<artifactId>jquery</artifactId>
	<version>3.4.1</version>
</dependency>
```

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163003745-257367827.png)


![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163014300-1291549722.png)


+ 第二种方法

ResourceProperties.java 类定义了几个资源地址的静态全局变量

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163040049-238478756.png)


按照源码新建文件夹，在该文件下的所有目录都直接能被取到

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163052590-1307130438.png)


![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163105752-767645068.png)


+ 总结

1. 在springboot，我们可以使用以下方式处理静态资源
   + webjars： `localhost:8080/webjars/`
   + public，static，resource，/**，这些都在 `localhost:8080/` 下
2. 优先级：resource>static(默认的)>public

#### 首页定制

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163124764-1689770857.png)


看源码，意思是在任意资源目录添加 index.html 文件，我这里添加到了 public 文件夹下

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163140449-1228718303.png)


启动后

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163150879-330261161.png)


经测试，index.html 文件放到三个子目录下都能生成主页，直接放到上级的 resources 里不生效，一般主页都放到 static 文件夹下

#### 模板引擎 Thymeleaf

导入依赖

```xml
<!--thymeleaf 以后都是基于3.x开发-->
<dependency>
	<groupId>org.thymeleaf</groupId>
	<artifactId>thymeleaf-spring5</artifactId>
</dependency>
<dependency>
	<groupId>org.thymeleaf.extras</groupId>
	<artifactId>thymeleaf-extras-java8time</artifactId>
</dependency>
```

源码

```java
public class ThymeleafProperties {
   private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;
   public static final String DEFAULT_PREFIX = "classpath:/templates/";
   public static final String DEFAULT_SUFFIX = ".html";
   ...
}
```

从源码看出，Thymeleaf 能取到 templates 目录下的 .html 文件

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163210618-585692301.png)


![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163219600-1688711081.png)


结论：只要需要使用 thymeleaf，只需要导入对应的依赖就可以了！我们将html放在我们的 templates 目录下即可！

```html
<!DOCTYPE html>
<!--特定的声明-->
<html lang="en" xmlns:th="http://www.thymeleaf.org"/>
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<h1>test</h1>

<!--所有的htmL元素都可以被thymeleaf 替换接管 th:元素名-->
<div th:text="${msg}"></div>

</body>
</html>
```

```java
@Controller
public class IndexController {

    @RequestMapping("/test")
    public String test(Model model){
        model.addAttribute("msg","hello,springboot");
        return "test";
    }
}
```

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163235042-1018902111.png)


+ thymeleaf语法

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163252318-1505676816.png)


  测试

  ```xml
  <!DOCTYPE html>
  <!--特定的声明-->
  <html lang="en" xmlns:th="http://www.thymeleaf.org"/>
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
  </head>
  <body>
  <h1>test</h1>
  
  <!--所有的htmL元素都可以被thymeleaf 替换接管 th:元素名-->
  <div th:text="${msg}"></div>
  <!--utext表示转义-->
  <div th:utext="${msg}"></div>
  
  <hr>
  
  <!--遍历取值-->
  <h3 th:each="user:${users}" th:text="${user}"></h3>
  <h3 th:each="user:${users}">[[${user}]]</h3><!--不建议使用-->
  
  </body>
  </html>
  ```

  ```java
  @Controller
  public class IndexController {
  
      @RequestMapping("/test")
      public String test(Model model){
          model.addAttribute("msg","<h1>hello,springboot</h1>");
          model.addAttribute("users", Arrays.asList("peng1","peng2"));
          return "test";
      }
  }
  ```

  结果

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163315190-1520788953.png)

  更多语法

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163327811-1703758311.png)
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163337287-306158700.png)
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163344867-489884543.png)
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163352340-2127121271.png)
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163359492-100895705.png)
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163405991-1493578942.png)
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711163414465-179529789.png)


### SpringMVC自动配置

自己扩展的mvc配置类 com.peng.config/WebMvcConfigurer.java

```java
//如果,你想diy一些定制化的功能，只要写这个组件，
//然后将它交给springboot, springboot会帮我们自动装配!
//扩展  springmvc       dispatchservlet
@Configuration
public class MyConfig implements WebMvcConfigurer {

    //ViewResolver实现了视图解析器按口的类,我们就可以把它看做视图解析器
    @Bean
    public ViewResolver myViewResolver(){
        return new MyViewResolver();
    }

    //自定义了一个自己的视图解析器
    public static class MyViewResolver implements ViewResolver{
        @Override
        public View resolveViewName(String s, Locale locale) throws Exception {
            return null;
        }
    }
}
```

在 springboot 中， 有非常多的xxxx Configuration帮助我们进行扩展配置，只要看见了这个东西，我们就要注意了！

一个例子：

```java
	//视图跳转
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/peng").setViewName("test");
    }
```]]></description></item><item><title>Springboot 配置 自动装配原理</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/11/java_21.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 11 Jul 2020 07:35:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/11/java_21.html</guid><description><![CDATA[### 原理初探

**pom.xml**

+ spring-boot-dependencies：核心依赖在父工程中
+ 我们在写或者引入一些Springboot依赖的时候，不需要指定版本，就因为有这些版本仓库

**启动器**

+ 通式

  ```xml
  <dependency>
  	<groupId>org.springframework.boot</groupId>
  	<artifactId>spring-boot-starter-xxx</artifactId>
  </dependency>
  ```

+ 启动器：说白了就是springboot的启动场景

+ 比如，spring-boot-starter-web，他就会帮我们自动导入web环境所有的依赖

+ springboot会将所有的功能场景，都变成一个个的启动器

+ 我们要使用什么功能，就只需要找到对应的启动器就可以了`starter`

**主程序**

```java
@SpringBootApplication //标注这个类是一个springboot的应用
public class HelloworldApplication {

	public static void main(String[] args) {
		//将springboot应用启动
		SpringApplication.run(HelloworldApplication.class, args);
	}
}
```

+ 注解

```java
@SpringBootConfiguration：springboot的配置
	@Configuration：spring配置类
	@Component：说明这也是一个spring的组件
@EnableAutoConfiguration：自动配置
	@AutoConfigurationPackage：自动配置包
		@Import({Registrar.class})：导入选择器，包注册
	@Import({AutoConfigurationImportSelector.class})：自动配置导入选择
List configurations = this.getCandidateConfigurations(annotationMetadata, attributes); //获取所有的配置
```

获取候选的配置

```java
protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
	List<String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader());
	Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.");
	return configurations;
}
```

META-INF/spring.factories：自动配置的核心文件
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711153049739-849221757.png)


```java
Properties properties = PropertiesLoaderUtils.loadProperties(resource);
//所有资源加载到配置类中!
```

结论：springboot所有自动配置都是在启动的时候扫描并加载：`spring.factories`所有的自动配置类都在这里面，但是不一定生效，要判断条件是否成立，只要导入了对应的start，就有对应的启动器了，有了启动器，我们自动装配就会生效，然后就配置成功！

1. springboot在启动的时候，从类路径下 /MEAT-INF/`spring.factories`获取指定的值
2. 将这些自动配置的类导入容器，自动配置就会生效，帮我进行自动配置
3. 以前我们需要自动配置的东西，现在 springboot 帮我们做了
4. 整个javaEE，解决方案和自动配置的东西都在 spring-boot-autoconfigure-2.2.0.RELEASE.jar 这个包下
5. 它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器
6. 容器中也会存在非常多的 xxxAutoConfiguration 的文件(@Bean),就是这些类给容器中导入了这个场景需要的所有组件；并自动配置，@Configuration，JavaConfig！
7. 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作

SpringApplication这个类(加了@SpringApplication注解的主类)主要做了以下四件事情：

1. 推断应用的类型是普通的项目还是Web项目
2. 查找并加载所有可用初始化器， 设置到 initializers 属性中
3. 找出所有的应用程序监听器，设置到 listeners 属性中
4. 推断并设置main方法的定义类，找到运行的主类

### springboot配置

#### 配置文件

SpringBoot使用一个全局的配置文件，配置文件名称是固定的

+ application.properties
  语法结构：`key=value`
+ application.yaml
  。语法结构：`key: 空格value`

配置文件的作用：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了

```yaml
#springboot配置文件都能配置什么东西呢？

#官方文档：https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/htmlsingle/#boot-features-external-config
#Part X. Appendices Appendix A. Common application properties

#官方的配置太多了，了解原理

##基本语法，对空格缩进要求很高

#普通的key-value
name: peng

#存一个对象
student:
  name: peng
  age: 18

#行内写法
student: {name: peng,age: 18}

#数组
pets:
  - cat
  - dog

pet: [cat,dog,pig]
```

yaml 可以直接给实体类赋值


#### yaml配置类的属性

application.yaml 配置

```yaml
person:
  name: peng${random.uuid}
  age: 18
  happy: false
  birth: 2001/06/03
  maps: {k1: v1,k2: v2}
  lists: [eat,sleep,girl]
  dog:
    name: ${person.name:没有主人}的狗 #冒号后面的是默认值
    age: ${random.int(1,5)}
```

Person.java Person类

```java
package com.peng.pojo;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.Date;
import java.util.List;
import java.util.Map;

@Component
@ConfigurationProperties(prefix = "person") //绑定yanl，让yaml生效
public class Person {
    private String name;
    private Integer age;
    private boolean happy;
    private Date birth;
    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;

    public Person() {
    }

    public Person(String name, Integer age, boolean happy, Date birth, Map<String, Object> maps, List<Object> lists, Dog dog) {
        this.name = name;
        this.age = age;
        this.happy = happy;
        this.birth = birth;
        this.maps = maps;
        this.lists = lists;
        this.dog = dog;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public boolean isHappy() {
        return happy;
    }

    public void setHappy(boolean happy) {
        this.happy = happy;
    }

    public Date getBirth() {
        return birth;
    }

    public void setBirth(Date birth) {
        this.birth = birth;
    }

    public Map<String, Object> getMaps() {
        return maps;
    }

    public void setMaps(Map<String, Object> maps) {
        this.maps = maps;
    }

    public List<Object> getLists() {
        return lists;
    }

    public void setLists(List<Object> lists) {
        this.lists = lists;
    }

    public Dog getDog() {
        return dog;
    }

    public void setDog(Dog dog) {
        this.dog = dog;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", happy=" + happy +
                ", birth=" + birth +
                ", maps=" + maps +
                ", lists=" + lists +
                ", dog=" + dog +
                '}';
    }
}
```

Spring02ConfigApplicationTest.java 测试类

```java
package com.peng;

import com.peng.pojo.Person;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest
public class Spring02ConfigApplicationTest {

    @Autowired
    private Person person;

    @Test
    public void contextLoads() {
        System.out.println(person);
    }
}
```

输出：

```
Person{name='peng24756efe-3e05-4d61-abe7-f31e59e94f6f', age=18, happy=false, birth=Sun Jun 03 00:00:00 CST 2001, maps={k1=v1, k2=v2}, lists=[eat, sleep, girl], dog=Dog{name='peng92a5f5f2-3149-4336-9c45-76da5e680285的狗', age=3}}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711153159388-793532217.png)


+ 松散绑定

  lastName，在yaml中可以写成last-name

+ JSR303校验：赋值前验证数据类型

  ```java
  @Validated //数据校验
  public class Person {
      @NotNull //传入的值必须不为空才能通过验证
      private String name;
  }
  ```

   **Bean Validation 中内置的 constraint**

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711153235870-798884964.png)


  **Hibernate Validator 附加的 constraint**

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711153317893-488603337.png)


#### 多环境配置

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711153344937-317014012.png)


```yaml
#springboot的多环境配置:可以选择激活哪一个配置文件
server:
  port: 8080
spring:
  profiles:
    active: dev

# --- 分文档模块
---
server:
  port: 8081
spring:
  profiles: dev
---
server:
  port: 8082
spring:
  profiles: test
```

#### 浅显的底层原理

```yaml
# 配置文件里到底能写什么 --联系-- spring.factories
# 在我们这配置文件中能配置的东西，都存在一个固有的规律
# xxxAutoConfiguration --连接-- xxxProperties --连接-- yaml
# xxxAutoConfiguration:自动装配的默认值
# xxxProperties有set方法改变默认值，和配置文件yaml绑定，设置新值并使用
server:
  port: 8080
```

ctrl+鼠标左键，点进 port 看源码，果然有 port 属性和 set 方法

```java
private Integer port;

public void setPort(Integer port) {
    this.port = port;
}
```

发现这个方法属于 ServerProperties 类，类上有注解 @ConfigurationProperties，他连接 server 的默认配置文件

```java
@ConfigurationProperties(prefix = "server", ignoreUnknownFields = true)
public class ServerProperties{...}
```

自动默认配置文件中果然有

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711153407416-1826404730.png)


![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711153422355-32339545.png)


点进去之后，确实是个自动配置类，在注解中，他允许了 ServerProperties 类重新设置 port 等属性，这些设置可通过配置文件 yaml 配置

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711153434175-982814771.png)


而 ServerProperties 类连接 yaml，就是通过之前说过的 @ConfigurationProperties 注解，点进 prefix，是一个配置属性的注解

```java
@ConfigurationProperties(prefix = "server", ignoreUnknownFields = true)
public class ServerProperties {
```

本质：我们原先需要在 bean 中配置的属性（properties）封装成一个类然后通过 yaml 文件进行自动注入，而我们可以在 application.yaml 文件中自定义这些 property 属性

+ 自动装配原理总结

  1. SpringBoot 启动会加载大量的自动配置类

  2. 我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中

  3. 我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）

  4. 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可

     xxxAutoConfigurartion：自动配置类；给容器中添加组件

     xxxProperties：封装配置文件中相关属性；

+ 通过 debug=true 来查看，哪些配置生效，哪些没有

  ```yaml
  debug: true
  ```]]></description></item><item><title>Hello Springboot</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/11/java_20.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 11 Jul 2020 07:09:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/11/java_20.html</guid><description><![CDATA[### 微服务阶段

javase：OOP

mysql：持久化

html+css+js+jquery+框架：视图

javaweb：独立开发MVC三层架构的网站，原始

ssm框架：简化了我们的开发流程，配置开始复杂

war：tomcat运行

spring再简化：SpringBoot - jar 内嵌tomcat，微服务架构

服务越来越多：SpringCloud

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711150641013-254741186.png)


约定大于配置：maven，spring，springmvc，springboot，docker，...

高内聚，低耦合！


### 第一个SpringBoot程序

+ jdk 1.8
+ maven 3.6.1
+ springboot 最新版
+ IDEA

官方：提供了一个快速生成的网站 https://start.spring.io/ ，IDEA继承了这个网站！

+ 可以在官网直接下载后，导入idea开发

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711150708052-1815053443.png)

整体结构

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711150729525-987366525.png)


HelloworldApplication.java

```java
package com.peng.helloworld;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

//程序的主入口
@SpringBootApplication
public class HelloworldApplication {

	public static void main(String[] args) {
		//SpringApplication
		SpringApplication.run(HelloworldApplication.class, args);
	}
}
```

application.properties 空的配置文件

```xml
# springboot 核心配置文件
```

HelloworldApplicationTests.java 测试类

```java
package com.peng.helloworld;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

//单元测试
@SpringBootTest
class HelloworldApplicationTests {
	@Test
	void contextLoads() {
	}
}
```

HelloController.java 

```java
package com.peng.helloworld.controler;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    //接口：http://localhost:8080/hello
    @RequestMapping("/hello")
    public String hello(){
        //调用业务，接受前端的参数
        return "hello,world";
    }
}
```

直接执行

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711150757601-1808790193.png)


发现自带一个error接口

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711150805990-2102130961.png)


双击package打包服务

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711150818321-889810040.png)


生成可执行的jar文件

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711150829880-758150666.png)


在cmd中运行
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711150843826-45337440.png)


在浏览器中还能运行，微服务思想，前后端分离

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711150856722-237088446.png)


+ 直接使用idea创建一个springboot项目（一般开发直接在IDEA中创建）]]></description></item><item><title>常用设计模式</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/11/java_19.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 11 Jul 2020 04:39:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/11/java_19.html</guid><description><![CDATA[![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711123135205-289344939.png)

## 一、OOP编程七大原则

### PBP/OBP/OOP的特征

PBP（基于过程）：函数、域与生命周期的概念、函数重载、函数模板、异常处理、范型算法。
OBP（基于对象）：类（接口）、类的生命周期、类模板。
OOP（面向对象）：继承、多态。
三个概念步步深入，后者包括前者。其目的是实现软件开发的可重用性，解决软件危机（软件工程思想未引入之前）。
OOP不可避免设计原则的发展与设计模式的产生，这是OOP独具的特征决定的（正如前面所说，特征的产生是由其产生目的决定的）。

### OOP的方法论（高内聚、低耦合、易复用）

OOP的方法论－－如何实现基于OOP特征的抽象?

### OOP设计原则：

**OCP（Open-Closed Principle），开放封闭原则**：软件实体应该扩展开放、修改封闭。
实现：合理划分构件，一种可变性不应当散落在代码的很多角落里，而应当被封装到一个对象里；一种可变性不应当与另一个可变性混合在一起。

**DIP(Dependency Inversion Principle)，依赖倒置原则**：摆脱面向过程编程思想中高层模块依赖于低层实现，抽象依赖于具体细节。OOP中要做到的是，高层模块不依赖于低层模块实现，二者都依赖于抽象；抽象不依赖于具体实现细节，细节依赖于抽象。
实现：应该通过抽象耦合的方式，使具体类最大可能的仅与其抽象类（接口）发生耦合；程序在需要引用一个对象时,应当尽可能的使用抽象类型作为变量的静态类型,这就是针对接口编程的含义。

**LSP(Liskov Substitution Principle)，Liskov替换原则**：继承思想的基础。“只有当衍生类可以替换掉基类，软件单位的功能不会受到影响时，基类才真正被复用，而衍生类也才能够在基类的基础上增加新的行为。”

**ISP（Interface Insolation Principle），接口隔离原则**：接口功能单一，避免接口污染。
实现：一个类对另外一个类的依赖性应当是建立在最小的接口上的。使用多个专门的接口比使用单一的总接口要好。

**SRP(Single Resposibility Principle)，单一职责原则**：就一个类而言，应该仅有一个引起它变化的原因。 如果一个类的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会抑止这个类完成其他职责的能力。

**CARP（Composite/Aggregate Reuse Principle），合成/聚合复用原则**：设计模式告诉我们对象委托优于类继承，从UML的角度讲，就是关联关系优于继承关系。尽量使用合成/聚合、尽量不使用继承。
实现：在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，以整合其功能。

**LoD(Law Of Demeter or Principle of Least Knowledge)，迪米特原则或最少知识原则**：就是说一个对象应当对其他对象尽可能少的了解。即只直接与朋友通信，或者通过朋友与陌生人通信。
朋友的定义（或关系）：
（1）当前对象本身。
（2）以参量的形式传入到当前对象方法中的对象。
（3）当前对象的实例变量直接引用的对象。
（4）当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友。
（5）当前对象所创建的对象。
实现：
（1）在类的划分上，应当创建有弱耦合的类。类之间的耦合越弱，就越有利于复用。
（2）在类的结构设计上，每一个类都应当尽量降低成员的访问权限。一个类不应当public自己的属性，而应当提供取值和赋值的方法让外界间接访问自己的属性。
（3）在类的设计上，只要有可能，一个类应当设计成不变类。
（4）在对其它对象的引用上，一个类对其它对象的引用应该降到最低。
（5）尽量限制局部变量的有效范围.  

## 二、单例模式

保证一个类只有一个对象

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711123223423-477890318.png)


### 饿汉式

```java
public class Hungry {
    //可能会浪费空间
    private byte[] data1 = new byte[1024*1024];
    private byte[] data2 = new byte[1024*1024];
    private byte[] data3 = new byte[1024*1024];
    private byte[] data4 = new byte[1024*1024];

    private Hungry(){

    }

    private final  static Hungry HUNGRY = new Hungry();

    public static Hungry getInstance(){
        return HUNGRY;
    }
}
```

### **DCL懒汉式**

```java
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class Lazy {

    private static boolean qinjiang = false;

    private Lazy(){
        synchronized (Lazy.class){
            if (qinjiang == false){
                qinjiang = true;
            } else {
                throw new RuntimeException("不要试图使用反射破坏异常\n");
            }
        }
        System.out.println(Thread.currentThread().getName()+"ok");
    }

    private volatile static Lazy lazy;

    //双重检测锁模式的懒汉式单例 DCL懒汉式
    public static Lazy getInstance(){
        //加锁
        if (lazy==null){
            synchronized (Lazy.class){
                if (lazy==null)
                    lazy = new Lazy(); //不是原子性操作
                    /*
                    1.分配内存空间
                    2.执行构造方法，初始化对象
                    3.把这个对象指向这个空间
                     */
            }
        }
        return lazy; //此时lazy还没有完成构造,所以必须volatile
    }

    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        //多线程并发
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                Lazy.getInstance();
            }).start();
        }

        //反射破坏单例模式，解决：加变量qinjiang
        Lazy instacne1 = Lazy.getInstance();
        Constructor<Lazy> declaredConstructor = Lazy.class.getDeclaredConstructor(null);
        declaredConstructor.setAccessible(true); //无视私有构造器
        Lazy instacne2 = declaredConstructor.newInstance();

        System.out.println(instacne1); //singleton.Lazy@3d075dc0
        System.out.println(instacne2); //singleton.Lazy@214c265e
    }
}
```

### 静态内部类

```java
public class Holder {

    private Holder(){

    }

    public static Holder getInstance(){
        return InnerClass.HOLDER;
    }

    public static class InnerClass{
        private static final Holder HOLDER = new Holder();
    }
}
```

单例不安全，都有反射

### 枚举

```java
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

//enum本身是一个class类
public enum EnumSingle {
    INSTANCE;
    public EnumSingle getInstance(){
        return INSTANCE;
    }
}

class Test{
    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        EnumSingle instance1 = EnumSingle.INSTANCE;
        Constructor<EnumSingle> declaredConstructor = EnumSingle.class.getDeclaredConstructor(null);
        declaredConstructor.setAccessible(true);
        EnumSingle instance2 = declaredConstructor.newInstance(String.class,int.class);

        //NoSuchMethodException: singleton.EnumSingle.<init>()
        System.out.println(instance1);
        System.out.println(instance2);
    }
}
```

## 三、工厂模式

实现了创建者和调用者的分离

核心本质：实例化对象不使用new，用工厂方法代替。将选择实现类，创建对象统一管理和控制，从而将调用者跟我们的实现类解耦。

### 简单/静态工厂模式

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711123250690-469554135.png)


不满足开闭原则，再加新的产品时需要改代码

Car接口

```java
public interface Car {
    void name();
}
```

两个实现类

```java
public class Tesla implements Car {
    @Override
    public void name() {
        System.out.println("Tesla!");
    }
}

public class Wuling implements Car {
    @Override
    public void name() {
        System.out.println("五菱宏光!");
    }
}
```

车工厂

```java
public class CarFactory {
    public static Car getCar(String car){
        if (car.equals("五菱")) {
            return new Wuling();
        }else if (car.equals("tesla")){
            return new Tesla();
        }else {
            return null;
        }
    }
}
```

测试类

```java
public class Consumer {
    public static void main(String[] args) {
        //1.传统方法需要知道 接口和所有的实现类
        //Car car1 = new Wuling();
        //Car car2 = new Tesla();
        //car1.name();
        //car2.name();

        //2.使用工厂
        Car car1 = CarFactory.getCar("五菱");
        Car car2 = CarFactory.getCar("tesla");
        car1.name();
        car2.name();
    }
}
```

### 工厂方法模式

解决了开闭，但是每多一个产品都需要多写一个工厂

车工厂接口

```java
public interface CarFactory {
    Car getCar();
}
```

工厂实现类

```java
public class TeslaFactory implements CarFactory {
    @Override
    public Car getCar() {
        return new Tesla();
    }
}

public class WulingFactory implements  CarFactory{
    @Override
    public Car getCar() {
        return new Wuling();
    }
}
```

测试类

```java
public class Consumer {
    public static void main(String[] args) {
        Car car1 = new WulingFactory().getCar();
        Car car2 = new TeslaFactory().getCar();
    }
}
```

### 抽象工厂模式

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711123323818-1566981221.png)


围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711123344828-1379979565.png)


优点:

+ 具体产品在应用层的代码隔离，无需关心创建的细节
+ 将一个系列的产品统-到-起创建

缺点:

+ 规定了所有可能被创建的产品集合,产品簇中扩展新的产品困难
+ 增加了系统的抽象性和理解难度

产品接口

```java
public interface IPhoneProduct {
    void start();
    void shutdown();
    void callup();
    void sendSMS();
}

public interface IRouterProduct {
    void start();
    void shutdown();
    void openwifi();
    void setting();
}
```

产品实现类

```java
public class MIPhone implements IPhoneProduct {
    @Override
    public void start() {
        System.out.println("开启小米手机");
    }

    @Override
    public void shutdown() {
        System.out.println("关闭小米手机");
    }

    @Override
    public void callup() {
        System.out.println("小米打电话");
    }

    @Override
    public void sendSMS() {
        System.out.println("小米发短信");
    }
}

public class HuaweiPhone implements IPhoneProduct {
    @Override
    public void start() {
        System.out.println("开启华为手机");
    }

    @Override
    public void shutdown() {
        System.out.println("关闭华为手机");
    }

    @Override
    public void callup() {
        System.out.println("华为打电话");
    }

    @Override
    public void sendSMS() {
        System.out.println("华为发短信");
    }
}

public class MIRouter implements IRouterProduct {
    @Override
    public void start() {
        System.out.println("启动小米路由器");
    }

    @Override
    public void shutdown() {
        System.out.println("关闭小米路由器");
    }

    @Override
    public void openwifi() {
        System.out.println("小米路由器打开wifi");
    }

    @Override
    public void setting() {
        System.out.println("小米路由器设置");
    }
}

public class HuaweiRouter implements IRouterProduct {
    @Override
    public void start() {
        System.out.println("启动华为路由器");
    }

    @Override
    public void shutdown() {
        System.out.println("关闭华为路由器");
    }

    @Override
    public void openwifi() {
        System.out.println("华为路由器打开wifi");
    }

    @Override
    public void setting() {
        System.out.println("华为路由器设置");
    }
}
```

抽象工厂接口

```java
public interface IProductFactory {
    //生产手机
    IPhoneProduct iPhoneProduct();
    //生产路由器
    IRouterProduct iRouterProduct();
}
```

不同等级的产品工厂

```java
public class MIFactory implements IProductFactory {
    @Override
    public IPhoneProduct iPhoneProduct() {
        return new MIPhone();
    }

    @Override
    public IRouterProduct iRouterProduct() {
        return new MIRouter();
    }
}

public class HuaweiFctory implements IProductFactory {
    @Override
    public IPhoneProduct iPhoneProduct() {
        return new HuaweiPhone();
    }

    @Override
    public IRouterProduct iRouterProduct() {
        return new HuaweiRouter();
    }
}
```

客户端

```java
public class Client {
    public static void main(String[] args) {
        System.out.println("=====小米系列产品=====");
        //小米工厂
        MIFactory miFactory = new MIFactory();

        IPhoneProduct iPhoneProduct = miFactory.iPhoneProduct();
        iPhoneProduct.start();

        IRouterProduct iRouterProduct = miFactory.iRouterProduct();
        iRouterProduct.openwifi();

        System.out.println("=====华为系列产品=====");
        //华为工厂
        HuaweiFctory huaweiFctory = new HuaweiFctory();

        IPhoneProduct iPhoneProduct1 = huaweiFctory.iPhoneProduct();
        iPhoneProduct1.callup();

        IRouterProduct iRouterProduct1 = huaweiFctory.iRouterProduct();
        iRouterProduct1.setting();
    }
}
```

## 四、创建者模式

建造者模式也属于创建型模式，它提供了一种创建对象的最佳方式。

定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

主要作用：在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。

用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象(把内部的建造过程和细节隐藏起来

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711123413104-1534791360.png)


### 一般用法，有指挥者

产品

```java
//产品：房子
public class Product {
    private String buildA;
    private String buildB;
    private String buildC;
    private String buildD;

    public String getBuildA() {
        return buildA;
    }

    public void setBuildA(String buildA) {
        this.buildA = buildA;
    }

    public String getBuildB() {
        return buildB;
    }

    public void setBuildB(String buildB) {
        this.buildB = buildB;
    }

    public String getBuildC() {
        return buildC;
    }

    public void setBuildC(String buildC) {
        this.buildC = buildC;
    }

    public String getBuildD() {
        return buildD;
    }

    public void setBuildD(String buildD) {
        this.buildD = buildD;
    }

    @Override
    public String toString() {
        return "Product{" +
                "buildA='" + buildA + '\'' +
                ", buildB='" + buildB + '\'' +
                ", buildC='" + buildC + '\'' +
                ", buildD='" + buildD + '\'' +
                '}';
    }
}
```

抽象的建造者

```java
public abstract class Builder {
    abstract void buildA(); //盖楼的四个步骤
    abstract void buildB();
    abstract void buildC();
    abstract void buildD();

    abstract Product getProduct(); //完工，得到产品
}
```

具体的建造者

```java
public class Worker extends Builder {

    private Product product;

    public Worker(){
        product = new Product();
    }

    @Override
    void buildA() {
        product.setBuildA("A");
        System.out.println("A");
    }

    @Override
    void buildB() {
        product.setBuildB("B");
        System.out.println("B");
    }

    @Override
    void buildC() {
        product.setBuildC("C");
        System.out.println("C");
    }

    @Override
    void buildD() {
        product.setBuildD("D");
        System.out.println("D");
    }

    @Override
    Product getProduct() {
        return product;
    }
}
```

指挥类

```java
//指挥：核心，决定了工作顺序（方式）
public class Director {

    //指挥工人建房子
    public Product build(Builder builder){
        builder.buildA();
        builder.buildB();
        builder.buildC();
        builder.buildD();
        return builder.getProduct();
    }
}
```

测试类

```java
public class Test {
    public static void main(String[] args) {
        //新建一个指挥
        Director director = new Director();
        //指挥控制工人完成产品
        //这里的例子是所有工作都由一类工人完成了
        Product product = director.build(new Worker());
        System.out.println(product.toString());
    }
}
```

### 客户当指挥

产品

```java
//产品：套餐，默认 ABCD 各一个
public class Product {
    private String buildA = "汉堡";
    private String buildB = "可乐";
    private String buildC = "薯条";
    private String buildD = "甜点";

    public void setBuildA(String buildA) {
        this.buildA = buildA;
    }

    public void setBuildB(String buildB) {
        this.buildB = buildB;
    }

    public void setBuildC(String buildC) {
        this.buildC = buildC;
    }

    public void setBuildD(String buildD) {
        this.buildD = buildD;
    }

    @Override
    public String toString() {
        return "Product{" +
                "buildA='" + buildA + '\'' +
                ", buildB='" + buildB + '\'' +
                ", buildC='" + buildC + '\'' +
                ", buildD='" + buildD + '\'' +
                '}';
    }
}
```

抽象建造者

```java
public abstract class Builder {
    abstract Builder buildA(String msg); //汉堡
    abstract Builder buildB(String msg); //可乐
    abstract Builder buildC(String msg); //薯条
    abstract Builder buildD(String msg); //甜点

    abstract Product getProduct();
}
```

具体建造者

```java
public class Worker extends Builder {

    private Product product;

    public Worker(){
        product = new Product();
    }

    @Override
    Builder buildA(String msg) {
        product.setBuildA(msg);
        return this;
    }

    @Override
    Builder buildB(String msg) {
        product.setBuildB(msg);
        return this;
    }

    @Override
    Builder buildC(String msg) {
        product.setBuildC(msg);
        return this;
    }

    @Override
    Builder buildD(String msg) {
        product.setBuildD(msg);
        return this;
    }

    @Override
    Product getProduct() {
        return product;
    }
}
```

客户

```java
public class Client {
    public static void main(String[] args) {
        //服务员
        Worker worker = new Worker();
        Product product = worker.getProduct(); //默认产品
        System.out.println(product.toString());

        //链式编程
        product = worker.buildA("全家桶").buildC("雪碧").getProduct();
        System.out.println(product.toString());
    }
}
// 输出
// Product{buildA='汉堡', buildB='可乐', buildC='薯条', buildD='甜点'}
// Product{buildA='全家桶', buildB='可乐', buildC='雪碧', buildD='甜点'}
```

## 五、原型模式

以某个对象为原型，克隆出一个新的一模一样的对象

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711123447481-1637895333.png)


### 浅克隆

Video类

```java
/*
1.实现一个接口 Cloneable
2.重写一个方法 clone()
 */
public class Video implements Cloneable{ //无良up，克隆别人的视频
    private String name;
    private Date createTime;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    public Video() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }

    public Video(String name, Date createTime) {
        this.name = name;
        this.createTime = createTime;
    }

    @Override
    public String toString() {
        return "Video{" +
                "name='" + name + '\'' +
                ", createTime=" + createTime +
                '}';
    }
}
```

测试类

```java
public class Bilibili {
    public static void main(String[] args) throws CloneNotSupportedException {
        //原型对象
        Date date = new Date();
        Video v1 = new Video("狂神java",date);
        System.out.println("v1=>"+v1.toString());
        System.out.println("v1.hash=>"+v1.hashCode());

        //v1 克隆 v2
        Video v2 = (Video)v1.clone();
        System.out.println("v2=>"+v2.toString());
        System.out.println("v2.hash=>"+v2.hashCode());

        //改变v1的date，v2也跟着变，说明只是浅克隆
        date.setTime(2333);
        System.out.println("v1=>"+v1.toString());
        System.out.println("v2=>"+v2.toString());
    }
}
```

### 深克隆

```java
    @Override
    protected Object clone() throws CloneNotSupportedException {
        Object obj = super.clone();
        Video v = (Video) obj;
        //将对象的属性也克隆
        v.setCreateTime((Date) this.createTime.clone());
        return obj;
    }
```

## 六、适配器模式

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711123510300-996950577.png)


```java
//要被适配的类： 网线
public class ToAdapter {
    public void request(){
        System.out.println("连接网线上网");
    }
}

//接口转换器的抽象实现
public interface NetToUsb {
    //作用：处理请求，网线=>USB
    public void handleRequest();
}

//1.继承实现
//真适配器，需要连接电脑的USB，需要连接网线
public class Adapter extends ToAdapter implements NetToUsb{
    @Override
    public void handleRequest() {
        super.request(); //可以上网了
    }
}

//2.组合实现，热拔插式
public class Adapter2 implements NetToUsb{

    private ToAdapter toAdapter;

    public Adapter2(ToAdapter toAdapter) {
        this.toAdapter = toAdapter;
    }

    @Override
    public void handleRequest() {
        toAdapter.request();
    }
}

//客户端类：想上网，插不上网线
public class Computer {

    //电脑需要连接转接器才能上网
    public void net(NetToUsb adapter){
        //上网的具体实现，找一个转接头
        adapter.handleRequest();
    }

    public static void main(String[] args) {
        //电脑，适配器，网线
        Computer computer = new Computer();
        ToAdapter toAdapter = new ToAdapter();
        Adapter adapter = new Adapter();
        computer.net(adapter);

        Computer computer2 = new Computer();
        Adapter2 adapter2 = new Adapter2(toAdapter);
        computer.net(adapter2);
    }
}
```

## 七、桥接模式

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711123529591-1672654114.png)

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711123540747-1491695157.png)


```java
//品牌
public interface Brand {
    void info();
}

//联想品牌
class Lenovo implements Brand{ //接口
    @Override
    public void info() {
        System.out.print("Lenovo");
    }
}

//苹果品牌
class Apple implements Brand{
    @Override
    public void info() {
        System.out.print("Apple");
    }
}

//抽象的电脑类
public abstract class Computer {

    //组合：品牌 ~ ，computer has a brand
    protected Brand brand;

    public Computer(Brand brand) {
        this.brand = brand;
    }

    public void info(){
        brand.info(); //自带品牌
    }
}

class Desktop extends Computer{ //继承
    public Desktop(Brand brand) {
        super(brand);
    }
    @Override
    public void info() {
        super.info();
        System.out.println("台式机");
    }
}

class Laptop extends Computer{
    public Laptop(Brand brand) {
        super(brand);
    }

    @Override
    public void info() {
        super.info();
        System.out.println("笔记本");
    }
}

//测试类
public class Test {
    public static void main(String[] args) {
        //苹果笔记本
        Computer computer = new Laptop(new Apple());
        computer.info();

        //联想台式机
        Computer computer2 = new Desktop(new Lenovo());
        computer2.info();
    }
}
// 输出
// Apple笔记本
// Lenovo台式机
```

## 八、代理模式

Spring里介绍过的，笔记：[https://www.cnblogs.com/peng8098/p/java_17.html](https://www.cnblogs.com/peng8098/p/java_17.html)

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711123602238-1434090354.png)


## 九、观察者模式

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711123732922-1071882407.png)


![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711123745940-470916472.png)


```java
// Subject 类
public class Subject {
   
   private List<Observer> observers 
      = new ArrayList<Observer>();
   private int state;
 
   public int getState() {
      return state;
   }
 
   public void setState(int state) {
      this.state = state;
      notifyAllObservers();
   }
 
   public void attach(Observer observer){
      observers.add(observer);      
   }
 
   public void notifyAllObservers(){
      for (Observer observer : observers) {
         observer.update();
      }
   }  
}

// Observer 类
public abstract class Observer {
   protected Subject subject; //it has a subject
   public abstract void update();
}

// 实体观察者类
public class BinaryObserver extends Observer{
 
   public BinaryObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
      System.out.println( "Binary String: " 
      + Integer.toBinaryString( subject.getState() ) ); 
   }
}
public class OctalObserver extends Observer{
 
   public OctalObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
     System.out.println( "Octal String: " 
     + Integer.toOctalString( subject.getState() ) ); 
   }
}
public class HexaObserver extends Observer{
 
   public HexaObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
      System.out.println( "Hex String: " 
      + Integer.toHexString( subject.getState() ).toUpperCase() ); 
   }
}

// 使用 Subject 和实体观察者对象测试
public class ObserverPatternDemo {
   public static void main(String[] args) {
      Subject subject = new Subject();
 
      new HexaObserver(subject);
      new OctalObserver(subject);
      new BinaryObserver(subject);
 
      System.out.println("First state change: 15");   
      subject.setState(15);
      System.out.println("Second state change: 10");  
      subject.setState(10);
   }
}
```

**输出**

```java
First state change: 15
Hex String: F
Octal String: 17
Binary String: 1111
Second state change: 10
Hex String: A
Octal String: 12
Binary String: 1010
```

## 十、策略模式

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200711123816107-401887661.png)


```java
//步骤 1 创建一个接口
public interface Strategy {
   public int doOperation(int num1, int num2);
}

//步骤 2 创建实现接口的实体类
public class OperationAdd implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 + num2;
   }
}
public class OperationSubtract implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 - num2;
   }
}
public class OperationMultiply implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 * num2;
   }
}

//步骤 3 创建 Context 类。
public class Context {
   private Strategy strategy;
 
   public Context(Strategy strategy){
      this.strategy = strategy;
   }
 
   public int executeStrategy(int num1, int num2){
      return strategy.doOperation(num1, num2);
   }
}
//步骤 4 使用 Context 来查看当它改变策略 Strategy 时的行为变化。
public class StrategyPatternDemo {
   public static void main(String[] args) {
      Context context = new Context(new OperationAdd());    
      System.out.println("10 + 5 = " + context.executeStrategy(10, 5));
 
      context = new Context(new OperationSubtract());      
      System.out.println("10 - 5 = " + context.executeStrategy(10, 5));
 
      context = new Context(new OperationMultiply());    
      System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
   }
}

// 步骤 5执行程序，输出结果：
// 10 + 5 = 15
// 10 - 5 = 5
// 10 * 5 = 50
```

## 十一、B/S C/S 架构

**C/S架构是什么？**

C/S架构，即Client/Server(客户端/服务器)架构，是一个典型的两层架构。通过将任务合理分配到客户端和服务器，降低了系统的通讯开销，需要安装客户端才可进行管理操作。

客户端包含一个或多个运行在用户计算机上的程序，有两个服务器，一个是数据库服务器，通过数据库连接客户端访问服务器端数据；另一种是套接字服务器，服务器通过套接字程序与客户端通信。

客户端和服务器端的程序不同，用户的程序主要在客户端，服务器端主要提供数据管理、数据共享、数据及系统维护和并发控制等，客户端程序主要完成用户的具体的业务。

开发比较容易，操作简便，但应用程序的升级和客户端程序的维护较为困难。

**B/S架构是什么？**

B/S架构，即Brower/Server(浏览器/服务器)架构。它由逻辑上相互分离的表示层、业务层和数据层构成。表示层向客户提供数据，业务层实施业务和数据规则，数据层定义数据访问标准；三层体系结构中的核心是组件对象模型。

B / S系统统一了客户端，无需特殊安装，拥有Web浏览器即可；它将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用。可以在服务器上安装数据库，然后浏览器通过mysql等数据库来进行数据交互。

**1、建立基础不同**

C/S是建立在局域网的基础上的；而，B/S是建立在广域网的基础上的。

**2、硬件环境不同**

C/S 一般建立在专用的网络上，小范围里的网络环境，局域网之间再通过专门服务器提供连接和数据交换服务。

B/S 建立在广域网之上的，不必有专门的网络硬件环境，例与电话上网，租用设备，信息自己管理。有比C/S更强的适应范围, 一般只要有操作系统和浏览器就行。

**3、对安全要求不同**

C/S 一般面向相对固定的用户群，对信息安全的控制能力很强。一般高度机密的信息系统采用C/S 结构适宜，可以通过B/S发布部分可公开信息.

B/S 建立在广域网之上， 对安全的控制能力相对弱， 面向是不可知的用户群。

**4、对程序架构不同**

C/S 程序更加注重流程， 可以对权限多层次校验， 对系统运行速度可以较少考虑。

B/S对安全以及访问速度的多重考虑， 建立在需要更加优化的基础之上。 比C/S有更高的要求 B/S结构的程序架构是发展的趋势， 从MS的。Net系列的BizTalk 2000 Exchange 2000等， 全面支持网络的构件搭建的系统。 SUN 和IBM推的JavaBean 构件技术等，使 B/S更加成熟。 例如智赢IPOWER，采用AJAX和数据存储优化技术，相比一般B/S架构软件速度提高30%至99%。

**5、软件重用不同**

C/S 程序不可避免的考虑整体性， 构件的重用性不如在B/S要求下的构件的重用性好。

B/S对的多重结构，要求构件相对独立的功能， 能够相对较好的重用。

**6、系统维护不同**

C/S 程序由于整体性， 必须整体考察， 处理出现的问题以及系统升级。 升级难， 可能是再做一个全新的系统

B/S 构件组成，方面构件个别的更换，实现系统的无缝升级。 系统维护开销减到最小；用户从网上自己下载安装就可以实现升级。

**7、处理问题不同**

C/S 程序可以处理用户面固定， 并且在相同区域， 安全要求高需求， 与操作系统相关。 应该都是相同的系统

B/S 建立在广域网上， 面向不同的用户群， 分散地域， 这是C/S无法作到的；与操作系统平台关系最小。

**8、用户接口不同**

C/S 多是建立的Window平台上，表现方法有限，对程序员普遍要求较高

B/S 建立在浏览器上， 通过WEB服务或其他公共可识别描述语言可跨平台，使用更灵活。不仅可应用在Window平台上，还可应用于unix/Linux等平台。

**9、信息流不同**

C/S 程序一般是典型的中央集权的机械式处理， 交互性相对低

B/S 信息流向可变化， B-B B-C B-G等信息、流向的变化， 更象交易中心。]]></description></item><item><title>Spring AOP</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_18.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 10 Jul 2020 09:19:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_18.html</guid><description><![CDATA[### 11. AOP

#### 11.1 什么是AOP

AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710171709996-911882161.png)


#### 11.2 AOP在Spring中的作用

提供声明式事务；允许用户自定义切面

+ 橫切关注点:跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的,但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等....
+ 切面(ASPECT)：横切关注点被模块化的特殊对象。即，它是一个类。
+ 通知(Advice)：切面必须要完成的工作。即，它是类中的一个方法。
+ 目标(Target)：被通知对象。
+ 代理(Proxy)：向目标对象应用通知之后创建的对象。
+ 切入点(PointCut)：切面通知执行的“地点"的定义。
+ 连接点(JointPoint)：与切入点匹配的执行点。

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710171726779-1256806759.png)


SpringAOP中，通过Advice定 义横切逻辑，Spring中支持5种类型的Advice：

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710171742998-501287116.png)


即AOP在不改变原有代码的情况下，去增加新的功能

#### 11.3 使用Spring实现AOP

【重点】使用AOP织入，需要导入一个依赖包

```xml
<!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver-->
<dependency>
	<groupId>org.aspectj</groupId>
	<artifactId>aspectjweaver</artifactId>
    <version>1.9.4</version>
</dependency>
```

**方式一：使用Spring的API接口**【主要SpringAPI接口实现】

UserService.java 接口

```java
package com.peng.service;

public interface UserService {
    public void add();
    public void delete();
    public void update();
    public void select();
}
```

UserServiceImpl.java 实现类

```java
package com.peng.service;

public class UserServiceImpl implements UserService{
    @Override
    public void add() {
        System.out.println("添加了一个用户");
    }

    @Override
    public void delete() {
        System.out.println("删除了一个用户");
    }

    @Override
    public void update() {
        System.out.println("更新了一个用户");
    }

    @Override
    public void select() {
        System.out.println("查询了一个用户");
    }
}
```

Log.java 要添加的日志功能

```java
package com.peng.log;

import org.springframework.aop.MethodBeforeAdvice;
import org.springframework.lang.Nullable;

import java.lang.reflect.Method;

public class Log implements MethodBeforeAdvice{

    //method：要执行的目标对象的方法
    //args：参数
    //target：目标对象
    @Override
    public void before(Method method, Object[] args, @Nullable Object target) throws Throwable {
        System.out.println(target.getClass().getName()+"的"+method.getName()+"被执行了");
    }
}
```

AfterLog.java 也是要添加的日志功能

```java
package com.peng.log;

import org.springframework.aop.AfterReturningAdvice;
import org.springframework.lang.Nullable;

import java.lang.reflect.Method;

public class AfterLog implements AfterReturningAdvice {

    //returnValue 返回值
    @Override
    public void afterReturning(@Nullable Object returnValue, Method method, Object[] args, @Nullable Object target) throws Throwable {
        System.out.println("执行了"+method.getName()+"方法，返回结果为"+returnValue);
    }
}
```

applicationContext.xml Spring配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd 
        http://www.springframework.org/schema/aop 
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!--注册bean-->
    <bean id="userService" class="com.peng.service.UserServiceImpl"/>
    <bean id="log" class="com.peng.log.Log"/>
    <bean id="afterlog" class="com.peng.log.AfterLog"/>

    <!--方式一：使用原生Spring API接口-->
    <!--配置aop，需要导入aop的约束-->
    <aop:config>
        <!--切入点:expression:表达式，execution(要执行的位置! * * * * *)-->
        <aop:pointcut id="pointcut" expression="execution(* com.peng.service.UserServiceImpl.*(..))"/>
        <!--执行环绕增加-->
        <aop:advisor advice-ref="log" pointcut-ref="pointcut"/>
        <aop:advisor advice-ref="afterlog" pointcut-ref="pointcut"/>
    </aop:config>
</beans>
```

MyTest.java 测试类

```java
import com.peng.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        //动态代理，代理的是接口 ※
        UserService userService = context.getBean("userService", UserService.class);
        userService.add();
        userService.delete();
        userService.update();
        userService.select();
    }
}
```

输出：

```
com.peng.service.UserServiceImpl的add被执行了
添加了一个用户
执行了add方法，返回结果为null
com.peng.service.UserServiceImpl的delete被执行了
删除了一个用户
执行了delete方法，返回结果为null
com.peng.service.UserServiceImpl的update被执行了
更新了一个用户
执行了update方法，返回结果为null
com.peng.service.UserServiceImpl的select被执行了
查询了一个用户
执行了select方法，返回结果为null
```

**方式二：自定义来实现AOP**【主要是切面定义】

DiyPointCut.java 自定义类

```java
package com.peng.diy;

public class DiyPointCut {
    public void before(){
        System.out.println("=====方法执行前=====");
    }
    public void after(){
        System.out.println("=====方法执行后=====");
    }
}
```

applicationContext.xml Spring配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!--注册bean-->
    <bean id="userService" class="com.peng.service.UserServiceImpl"/>

    <!--方式二：自定义类-->
    <bean id="diy" class="com.peng.diy.DiyPointCut"/>
    <aop:config>
        <!--自定义切面，ref要引用的类-->
        <aop:aspect ref="diy">
            <!--切入点-->
            <aop:pointcut id="point" expression="execution(* com.peng.service.UserServiceImpl.*(..))"/>
            <!--通知-->
            <aop:before method="before" pointcut-ref="point"/>
            <aop:after method="after" pointcut-ref="point"/>
        </aop:aspect>
    </aop:config>

</beans>
```

测试类和其他类不变

**方式三：使用注解实现AOP**

AnnoPointCut.java 切面类

```java
package com.peng.diy;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

//方式三：使用注解实现AOP
@Aspect //标注这个类是切面
public class AnnoPointCut {

    @Before("execution(* com.peng.service.UserServiceImpl.*(..))")
    public void before(){
        System.out.println("=====方法执行前=====");
    }

    @After("execution(* com.peng.service.UserServiceImpl.*(..))")
    public void after(){
        System.out.println("=====方法执行后=====");
    }

    //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点
    @Around("execution(* com.peng.service.UserServiceImpl.*(..))")
    public void around(ProceedingJoinPoint jp) throws Throwable {
        System.out.println("环绕前");

        Signature signature = jp.getSignature();// 获得签名（类的信息）
        System.out.println(signature);

        //执行方法
        Object proceed = jp.proceed();

        System.out.println("环绕后");
    }
}
```

applicationContext.xml Spring配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!--注册bean-->
    <bean id="userService" class="com.peng.service.UserServiceImpl"/>

    <!--方式三-->
    <bean id="annoPointCut" class="com.peng.diy.AnnoPointCut"/>
    <!--开启注解支持!  JDK(默认)(false)  cglib(true)-->
    <aop:aspectj-autoproxy proxy-target-class="false"/>

</beans>
```

测试类和其他类不变

输出：

```
环绕前
void com.peng.service.UserService.select()
=====方法执行前=====
查询了一个用户
环绕后
=====方法执行后=====
```]]></description></item><item><title>代理模式</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_17.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 10 Jul 2020 08:51:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_17.html</guid><description><![CDATA[### 10. 代理模式

代理模式是SpringAOP的底层！【SpringAOP和SpringMVC】

+ 代理模式的分类：静态代理  动态代理

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710164913919-726675970.png)


#### 10.1 静态代理

角色分析：

+ 抽象角色：一般会使用接口或者抽象类来解决

  ```java
  package com.peng.demo01;
  
  //租房
  public interface Rent {
      public void rent();
  }
  ```

+ 真实角色：被代理的角色

  ```java
  package com.peng.demo01;
  
  //房东
  public class Host implements Rent{
      @Override
      public void rent() {
          System.out.println("房东要出租房子！");
      }
  }
  ```

+ 代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作

  ```java
  package com.peng.demo01;
  
  public class Proxy implements Rent {
      private Host host;
  
      public Proxy() {
      }
  
      public Proxy(Host host) {
          this.host = host;
      }
  
      @Override
      public void rent() {
          seeHouse();
          host.rent();
          sign();
          fare();
      }
  
      //看房
      public void seeHouse(){
          System.out.println("中介带你看房");
      }
  
      //签合同
      public void sign(){
          System.out.println("签租赁合同");
      }
  
      //收中介费
      public void fare(){
          System.out.println("收中介费");
      }
  }
  ```

+ 客户端：访问代理对象的人！

  ```java
  package com.peng.demo01;
  
  public class Client {
      public static void main(String[] args) {
          //房东要租房子
          Host host = new Host();
          //代理，中介帮房东租房子，但是呢?代理一般会有一些附属操作!
          Proxy proxy = new Proxy(host);
          //你不用面对房东，直接找中介租房即可
          proxy.rent();
      }
  }
  ```

代理模式的好处：

+ 可以使真实角色的操作更加纯粹，不用去关注一些公共的业务
+ 公共也就就交给代理角色!实现了业务的分工
+ 公共业务发生扩展的时候，方便集中管理

缺点：一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低

#### 10.2 加深理解

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710164944181-1472231007.png)

对修改关闭，不修改源码，外边套一层

#### 10.3 动态代理

+ 动态代理和静态代理角色一样
+ 动态代理的代理类是动态生成的，不是我们直接写好的
+ 动态代理分为两大类：基于接口的动态代理，基于类的动态代理
  + 基于接口：JDK动态代理【我们在这里使用】
  + 基于类：cglib
  + java字节码实现：javasist

需要了解两个类：Proxy 代理，InvocationHandler 调用处理程序

Rent.java 租房接口

```java
package com.peng.demo03;

//租房
public interface Rent {
    public void rent();
}
```

Host.java 房东实体类

```java
package com.peng.demo03;

//房东
public class Host implements Rent {
    @Override
    public void rent() {
        System.out.println("房东要出租房子！");
    }
}
```

ProxyInvocationHandler.java 动态代理类

```java
package com.peng.demo03;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

//用这个类自动生成代理类
public class ProxyInvocationHandler implements InvocationHandler{

    //被代理的接口
    private Rent rent;

    public void setRent(Rent rent) {
        this.rent = rent;
    }

    //生成得到代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this);
    }

    //处理代理实力，并返回结果
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        //动态代理的本质，就是使用反射机制实现
        seeHouse();
        Object result = method.invoke(rent, args);
        fare();
        return result;
    }

    public void seeHouse(){
        System.out.println("中介带看房子");
    }

    public void fare(){
        System.out.println("收中介费");
    }
}
```

Client.java 客户端

```java
package com.peng.demo03;

public class Client {
    public static void main(String[] args) {
        //真实角色
        Host host = new Host();

        //代理角色：现在没有
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        //通过调用程序处理角色来处理我们要调用的按口对象!
        pih.setRent(host);

        Rent proxy = (Rent) pih.getProxy(); //这里的proxy就是动态生成的，我们并没有写
        proxy.rent();
    }
}
```

动态代理的好处：

+ 可以使真实角色的操作更加纯粹!不用去关注一些公共的业务
+ 公共也就就交给代理角色!实现了业务的分工
+ 公共业务发生扩展的时候，方便集中管理
+ 一个动态代理类代理的是一个**接口**， 一般就是对应的**一类**业务
+ 一个动态代理类可以代理多个类，只要是实现了同一个接口即可

通式

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyInvocationHandler implements InvocationHandler{

    //被代理的接口
    private Object target;

    public void setRent(Object target) {
        this.target = target;
    }

    //生成得到代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    }

    //处理代理实力，并返回结果
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //动态代理的本质，就是使用反射机制实现
        log(method.getName()); //利用反射写活了
        Object result = method.invoke(target, args);
        return result;
    }

    public void log(String msg){
        System.out.println("执行了"+msg+"方法");
    }
}
```
]]></description></item><item><title>Spring JavaConfig配置</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_16.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 10 Jul 2020 08:37:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_16.html</guid><description><![CDATA[### 9. JavaConfig 配置

我们现在要完全不使用Spring的xml配置了，全权交给lava来做

JavaConfig 是 Spring 的一个子项目，在 Spring 4 之后，它成为了一个核心功能！

User.java 实体类

```java
package com.peng.pojo;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

//这里这个注解的意思，就是说明这个类被Spring注册到了齐器中
@Component
public class User {
    private String name;

    public String getName() {
        return name;
    }

    @Value("peng") //属性注入值
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

MyConfig.java 配置类

```java
package com.peng.config;

import com.peng.pojo.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

//这个也会Spring容器托管，注册到容器中。因为他本来就是一个@Component
@Configuration //@Configuration代表这是一个配置类，跟beans.xml一样
@ComponentScan("com.peng")
@Import(MyConfig2.class) //合并其他beans配置
public class MyConfig {

    //注册一个bean，就相当于我们之前写的bean标签
    //方法名：bean标签中的id
    //返回值：bean标签中的class
    @Bean
    public User getUser(){
        return new User(); //就是返回要注入bean的对象!
    }
}
```

MyTest.java 测试类

```java
import com.peng.config.MyConfig;
import com.peng.pojo.User;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class MyTest {
    public static void main(String[] args) {
        //如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载!
        ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
        User user = context.getBean("user",User.class);
        System.out.println(user.getName());
    }
}
```

这种纯Java的配置方式，在SpringBoot中随处可见！]]></description></item><item><title>Spring 面向注解开发</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_15.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 10 Jul 2020 08:26:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_15.html</guid><description><![CDATA[### 8. Spring注解开发

在Spring4之后，要使用注解开发，必须要保证aop的包导入了

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710162447672-1685193753.png)

使用注解需要导入context约束，增加注解的支持!

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <!--指定要扫描的包，这个包下的注解就会生效 ※ -->
    <context:component-scan base-package="com.peng.pojo"/>
    <context:annotation-config/>
</beans>
```

1. bean

   ```java
   //等价于 <bean id="user" class="com.peng.dao.User"/>
   //@Component组件,放在类上，说明这个类被Spring管理了
   @Component
   public class User {
       public String name = "peng";
   }
   ```

2. 属性如何注入

   ```java
   @Component
   public class User {
       //相当于 <property name="name" value="peng"/>
       @Value("peng")
       public String name;
   }
   ```

   也可以放到set上

   ```java
   @Component
   public class User {
       public String name;
       
       @Value("peng")
       public void setName(String name) {
           this.name = name;
       }
   }
   ```

3. 衍生的注解

   @Component 有几个衍生注解，我们在web开发中，会按照mvc三层架构分层！

   - dao【@Repository】

     ```java
     import org.springframework.stereotype.Repository;
     
     @Repository
     public class UserDao {
     }
     ```

   - service【@Service】

   - controller【@Controller】

   这四个注解功能都是一样的，都是代表将某个类注册到Spring中，装配Bean

4. 自动装配置

   @Autowired、@Nullable、@Resource，前面介绍过

5. 作用域

   @Scope("singleton") / @Scope("prototype")

6. 小结 **xml 与 注解**

   + xml更加万能，适用于任何场合，维护简单方便
   + 注解不是自己类使用不了，维护相对复杂

   xml与注解最佳实践：

   + xml用来管理bean
   + 注解只负责完成属性的注入
   + 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持]]></description></item><item><title>Spring Bean 自动装配</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_14.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 10 Jul 2020 07:35:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_14.html</guid><description><![CDATA[### 7. Bean的自动装配

+ 自动装配是Spring满足bean依赖一种方式
+ Spring会在上下文中自动寻找，并自动给bean装配属性

在Spring中有三种装配的方式

1. 在xml中显示的配置
2. 在java中显示配置
3. 隐式的自动装配bean ※

#### 7.1 测试

环境搭建：一个人有两个宠物

```java
package com.peng.pojo;

public class Cat {
    public void shout(){
        System.out.println("miao~");
    }
}

public class Dog {
    public void shout(){
        System.out.println("wang~");
    }
}

package com.peng.pojo;

public class People {
    private Cat cat;
    private Dog dog;
    private String name;

    public Cat getCat() {
        return cat;
    }

    public void setCat(Cat cat) {
        this.cat = cat;
    }

    public Dog getDog() {
        return dog;
    }

    public void setDog(Dog dog) {
        this.dog = dog;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "People{" +
                "cat=" + cat +
                ", dog=" + dog +
                ", name='" + name + '\'' +
                '}';
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:c="http://www.springframework.org/schema/c"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="cat" class="com.peng.pojo.Cat"/>
    <bean id="dog" class="com.peng.pojo.Dog"/>

    <bean id="people" class="com.peng.pojo.People">
        <property name="name" value="peng"/>
        <property name="cat" ref="cat"/>
        <property name="dog" ref="dog"/>
    </bean>
</beans>
```

```java
import com.peng.pojo.People;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest {
    @Test
    public void test1(){
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");

        People people = context.getBean("people",People.class);
        System.out.println(people.toString());
        people.getCat().shout();
        people.getDog().shout();
    }
}
```

#### 7.2 自动装配

1. ```xml
   <!--byName：会自动在容器上下文中查线，和白己对象set方法后面的值对应的beanid !-->
   <bean id="people" class="com.peng.pojo.People" autowire="byName">
   	<property name="name" value="peng"/>
   </bean>
   ```

2. ```xml
   <bean class="com.peng.pojo.Cat"/>
   <bean class="com.peng.pojo.Dog"/>
   
   <!--byType：会自动在容器上下文中查找，和自己对象属性类型相同的bean!-->
   <bean id="people" class="com.peng.pojo.People" autowire="byType">
       <property name="name" value="peng"/>
   </bean>
   ```

小结：

byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致!
bytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致!

#### 7.3 使用注解实现自动装配

jdk1.5支持的注解，Spring2.5就支持注解了!

官网介绍：The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.

要使用注解须知：

1. 导入约束：context约束

2. **配置注解的支持：<context:annotation-config/>**

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           https://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           https://www.springframework.org/schema/context/spring-context.xsd">
   
       <context:annotation-config/>
   
   </beans>
   ```


3. @Autowired 在属性上用：使用Autowired我们可以不用编写Set方法了，前提是你这个自动装配的属性在I0C (Spring) 容器中存在，且符合名字，即 byName！

   ```java
   public class People {
   
       @Autowired
       private Cat cat;
       @Autowired
       private Dog dog;
       private String name;
   
       public Cat getCat() { return cat;}
   
       public Dog getDog() {return dog;}
   
       public String getName() {return name;}
   
       public void setName(String name) {this.name = name;}
   
       @Override
       public String toString() {
           return "People{" +
                   "cat=" + cat +
                   ", dog=" + dog +
                   ", name='" + name + '\'' +
                   '}';
       }
   }
   ```

   @Autowired 在set方法上用

   ```java
   import org.springframework.beans.factory.annotation.Autowired;
   
   public class People {
   
       private Cat cat;
       private Dog dog;
       private String name;
   
       public Cat getCat() {return cat;}
   
       @Autowired
       public void setCat(Cat cat) {
           this.cat = cat;
       }
   
       public Dog getDog() {return dog;}
   
       @Autowired
       public void setDog(Dog dog) {
           this.dog = dog;
       }
   
       public String getName() {return name;}
   
       public void setName(String name) {this.name = name;}
   
       @Override
       public String toString() {
           return "People{" +
                   "cat=" + cat +
                   ", dog=" + dog +
                   ", name='" + name + '\'' +
                   '}';
       }
   }
   ```

   构造器中加注解 @Nullable name可以为空，在初始化时不给name赋值也不会报错

   ```java
   public People(@Nullable String name) {
       this.name = name;
   }
   ```

   如果显示定义了Autowired的required属性为false, 说明这个对象可以为mull，否则不允许为空

   ```java
   @Autowired(required = false)
   private Cat cat;
   ```

   如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用 @Qualifier(value="xxx") 去配合@Autowired的使用， 指定一个唯一的bean对象注入！

   ```java
   public class People {
       @Autowired
       @Qualifier(value="dog222")
       private Dog dog;
   }
   ```

   @Resource注解

   ```java
   public class People {
       @Resource(name="dog222")
       private Dog dog;
       @Resource
       private Cat cat;
   }
   ```

   @Resource和@ Autowired的区别:

   + 都是用来自动装配的，都可以放在属性字段上
   + @Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用]】
   + @Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现!如果两个都找不到的情况下，就报错! 【常用】
   + 执行顺序不同：@Autowired：类型、名字；@Resource：名字、类型]]></description></item><item><title>Spring 依赖注入</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_13.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 10 Jul 2020 07:18:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_13.html</guid><description><![CDATA[### 6. 依赖注入

#### 6.1 构造器注入

前面已经说过

#### 6.2 set方式注入※

+ 依赖注入：本质是set注入！

+ 依赖：bean对象的创建依赖于容器

+ 注入：bean对象中的所有属性，由容器来注入

+ 环境搭建

  1. 复杂类型

     ```java
     package com.peng.pojo;
     
     public class Address {
         private String address;
     
         public String getAddress() {
             return address;
         }
     
         public void setAddress(String address) {
             this.address = address;
         }
         
         @Override
         public String toString() {
             return "Address{" +
                     "address='" + address + '\'' +
                     '}';
         }
     }
     ```

  2. 真实测试对象

     ```java
     package com.peng.pojo;
     
     import java.util.*;
     
     public class Student {
         private String name;
         private Address address;
         private String[] book;
         private List<String> hobbys;
         private Map<String,String> card;
         private Set<String> games;
         private String wife;
         private Properties info;
     
         public String getName() {
             return name;
         }
     
         public void setName(String name) {
             this.name = name;
         }
     
         public Address getAddress() {
             return address;
         }
     
         public void setAddress(Address address) {
             this.address = address;
         }
     
         public String[] getBook() {
             return book;
         }
     
         public void setBook(String[] book) {
             this.book = book;
         }
     
         public List<String> getHobbys() {
             return hobbys;
         }
     
         public void setHobbys(List<String> hobbys) {
             this.hobbys = hobbys;
         }
     
         public Map<String, String> getCard() {
             return card;
         }
     
         public void setCard(Map<String, String> card) {
             this.card = card;
         }
     
         public Set<String> getGames() {
             return games;
         }
     
         public void setGames(Set<String> games) {
             this.games = games;
         }
     
         public String getWife() {
             return wife;
         }
     
         public void setWife(String wife) {
             this.wife = wife;
         }
     
         public Properties getInfo() {
             return info;
         }
     
         public void setInfo(Properties info) {
             this.info = info;
         }
     
         @Override
         public String toString() {
             return "Student{" +
                     "name='" + name + '\'' +
                     ", address=" + address.toString() +
                     ", book=" + Arrays.toString(book) +
                     ", hobbys=" + hobbys +
                     ", card=" + card +
                     ", games=" + games +
                     ", wife='" + wife + '\'' +
                     ", info=" + info +
                     '}';
         }
     }
     ```

  3. beans.xml

     ```xml
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans
             https://www.springframework.org/schema/beans/spring-beans.xsd">
     
         <bean id="address" class="com.peng.pojo.Address">
             <property name="address" value="葫芦岛"/>
         </bean>
         <bean id="student" class="com.peng.pojo.Student">
             <!--1.普通值注入，value-->
             <property name="name" value="peng"/>
     
             <!--2.其他高级类型注入，bean注入，ref-->
             <property name="address" ref="address"/>
     
             <!--3.数组注入，ref-->
             <property name="book">
                 <array>
                     <value>红楼梦</value>
                     <value>西游记</value>
                     <value>水浒传</value>
                     <value>三国演义</value>
                 </array>
             </property>
     
             <!--4.List-->
             <property name="hobbys">
                 <list>
                     <value>吃饭</value>
                     <value>睡觉</value>
                 </list>
             </property>
     
             <!--5.Map-->
             <property name="card">
                 <map>
                     <entry key="身份证" value="132151313213513553"/>
                     <entry key="银行卡" value="165562612020201234"/>
                 </map>
             </property>
     
             <!--6.Set-->
             <property name="games">
                 <set>
                     <value>LOL</value>
                     <value>CF</value>
                 </set>
             </property>
     
             <!--7.null，空值注入-->
             <property name="wife">
                 <null/>
             </property>
             
             <!--8.Properties-->
             <property name="info">
                 <props>
                     <prop key="学号">20200525</prop>
                     <prop key="性别">男</prop>
                     <prop key="生日">20010604</prop>
                 </props>
             </property>
         </bean>
     </beans>
     ```

  4. 测试类

     ```java
     import com.peng.pojo.Student;
     import org.springframework.context.ApplicationContext;
     import org.springframework.context.support.ClassPathXmlApplicationContext;
     
     public class MyTest {
         public static void main(String[] args) {
             ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
             Student student = (Student) context.getBean("student");
             System.out.println(student.toString());
         }
     }
     ```

  5. 输出

     ```
     Student{name='peng', address=Address{address='葫芦岛'}, book=[红楼梦, 西游记, 水浒传, 三国演义], hobbys=[吃饭, 睡觉], card={身份证=132151313213513553, 银行卡=165562612020201234}, games=[LOL, CF], wife='null', info={学号=20200525, 生日=20010604, 性别=男}}
     ```

#### 6.3 其他方式

+ p标签：`xmlns:p="http://www.springframework.org/schema/p"`
+ c标签：`xmlns:c="http://www.springframework.org/schema/c"`

User.java

```java
package com.peng.pojo;

public class User {
    private String name;
    private int age;

    public User() {
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

userbeans.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:c="http://www.springframework.org/schema/c"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--p命名空间注入，可以直接注入属性的值,property-->
    <bean id="user" class="com.peng.pojo.User" p:name="peng" p:age="18"/>
    <!--c命名空间注入，通过构造器注入，constructor-->
    <bean id="user2" class="com.peng.pojo.User" c:age="18" c:name="peng"/>
</beans>
```

测试类

```java
import com.peng.pojo.User;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest {
    public static void main(String[] args) {
        test2();
        test3();
    }

    @Test
    public static void test2(){
        ApplicationContext context = new ClassPathXmlApplicationContext("userbeans.xml");
        User user = context.getBean("user",User.class);
        System.out.println(user);
    }

    @Test
    public static void test3(){
        ApplicationContext context = new ClassPathXmlApplicationContext("userbeans.xml");
        User user = context.getBean("user2",User.class);
        System.out.println(user);
    }
}
```

#### 6.4 bean的作用域

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710151621056-2074834142.png)


1. 单例模式 singleton

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710151637825-296640082.png)


![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710151653206-1210972809.png)


2. 原型模式 prototype

   每次从容器中get的时候，都会产生一个新对象

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710151710197-1553333840.png)


3. 其余的 request、session、application，这些只能在web开发中使用到]]></description></item><item><title>Spring Bean 的配置</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_12.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 10 Jul 2020 07:13:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_12.html</guid><description><![CDATA[### 5. Spring配置

#### 5.1 别名

```xml
<alias name="user" alias="userPeng"/>
```

添加别名后，获取对象既可使用原名，也可以使用别名

```java
User user = (User)context.getBean("user");
//User user = (User)context.getBean("userPeng");
```

#### 5.2 Bean的配置

id：bean 的唯一标识符，也就是相当于我们的对象名

class：bean 对象所对应的全限定名：包名+类名

name：也是别名，而且name可以同时取多个（`name="user2,u2;u3"`），alias 只能一一对应

#### 5.3 import

一般用于团队开发使用，它可以将多个配置文件，导入合并为一个。

applicationContext.xml

```xml
<import resource="beans1.xml"/>
<import resource="beans2.xml"/>
<import resource="beans3.xml"/>
```
]]></description></item><item><title>Spring IOC创建对象</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_11.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 10 Jul 2020 06:10:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_11.html</guid><description><![CDATA[### 4. IOC创建对象的方式

1. 使用无参构造创建，默认

   User.java 类

   ```java
   package com.peng.pojo;
   
   public class User {
       private String name;
   
       public User(){
           System.out.println("User无参构造");
       }
   
       public User(String name) {
           this.name = name;
           System.out.println("User有参构造");
       }
   
       public String getName() {
           return name;
       }
   
       public void setName(String name) {
           this.name = name;
       }
   
       public void show(){
           System.out.println("name="+name);
       }
   }
   ```

   beans.xml

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
           https://www.springframework.org/schema/beans/spring-beans.xsd">
       <bean id="user" class="com.peng.pojo.User">
           <property name="name" value="peng"/>
       </bean>
   </beans>
   ```

   MyTest.java 测试类

   ```java
   import com.peng.pojo.User;
   import org.springframework.context.ApplicationContext;
   import org.springframework.context.support.ClassPathXmlApplicationContext;
   
   public class MyTest {
       public static void main(String[] args) {
           ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
   
           User user = (User)context.getBean("user");
           user.show();
       }
   }
   ```

   输出

   ```
   User无参构造
   name=peng
   ```

2. 有参构造创建对象（三种方式）

   ```xml
   <beans>    
   	<!--有参构造的三种方法-->
   
       <!--1.下标赋值-->
       <bean id="user" class="com.peng.pojo.User">
           <constructor-arg index="0" value="peng"/>
       </bean>
   
       <!--2.通过类型创建不建议使用-->
       <bean id="user" class="com.peng.pojo.User">
           <constructor-arg type="java.lang.String" value="peng"/>
       </bean>
   
       <!--3.直接通过参数名来设置-->
       <bean id="user" class="com.peng.pojo.User">
           <constructor-arg name="name" value="peng"/>
       </bean>
   </beans>
   ```

3. Spring 容器执行的时候，不管测试类中是否 get，所有的类都已经被实例化了，什么时候用什么时候 get。

   ```java
   User user = (User)context.getBean("user");
   User user2 = (User)context.getBean("user");
   System.out.println(user == user2); //输出为true
   ```

   Spring 中只有一个实例！]]></description></item><item><title>第一个 Spring 程序</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_10.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 10 Jul 2020 05:49:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/10/java_10.html</guid><description><![CDATA[### 3. HelloSpring

#### 3.1 Hello

+ 防止每次 reimport 都回到1.5，在pom.xml中加上java版本号

  ```xml
  <build>
      <finalName>income</finalName>
      <plugins>
          <plugin>
              <groupId>org.apache.maven.plugins</groupId>
              <artifactId>maven-compiler-plugin</artifactId>
              <version>3.1</version>
              <configuration>
                  <source>1.8</source>
                  <target>1.8</target>
              </configuration>
          </plugin>
      </plugins>
  </build>
  ```

+ 官网beans格式

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.springframework.org/schema/beans
          https://www.springframework.org/schema/beans/spring-beans.xsd">
  
      <!--bean可配置多个-->
      <bean id="..." class="...">  
          <!-- collaborators and configuration for this bean go here -->
      </bean>
  
      <!-- more bean definitions go here -->
  </beans>
  ```

+ Hello程序

  Hello类

  ```java
  package com.peng.pojo;
  
  public class Hello {
  
      private String str;
  
      public String getStr() {
          return str;
      }
  
      public void setStr(String str) {
          this.str = str;
      }
  
      @Override
      public String toString() {
          return "Hello{" + "str='" + str + "\'" + "}";
      }
  }
  ```

  beans.xml 容器，用户在此修改配置，无需程序员修改源码

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
          https://www.springframework.org/schema/beans/spring-beans.xsd">
  
      <!--使用Spring来创建对象，在Spring这些都被称为bean
      类型 变量名 = new 类名();
      Hello hello = new Hello();
      id = 变量名
      class = new的对象
      property 给对象中的属性设置一个值
      -->
      <bean id="hello" class="com.peng.pojo.Hello">
          <property name="str" value="Spring"></property>
      </bean>
  </beans>
  ```

  MyTest.java 测试类

  ```java
  import com.peng.pojo.Hello;
  import org.springframework.context.ApplicationContext;
  import org.springframework.context.support.ClassPathXmlApplicationContext;
  
  public class MyTest {
      public static void main(String[] args) {
          //获取Spring的上下文对象
          ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
          //我们的对象现在都在Spring中管理，我们要使用，直接去里面取出来就可以！
          Hello hello = (Hello) context.getBean("hello");
          System.out.println(hello.toString());
      }
  }
  ```

#### 3.2 上一节代码修改

+ beans.xml

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
          https://www.springframework.org/schema/beans/spring-beans.xsd">
  
      <bean id="mysqlImpl" class="com.peng.dao.UserDaoMysqlImpl"></bean>
      <bean id="oracleImpl" class="com.peng.dao.UserDaoOracleImpl"></bean>
  
      <bean id="UserServiceImpl" class="com.peng.service.UserServiceImpl">
          <!--
          ref：引用Spring容器中创建好的对象
          value：具体的值，基本数据类型
          -->
          <property name="userDao" ref="mysqlImpl"/>
      </bean>
  </beans>
  ```

+ 测试类

  用容器操作，从此不用再new！

  ```java
  import com.peng.service.UserServiceImpl;
  import org.springframework.context.support.ClassPathXmlApplicationContext;
  
  public class MyTest {
      public static void main(String[] args) {
          //获取ApplicationContext，拿到Spring的容器，官网固定用法
          ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
  
          //需要什么get什么
          UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean("UserServiceImpl");
  
          userServiceImpl.getUser();
      }
  }
  ```

#### 3.3 总结

IOC的理解：原来的对象都是由程序员new出来的，现在我们提供了spring容器，它可以创建出一个对象，并配置这个对象的属性。spring容器的配置文件xml是方便修改的，原来的程序只需被动接受spring提供的对象。一句话说：对象由Spring来创建，管理，装配！]]></description></item><item><title>Spring IOC理论</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/10/spring_02.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 10 Jul 2020 05:29:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/10/spring_02.html</guid><description><![CDATA[### 2. IOC理论推导

+ Springmvc jar包

  地址：https://mvnrepository.com/artifact/org.springframework/spring-webmvc

  ```xml
      <dependencies>
              <!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
          <dependency>
              <groupId>org.springframework</groupId>
              <artifactId>spring-webmvc</artifactId>
              <version>5.2.0.RELEASE</version>
          </dependency>
      </dependencies>
  ```

  导这个包的好处：前置的包都自动导入了

1. UserDao 接口

   ```java
   package com.peng.dao;
   
   public interface UserDao {
       void getUser();
   }
   ```

2. UserDaoImpl 实现类

   ```java
   package com.peng.dao;
   
   public class UserDaoImpl implements UserDao{
       public void getUser() {
           System.out.println("默认获取用户的数据");
       }
   }
   ```

3. UserService 业务接口

   ```java
   package com.peng.service;
   
   public interface UserService {
       void getUser();
   }
   ```

4. UserServiceImpl 业务实现类

   ```java
   package com.peng.service;
   
   import com.peng.dao.UserDao;
   import com.peng.dao.UserDaoImpl;
   import com.peng.dao.UserDaoMysqlImpl;
   import com.peng.dao.UserDaoOracleImpl;
   
   public class UserServiceImpl implements UserService{
   
       //private UserDao userDao = new UserDaoImpl();
       //private UserDao userDao = new UserDaoMysqlImpl();
       private UserDao userDao = new UserDaoOracleImpl();
       //用户每次提出新需求都要改代码
   
       //利用set进行动态实现值的注入
       public void setUserDao(UserDao userDao){
           this.userDao = userDao;
       }
   
       public void getUser() {
           userDao.getUser();
       }
   }
   ```

5. MyTest 测试类

   ```java
   import com.peng.dao.UserDaoMysqlImpl;
   import com.peng.service.UserServiceImpl;
   
   public class MyTest {
       public static void main(String[] args) {
   
           //用户实际调用的是业务层，dao层不需要接触
           UserServiceImpl userService = new UserServiceImpl();
   
           userService.getUser();
   
           //用户自己控制，无需改源码
           ((UserServiceImpl) userService).setUserDao(new UserDaoMysqlImpl());
           userService.getUser();
       }
   }
   ```

6. 添加其他的业务 UserDaoMysqlImpl 和 UserDaoOracleImpl

   ```java
   package com.peng.dao;
   
   public class UserDaoMysqlImpl implements UserDao{
       public void getUser(){
           System.out.println("MySQL获取用户的数据");
       }
   }
   ```

   ```java
   package com.peng.dao;
   
   public class UserDaoOracleImpl implements UserDao{
       public void getUser(){
           System.out.println("Oracle获取用户的数据");
       }
   }
   ```

在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵!

我们使用一个Set接口实现，已经发生了革命性的变化

```java
private UserDao userDao;

//利用set进行动态实现值的注入
public void setUserDao(UserDao userDao){
    this.userDao = userDao;
}
```

之前，程序是主动创建对象！控制权在程序猿手上！
使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象！

这种思想，从本质上解决了问题，我们程序猿不用再去管理对象的创建了。系统的耦合性大大降低，可以更加专注到业务的实现上。这是**IOC**的原型！

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710132902334-150359094.png)


控制反转**loC(Inversion of Control)**，是一种设计思想，**DI(依赖注入)**是实现IoC的一种方法，也有人认为DI只是IoC的另一-种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是:获得依赖对象的方式反转了。

采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。

**控制反转是一种通过描述(XML或注解)并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是loC容器，其实现方法是依赖注入(Dependency Injection，DI)。**]]></description></item><item><title>Spring 介绍</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/10/spring_01.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 10 Jul 2020 05:24:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/10/spring_01.html</guid><description><![CDATA[### 1. Spring

#### 1.1 简介

+ Spring

  春天

+ 历史

  2002，首次推出了Spring框架的雏形

  2004.3.24，首次推出了Spring框架的雏形：interface21框架

  Spring框架即以interface21框架为基础经过重新设计，并不断丰富其内涵，于2004年月24日发布了1.0正式版。

  Rod Johnsoh，Spring Framework创始人。

+ Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架!

+ SSH：Struct2 + Spring + Hibernate

+ SSM：SpringMVC + Spring + Mybatis

#### 1.2 优点

+ Spring是一个开源的免费的框架(容器) 
+ Spring是一个轻量级的、非入侵式的框架
+ **控制反转（IOC），面向切面（AOP）**
+ 支持事务的处理，对框架整合的支持
+ 总结：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架

#### 1.3 组成

+ Spring 7大模块
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710132245476-1346907764.png)


#### 1.4 Spring 官网

+ 现代化的java开发，基于Spring的开发


![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710132259010-396703778.png)


+ SpringBoot

  一个快速开发的脚手架

  基于SpringBoot可以快速开发单个微服务

  约定大于配置

+ SpringCloud

  是基于SpringBoot实现的

+ 现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！

+ Spring弊端

  发展了太久，违背了原来的理念，配置十分繁琐，"配置地狱"

+ Spring官方文档

  https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html]]></description></item><item><title>MySQL 数据库（下）</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/10/db_02.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 10 Jul 2020 01:07:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/10/db_02.html</guid><description><![CDATA[### 事务

#### 什么是事务

+ A给B转账，B收到A的钱

  要么都成功，要么都失败

  将一组SQL放到一个批次中去执行

+ ACID原则

  原子性Atomicity，要么都完成，要么都不完成

  一致性Consistency，针对一个事务操作前与操作后状态一直

  持久性Durability，表示事务结束后的数据不随着外界原因导致数据丢失（事务一旦提交不可逆）

  隔离性Isolation，针对多个用户同时操作，主要是排除其他事务对本次事务的影响

+ 隔离导致的问题

  脏读：指一个事务读取了另外- -个事务未是交的数据。
  不可重复读：在一个事务内读取表中的某一行数据， 多次读取结果不同。(这个不一定是错误， 只是某些场合不对)
  虚读(幻读)：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。

#### MySQL中的事务

+ 用法

  ```mysql
  -- MySQL 是默认开启事务自动提交的
  SET autocommit = 0 -- 关闭
  SET autocommit = 1 -- 开启
  
  -- 手动处理事务
  SET autocommit = 0 -- 关闭自动提交
  -- 事务开启
  START TRANSACTION -- 标记一个事务的开始，从这个之后的sql都在同一个事务内
  INSERT XXX
  INSERT XXX
  -- 提交：持久化（成功）
  COMMIT
  -- 回滚：回到原来的样子（失败）
  ROLLBACK
  -- 事务结束
  SET autocommit = 1 -- 开启自动提交
  
  SAVEPOINT 保存点名 -- 设置一个事务的保存点
  ROLLBACK TO SAVEPOINT 保存点名 -- 回滚到保存点
  RELEASE SAVEPOINT 保存点名 -- 删除保存点
  ```

+ 模拟场景 转账

  ```mysql
  -- 转账
  CREATE DATABASE shop CHARACTER SET utf8 COLLATE utf8_general_ci
  USE shop
  
  CREATE TABLE `account`(
  	`id` INT(3) NOT NULL AUTO_INCREMENT,
  	`name` VARCHAR(30) NOT NULL,
  	`money` DECIMAL(9,2) NOT NULL,
  	PRIMARY KEY(`id`)
  )ENGINE=INNODB DEFAULT CHARSET=utf8
  
  INSERT INTO account(`name`,`money`)
  VALUES ('A',2000.00),('B',10000.00)
  
  -- 模拟转账：事务
  SET autocommit = 0; -- 关闭自动提交
  START TRANSACTION; -- 开启一个事务
  
  UPDATE account SET money=money-500 WHERE `name` = 'A'; -- A减500
  UPDATE account SET money=money+500 WHERE `name` = 'B'; -- B加500
  
  COMMIT; -- 提交事务
  ROLLBACK; -- 回滚
  
  SET autocommit = 1; -- 恢复默认值
  ```

+ Java中操作事务

  ```java
  方法(){
      try(){
          //正常的业务代码
          commit();
      }catch(){
          rollback();
      }
  }
  ```

### 索引

MySQL官方对索引的定义为：**索引(Index) 是帮助MySQL高效获取数据的数据结构**。提取句子主干，就可以得到索引的本质：索引是数据结构。

+ 索引的分类

  主键索引 PRIMARY KEY：唯一的标识，不可重复，只有一个列作为主键

  唯一索引 UNIQUE KEY：避免重复的列（字段）出现，可以重复，多个列都可以标识为唯一索引

  常规索引 KEY / INDEX：默认的

  全文索引 FULLTEXT INDEX：在特定的数据库引擎下才有，快速定位数据

+ 索引的使用

  ```mysql
  -- 显示所有的索引信息
  SHOW INDEX FROM student
  
  -- 添加一个全文索引 索引名（列名）
  ALTER TABLE school.student ADD FULLTEXT INDEX `name`(`name`);
  
  -- EXPLAIN 分析sql执行的状况
  EXPLAIN SELECT * FROM student; -- 非全文索引
  SELECT * FROM student WHERE MATCH(`name`) AGAINST('刘')
  ```

#### 测试索引

+ 插入100万数据

  ```mysql
  DELIMITER $$ -- 写函数之前必须要写的标志
  CREATE FUNCTION mock_data()
  RETURNS INT
  BEGIN
  	DECLARE num INT DEFAULT 1000000;
  	DECLARE i INT DEFAULT 0;
  	WHILE i<num DO
  		INSERT INTO app_user(`name`,`phone`,`password`,`age`) 
  		VALUES(CONCAT('用户',i),CONCAT('18',FLOOR(1000000000-RAND()*999999999)),UUID(),FLOOR(RAND()*100)); -- 插入语句
  		SET i = i+1;
  	END WHILE;
  	RETURN i;
  END;
  
  CREATE TABLE app_user(
  		`id` INT(3) NOT NULL AUTO_INCREMENT,
  		`name` VARCHAR(20) NOT NULL,
  		`phone` VARCHAR(11) NOT NULL,
  		`password` VARCHAR(50) NOT NULL,
  		`age` INT(3) NOT NULL,
  		PRIMARY KEY(`id`)
  )ENGINE=INNODB DEFAULT CHARSET=utf8;
  
  SELECT mock_data();
  ```

+ 测试

  ```mysql
  SELECT * FROM app_user WHERE `name`='用户9999'; -- 将近1s才找到
  CREATE INDEX id_app_user_name ON app_user(`name`); -- 添加索引，用1s多
  SELECT * FROM app_user WHERE `name`='用户9999'; -- 添加索引后查询0.001s
  ```

+ 索引在小数据量的时候用处不大，大数据的时候效果明显变快

#### 索引原则

+ 索引不是越多越好

+ 不要对经常变动数据加索引

+ 小数据量的表不需要加索引

+ 索引一般加在常用来查询的字段上

+ 索引的数据结构

  Hash类型的索引

  Btree：INNODB的默认数据结构

### 权限管理

#### 用户管理

+ Navicat可视化管理

+ mysql.user 用户表

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710090514265-2060164321.png)


  对用户表进行增删改查

  ```mysql
  -- 创建用户
  CREATE USER peng IDENTIFIED BY '123456';
  
  -- 修改当前用户密码
  SET PASSWORD = PASSWORD('111111');
  
  -- 修改指定用户密码
  SET PASSWORD FOR peng = PASSWORD('111111');
  
  -- 重命名
  RENAME USER peng TO pengpeng;
  
  -- 授予权限  库.表  *.*表示全部库的全部表
  GRANT ALL PRIVILEGES ON *.* TO pengpeng; -- 除了GRANT别人，其他事都能干
  
  -- 查询权限
  SHOW GRANT FOR pengpeng;
  SHOW GRANT FOR root@localhost;
  
  -- ROOT用户的权限
  GRANT ALL PRIVILEGES ON *.* TO root@localhost WITH GRANT OPTION;
  
  -- 撤销权限
  REVOKE ALL PRIVILEGES ON *.* FROM pengpeng;
  
  -- 删除用户
  DROP USER pengpeng;
  ```

#### MySQL备份

+ why

  1. 保证重要的数据不丢失

  2. 数据转换
  3. 存起来比较小

+ 备份方式

  1. 直接拷贝物理文件

  2. 可视化工具：导出的是SQL语句，拉过来执行就行了

  3. 命令行 mysqlump 导出

     ```CMD
     mysqlump -h127.0.0.1 -uroot -p123456 school [student] >D:/a.sql #导出
     source D:/a.sql #导入(需要先登录)
     ```

### 规范数据库设计

#### 为什么需要设计

数据库比较复杂的时候，我们就需要设计

+ 设计
  1. 分析需求：分析业务和需要处理的数据库的需求
  2. 概要设计：设计关系图E-R图

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710090543701-1086391958.png)


#### 三大范式

+ 问题

  信息会重复

  更新会导致异常

  插入异常：无法正常显示信息

  删除异常：丢失有效信息

+ 三大范式（规范数据库）

  1. 第一范式(1NF)：要求数据库表的每一列都是不可分割的原子数据项，原子性
  2. 第二范式(1NF)：前提，满足第一范式；每张表只描述一件事情
  3. 第三范式(1NF)：前提，满足第一、二范式；每一列都跟主键直接相关，不能间接相关

+ **规范性 和 性能 的问题**

  一般地，关联查询的表不能超过三张表

  1. 考虑商业化的需求和目标，(成本, 用户体验! )数据库的性能更加重要
  2. 在规范性能的问题的时候，需要适当的考虑一下 规范性!
  3. 故意给某些表增加一些冗余的字段。(从多表查询中变为单表查询)
  4. 故意增加一-些计算列(从大数据量降低为小数据量的查询: 索引)

### JDBC

#### 数据库驱动

+ 驱动：声卡，显卡，数据库

  程序通过数据库驱动连接数据库

+ JDBC

  为了简化开发人员的（对数据库的）操作，提供的一个（Java操作数据库的）规范

+ Java包

  java.sql

  javax.sql

  导入一个数据库驱动包 mysql-connector-java-5.1.47.jar

#### 第一个JDBC程序

准备工作（创建测试数据库）：

```mysql
CREATE DATABASE jdbcStudy CHARACTER SET utf8 COLLATE utf8_general_ci;

USE jdbcStudy;

CREATE TABLE `users`(
id INT PRIMARY KEY,
NAME VARCHAR(40),
PASSWORD VARCHAR(40),
email VARCHAR(60),
birthday DATE
);

INSERT INTO `users`(id,NAME,PASSWORD,email,birthday)
VALUES(1,'zhansan','123456','zs@sina.com','1980-12-04'),
(2,'lisi','123456','lisi@sina.com','1981-12-04'),
(3,'wangwu','123456','wangwu@sina.com','1979-12-04')
```

+ 创建一个普通项目

+ 导入数据库驱动

  1. 右键项目，新建一个 lib 目录
  2. 把 jar 包拷贝进来
  3. 右键 lib，选择Add as Library...

+ 编写测试代码

  ```java
  import java.sql.*;
  
  //我的第一个JDBC程序
  public class JdbcFirstDemo {
      public static void main(String[] args) throws Exception {
          //1.加载驱动
          Class.forName("com.mysql.jdbc.Driver"); //固定写法
  
          //2.连接信息，用户信息 和 url
          //SSL安全
          String url = "jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&characterEncoding=utf8&useSSL=true";
          String username = "root";
          String password = "3306";
  
          //3.连接成功，数据库对象  Connection代表数据库
          Connection connection = null;
          connection = DriverManager.getConnection(url,username,password);
  
          //4.执行SQL的对象
          Statement statement = connection.createStatement();
  
          //5.执行SQL的对象 去执行SQL
          String sql = "SELECT * FROM users";
  
          ResultSet resultSet = statement.executeQuery(sql);
          //返回的结果集，结果集中封装了我们全部的查询出来的结果
  
          while (resultSet.next()){ //是个链表
              System.out.println("id="+resultSet.getObject("id"));
              System.out.println("name="+resultSet.getObject("NAME"));
              System.out.println("pwd="+resultSet.getObject("PASSWORD"));
              System.out.println("email="+resultSet.getObject("email"));
              System.out.println("birth="+resultSet.getObject("birthday"));
              System.out.println("=============================");
          }
  
          //6.释放连接
          resultSet.close();
          statement.close();
          connection.close();
      }
  }
  ```

  + JDBC 对象

    DriverManager：`Class.forName("com.mysql.jdbc.Driver"); //固定写法 加载驱动`

    Connection：代表数据库，数据库能做的他都能做

    ```java
    connection.rollback();
    connection.commit();
    connection.setAutoCommit();
    ...
    ```

    URL：`String url = "jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&characterEncoding=utf8&useSSL=true";`

    Statement：执行sql的对象

    ```java
    statement.executeQuery(); //查
    statement.execute(); //任何sql语句
    statement.executeUpdate(); //增删改
    ```

    ResultSet：查询结果集

    ```java
    resultSet.getObject(); //不知道什么类型
    resultSet.getString();
    resultSet.getFloat();
    ...
    resultSet.beforeFirst(); //移动到最前面
    resultSet.afterLast(); //移动到最后面
    resultSet.next(); //移动到下一个数据
    resultSet.previous(); //移动到前一行
    resultSet.absolute(row); //移动到指定行
    ```

    释放资源

    ```java
    resultSet.close();
    statement.close();
    connection.close(); //耗资源，用完关闭
    ```

#### statement对象

+ Jdbc中的statement对象用于向数据库发送SQL语句，想完成对数据库的增删改查,只需要通过这个对象向数据库发送增删改查语句即可。

+ Statement对象的executeUpdate方法，用于向数据库发送增、删、改的sq|语句，executeUpdate执行完后， 将会返回一个整数(即增删改语句导致了数据库几行数据发生了变化)。

+ Statement.executeQuery方法用于向数据库发送查询语句，executeQuery方法返回代表查询结果的ResultSet对象。

+ CRUD操作-create

  使用executeUpdate(String sq|)方法完成数据添加操作，示例操作：

  ```java
  Statement st = conn.createStatement();
  Stirng sql = "insert into user(...) values(...)";
  int num = st.executeUpdate(sql);
  if(num>0){
      System.out.println("插入成功！！");
  }
  ```

+ CRUD操作-delete

  使用executeUpdate(String sq|)方法完成数据删除操作，示例操作：

  ```java
  Statement st = conn.createStatement();
  Stirng sql = "delete from user where id=1";
  int num = st.executeUpdate(sql);
  if(num>0){
      System.out.println("删除成功！！");
  }
  ```

+ CRUD操作-update

  使用executeUpdate(String sq|)方法完成数据修改操作，示例操作：

  ```java
  Statement st = conn.createStatement();
  Stirng sql = "update user set name='pengpeng' where name='peng'";
  int num = st.executeUpdate(sql);
  if(num>0){
      System.out.println("修改成功！！");
  }
  ```

+ CRUD操作-read

  使用executeQuery(String sq|)方法完成数据查询操作，示例操作：

  ```java
  Statement st = conn.createStatement();
  Stirng sql = "select * from user where id=1";
  ResultSet rs = st.executeQuery(sql);
  while(rs.next){
      //根据获取列的数据类型，分别调用rs的相应方法映射到java对象中
  }
  ```

+ 代码

  1. 配置

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710090630173-1586377350.png)


  2. 工具类 JbdcUtils

     ```java
     package lesson02.utils;
     
     import java.io.InputStream;
     import java.sql.*;
     import java.util.Properties;
     
     public class JdbcUtils {
     
         private static String driver = null;
         private static String url = null;
         private static String username = null;
         private static String password = null;
     
         static{
             try{
                 InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream("db.properties");
                 Properties properties = new Properties();
                 properties.load(in);
     
                 driver = properties.getProperty("driver");
                 url = properties.getProperty("url");
                 username = properties.getProperty("username");
                 password = properties.getProperty("password");
     
                 //1.驱动只用加载一次
                 Class.forName(driver);
     
             }catch (Exception e){
                 e.printStackTrace();
             }
         }
     
         //获取连接
         public static Connection getConnection() throws SQLException {
             return DriverManager.getConnection(url,username,password);
         }
     
         //释放资源
         public static void release(Connection conn, Statement st, ResultSet rs){
             if (rs!=null){
                 try {
                     rs.close();
                 } catch (SQLException e) {
                     e.printStackTrace();
                 }
             }
             if (st!=null){
                 try {
                     st.close();
                 } catch (SQLException e) {
                     e.printStackTrace();
                 }
             }
             if (conn!=null){
                 try {
                     conn.close();
                 } catch (SQLException e) {
                     e.printStackTrace();
                 }
             }
         }
     }
     ```

  3. 测试类

     ```java
     package lesson02;
     
     import lesson02.utils.JdbcUtils;
     
     import java.sql.Connection;
     import java.sql.ResultSet;
     import java.sql.SQLException;
     import java.sql.Statement;
     
     public class TestDelete {
         public static void main(String[] args) {
     
             Connection conn = null;
             Statement st = null;
             ResultSet rs = null;
     
             try {
                 conn = JdbcUtils.getConnection(); //获取数据库连接
                 st = conn.createStatement(); //获得执行sql的对象
                 String sql = "DELETE * FROM users WHERE id=1";
                 int i=st.executeUpdate(sql);
                 if (i>0){
                     System.out.println("删除成功!!");
                 }
             } catch (SQLException e) {
                 e.printStackTrace();
             }finally {
                 JdbcUtils.release(conn,st,rs);
             }
         }
     }
     ```

     

+ SQL注入的问题

  sql存在漏洞，会被攻击

  login(username=" ' or ' 1=1 ",password=" ' or ' 1=1 ")

#### PrepareStatement

+ 是Statement的子类，可以防止sql注入，并且效率更高

  ```java
  package lesson03;
  
  import lesson02.utils.JdbcUtils;
  
  import java.sql.Connection;
  import java.sql.PreparedStatement;
  import java.sql.SQLException;
  import java.util.Date;
  
  public class TestInsert {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement st = null;
  
          try {
              conn = JdbcUtils.getConnection();
  
              //区别
              //使用？占位符代替参数
              String sql = "INSERT INTO user(id,`name`,`password`,`birthday`) VALUES(?,?,?,?)";
  
              st = conn.prepareStatement(sql); //预编译sql，先写sql，然后不执行
  
              //手动给参数赋值
              st.setInt(1,2018215555);
              st.setString(2,"peng");
              st.setString(3,"8098");
              //注意点： sql.Date  数据库  java.sql.Date()转换
              //        util.Date  Java   new Date().getTime() 获得时间戳
              st.setDate(4,new java.sql.Date(new Date().getTime()));
  
              //执行
              int i = st.executeUpdate();
              if (i>0){
                  System.out.println("插入成功！！");
              }
          } catch (SQLException e) {
              e.printStackTrace();
          } finally {
              JdbcUtils.release(conn,st,null);
          }
      }
  }
  ```

+ 防注入本质

  传递过来的参数当作字符，有转义字符时直接忽略

#### IDEA连接数据库

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200710090653123-2124358620.png)


#### 事务

+ ACID原则

  原子性，一致性，**隔离性**，持久性

+ 隔离性的问题

  脏读：一个事务读取了另一个没有提交的事务
  不可重复读：在同一个事务内，重复读取表中的数据，表数据发生了改变
  虛读(幻读)：在一个事务内，读取到了别人插入的数据，导致前后读出来结果不一致

  ```java
  package lesson04;
  
  import lesson02.utils.JdbcUtils;
  
  import java.sql.Connection;
  import java.sql.PreparedStatement;
  import java.sql.ResultSet;
  import java.sql.SQLException;
  
  public class TestTransaction {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement st = null;
          ResultSet rs = null;
  
          try {
              conn = JdbcUtils.getConnection();
              //关闭数据库的自动提交，自动会开启事务
              conn.setAutoCommit(false); //开启事务
  
              String sql1 = "UPDATE account set money=money-100 WHERE name='A'";
              st = conn.prepareStatement(sql1);
              st.executeUpdate();
  
              String sql2 = "UPDATE account set money=money+100 WHERE name='B'";
              conn.prepareStatement(sql2);
              st.executeUpdate();
  
              //业务完毕，提交事务
              conn.commit();
              System.out.println("成功！！");
          } catch (SQLException e) {
              //conn.rollback(); //失败则回滚，可以不写，失败默认回滚
              e.printStackTrace();
          } finally {
              try {
                  conn.setAutoCommit(true);
              } catch (SQLException e) {
                  e.printStackTrace();
              }
              JdbcUtils.release(conn,st,rs);
          }
      }
  }
  ```

#### 数据库连接池

连接 - - 释放，浪费系统资源

+ 池化技术

  准备一些预先的资源，过来就连接预先准备好的

  常用连接数 10个

  最小连接数 10

  最大连接数 15  业务最高承载上限

  等待超时 100ms

+ 编写连接池

  实现一个接口 DataSource

+ 开源数据源实现(拿来即用)

  DBCP，C3P0，Druid

  使用了这些连接池后，我们在项目开发中就不需要编写连接数据库的代码了

+ DBCP

  需要用到的jar包

  commons-dbcp-1.4、commons-pool-1.6

+ C3P0

  需要用到的jar包

  c3p0-0.9.5.5、mchange-commons-java-0.2.19

+ 结论

  无论使用什么数据源，本质还是一样的，DataSource接口不会变, 方法就不会变]]></description></item><item><title>MySQL 数据库（上）</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/09/db_01.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 09 Jul 2020 13:20:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/09/db_01.html</guid><description><![CDATA[### 初识MySQL
JavaEE：企业级开发 web
前端（页面：展示，数据）
后台（连接点：连接数据库JDBC，链接前端(控制，控制视图跳转,和给前端传递数据)）
数据库（存数据）
#### 数据库
DB database
概念：数据仓库，软件，安装在操作系统（windows，linux，mac...）之上
作用：存储数据，管理数据
#### 数据库分类
+ 按关系
1. 关系型数据库(SQL) MySQL，Oracle，SQL server，DB2，SQLlite
通过表和表之间，行和列的关系进行数据的存储
2. 非关系型数据库(NoSQL not only sql) Redis，MongDB
对象存储，通过对象的自身属性来决定
+ DBMS 数据库管理系统
数据库的管理软件，科学有效的管理我们的数据，维护和获取数据
MySQL，是个DBMS
#### MySQL
+ MySQL 是一种开放源代码的**关系型数据库管理系统**
体积小、速度快、总体拥有成本低
5.7 稳定
8.0 新的
+ 安装
1. 尽量不要用exe，注册表，卸载不干净
2. 尽可能使用压缩包安装
+ 可视化工具Navicat中创建数据库
右键数据库链接 --> 新建数据库
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211351881-1813752714.png)

对应的创建数据库的语句：
`CREATE DATABASE 'school' CHARACTER SET utf8 COLLATE utf8_general_ci;`
工具-->历史日志(Ctrl+L)：能看到复杂操作的MySQL语句
+ 新建表
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211358315-195432857.png)

键表示“主键”，不能重复
历史记录中的具体代码操作：
```
CREATE TABLE `school`.`student`  (
  `id` int(10) NOT NULL COMMENT '学生id',
  `name` varchar(100) NOT NULL COMMENT '学生姓名',
  `age` int(3) NOT NULL COMMENT '学生年龄',
  PRIMARY KEY (`id`)
)
```
+ 打开表
右键，打开表，像excel一样添加和删除数据
+ 连接数据库
```
C:\WINDOWS\system32>mysql -uroot -p8098 //连接
mysql> exit; //断开
Bye
```
sql的注释：
单行 `--`
多行 `/* */`
常用命令：
```
mysql> show databases; --显示所欲的数据库
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| school             |
| sys                |
+--------------------+
5 rows in set (0.00 sec)

mysql> use school; --切换到指定数据库
Database changed
mysql> show tables; --显示当前数据库下的表
+------------------+
| Tables_in_school |
+------------------+
| student          |
+------------------+
1 row in set (0.00 sec)

mysql> describe student; --查看表
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int(10)      | NO   | PRI | NULL    |       |
| name  | varchar(100) | NO   |     | NULL    |       |
| age   | int(3)       | NO   |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

mysql> create database westos; --创建新的数据库
Query OK, 1 row affected (0.00 sec)
```
+ 数据库xxx语言 CRUD 增删改查
DDL 定义
DML 操作
DQL 查询
DCL 控制
### 操作数据库
操作数据库>操作数据库中的表>操作数据库中的表的数据
MySQL语句不分大小写
#### 操作数据库
+ 创建
`CREATE DATABASE if not EXISTS westos;`
+ 删除
`Drop DATABASE if EXISTS westos;`
+ 学习思路
可视化操作，查看日志里的语句
#### 数据库的列类型
常用的为加粗
+ 数值
tinyint 十分小的数据 1个字节
smallint 较小的数据 2个字节
mediumint 中等大小的数据 3个字节
**int** 标准的整数 4个字节
bigint 较大的数据 8个字节
float 单精度浮点数 4个字节
double 双精度浮点数 8个字节（精度问题）
**decimal** 字符串形式的浮点数 金融计算时使用
+ 字符串
char 字符串固定大小的 0-255
**varchar** 可变字符串 0-655635
tinytext 微型文本 2^8-1
**text** 文本串 2^16-1
+ 时间日期
date YYYY-MM-DD，日期
time HH:MM:SS，时间
**datatime** YYYY-MM-DD HH:MM:SS 日期+时间，最常用
**timestamp** 时间戳 1970.1.1到现在的毫秒数
year 年份
+ null
没有值，位置
不用使用NULL进行运算，结果肯定为NULL
#### 数据库的字段属性※
+ Unsigned
无符号的整数，声明该列不能声明为负数
+ zerofill
不足的位数使用0来填充，（如，int类型 长度3，5会写成005）
+ 自增
自动在上一条记录的基础上+1，通常用来设计主键
可以自定义设计主键自增的起始值和步长
+ 非空
NOT NULL，不允许为空
+ 默认
设置默认的值，不指定则为默认的值
+ 拓展
```
每一个表，都必须存在以下五个字段!未来做项目用的，表示一个记录存在意义!
id 主键
`version` 乐观锁
is delete 伪删除
gmt_create 创建时间
gmt_update 修改时间
```
#### 创建表
+ 格式
```
CREATE TABLE [IF NOT EXIST] `表名`(
    '字段名' 列类型 [属性] [索引] [注释],
    字段名' 列类型 [属性] [索引] [注释],
    ... ...
    字段名' 列类型 [属性] [索引] [注释],
    [PRIMARY KEY(`字段名`)]
)[表类型] [字符集类型] [注释]
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211430008-1062632571.png)

+ 逆向查语句
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211439285-1273618645.png)
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211447365-856477592.png)

+ 显示表的结构
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211456280-2093785948.png)

#### 数据表的类型
+ 数据表的类型，即数据库引擎
INNODB：默认，安全性高，事务的处理，多表多用户处理
MYISAM：早些年使用的，节约空间，速度较快
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211504411-969819753.png)

+ 在物理空间存在的位置
所有的数据库文件都存在data目录下，一个文件夹就对应一个数据库，本质还是文件的存储!
MySQL引擎在物理文件上的区别
●InnoDB在数据库表中 只有一个*.frm文件，以及上级目录下的ibdata文件
●MYISAM对应文件
`*.frm 表结构的定义文件`
`*.MYD 数据文件(data)`
`*.MY| 索引文件(index)`
#### 修改删除表
字段名加上tab键上面的符号包住
所有操作加上 IF EXISTS 防止报错
```
# 修改表名 
ALTER TABLE `studentinf` RENAME AS `student`;
# 增加表的字段
ALTER TABLE `student` ADD `score` INT(3);
# 修改表的字段：1.重命名 2.修改约束
ALTER TABLE `student` MODIFY `score` SMALLINT(3);
ALTER TABLE `student` CHANGE `score` `degree` INT(1);
# 删除表的字段
ALTER TABLE `student` DROP `degree`;
# 删除表
DROP TABLE IF EXISTS `ke`;
```
### MySQL数据管理
#### 外键
+ 方式一 (一般不用)
在创建表的时候，增加约束(麻烦， 比较复杂)
```
# 创建时添加
KEY `FK_gradeid` (`gradeid`) ,
CONSTRINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`)
```
删除有外键关系的表的时候，必须要先删除引用别人的表(从表) ，再删除被引用的表(主表)
+ 方式二 ※
在创建表的时候，没有外键关系，创建表成功后添加外键约束
```
# 单独加的语句
ALTER TABLE `student`
ADD CONSTRINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`);
```
+ 以上两种方式的操作都是物理外键，数据库级别的外键，我们不建议使用! (避免数据库过多造成困扰，了解即可)
+ 最佳实践
1. 数据库就是单纯的表，只用来存数据，只有行(数据)和列(字段)
2. 我们想使用多张表的数据，想使用外键(程序去实现)
#### DML全部记住
+ 数据库意义
数据存储，数据管理
+ DML语言：数据操作语言
insert update delete
#### 添加
```
# 插入语句（添加）
# INSERT INTO 表名(字段1,字段2...)VALUES(值1,值2...)
INSERT INTO `student`(`name`)VALUES('小明');
# 主键自增，所以我们可以省略
# 数据和字段一定要一一对应
INSERT INTO `student`(`name`,`sex`)VALUES('小刚','男');
INSERT INTO `student`(`name`,`sex`,`password`)
VALUES('张三','男',5678)
# 字段可以不写，但值要写全，并且一一对应
# 可以同时插入多条数据，VALUES 后面的值，需要使用，隔开即可 VALUES(),(),//...
INSERT INTO `student`(`name`)
VALUES('TOM'),('JERRY');
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211520221-1317995500.png)

#### 修改
```
# 修改语句 修改条件 设置新值
# 语法 UPDATE 表名 SET 列名=新值[,列名=新值,...] [WHERE 条件];
UPDATE `student` SET `name`='小红' WHERE id = 1;
```
+ 条件 
WHERE 子句 运算符id等于某个值，大于某个值，在某个区间内修改...
操作符返回布尔值，确定要不要执行
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211535369-2121695316.png)

#### 删除
+ 删除数据
```
# 删除数据
# 语法 DELETE FROM 表名 [WHERE 条件]
DELETE FROM `student` WHERE `password`=5678;
```
+ 清空
```
DELETE FROM `student`; --不加约束，全删了
TRUNCATE `student`; --也是清空，推荐使用
```
+ delete的TRUNCATE区别
相同点：都能删除数据，都不会删除表结构，不会影响自增
不同：
TRUNCATE 重新设置自增列计数器会归零
TRUNCATE 不会影响事务
### DQL查询数据※※
#### DQL
+ Data Query Language
1. 所有的查询操作都用它Select
2. 简单的查询，复杂的查询它都能做~
3. 数据库中最核心的语言，最重要的语句
4. 使用频率最高的语句
#### 指定查询字段
+ SELECT完整语法
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211548340-1467265273.png)

+ 查询语法
`SELECT 字段,... FROM 表`
+ 查询所有
`SELECT * FROM 表`
+ 给结果起别名 AS
`SELECT 字段 [AS 字段别名] FROM 表 [AS 表别名]`
+ 函数 CONCAT(a,b)
`SELECT CONCAT('姓名：',StudentName) AS 新名字 FROM student`
+ 去重 distinct
查询哪些同学参加了考试
`SELECT * FROM result --查询全部考试成绩`  
`SELECT StudentNo FROM result` 有重复
`SELECT DISTINCT StudentNo FROM result` 去重
+ 用来计算
`SELECT 100*3-1 AS 计算结果`
+ 查询自增步长（变量）
`SELECT @@auto_increment_increment`
+ 所有学生考试成绩 +1分查看
`SELECT StudentNo,StudentResult+1 AS '提分后' FROM result`
+ 数据中的列（表达式）：文本值，列，Null，函数，计算表达式，系统变量
### where条件子句
+ 作用
检索数据中符合条件的值
+ 逻辑运算符
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211558845-908836039.png)

尽量使用英文
+ 查询考试成绩95-100之间
```
SELECT StudentNo,StudentResult FROM result
WHERE StudentResult>=95 AND StudentResult<=100
```
+ 模糊查询：比较运算符
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211607365-2061265150.png)

+ 查询姓刘的同学
like结合 %（代表0到任意个字符）_（一个字符）
```
SELECT StudentNo,StudentResult FROM result
WHERE StudentName LIKE '刘%'
```
+ 查询名字中有佳的同学
```
SELECT StudentNo,StudentResult FROM result
WHERE StudentName LIKE '%佳%'
```
+ 查询1，2，3班的同学
IN不能用LIKE的写法，IN必须用具体的词
```
SELECT StudentNo,StudentResult FROM result
WHERE StudentClass IN (1,2,3)
```
+ 查询地址为空的学生（null 或 ''）
```
SELECT StudentNo,StudentResult FROM result
WHERE Address='' OR Address IS NULL
```
#### 联表查询
+ JOIN (链接的表) ON (条件)
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211629656-142539767.png)

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211733376-786019486.png)

+ 查询参加了考试的同学（学号，姓名，科目编号，分数）
思路：
1.分析需求，分析查询的字段来自哪些表，连接查询
2.确定使用哪些连接查询？（7种）
3.确定交叉点（这两个表中哪些数据是相同的）
判断的条件：学生表中的 StudentNo = 成绩表中的 StudentNo
```
# INNER JOIN 
SELECT s.StudentNo,studentName,SubjectNo,StudentResult
FROM student AS s
INNER JOIN result AS r
ON s.StudentNo = r.StudentNo

# RIGHT JOIN 只有这个可以
SELECT s.StudentNo,studentName,SubjectNo,StudentResult
FROM student s
RIGHT JOIN result r
ON s.StudentNo = r.StudentNo

# LEFT JOIN 
SELECT s.StudentNo,studentName,SubjectNo,StudentResult
FROM student s
LEFT JOIN result r
ON s.StudentNo = r.StudentNo
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211745577-860103458.png)

+ 查询缺考同学
```
# LEFT JOIN 
SELECT s.StudentNo,studentName,SubjectNo,StudentResult
FROM student s
LEFT JOIN result r
ON s.StudentNo = r.StudentNo
WHERE StudentResult IS NULL
```
+ 三表查询
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211752682-999536806.png)

#### 自连接
自己的表和自己的表连接，核心：一张表拆为两张一模一样的表即可
```
# 查询父子信息
SELECT a.`categoryName` AS '父栏目' , b.`categoryName` AS '子栏目'
FROM `category` AS a, `category` as b
WHERE a.`categoryId` = b.`pid`
```
#### 分页和排序
+ 排序 ORDER BY
升序 ASC
降序 DESC
```
#成绩排序
SELECT name,score FROM student
ORDER BY score DESC
```
+ 分页
1. 缓解数据库压力
2. 好的视觉效果，相反--瀑布流
语法：LIMIT 起始值,页面的大小
LIMIT 0,5  第一页1-5条数据
LIMIT 5,5  第二页6-10条数据
第n页：`LIMIT (n-1)*pageSize,pageSize`
pageSize：页面大小
`LIMIT (n-1)*pageSize`：起始值
n：当前页
[页面总数/页面大小]向上取整 = 总页数
#### 子查询
+ where（这个值是计算出来的）
本质：在where嵌套一个子查询
where（select ....）
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211808151-28036642.png)

### SQL函数
#### 常用函数（并不常用）
+ 数学运算
```
SELECT ABS(-5) --绝对值
SELECT CEILING(9.4) --向上取整
SELECT FLOOR(9.4) --向下取整
SELECT RAND() --随机数0-1之间
SELECT SIGN(0) --判断一个数的符号 signal函数，返回值为-1，0，1
```
+ 字符串函数
```
SELECT CHAR_LENGTH('你好') --字符串长度
SELECT CONCAT('我','和','你') --拼接字符串
SELECT INSERT('Hello，world',1,5,'Bye') --某个位置开始替换某个长度
SELECT LOWER() --字符串转小写
SELECT UPPER() --字符串转大写
SELECT INSTR('hello','o') --字符在字符串的第几个位置
SELECT REPLACE('HELLO JAVA','JAVA','MYSQL') --替换指定字符串
SELECT SUBSTR('HELLO',2,3) --第二个字母开始，截取三个
SELECT REVERSE() --反转字符串
```
+ 时间和日期※
```
SELECT CURRENT_DATE() --获取当前日期
SELECT CURDATE --获取当前日期
SELECT NOW() --获取当前日期和时间
SELECT LOCALTIME() --本地时间
SELECT SYSDATE() --系统时间
SELECT YEAR(NOW())
SELECT MONTH(NOW())
SELECT DAY(NOW())
SELECT HOUR(NOW())
SELECT MINUTE(NOW())
SELECT SECOND(NOW())
```
+ 系统
```
SELECT SYSTEM_USER()
SELECT USER()
SELECT VERSION()
```
#### 聚合函数（真·常用）
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211822714-950631209.png)

```
# 查询表中计数
SELECT COUNT(studentName) FROM student; --COUNT(字段)，会忽略所有的null值
SELECT COUNT(*) FROM student; --不会忽略null值，本质，计算行数
SELECT COUNT(1) FROM student; --不会忽略null值，本质，计算行数

#
SELECT SUM(`studentResult`) AS 总和 FROM result;
SELECT AVG(`studentResult`) AS 平均分 FROM result;
SELECT MAX(`studentResult`) AS 最高分 FROM result;
SELECT MIN(`studentResult`) AS 最低分 FROM result;
```
+ 分组查询
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211831192-822915003.png)

#### 数据库级别的MD5加密
+ 什么是MD5?
主要增强算法复杂度和不可逆性。
MD5 不可逆，具体的值的md5是一样的
MD5破解网站的原理，背后有一个字典，MD5加密后的值，加密前的值
```
# 加密密码
UPDATE testmd5 SET pwd=MD5(pwd); --加密全部密码
INSERT INTO testmd5 VALUES(4,'xiaoming',MD5('123456')) --插入时加密
# 如何校验：输入正常的，再加密，和之前加密后的对比
SELECT * FROM testmd5 WHERE `name`='xiaoming' AND pwd=MD5('123456')
```
#### SELECT小结
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709211900330-394373011.png)
]]></description></item><item><title>Maven介绍 IDEA中部署tomcat</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/09/java_05.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 09 Jul 2020 12:51:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/09/java_05.html</guid><description><![CDATA[### Maven

+ 作用
  1. 在Javaweb开发中，需要使用大量的jar包，我们手动去导入；
  2. 如何能够让一个东西自动帮我导入和配置这个jar包。

#### Maven项目架构管理工具

我们目前用来就是方便导入jar包的

+ 核心思想：**约定大于配置**，有约束，不要去违反

  Maven会规定好你如何去编写java代码，必须要按照这个规范来

#### 下载安装Maven

+ 下载地址

  http://maven.apache.org/download.cgi

+ 安装配置

  1. 下载 binary.zip 的 maven 并解压

  2. 配置环境变量

     + M2_HOME：maven下的bin目录
     + MAVEN_HOME：maven目录
     + 在系统的path中配置 %MAVEN_HOME%\bin

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204512663-1491233528.png)


#### 阿里云镜像

+ 镜像：mirrors

  加速我们的下载，国内建议使用阿里云的镜像

  conf - - setting.xml 文件里找到 mirrors

  ```XML
  <mirror>
  	<id>nexus-aliyun</id>
  	<mirrorOf>*,!jeecg,!jeecg-snapshots</mirrorOf>
  	<name>Nexus aliyun</name>
  	<url>http://maven.aliyun.com/nexus/content/groups/public</url>
  </mirror>
  ```
#### maven repository
下载依赖的地方：[https://mvnrepository.com/](https://mvnrepository.com/)

#### 本地仓库

+ 建立一个本地仓库：LocalRepository

  ```xml
  <localRepository>D:\environment\apache-maven-3.6.3\maven-repo</localRepository>
  ```

  仓库里管理的是jar包

#### IDEA中使用Maven

1. 启动IDEA，创建一个Maven项目

  ![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204545010-654082527.png)

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204600150-31811371.png)


2. 等待项目初始化完毕

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204616471-858399225.png)


3. 观察maven仓库中多了什么东西

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204627905-1075122323.png)


4. IDEA中的maven设置

   IDEA项目创建成功后，看一眼Maven的配置，看local文件是不是原来配置的地方

5. 到这里，Maven在IDEA中的配置和使用就OK了

#### 创建一个普通的Maven项目

1. 什么都不勾，直接next

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204649477-1337464972.png)

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204700487-204010417.png)

#### 标记文件夹功能

+ mark directory as

  sources root 源码目录

  test sources root 测试源码目录

  resources root 资源目录

  test resources root 测试资源目录

+ 另一种方式

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204714651-1315586426.png)


![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204729982-237384545.png)


#### 在IDEA中配置tomcat

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204742999-989742394.png)


![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204755252-213156804.png)

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204806038-233619452.png)


为什么会有这个问题：我们访问一个网站，需要指定一个文件夹名字

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204823967-2051686259.png)


![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204837063-1793895280.png)


启动tomcat

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204856874-1831476334.png)


启动成功

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204933555-832871143.png)



这里访问到的helloworld，就是我们默认的index.jsp的内容

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709204922343-193636904.png)

#### pom文件

pom.xml 是maven的核心配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>

<!--maven的版本和头文件-->
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <!--创建项目时配置的GAV-->
  <groupId>com.peng</groupId>
  <artifactId>javaweb-01-maven</artifactId>
  <version>1.0-SNAPSHOT</version>
  <!--package：项目的打包方式
  jar：java应用
  war：javaweb应用
  -->
  <packaging>war</packaging>

  <!--name没啥用，可以删掉-->
  <name>javaweb-01-maven Maven Webapp</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>

  <!--配置-->
  <properties>
    <!--项目的默认构建编码-->
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <!--编译版本-->
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
  </properties>

  <!--项目依赖-->
  <dependencies>
    <!--具体依赖的jar包配置文件-->
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
    </dependency>
  </dependencies>

  <!--项目构建用的东西-->
  <build>
    <finalName>javaweb-01-maven</finalName>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.1.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.8.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.22.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-war-plugin</artifactId>
          <version>3.2.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>
```

+ maven 的高级之处在于，他会帮你导入这个JAR包所低赖的其它jar包]]></description></item><item><title>Java注解与反射</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/09/java_04.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 09 Jul 2020 08:28:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/09/java_04.html</guid><description><![CDATA[### 注解 Annotation
+ 什么是注解
JDK5.0开始引入的技术
+ Annotation的作用:
1. 不是程序本身，可以对程序作出解释(这一点和注释(comment)没什么区别)
2. 可以被其他程序(比如:编译器等)读取.
+ Annotation的格式:
注解是以"@注释名"在代码中存在的,还可以添加一些参数值，
例如：@SuppressWarnings(value="unchecked").
+ Annotation在哪里使用?
可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息，
我们可以通过反射机制编程实现对这些元数据的访问
+ 注解举例
```
public class Test01 extends Object {
    //@Override 重写的注解
    @Override
    public String toString() {
        return "Test01{}";
    }
}
```
#### 内置注解
+ @Overpfide：定义在java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明
+ @Deprecated：定义在java.lang.Deprecated中，此注释可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择
+ @SuppressWarnings：定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息与前两个注释有所不同，你需要添加一个参数才能正确使用，这些参数都是已经定义好了的，我们选择性的使用就好了
@SuppressWarnings("ll")
@SuppressWarnings("unchecked")
@SuppressWarnings(value={"unchecked","deprecation"})
等等.....
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709162615986-1571263827.png)

#### 元注解
+ 元注解的作用就是负责注解其他注解, Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明.
+ 这些类型和它们所支持的类在java.lang.annotation包中可以找到（@Target，@Retention，@Documented，@Inherited）
➢@Target：用于描述注解的使用范围(即:被描述的注解可以用在什么地方)
➢@Retention：表示需要在什么级别保存该注释信息,用于描述注解的生命周期
➢(SOURCE < CLASS < **RUNTIME**)
➢@Document：说明该注解将被包含在javadoc中
➢@Inherited：说明子类可以继承父类中的该注解
```
import java.lang.annotation.*;

@MyAnnotation
public class Test02 {

    @MyAnnotation
    public void test(){}

}

//定义一个注解
//Target表示注解能用在哪些地方
@Target(value = {ElementType.METHOD,ElementType.TYPE}) //表示在方法和类上有效

//Retention表示我们的注解在什么地方还有效 runtime>class>sources
@Retention(value = RetentionPolicy.RUNTIME) //运行时有效

//Documented表示是否将我们的注解生成到JavaDoc中
@Documented

//Inherited子类可以继承父类的注解
@Inherited
@interface MyAnnotation{

}
```
#### 自定义注解
+ 使用@interface自定义注解时,自动继承了java.lang.annotation.Annotation接口
+ 分析
1. @interface用来声明一个注解，格式：public @ jinterface注解名{定义内容}
2. 其中的每一个方法实际上是声明了一个配置参数
3. 方法的名称就是参数的名称
4. 返回值类型就是参数的类型（）返回值只能是基本类型，Class，String，enum )
5. 可以通过default来声明参数的默认值
6. 如果只有一个参数成员，一般参数名为value
7. 注解元素必须要有值,我们定义注解元素时，经常使用空字符串，0作为默认值
```
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

//自定义注解
public class Test03 {
    //注解可以显示赋值，如果没有默认值，我们必须给注解赋值
    @MyAnnotation2(age = 25)
    public void test(){}

    @MyAnnotation3("peng") //只有value能省略
    public void test2(){}
}

@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation2{
    //注解的参数格式:  参数类型 参数名();
    String name() default "";
    int age() default 18;
    int id() default -1; //默认值为-1，代表不存在

    String[] schools() default {"清华","北大"};
}

@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation3{
    String value(); //只有value能省略，([value=]"peng")
}
```
#### 反射机制 Reflection
+ 动态语言
是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。
主要动态语言：Object-C、 C#、JavaScript、 PHP、 Python等。
```
//js
function f() {
    var x = "var a=3;var b=5;alert(a+b)";    
    eval(x); //运行时执行了x
}
```
+ 静态语言
与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++.
Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性,我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活!
+ Reflection (反射) 
是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。
`Class c = Class forName("java.lang.String")；`
加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象 (一个类只有一个Class对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709162636145-1643289597.png)

+ Java反射机制提供的功能
➢在运行时判断任意一个对象所属的类
➢在运行时构造任意一个类的对象
➢在运行时判断任意一个类所具有的成员变量和方法
➢在运行时获取泛型信息
➢在运行时调用任意一个对象的成员变量和方法
➢在运行时处理注解
➢生成动态代理
+ Java反射优点和缺点
优点:
➢可以实现动态创建对象和编译,体现出很大的灵活性
缺点:
➢对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。
```
public class Test02 extends Object{
    public static void main(String[] args) throws Exception{
        //通过反射获取类的class对象
        Class c1 = Class.forName("reflection.User");
        System.out.println(c1);

        Class c2 = Class.forName("reflection.User");
        Class c3 = Class.forName("reflection.User");

        //一个类在内存中只有一个class对象
        //一个类被加载后，类的整个结构都会被封装到class对象中
        System.out.println(c1.hashCode());
        System.out.println(c2.hashCode());
        System.out.println(c3.hashCode());
    }
}

//实体类 pojo entity
class User{
    private String name;
    private int id;
    private int age;

    public User(){

    }

    public User(String name, int id, int age) {
        this.name = name;
        this.id = id;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", id=" + id +
                ", age=" + age +
                '}';
    }
}
```
+ Class类
在Object类中定义了以下的方法，此方法将被所有子类继承
`public final Class getClass()`
以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。
➢Class本身也是一个类
➢Class对象只能由系统建立对象
➢一个加载的类在JVM中只会有一个Class实例
➢一个Class对象对应的是一个加载到JVM中的一个.class文件
➢每个类的实例都会记得自己是由哪个Class实例所生成
➢通过Class可以完整地得到一个类中的所有被加载的结构
➢Class类是Reflection的根源， 针对任何你想动态加载、运行的类，唯有先获得相应的Class对象
+ Class类常用方法
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709162649796-955564975.png)

+ 获取Class类的实例
a)若已知具体的类，通过类的class属性获取，该方法最为安全可靠,程序性能最高。
`Class clazz = Persun.class;`
b) 已知某个类的实例，调用该实例的getClass()方法获取Class对象
`Class clazz = person.getClass();`
c) 已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException
`Class clazz = Class.forName("demo01.Student");`
d)内置基本数据类型可以直接用类名`.Type`
e)还可以利用`ClassLoader`我们之后讲解
+ 哪些类型可以有Class对象
1. class 各种类
2. interface 接口
3. [] 数组
4. enum 枚举
5. annotation 注解
6. primitive type 基本数据类型
7. void
```
public class Test04 {
    public static void main(String[] args) {
        Class c1 = Object.class;
        Class c2 = Comparable.class; //接口类型
        Class c3 = String[].class;
        Class c4 = int[][].class;
        Class c5 = Override.class; //注解类型
        Class c6 = ElementType.class; //枚举类型
        Class c7 = Integer.class; //基本数据类型
        Class c8 = void.class;
        Class c9 = Class.class;

        System.out.println(c1);
        System.out.println(c2);
        System.out.println(c3);
        System.out.println(c4);
        System.out.println(c5);
        System.out.println(c6);
        System.out.println(c7);
        System.out.println(c8);
        System.out.println(c9);
    }
}
```
输出
```
class java.lang.Object
interface java.lang.Comparable
class [Ljava.lang.String;
class [[I
interface java.lang.Override
class java.lang.annotation.ElementType
class java.lang.Integer
void
class java.lang.Class
```
#### 类加载内存分析
+ 类加载三步
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709162700618-1261971640.png)

1. 加载:将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象
2. 链接:将Java类的二 进制代码合并到JVM的运行状态之中的过程。
➢验证：确保加载的类信息符合JVM规范，没有安全方面的问题
➢准备：正式为类变量(static)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配
➢解析：虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程
3. 初始化：
➢执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。(类构造器是构造类信息的，不是构造该类对象的构造器)
➢当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化
➢虚拟机会保证一个类的< clinit> ()方法在多线程环境中被正确加锁和同步
```
public class Test05 {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(A.m); //100,因为后执行的 m=100

        /*
        1.加载到内存，会产生一个类对应class对象
        2.链接，链接结束后 m = 0
        3.初始化
            <clinit>(){ //JVM做的
                System.out.println("A类静态代码块初始化");
                m = 300;
                m = 100;
            }
            初始化之后，m = 100
         */
    }
}

class A{
    static {
        System.out.println("A类静态代码块初始化");
        m = 300;
    }

    static int m = 100;

    public A(){
        System.out.println("A类的无参构造初始化");
    }
}
```
#### 什么时候会发生类初始化?
+ 类的主动引用(一定会发生类的初始化)
➢当虚拟机启动， 先初始化main方法所在的类
➢new一个类的对象
➢调用类的静态成员(除了final常量)和静态方法
➢使用java.lang.reflect包的方 法对类进行反射调用
➢当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类
+ 类的被动引用(不会发生类的初始化)
➢当访问一个静态域时，只有真正声明这个域的类才会被初始化。如:当通过子类引用父类的静态变量,不会导致子类初始化
➢通过数组定义类引用，不会触发此类的初始化
➢引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了)
```
public class Test06 {
    static {
        System.out.println("main被加载");
    }

    public static void main(String[] args) throws Exception{
        //1.主动引用
        //Son son = new Son();

        //2.反射也会产生主动引用
        //Class.forName("reflection.Son");

        //不会产生类的引用的方法
        //1.通过子类引用父类的值，子类不被加载
        //System.out.println(Son.b);

        //2.通过数组定义类引用，不会触发此类的初始化
        //Son[] array = new Son[5];

        //3.调用常量
        System.out.println(Son.M);

    }
}

class Father{
    static int b = 2;

    static {
        System.out.println("父类被加载");
    }
}

class Son extends Father{
    static {
        System.out.println("子类被加载");
        m = 300;
    }

    static int m = 100;
    static final int M = 1;
}
```
#### 类加载器
+ 类加载器的作用
将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一-个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。
+ 类缓存（提高效率）
标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间，不过JVM垃圾回收机制可以回收这些Class对象
+ 三种类加载器
1. 引导类加载器：用C++编写的，是JVM自带的类加载器，负责Java平台核心库（rt.jar），用来装载核心类库。该加载器无法直接获取
2. 扩展类加载器：负贵jre/lib/ext目录下的jar包或-D java.ext.dirs指定目录下的jar包装入工作库
3.系统类加载器：负责java classpath 或-D java. .class path所指的目录下的类与jar包装入工作，是最常用的加载器
```
public class Test07 {
    public static void main(String[] args) throws Exception{
        //获取系统类的加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);

        //获取系统类的加载器的父类加载器-->扩展类加载器
        ClassLoader parent = systemClassLoader.getParent();
        System.out.println(parent);

        //获取扩展类加载器的父类加载器-->根加载器 C/C++
        ClassLoader parent1 = parent.getParent();
        System.out.println(parent1); //null 无法获取

        //测试当前类是哪个加载器加载的
        ClassLoader classLoader = Class.forName("reflection.Test07").getClassLoader();
        System.out.println(classLoader);

        classLoader = Class.forName("java.lang.Object").getClassLoader();
        System.out.println(classLoader); //null

        //如何获得系统类加载器可以加载的路径
        System.out.println(System.getProperty("java.class.path"));

        //双亲委派机制
        //自己写的类会到标准类中检查，如果重复的就用系统原来的

        /*
        D:\jdk181\jre\lib\charsets.jar;
        D:\jdk181\jre\lib\deploy.jar;
        D:\jdk181\jre\lib\ext\access-bridge-64.jar;
        D:\jdk181\jre\lib\ext\cldrdata.jar;
        D:\jdk181\jre\lib\ext\dnsns.jar;
        D:\jdk181\jre\lib\ext\jaccess.jar;
        D:\jdk181\jre\lib\ext\jfxrt.jar;
        D:\jdk181\jre\lib\ext\localedata.jar;
        D:\jdk181\jre\lib\ext\nashorn.jar;
        D:\jdk181\jre\lib\ext\sunec.jar;
        D:\jdk181\jre\lib\ext\sunjce_provider.jar;
        D:\jdk181\jre\lib\ext\sunmscapi.jar;
        D:\jdk181\jre\lib\ext\sunpkcs11.jar;
        D:\jdk181\jre\lib\ext\zipfs.jar;
        D:\jdk181\jre\lib\javaws.jar;
        D:\jdk181\jre\lib\jce.jar;
        D:\jdk181\jre\lib\jfr.jar;
        D:\jdk181\jre\lib\jfxswt.jar;
        D:\jdk181\jre\lib\jsse.jar;
        D:\jdk181\jre\lib\management-agent.jar;
        D:\jdk181\jre\lib\plugin.jar;
        D:\jdk181\jre\lib\resources.jar;
        D:\jdk181\jre\lib\rt.jar;
        F:\project\annotation\out\production\annotation;
        D:\IntelliJ IDEA 2016.1.2\lib\idea_rt.jar
         */
    }
}
```
#### 获取类的运行时结构
```
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class Test08 {
    public static void main(String[] args) throws Exception{
        User user = new User();
        Class c1 = user.getClass();

        //获得类的名字
        System.out.println(c1.getName()); //包名+类名
        System.out.println(c1.getSimpleName()); //类名

        //获得类的属性
        //Field[] fields = c1.getFields(); //只能找到public属性
        Field[] fields = c1.getDeclaredFields(); //找到全部属性
        for (Field field : fields) {
            System.out.println(field);
        }

        //获得指定属性
        Field name = c1.getDeclaredField("name");
        System.out.println(name);

        //获得类的方法
        Method[] methods = c1.getMethods(); //获得本类和父类的public方法
        for (Method method : methods) {
            System.out.println("正常的："+method);
        }
        methods = c1.getDeclaredMethods(); //获得本类的所有方法
        for (Method method : methods) {
            System.out.println("加Declared的："+method);
        }

        //获得指定方法
        //因为有重载，所以必须有方法名
        Method getName = c1.getMethod("getName",null);
        Method setName = c1.getMethod("setName",String.class);
        System.out.println(getName);
        System.out.println(setName);

        //获得指定的构造器
        System.out.println("================================");
        Constructor[] constructors = c1.getConstructors();
        for (Constructor constructor : constructors) {
            System.out.println(constructor);
        }
        constructors = c1.getDeclaredConstructors();
        for (Constructor constructor : constructors) {
            System.out.println(constructor);
        }

        //获得指定的构造器
        Constructor declaredConstructor = c1.getDeclaredConstructor(String.class,int.class,int.class);
        System.out.println("指定："+declaredConstructor);
    }
```
#### 动态创建对象 方法 属性
```
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

//动态的创建对象，通过反射
public class Test09 {
    public static void main(String[] args) throws Exception{
        //获得class对象
        Class c1 = Class.forName("reflection.User");

        //构造一个对象,本质是调用了类的无参构造器
        User user = (User) c1.newInstance(); //如果User类没有无参构造器，则会报错
        System.out.println(user);

        //通过构造器创建对象,有参构造
        Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, int.class, int.class);
        User user2 = (User) declaredConstructor.newInstance("peng",1,25);
        System.out.println(user2);

        //通过反射调用普通方法
        User user3 = (User)c1.newInstance();
        //通过反射获取一个方法
        //（对象，"方法的值"）
        Method setName = c1.getDeclaredMethod("setName",String.class);
        setName.invoke(user3,"pengpeng");
        System.out.println(user3.getName());

        //通过反射操作属性
        User user4 = (User)c1.newInstance();
        Field name = c1.getDeclaredField("name");

        //不能直接操作私有属性，我们需要关闭程序的安全检测
        name.setAccessible(true); //true 跳过安全检测
        name.set(user4,"peng250");
        System.out.println(user4.getName());
    }
}
```
#### 性能对比分析
```
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

//分析性能问题
public class Test10 {
    //普通方式调用
    public static void test01(){
        User user = new User();
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000000000; i++) {
            user.getName();
        }
        long endTime = System.currentTimeMillis();
        System.out.println("普通方法执行10亿次时间"+(endTime-startTime)+"ms");
    }

    //反射方式调用
    public static void test02() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        User user = new User();
        Class c1 = user.getClass();

        Method getName = c1.getDeclaredMethod("getName",null);

        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000000000; i++) {
            getName.invoke(user,null);
        }
        long endTime = System.currentTimeMillis();
        System.out.println("反射方式执行10亿次时间"+(endTime-startTime)+"ms");
    }

    //反射方式调用 关闭检测
    public static void test03() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        User user = new User();
        Class c1 = user.getClass();

        Method getName = c1.getDeclaredMethod("getName",null);
        getName.setAccessible(true);

        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000000000; i++) {
            getName.invoke(user,null);
        }
        long endTime = System.currentTimeMillis();
        System.out.println("关闭检测后反射方式执行10亿次时间"+(endTime-startTime)+"ms");
    }

    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        test01();
        test02();
        test03();
    }
}
```
结果
```
普通方法执行10亿次时间4ms
反射方式执行10亿次时间3451ms
关闭检测后反射方式执行10亿次时间1344ms
```
#### 反射操作泛型
+ Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成,所有和泛型有关的类型全部擦除为了通过反射操作这些类型，Java新增了ParameterizedType, GenericArrayType，
+ TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原
始类型齐名的类型.
+ ParameterizedType：表示一种参数化类型，比如Collection<String>
+ GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数组类型
+ TypeVariable :是各种类型变量的公共父接口
+ WildcardType :代表-种通配符类型表达式
```
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.List;
import java.util.Map;

//通过反射获取泛型
public class Test11 {

    public void test01(Map<String,User> map, List<User> list){
        System.out.println("test01");
    }

    public Map<String,User> test02(){
        System.out.println("test02");
        return null;
    }

    public static void main(String[] args) throws NoSuchMethodException {
        
        //打印泛型参数类型
        Method method = Test11.class.getMethod("test01",Map.class,List.class);

        Type[] genericParameterTypes = method.getGenericParameterTypes();

        for (Type genericParameterType : genericParameterTypes) {
            System.out.println("#"+genericParameterType); //打印泛型类型
            if (genericParameterType instanceof ParameterizedType){
                Type[] actualTpyeArguments = ((ParameterizedType)genericParameterType).getActualTypeArguments();
                for (Type actualTpyeArgument : actualTpyeArguments) {
                    System.out.println(actualTpyeArgument); //打印泛型内的真实类型
                }
            }
        }

        System.out.println("========================");

        //打印泛型返回值类型
        method = Test11.class.getMethod("test02",null);
        Type genericReturnType = method.getGenericReturnType();
        System.out.println(genericReturnType); //打印泛型类型

        if (genericReturnType instanceof ParameterizedType){
            Type[] actualTpyeArguments = ((ParameterizedType)genericReturnType).getActualTypeArguments();
            for (Type actualTpyeArgument : actualTpyeArguments) {
                System.out.println(actualTpyeArgument); //打印泛型内的真实类型
            }
        }
    }
}
```
#### 反射获取注解信息
+ 练习：ORM
Object Relationship Mapping 对象关系映射
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709162734739-2141543231.png)

◆类和表结构对应
◆属性和字段对应
◆对象和记录对应
◆要求：利用注解和反射完成类和表结构的映射关系
```
package reflection;

import java.lang.annotation.*;
import java.lang.reflect.Field;

/**
 * Created by peng on 2020/5/7.
 */
public class Test12 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {
        Class c1 = Class.forName("reflection.Student2");

        //通过反射获得注解
        Annotation[] annotations = c1.getAnnotations();
        for (Annotation annotation : annotations) {
            System.out.println(annotation);
        }

        //获得注解的value值
        Tablekuang tablekuang = (Tablekuang)c1.getAnnotation(Tablekuang.class);
        String value = tablekuang.value();
        System.out.println(value);

        //获得类指定的注解
        Field f = c1.getDeclaredField("age");
        Fieldkuang annootation = f.getAnnotation(Fieldkuang.class);
        System.out.println(annootation.columnName());
        System.out.println(annootation.type());
        System.out.println(annootation.length());
    }
}

@Tablekuang("db_student")
class Student2{

    @Fieldkuang(columnName = "db_id",type = "int",length = 10)
    private int id;
    @Fieldkuang(columnName = "db_age",type = "int",length = 3)
    private int age;
    @Fieldkuang(columnName = "db_name",type = "varchar",length = 5)
    private String name;

    public Student2() {
    }

    public Student2(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

//类名的注解
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface Tablekuang{
    String value();
}

//属性的注解
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface Fieldkuang{
    String columnName();
    String type();
    int length();
}
```]]></description></item><item><title>Java集合框架与泛型</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/09/java_03.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 09 Jul 2020 06:15:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/09/java_03.html</guid><description><![CDATA[### ArrayList
#### 与数组的区别
+ 使用数组的局限性
如果要存放多个对象，可以使用数组，但是数组有局限性
比如 声明长度是10的数组
不用的数组就浪费了，超过10的个数，又放不下
```
package charactor;
 
public class Hero {
    public String name;
    public float hp;
 
    public int damage;
 
    public Hero() {
 
    }
 
    // 增加一个初始化name的构造方法
    public Hero(String name) {
 
        this.name = name;
    }
 
    // 重写toString方法
    public String toString() {
        return name;
    }
}
```
```
package collection;
 
import charactor.Hero;
 
public class TestCollection {
    public static void main(String[] args) {
        //数组的局限性
        Hero heros[] = new Hero[10];
        //声明长度是10的数组
        //不用的数组就浪费了
        //超过10的个数，又放不下
        heros[0] = new Hero("盖伦");
                //放不下要报错
        heros[20] = new Hero("提莫"); 
    }  
}
```

+ ArrayList存放对象
为了解决数组的局限性，引入容器类的概念。 
最常见的容器类就是ArrayList，容器的容量会随着对象的增加自动增长
只需要不断往容器里增加英雄即可，不用担心会出现数组的边界问题。
```
package collection;
 
import java.util.ArrayList;
import charactor.Hero;
 
public class TestCollection {
    @SuppressWarnings("rawtypes")
    public static void main(String[] args) {
        //容器类ArrayList，用于存放对象
        ArrayList heros = new ArrayList();
        heros.add( new Hero("盖伦"));
        System.out.println(heros.size());
         
        //容器的容量"capacity"会随着对象的增加，自动增长
        //只需要不断往容器里增加英雄即可，不用担心会出现数组的边界问题。
        heros.add( new Hero("提莫"));
        System.out.println(heros.size());  
    } 
}
```
#### 常用方法
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709140709443-538840567.png)

+ 增加
add 有两种用法
第一种是直接add对象，把对象加在最后面
`heros.add(new Hero("hero " + i));`
第二种是在指定位置加对象
`heros.add(3, specialHero);`
```
package collection;
 
import java.util.ArrayList;
import charactor.Hero;
 
public class TestCollection {
    public static void main(String[] args) {
        ArrayList heros = new ArrayList();
 
        // 把5个对象加入到ArrayList中
        for (int i = 0; i < 5; i++) {
            heros.add(new Hero("hero " + i));
        }
        System.out.println(heros);
 
        // 在指定位置增加对象
        Hero specialHero = new Hero("special hero");
        heros.add(3, specialHero);
 
        System.out.println(heros.toString()); 
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709140738292-1214341464.png)

+ 判断是否存在
通过方法 contains 判断一个对象是否在容器中
判断标准： 是否是同一个对象，而不是name是否相同
```
package collection;
 
import java.util.ArrayList;
import charactor.Hero;
 
public class TestCollection {
    public static void main(String[] args) {
        ArrayList heros = new ArrayList();
 
        // 初始化5个对象
        for (int i = 0; i < 5; i++) {
            heros.add(new Hero("hero " + i));
        }
        Hero specialHero = new Hero("special hero");
        heros.add(specialHero);
 
        System.out.println(heros);
        // 判断一个对象是否在容器中
        // 判断标准： 是否是同一个对象，而不是name是否相同
        System.out.print("虽然一个新的对象名字也叫 hero 1，但是contains的返回是:");
        System.out.println(heros.contains(new Hero("hero 1")));
        System.out.print("而对specialHero的判断，contains的返回是:");
        System.out.println(heros.contains(specialHero));
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709140830214-34661212.png)


+ 获取指定位置的对象
通过 get 获取指定位置的对象，如果输入的下标越界，一样会报错
```
package collection;
 
import java.util.ArrayList;
import charactor.Hero;
 
public class TestCollection {
    public static void main(String[] args) {
        ArrayList heros = new ArrayList();
 
        // 初始化5个对象
        for (int i = 0; i < 5; i++) {
            heros.add(new Hero("hero " + i));
        }
        Hero specialHero = new Hero("special hero");
        heros.add(specialHero);
         
        //获取指定位置的对象
        System.out.println(heros.get(5));
        //如果超出了范围，依然会报错
        System.out.println(heros.get(6));
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709140841070-2102411476.png)

+ 获取对象所处的位置
indexOf用于判断一个对象在ArrayList中所处的位置
与contains一样，判断标准是对象是否相同，而非对象的name值是否相等
```
package collection;
 
import java.util.ArrayList;
import charactor.Hero;
 
public class TestCollection {
    public static void main(String[] args) {
        ArrayList heros = new ArrayList();
 
        // 初始化5个对象
        for (int i = 0; i < 5; i++) {
            heros.add(new Hero("hero " + i));
        }
        Hero specialHero = new Hero("special hero");
        heros.add(specialHero);
 
        System.out.println(heros);
        System.out.println("specialHero所处的位置:"+heros.indexOf(specialHero));
        System.out.println("新的英雄，但是名字是\"hero 1\"所处的位置:"+heros.indexOf(new Hero("hero 1")));
 
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709140850642-663383688.png)

+ 删除
remove用于把对象从ArrayList中删除
remove可以根据下标删除ArrayList的元素
`heros.remove(2);`
也可以根据对象删除
`heros.remove(specialHero);`
```
package collection;
 
import java.util.ArrayList;
import charactor.Hero;
 
public class TestCollection {
    public static void main(String[] args) {
        ArrayList heros = new ArrayList();
 
        // 初始化5个对象
        for (int i = 0; i < 5; i++) {
            heros.add(new Hero("hero " + i));
        }
        Hero specialHero = new Hero("special hero");
        heros.add(specialHero);
         
        System.out.println(heros);
        heros.remove(2);
        System.out.println("删除下标是2的对象");
        System.out.println(heros);
        System.out.println("删除special hero");
        heros.remove(specialHero);
        System.out.println(heros);         
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709140859727-1022223068.png)

+ 替换
set用于替换指定位置的元素
```
package collection;
 
import java.util.ArrayList;
import charactor.Hero;
 
public class TestCollection {
    public static void main(String[] args) {
        ArrayList heros = new ArrayList();
 
        // 初始化5个对象
        for (int i = 0; i < 5; i++) {
            heros.add(new Hero("hero " + i));
        }
        Hero specialHero = new Hero("special hero");
        heros.add(specialHero);
         
        System.out.println(heros);
        System.out.println("把下标是5的元素，替换为\"hero 5\"");
        heros.set(5, new Hero("hero 5"));
        System.out.println(heros);
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709140910472-1720817546.png)

+ 获取大小
size 用于获取ArrayList的大小
```
package collection;
 
import java.util.ArrayList;
import charactor.Hero;
 
public class TestCollection {
    public static void main(String[] args) {
        ArrayList heros = new ArrayList();
 
        // 初始化5个对象
        for (int i = 0; i < 5; i++) {
            heros.add(new Hero("hero " + i));
        }
        Hero specialHero = new Hero("special hero");
        heros.add(specialHero);
        System.out.println(heros);
        System.out.println("获取ArrayList的大小：");
        System.out.println(heros.size());
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709140918713-1541873747.png)

+  转换为数组
toArray可以把一个ArrayList对象转换为数组。
需要注意的是，如果要转换为一个Hero数组，那么需要传递一个Hero数组类型的对象给toArray()，这样toArray方法才知道，你希望转换为哪种类型的数组，否则只能转换为Object数组
```
package collection;
 
import java.util.ArrayList;
import charactor.Hero;
 
public class TestCollection {
    public static void main(String[] args) {
        ArrayList heros = new ArrayList();
 
        // 初始化5个对象
        for (int i = 0; i < 5; i++) {
            heros.add(new Hero("hero " + i));
        }
        Hero specialHero = new Hero("special hero");
        heros.add(specialHero);
        System.out.println(heros);
        Hero hs[] = (Hero[])heros.toArray(new Hero[]{});
        System.out.println("数组:" +hs);
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709140928531-1382101142.png)

+ 把另一个容器所有对象都加进来
addAll 把另一个容器所有对象都加进来
```
package collection;
 
import java.util.ArrayList;
import charactor.Hero;
 
public class TestCollection {
    public static void main(String[] args) {
        ArrayList heros = new ArrayList();
 
        // 初始化5个对象
        for (int i = 0; i < 5; i++) {
            heros.add(new Hero("hero " + i));
        }
 
        System.out.println("ArrayList heros:\t" + heros);
          
        //把另一个容器里所有的元素，都加入到该容器里来
        ArrayList anotherHeros = new ArrayList();
        anotherHeros.add(new Hero("hero a"));
        anotherHeros.add(new Hero("hero b"));
        anotherHeros.add(new Hero("hero c"));
        System.out.println("anotherHeros heros:\t" + anotherHeros);
        heros.addAll(anotherHeros);
        System.out.println("把另一个ArrayList的元素都加入到当前ArrayList:");
        System.out.println("ArrayList heros:\t" + heros);   
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709140939697-1057728596.png)

+ 清空
clear 清空一个ArrayList
```
package collection;
 
import java.util.ArrayList;
import charactor.Hero;
 
public class TestCollection {
    public static void main(String[] args) {
        ArrayList heros = new ArrayList();
 
        // 初始化5个对象
        for (int i = 0; i < 5; i++) {
            heros.add(new Hero("hero " + i));
        }
 
        System.out.println("ArrayList heros:\t" + heros);
        System.out.println("使用clear清空");
        heros.clear();
        System.out.println("ArrayList heros:\t" + heros);
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709140949868-1242819930.png)

#### List接口
+ ArrayList 和 List
ArrayList实现了接口List
常见的写法会把引用声明为接口List类型
注意：是java.util.List，而不是java.awt.List
```
package collection;
  
import java.util.ArrayList;
import java.util.List;
import charactor.Hero;
  
public class TestCollection {
    public static void main(String[] args) {
        //ArrayList实现了接口List
         
        //常见的写法会把引用声明为接口List类型
        //注意：是java.util.List,而不是java.awt.List
        //接口引用指向子类对象（多态）
         
        List heros = new ArrayList();
        heros.add( new Hero("盖伦"));
        System.out.println(heros.size());
    } 
}
```
+ List接口的方法
因为ArrayList实现了List接口，所以List接口的方法ArrayList都实现了。
#### 泛型
+ 泛型 Generic
不指定泛型的容器，可以存放任何类型的元素
指定了泛型的容器，只能存放指定类型的元素以及其子类
```
package property;
 
public class Item {
    String name;
    int price;
     
    public Item(){
         
    }
     
    //提供一个初始化name的构造方法
    public Item(String name){
        this.name = name;
    }
     
    public void effect(){
        System.out.println("物品使用后，可以有效果");
    }  
}
```
```
package collection;
   
import java.util.ArrayList;
import java.util.List;
  
import property.Item;
import charactor.APHero;
import charactor.Hero;
   
public class TestCollection {
    public static void main(String[] args) {
          
        //对于不使用泛型的容器，可以往里面放英雄，也可以往里面放物品
        List heros = new ArrayList();
          
        heros.add(new Hero("盖伦"));
          
        //本来用于存放英雄的容器，现在也可以存放物品了
        heros.add(new Item("冰杖"));
          
        //对象转型会出现问题
        Hero h1=  (Hero) heros.get(0);
        //尤其是在容器里放的对象太多的时候，就记不清楚哪个位置放的是哪种类型的对象了
        Hero h2=  (Hero) heros.get(1);
          
        //引入泛型Generic
        //声明容器的时候，就指定了这种容器，只能放Hero，放其他的就会出错
        List<Hero> genericheros = new ArrayList<Hero>();
        genericheros.add(new Hero("盖伦"));
        //如果不是Hero类型，根本就放不进去
        //genericheros.add(new Item("冰杖"));
          
        //除此之外，还能存放Hero的子类
        genericheros.add(new APHero());
         
        //并且在取出数据的时候，不需要再进行转型了，因为里面肯定是放的Hero或者其子类
        Hero h = genericheros.get(0);         
    }       
}
```
+ 泛型的简写
为了不使编译器出现警告，需要前后都使用泛型，像这样：
`List<Hero> genericheros = new ArrayList<Hero>();`
不过JDK7提供了一个可以略微减少代码量的泛型简写方式
`List<Hero> genericheros2 = new ArrayList<>();`
```
package collection;
   
import java.util.ArrayList;
import java.util.List; 
import charactor.Hero;
   
public class TestCollection {  
    public static void main(String[] args) {
        List<Hero> genericheros = new ArrayList<Hero>();
        List<Hero> genericheros2 = new ArrayList<>();      
    }       
}
```
#### 遍历
+ 用for循环遍历
```
package collection;
 
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import charactor.Hero;
 
public class TestCollection {
 
    public static void main(String[] args) {
        List<Hero> heros = new ArrayList<Hero>();
 
        // 放5个Hero进入容器
        for (int i = 0; i < 5; i++) {
            heros.add(new Hero("hero name " + i));
        }
 
        // 第一种遍历 for循环
        System.out.println("--------for 循环-------");
        for (int i = 0; i < heros.size(); i++) {
            Hero h = heros.get(i); //获得第i个英雄对象
            System.out.println(h);
        } 
    }
}
```
+ 迭代器遍历
迭代器有一个空的头部，直接hasNext的就是第一个
```
package collection;
 
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List; 
import charactor.Hero;
  
public class TestCollection { 
    public static void main(String[] args) {
        List<Hero> heros = new ArrayList<Hero>();
         
        //放5个Hero进入容器
        for (int i = 0; i < 5; i++) {
            heros.add(new Hero("hero name " +i));
        }
         
        //第二种遍历，使用迭代器
        System.out.println("--------使用while的iterator-------");
        Iterator<Hero> it= heros.iterator();
        //从最开始的位置判断"下一个"位置是否有数据
        //如果有就通过next取出来，并且把指针向下移动
        //直到"下一个"位置没有数据
        while(it.hasNext()){
            Hero h = it.next();
            System.out.println(h);
        }
        //迭代器的for写法
        System.out.println("--------使用for的iterator-------");
        for (Iterator<Hero> iterator = heros.iterator(); iterator.hasNext();) {
            Hero hero = (Hero) iterator.next();
            System.out.println(hero);
        }         
    }      
}
```
+ 用增强型for循环
使用增强型for循环可以非常方便的遍历ArrayList中的元素，这是很多开发人员的首选。
不过增强型for循环也有不足：
1.无法用来进行ArrayList的初始化
2.无法得知当前是第几个元素了，当需要只打印单数元素的时候，就做不到了，必须再自定下标变量。
```
package collection;
 
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List; 
import charactor.Hero;
 
public class TestCollection { 
    public static void main(String[] args) {
        List<Hero> heros = new ArrayList<Hero>();
 
        // 放5个Hero进入容器
        for (int i = 0; i < 5; i++) {
            heros.add(new Hero("hero name " + i));
        }
 
        // 第三种，增强型for循环
        System.out.println("--------增强型for循环-------");
        for (Hero h : heros) {
            System.out.println(h);
        } 
    } 
}
```
### 其他集合
#### LinkedList
+ LinkedList 与 List接口
与ArrayList一样，LinkedList也实现了List接口，诸如add,remove,contains等等方法，在此不作赘述，接下来要讲的是LinkedList的一些特别的地方
+ 双向链表 - Deque
除了实现了List接口外，LinkedList还实现了**双向链表结构**Deque，可以很方便的在头尾插入删除
数据什么是链表结构：与数组结构相比较，数组结构，就好像是电影院，每个位置都有标示，每个位置之间的间隔都是一样的。 而链表就相当于佛珠，每个珠子，只连接前一个和后一个，不用关心除此之外的其他佛珠在哪里。
```
package collection;
 
import java.util.LinkedList; 
import charactor.Hero;
 
public class TestCollection { 
    public static void main(String[] args) {
         
        //LinkedList是一个双向链表结构的list
        LinkedList<Hero> ll =new LinkedList<Hero>();
         
        //所以可以很方便的在头部和尾部插入数据
        //在最后插入新的英雄
        ll.addLast(new Hero("hero1"));
        ll.addLast(new Hero("hero2"));
        ll.addLast(new Hero("hero3"));
        System.out.println(ll);
         
        //在最前面插入新的英雄
        ll.addFirst(new Hero("heroX"));
        System.out.println(ll);
         
        //查看最前面的英雄
        System.out.println(ll.getFirst());
        //查看最后面的英雄
        System.out.println(ll.getLast());
         
        //查看不会导致英雄被删除
        System.out.println(ll);
        //取出最前面的英雄
        System.out.println(ll.removeFirst());
         
        //取出最后面的英雄
        System.out.println(ll.removeLast());
         
        //取出会导致英雄被删除
        System.out.println(ll);         
    }      
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141021905-306077823.png)

+ 队列 - Queue
LinkedList 除了实现了List和Deque外，还实现了Queue接口(队列)。
Queue是先进先出队列 FIFO，常用方法：
offer 在最后添加元素
poll 取出第一个元素
peek 查看第一个元素
```
package collection;
  
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;  
import charactor.Hero;
  
public class TestCollection {  
    public static void main(String[] args) {
        //和ArrayList一样，LinkedList也实现了List接口
        List ll =new LinkedList<Hero>();
          
        //所不同的是LinkedList还实现了Deque，进而又实现了Queue这个接口
        //Queue代表FIFO 先进先出的队列
        Queue<Hero> q= new LinkedList<Hero>();
          
        //加在队列的最后面
        System.out.print("初始化队列：\t");
        q.offer(new Hero("Hero1"));
        q.offer(new Hero("Hero2"));
        q.offer(new Hero("Hero3"));
        q.offer(new Hero("Hero4"));
          
        System.out.println(q);
        System.out.print("把第一个元素取poll()出来:\t");
        //取出第一个Hero，FIFO 先进先出
        Hero h = q.poll();
        System.out.println(h);
        System.out.print("取出第一个元素之后的队列:\t");
        System.out.println(q);
          
        //把第一个拿出来看一看，但是不取出来
        h=q.peek();
        System.out.print("查看peek()第一个元素:\t");
        System.out.println(h);
        System.out.print("查看并不会导致第一个元素被取出来:\t");
        System.out.println(q);          
    }       
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141031765-1177348949.png)

+ 使用LinkedList实现Stack栈
```
package collection;
 
import charactor.Hero;
 
public interface Stack {
 
    //把英雄推入到最后位置
    public void push(Hero h);
    //把最后一个英雄取出来
    public Hero pull();
    //查看最后一个英雄
    public Hero peek();
}
```
```
package collection;
   
import java.util.LinkedList;   
import charactor.Hero;
   
public class MyStack implements Stack{
   
    LinkedList<Hero> heros = new LinkedList<Hero>();
       
    @Override
    public void push(Hero h) {
        heros.addLast(h);
    }
   
    @Override
    public Hero pull() {
        return heros.removeLast();
    }
   
    @Override
    public Hero peek() {
        return heros.getLast();
    }
       
    public static void main(String[] args) {
           
        MyStack heroStack = new MyStack();
        for (int i = 0; i < 5; i++) {
            Hero h = new Hero("hero name " + i);
            System.out.println("压入 hero:" + h);
            heroStack.push(h);
        }
        for (int i = 0; i < 5; i++) {
            Hero h =heroStack.pull();
            System.out.println("弹出 hero" + h);
        }
    }   
}
```
#### 二叉树
+ 二叉树
二叉树由各种节点组成
二叉树特点：
每个节点都可以有左子节点
右子节点每一个节点都有一个值
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141041788-804355020.png)

```
package collection;
 
public class Node {
    // 左子节点
    public Node leftNode;
    // 右子节点
    public Node rightNode;
    // 值
    public Object value;
}
```
+ 二叉树排序-插入数据
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141052739-1135662346.png)

```
package collection;
  
public class Node {
    // 左子节点
    public Node leftNode;
    // 右子节点
    public Node rightNode;
  
    // 值
    public Object value;
  
    // 插入 数据
    public void add(Object v) {
        // 如果当前节点没有值，就把数据放在当前节点上
        if (null == value)
            value = v;
  
        // 如果当前节点有值，就进行判断，新增的值与当前值的大小关系
        else {
            // 新增的值，比当前值小或者相同
             
            if ((Integer) v -((Integer)value) <= 0) {
                if (null == leftNode)
                    leftNode = new Node();
                leftNode.add(v);
            }
            // 新增的值，比当前值大
            else {
                if (null == rightNode)
                    rightNode = new Node();
                rightNode.add(v);
            }  
        }  
    }
  
    public static void main(String[] args) {
  
        int randoms[] = new int[] { 67, 7, 30, 73, 10, 0, 78, 81, 10, 74 };
  
        Node roots = new Node();
        for (int number : randoms) {
            roots.add(number);
        }  
    }
}
```
+ 遍历
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141105595-1777374055.png)

```
package collection;
 
import java.util.ArrayList;
import java.util.List;
 
public class Node {
    // 左子节点
    public Node leftNode;
    // 右子节点
    public Node rightNode;
  
    // 值
    public Object value;
  
    // 插入 数据
    public void add(Object v) {
        // 如果当前节点没有值，就把数据放在当前节点上
        if (null == value)
            value = v;
  
        // 如果当前节点有值，就进行判断，新增的值与当前值的大小关系
        else {
            // 新增的值，比当前值小或者相同
             
            if ((Integer) v -((Integer)value) <= 0) {
                if (null == leftNode)
                    leftNode = new Node();
                leftNode.add(v);
            }
            // 新增的值，比当前值大
            else {
                if (null == rightNode)
                    rightNode = new Node();
                rightNode.add(v);
            }
  
        }
  
    }
  
 // 中序遍历所有的节点
    public List<Object> values() {
        List<Object> values = new ArrayList<>();
  
        // 左节点的遍历结果
        if (null != leftNode)
            values.addAll(leftNode.values());
  
        // 当前节点
        values.add(value);
  
        // 右节点的遍历结果
        if (null != rightNode)
  
            values.addAll(rightNode.values());
  
        return values;
    }
  
    public static void main(String[] args) {
  
        int randoms[] = new int[] { 67, 7, 30, 73, 10, 0, 78, 81, 10, 74 };
  
        Node roots = new Node();
        for (int number : randoms) {
            roots.add(number);
        }
  
        System.out.println(roots.values());  
    }
}
```
#### HashMap
+ HashMap的键值对
HashMap储存数据的方式是——键值对
```
package collection;
   
import java.util.HashMap;
   
public class TestCollection {
    public static void main(String[] args) {
        HashMap<String,String> dictionary = new HashMap<>();
        dictionary.put("adc", "物理英雄");
        dictionary.put("apc", "魔法英雄");
        dictionary.put("t", "坦克");
         
        System.out.println(dictionary.get("t"));
    }
}
```
+ 键不能重复，值可以重复
对于HashMap而言，key是唯一的，不可以重复的。
所以，以相同的key 把不同的value插入到 Map中会导致旧元素被覆盖，只留下最后插入的元素。
不过，同一个对象可以作为值插入到map中，只要对应的key不一样
```
package collection;
  
import java.util.HashMap;
  
import charactor.Hero;
  
public class TestCollection {
    public static void main(String[] args) {
        HashMap<String,Hero> heroMap = new HashMap<String,Hero>();
         
        heroMap.put("gareen", new Hero("gareen1"));
        System.out.println(heroMap);
         
        //key为gareen已经有value了，再以gareen作为key放入数据，会导致原英雄，被覆盖
        //不会增加新的元素到Map中
        heroMap.put("gareen", new Hero("gareen2"));
        System.out.println(heroMap);
         
        //清空map
        heroMap.clear();
        Hero gareen = new Hero("gareen");
         
        //同一个对象可以作为值插入到map中，只要对应的key不一样
        heroMap.put("hero1", gareen);
        heroMap.put("hero2", gareen);
         
        System.out.println(heroMap);
         
    }
}
```
+ ArrayList 和 HashMap 性能对比
```
import java.util.*;

public class Test02 {
    public static void main(String[] args) {
        HashMap<String,Hero> heroHashMap = new HashMap<>();
        List<Hero> heroList = new ArrayList<>();
        for (int i = 0; i < 3000000; i++) {
            heroList.add(new Hero("hero in list "+i));
            heroHashMap.put("hero in hashmap "+i,new Hero("hashmap hero "+i));
        }

        long startL = System.currentTimeMillis();
        for (Hero hero : heroList) {
            if (hero.name.equals("hero in list 2626435")){
                System.out.println(hero.name);
            }
            if (hero.name.equals("hero in list 126435")){
                System.out.println(hero.name);
            }
            if (hero.name.equals("hero in list 326435")){
                System.out.println(hero.name);
            }
        }
        long endL = System.currentTimeMillis();
        System.out.println("List查找时间："+(endL-startL)+"ms");

        long startH = System.currentTimeMillis();
        System.out.println(heroHashMap.get("hero in hashmap 2626435"));
        System.out.println(heroHashMap.get("hero in hashmap 126435"));
        System.out.println(heroHashMap.get("hero in hashmap 326435"));
        long endH = System.currentTimeMillis();
        System.out.println("Hashmap查找时间："+(endH-startH)+"ms");
    }
}
```
输出
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141121825-1887313389.png)

#### HashSet
+ Set中的元素，不能重复
```
package collection;
  
import java.util.HashSet;
  
public class TestCollection {
    public static void main(String[] args) {
         
        HashSet<String> names = new HashSet<String>();
         
        names.add("gareen");
         
        System.out.println(names);
         
        //第二次插入同样的数据，是插不进去的，容器中只会保留一个
        names.add("gareen");
        System.out.println(names);
    }
}
```
+ 没有顺序
Set中的元素，没有顺序。严格的说，是没有按照元素的插入顺序排列
不保证Set的迭代顺序; 确切的说，在不同条件下，元素的顺序都有可能不一样
换句话说，同样是插入0-9到HashSet中， 在JVM的不同版本中，看到的顺序都是不一样的。 所以在开发的时候，不能依赖于某种臆测的顺序，这个顺序本身是不稳定的
```
package collection;
 
import java.util.HashSet;
 
public class TestCollection {
    public static void main(String[] args) {
        HashSet<Integer> numbers = new HashSet<Integer>();
 
        numbers.add(9);
        numbers.add(5);
        numbers.add(1);
 
        // Set中的元素排列，不是按照插入顺序
        System.out.println(numbers);
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141130791-814253244.png)

+ 遍历
Set不提供get()来获取指定位置的元素，所以遍历需要用到迭代器，或者增强型for循环
```
package collection;
  
import java.util.HashSet;
import java.util.Iterator;
  
public class TestCollection {
    public static void main(String[] args) {
        HashSet<Integer> numbers = new HashSet<Integer>();
         
        for (int i = 0; i < 20; i++) {
            numbers.add(i);
        }
         
        //Set不提供get方法来获取指定位置的元素
        //numbers.get(0)
         
        //遍历Set可以采用迭代器iterator
        for (Iterator<Integer> iterator = numbers.iterator(); iterator.hasNext();) {
            Integer i = (Integer) iterator.next();
            System.out.println(i);
        }
         
        //或者采用增强型for循环
        for (Integer i : numbers) {
            System.out.println(i);
        }         
    }
}
```
+ HashSet和HashMap的关系
HashSet自身并没有独立的实现，而是在里面封装了一个Map.HashSet是作为Map的key而存在的
#### Collection
Collection是 Set List Queue和 Deque的接口
Queue: 先进先出队列
Deque: 双向链表
注：Collection和Map之间没有关系，Collection是放一个一个对象的，Map 是放键值对的
注：Deque 继承 Queue，间接的继承了 Collection
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141201062-33988428.png)

#### Collections
Collections是一个类，容器的工具类，就如同Arrays是数组的工具类
+ 方法
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141207100-2056134579.png)

+ 反转
```
package collection;
   
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
   
public class TestCollection {
    public static void main(String[] args) {
        //初始化集合numbers
        List<Integer> numbers = new ArrayList<>();
         
        for (int i = 0; i < 10; i++) {
            numbers.add(i);
        }
         
        System.out.println("集合中的数据:");
        System.out.println(numbers);
         
        Collections.reverse(numbers);
         
        System.out.println("翻转后集合中的数据:");
        System.out.println(numbers);         
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141216754-1805868277.png)

+ 混淆
```
package collection;
   
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
   
public class TestCollection {
    public static void main(String[] args) {
        //初始化集合numbers
        List<Integer> numbers = new ArrayList<>();
         
        for (int i = 0; i < 10; i++) {
            numbers.add(i);
        }
         
        System.out.println("集合中的数据:");
        System.out.println(numbers);
         
        Collections.shuffle(numbers);
         
        System.out.println("混淆后集合中的数据:");
        System.out.println(numbers);         
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141225881-129883030.png)

+ 排序
```
package collection;
   
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
   
public class TestCollection {
    public static void main(String[] args) {
        //初始化集合numbers
        List<Integer> numbers = new ArrayList<>();
         
        for (int i = 0; i < 10; i++) {
            numbers.add(i);
        }
         
        System.out.println("集合中的数据:");
        System.out.println(numbers);
 
        Collections.shuffle(numbers);
        System.out.println("混淆后集合中的数据:");
        System.out.println(numbers);
 
        Collections.sort(numbers);
        System.out.println("排序后集合中的数据:");
        System.out.println(numbers);         
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141234044-605870057.png)

+ 交换
```
package collection;
   
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
   
public class TestCollection {
    public static void main(String[] args) {
        //初始化集合numbers
        List<Integer> numbers = new ArrayList<>();
         
        for (int i = 0; i < 10; i++) {
            numbers.add(i);
        }
         
        System.out.println("集合中的数据:");
        System.out.println(numbers);
 
        Collections.swap(numbers,0,5);
        System.out.println("交换0和5下标的数据后，集合中的数据:");
        System.out.println(numbers);         
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141241371-701912291.png)

+ 滚动
```
package collection;
   
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
   
public class TestCollection {
    public static void main(String[] args) {
        //初始化集合numbers
        List<Integer> numbers = new ArrayList<>();
         
        for (int i = 0; i < 10; i++) {
            numbers.add(i);
        }
         
        System.out.println("集合中的数据:");
        System.out.println(numbers);
 
        Collections.rotate(numbers,2);
        System.out.println("把集合向右滚动2个单位，标的数据后，集合中的数据:");
        System.out.println(numbers);         
    }
}
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141251221-593932909.png)

+ 线程安全化
synchronizedList 把非线程安全的List转换为线程安全的List。 因为截至目前为止，还没有学习线程安全的内容，暂时不展开。 线程安全的内容将在多线程章节展开。
```
package collection;
 
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
 
public class TestCollection {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>();
 
        System.out.println("把非线程安全的List转换为线程安全的List");
        List<Integer> synchronizedNumbers = (List<Integer>) Collections.synchronizedList(numbers); 
    }
}
```
### HashTable
HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式
区别1：HashMap可以存放  nullHashtable不能存放null
区别2：HashMap不是线程安全的类  Hashtable是线程安全的类
```
package collection;
 
import java.util.HashMap;
import java.util.Hashtable;
 
public class TestCollection {
    public static void main(String[] args) {
         
        //HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式
         
        HashMap<String,String> hashMap = new HashMap<String,String>();
         
        //HashMap可以用null作key,作value
        hashMap.put(null, "123");
        hashMap.put("123", null);
         
        Hashtable<String,String> hashtable = new Hashtable<String,String>();
        //Hashtable不能用null作key，不能用null作value
        hashtable.put(null, "123");
        hashtable.put("123", null); 
    }
}
```
### 泛型
#### 集合中的泛型
+ 不使用泛型
不使用泛型带来的问题ADHero（物理攻击英雄） APHero（魔法攻击英雄）都是Hero的子类
ArrayList 默认接受Object类型的对象，所以所有对象都可以放进ArrayList中
所以get(0) 返回的类型是Object
接着，需要进行强制转换才可以得到APHero类型或者ADHero类型。
如果软件开发人员记忆比较好，能记得哪个是哪个，还是可以的。 但是开发人员会犯错误，比如第20行，会记错，把第0个对象转换为ADHero,这样就会出现类型转换异常
```
package generic;
 
import java.util.ArrayList;
 
import charactor.ADHero;
import charactor.APHero;
 
public class TestGeneric {
 
    public static void main(String[] args) {
         
        ArrayList heros = new ArrayList();
         
        heros.add(new APHero());
        heros.add(new ADHero());
         
        APHero apHero =  (APHero) heros.get(0);
        ADHero adHero =  (ADHero) heros.get(1);
         
        //ADHero adHero2 =  (ADHero) heros.get(0); //出错
    }
}
```
+ 使用泛型
使用泛型的好处：泛型的用法是在容器后面添加<Type>
Type可以是类，抽象类，接口
泛型表示这种容器，只能存放APHero，ADHero就放不进去了。
```
package generic;
 
import java.util.ArrayList; 
import charactor.APHero;
 
public class TestGeneric {
 
    public static void main(String[] args) {
        ArrayList<APHero> heros = new ArrayList<APHero>();
         
        //只有APHero可以放进去    
        heros.add(new APHero());
         
        //ADHero甚至放不进去
        //heros.add(new ADHero());
         
        //获取的时候也不需要进行转型，因为取出来一定是APHero
        APHero apHero =  heros.get(0);         
    }
}
```
+ 子类对象
假设容器的泛型是Hero，那么Hero的子类APHero，ADHero都可以放进去
和Hero无关的类型Item还是放不进去
```
package generic;
 
import java.util.ArrayList;
 
import property.Item;
 
import charactor.ADHero;
import charactor.APHero;
import charactor.Hero;
 
public class TestGeneric {
 
    public static void main(String[] args) {
        ArrayList<Hero> heros = new ArrayList<Hero>();
         
        //只有作为Hero的子类可以放进去     
        heros.add(new APHero());
        heros.add(new ADHero());
         
        //和Hero无关的类型Item还是放不进去
        //heros.add(new Item());         
    }
}
```
+ 泛型的简写
为了不使编译器出现警告，需要前后都使用泛型，像这样：
`ArrayList<Hero> heros = new ArrayList<Hero>();`
不过JDK7提供了一个可以略微减少代码量的泛型简写方式
`ArrayList<Hero> heros2 = new ArrayList<>();`
```
package generic;
  
import java.util.ArrayList; 
import charactor.Hero;
  
public class TestGeneric {  
    public static void main(String[] args) {
        ArrayList<Hero> heros = new ArrayList<Hero>();
        //后面可以只用<>
        ArrayList<Hero> heros2 = new ArrayList<>();         
    }
}
```
#### 支持泛型的类
+ 不支持泛型的Stack
以Stack栈为例子，如果不使用泛型
当需要一个只能放Hero的栈的时候，就需要设计一个HeroStack
当需要一个只能放Item的栈的时候，就需要一个ItemStack
```
package generic;
   
import java.util.LinkedList; 
import charactor.Hero;
   
public class HeroStack {
   
    LinkedList<Hero> heros = new LinkedList<Hero>();
       
    public void push(Hero h) {
        heros.addLast(h);
    }
   
    public Hero pull() {
        return heros.removeLast();
    }
   
    public Hero peek() {
        return heros.getLast();
    }
       
    public static void main(String[] args) {
           
        HeroStack heroStack = new HeroStack();
        for (int i = 0; i < 5; i++) {
            Hero h = new Hero("hero name " + i);
            System.out.println("压入 hero:" + h);
            heroStack.push(h);
        }
        for (int i = 0; i < 5; i++) {
            Hero h =heroStack.pull();
            System.out.println("弹出 hero" + h);
        }
    }   
}
```
```
package generic;
   
import java.util.LinkedList;
 
import property.Item;
   
public class ItemStack {
   
    LinkedList<Item> Items = new LinkedList<Item>();
       
    public void push(Item h) {
        Items.addLast(h);
    }
   
    public Item pull() {
        return Items.removeLast();
    }
   
    public Item peek() {
        return Items.getLast();
    }
       
    public static void main(String[] args) {
           
        ItemStack ItemStack = new ItemStack();
        for (int i = 0; i < 5; i++) {
            Item item = new Item("Item name " + i);
            System.out.println("压入 Item:" + item);
            ItemStack.push(item);
        }
        for (int i = 0; i < 5; i++) {
            Item item =ItemStack.pull();
            System.out.println("弹出 Item" + item);
        }
    }   
}
```
+ 支持泛型的Stack
设计一个支持泛型的栈MyStack
设计这个类的时候，在类的声明上，加上一个<T>，表示该类支持泛型。
T是type的缩写，也可以使用任何其他的合法的变量，比如A,B,X都可以，但是一般约定成俗使用T，代表类型。
```
package generic;
   
import java.util.HashMap;
import java.util.LinkedList;
 
import charactor.Hero;
import property.Item;
   
public class MyStack<T> {
   
    LinkedList<T> values = new LinkedList<T>();
       
    public void push(T t) {
        values.addLast(t);
    }
   
    public T pull() {
        return values.removeLast();
    }
   
    public T peek() {
        return values.getLast();
    }
       
    public static void main(String[] args) {
        //在声明这个Stack的时候，使用泛型<Hero>就表示该Stack只能放Hero
        MyStack<Hero> heroStack = new MyStack<>();
        heroStack.push(new Hero());
        //不能放Item
        heroStack.push(new Item());
         
        //在声明这个Stack的时候，使用泛型<Item>就表示该Stack只能放Item
        MyStack<Item> itemStack = new MyStack<>();
        itemStack.push(new Item());
        //不能放Hero
        itemStack.push(new Hero());
    }   
}
```
+ 支持泛型的二叉树
```
package collection;
 
import java.util.ArrayList;
import java.util.List;
 
public class Node<T> {
    // 左子节点
    public Node<T> leftNode;
    // 右子节点
    public Node<T> rightNode;
  
    // 值
    public T value;
  
    // 插入 数据
    public void add(T t) {
        // 如果当前节点没有值，就把数据放在当前节点上
        if (null == value)
            value = t;
  
        // 如果当前节点有值，就进行判断，新增的值与当前值的大小关系
        else {
            // 新增的值，比当前值小或者相同
             
            if ((Integer) t -((Integer)value) <= 0) {
                if (null == leftNode)
                    leftNode = new Node<T>();
                leftNode.add(t);
            }
            // 新增的值，比当前值大
            else {
                if (null == rightNode)
                    rightNode = new Node<T>();
                rightNode.add(t);
            }
  
        }
  
    }
  
 // 中序遍历所有的节点
    public List<T> values() {
        List<T> values = new ArrayList<>();
  
        // 左节点的遍历结果
        if (null != leftNode)
            values.addAll(leftNode.values());
  
        // 当前节点
        values.add(value);
  
        // 右节点的遍历结果
        if (null != rightNode)
  
            values.addAll(rightNode.values());
  
        return values;
    }
  
    public static void main(String[] args) {
  
        int randoms[] = new int[] { 67, 7, 30, 73, 10, 0, 78, 81, 10, 74 };
  
        Node<Integer> roots = new Node<>();
        for (int number : randoms) {
            roots.add(number);
        }
  
        System.out.println(roots.values());  
    }
}
```
#### 通配符
+ ? extends
ArrayList heroList<? extends Hero> 表示这是一个Hero泛型或者其子类泛型
heroList 的泛型可能是
HeroheroList 的泛型可能是APHero
heroList 的泛型可能是ADHero
所以 可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的
但是，不能往里面放东西，因为
放APHero就不满足<ADHero>
放ADHero又不满足<APHero>
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141328702-234570960.png)

```
package generic;
   
import java.util.ArrayList;  
import charactor.ADHero;
import charactor.APHero;
import charactor.Hero;
   
public class TestGeneric {
   
    public static void main(String[] args) {
          
        ArrayList<APHero> apHeroList = new ArrayList<APHero>();
        apHeroList.add(new APHero());
         
        ArrayList<? extends Hero> heroList = apHeroList;
          
        //? extends Hero 表示这是一个Hero泛型的子类泛型
          
        //heroList 的泛型可以是Hero
        //heroList 的泛型可以使APHero
        //heroList 的泛型可以使ADHero
          
        //可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的
          
        Hero h= heroList.get(0);
          
        //但是，不能往里面放东西
        //heroList.add(new ADHero()); //编译错误，因为heroList的泛型 有可能是APHero
    }      
}
```
+ ? super
ArrayList heroList<? super Hero> 表示这是一个Hero泛型或者其父类泛型
heroList的泛型可能是Hero
heroList的泛型可能是Object
可以往里面插入Hero以及Hero的子类
但是取出来有风险，因为不确定取出来是Hero还是Object
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141338229-561365545.png)

```
package generic;
  
import java.util.ArrayList;
  
import charactor.ADHero;
import charactor.APHero;
import charactor.Hero;
  
public class TestGeneric {
    public static void main(String[] args) {
  
        ArrayList<? super Hero> heroList = new ArrayList<Object>();
          
        //? super Hero 表示 heroList的泛型是Hero或者其父类泛型
          
        //heroList 的泛型可以是Hero
        //heroList 的泛型可以是Object
          
        //所以就可以插入Hero
        heroList.add(new Hero());
        //也可以插入Hero的子类
        heroList.add(new APHero());
        heroList.add(new ADHero());
          
        //但是，不能从里面取数据出来,因为其泛型可能是Object,而Object是强转Hero会失败
        //Hero h= heroList.get(0); //报错
    }  
}
```
+ 泛型通配符?
泛型通配符? 代表任意泛型
既然?代表任意泛型，那么换句话说，这个容器什么泛型都有可能
所以只能以 Object 的形式取出来
并且不能往里面放对象，因为不知道到底是一个什么泛型的容器
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709141349120-934546554.png)

```
package generic;
  
import java.util.ArrayList;
 
import property.Item;
import charactor.APHero;
import charactor.Hero;
  
public class TestGeneric {
  
    public static void main(String[] args) {
  
        ArrayList<APHero> apHeroList = new ArrayList<APHero>();
         
        //?泛型通配符，表示任意泛型
        ArrayList<?> generalList = apHeroList;
 
        //?的缺陷1： 既然?代表任意泛型，那么换句话说，你就不知道这个容器里面是什么类型
        //所以只能以Object的形式取出来
        Object o = generalList.get(0);
 
        //?的缺陷2： 既然?代表任意泛型，那么既有可能是Hero,也有可能是Item
        //所以，放哪种对象进去，都有风险，结果就什么什么类型的对象，都不能放进去
        //generalList.add(new Item()); //编译错误 因为?代表任意泛型，很有可能不是Item
        //generalList.add(new Hero()); //编译错误 因为?代表任意泛型，很有可能不是Hero
        //generalList.add(new APHero()); //编译错误  因为?代表任意泛型，很有可能不是APHero
    }
}
```
+ 总结
如果希望只取出，不插入，就使用? extends Hero
如果希望只插入，不取出，就使用? super Hero
如果希望，又能插入，又能取出，就不要用通配符？
#### 泛型转型
+ 对象转型
子类转父类
```
package generic;
 
import charactor.ADHero;
import charactor.Hero;
 
public class TestGeneric { 
    public static void main(String[] args) {
 
        Hero h = new Hero();
        ADHero ad = new ADHero();
        //子类转父类
        h = ad;
    } 
}
```
+ 子类泛型转父类泛型
既然 子类对象 转 父类对象是可以成功的，那么子类泛型转父类泛型能成功吗？
如代码
hs的泛型是父类Hero
adhs 的泛型是子类ADHero
```
package generic;
 
import java.util.ArrayList;
 
import charactor.ADHero;
import charactor.Hero;
 
public class TestGeneric {
 
    public static void main(String[] args) {
        ArrayList<Hero> hs =new ArrayList<>();
        ArrayList<ADHero> adhs =new ArrayList<>();
 
        //子类泛型转父类泛型
        hs = adhs;
    } 
}
```
+ 父类泛型不能转子类泛型
```
package generic;
  
import java.util.ArrayList;  
import charactor.ADHero;
import charactor.Hero;
  
public class TestGeneric {
  
    public static void main(String[] args) {
        ArrayList<Hero> hs =new ArrayList<>();
        ArrayList<ADHero> adhs =new ArrayList<>();
  
        //假设能成功
        adhs = hs;
         
        //这个时候adhs实际上指向的是泛型是Hero的容器,而这个容器里可能放的是一个APHero
        //而根据泛型，直接取出来就转型成了ADHero
        //所以就变成了APHero转型成ADHero，这是矛盾的。
        ADHero ad =adhs.get(0);        
    }  
}
```]]></description></item><item><title>Java网络编程</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/09/java_02.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 09 Jul 2020 04:59:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/09/java_02.html</guid><description><![CDATA[#### 概述
+ 信件
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709125628921-1690253212.png)

+ 计算机网络
计算机网络是指将**地理位置不同**的具有独立功能的**多台计算机及其外部设备，通过通信线路连接起来**，在网络操作系统，网络管理软件及**网络通信协议**的管理和协调下，**实现资源共享**和信息传递的计算机系统。
+ 网络编程的目的
无线电台，传播交流信息，数据交换、通信
1. 如何准确定位网络上的一台主机 IP地址:端口，定位到这个计算机上的某个资源
2. 找到了这个主机，如何传输数据
javaweb：网页编程 B/S
网络编程：ICP/IP C/S
#### 网络通信的要素
+ 如何实现网络的通信
**通信双方地址**
ip
端口号
192.168.16.124:5900
**规则：网络通信协议**
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709125652995-1610502844.png)

网络编程：重点时传输层，TCP、UDP
+ 小结
1. 网络编程中有两个主要的问题：如何准确的定位到网络上的一台或者多台主机；找到主机之后如何进行通信
2. 网络编程中的要素：IP和端口号；网络通信协议
3. 万物皆对象
### IP
+ ip地址：InetAddress
+ 唯一定位一台网络上计算机
+ 127.0.0.1：本地 localhost
+ ip的分类
1. ipv4/ipv6：**ipv4**：127.0.0.1，4个字节组成，0-255，42亿个，2011年用尽了；
                  **ipv6**：fe80::183c:9bcb:1848:a115%14，128位，8个无符号整数，16^32个
2. 公网（互联网）/私网（局域网）
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709125729282-708775319.png)

公网：ABCD类
私网：192.168.xx.xx
+ 域名
记忆IP
```
import java.net.InetAddress;
import java.net.UnknownHostException;

public class TestInetAddress {
    public static void main(String[] args) {
        try {
            //查询本地地址
            InetAddress inetAddress1 = InetAddress.getByName("127.0.0.1");
            System.out.println(inetAddress1);
            InetAddress inetAddress3 = InetAddress.getByName("localhost");
            System.out.println(inetAddress3);
            InetAddress inetAddress4 = InetAddress.getLocalHost();
            System.out.println(inetAddress4);

            //查询网站ip地址
            InetAddress inetAddress2 = InetAddress.getByName("www.baidu.com");
            System.out.println(inetAddress2);

            //常用方法
            //System.out.println(inetAddress2.getAddress()); //没卵用
            System.out.println(inetAddress2.getCanonicalHostName()); //规范的名字
            System.out.println(inetAddress2.getHostAddress()); //ip
            System.out.println(inetAddress2.getHostName()); //域名，或自己电脑的名字

        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
```
输出
```
/127.0.0.1
localhost/127.0.0.1
DESKTOP-OKLJ610/192.168.1.104
www.baidu.com/220.181.38.149
220.181.38.149
220.181.38.149
www.baidu.com
```
### 端口
+ 表示计算机上的一个程序的进程
1. 不同的进程有不同的端口号！用来区分软件
2. 被规定0-65535
3. TCP,UDP：各有65535，两个协议，端口号不冲突
4. 分类：
公有端口 0-1023
HTTP 80
HTTPS 443
FTP 21
Telent 23
程序注册端口 1024-49151，分配用户或者程序
Tomcat 8080
MySQL 3306
Oracle 1521
动态、私有 49152-65535
```
#cmd命令 
netstat -ano #查看所有端口
netstat -ano|findstr "5900" #查看指定端口
tasklist|findstr "2244" #查看指定端口的进程
```
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709125749899-1592791318.png)

```
import java.net.InetSocketAddress;

public class TestInetSocketAddress {
    public static void main(String[] args) {
        InetSocketAddress socketAddress = new InetSocketAddress("127.0.0.1",8080);
        InetSocketAddress socketAddress2 = new InetSocketAddress("localhost",8080);
        System.out.println(socketAddress);
        System.out.println(socketAddress2);

        System.out.println(socketAddress.getAddress());
        System.out.println(socketAddress.getHostName()); //地址
        System.out.println(socketAddress.getPort()); //端口
    }
}
```
输出
```
/127.0.0.1:8080
localhost/127.0.0.1:8080
/127.0.0.1
127.0.0.1
8080
```
+ 端口对应
两台电脑应用的通信要找到对应的端口
### 通信协议
+ 协议：约定，普通话
+ 网络通信协议
速率，传输码率，代码结构，传输控制...
问题：非常的复杂
大事化小：分层！
**TCP/IP协议簇：实际上是一组协议**
TCP：用户传输协议，打电话
UDP：用户数据报协议，发短信
出名的协议
TCP
IP：网络互连协议
+ TCP UDP 对比
TCP：打电话；连接，稳定；三次握手，四次挥手；客户端、服务端；传输完成释放连接，效率低
UDP：不连接，不稳定；客户端和服务端没有明确的界限；导弹；DDOS洪水攻击，饱和攻击
+ 三次握手
A：想连接
B：可以，你还在吗
A：在，连吧
+ 四次挥手
A：我要断开了
B：你要走了吗
B：真的要走了吗
A：真的走了
### TCP
+ 客户端
1. 连接服务器 Socket
2. 发送消息
```
import java.io.IOException;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;

//客户端
public class TcpClientDemo01 {
    public static void main(String[] args) {

        Socket socket = null;
        OutputStream os = null;

        try {
            //1.要知道服务器的 地址 和 端口号
            InetAddress serverIP = InetAddress.getByName("127.0.0.1");
            int port = 9999;
            //2.创建一个socket连接
            socket = new Socket(serverIP,port);
            //3.发送消息 IO流
            os = socket.getOutputStream();
            os.write("hello".getBytes());

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (os != null){
                try {
                    os.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (socket != null){
                try {
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```
+ 服务器
1. 建立服务的端口 ServerSocket
2. 等待用户的链接 accept
3. 接收用的消息
```
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class TcpServerDemo01 {
    public static void main(String[] args) {
        ServerSocket serverSocket = null;
        Socket socket = null;
        InputStream is = null;
        ByteArrayOutputStream baos = null;
        try {
            //1.我得有一个地址
            serverSocket = new ServerSocket(9999);

            while (true){
                //2.等待客户端连接过来
                socket = serverSocket.accept();
                //3.读取客户端的消息
                is = socket.getInputStream();

                //管道流
                baos = new ByteArrayOutputStream();
                byte[] buffer = new byte[1024];
                int len;
                while ((len=is.read(buffer))!=-1){
                    baos.write(buffer,0,len);
                }
                System.out.println(baos.toString());
            }

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭资源
            if (baos != null) {
                try {
                    baos.close();
                }
                catch(IOException e){
                    e.printStackTrace();
                }
            }
            if (is != null){
                try {
                    is.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (socket != null){
                try {
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (serverSocket != null){
                try {
                    serverSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```
### 文件上传
#### 传输一个图片
+ 客户端
```
import java.io.*;
import java.net.InetAddress;
import java.net.Socket;

public class TcpClientDemo02 {
    public static void main(String[] args) throws Exception{
        //1.创建一个socket连接
        Socket socket = new Socket(InetAddress.getByName("127.0.0.1"),9000);
        //2.创建一个输出流
        OutputStream os = socket.getOutputStream();
        //3.文件流
        FileInputStream fis = new FileInputStream(new File("jia.jpg"));
        //4.写出文件
        byte[] buffer = new byte[1024];
        int len;
        while ((len=fis.read(buffer))!=-1){
            os.write(buffer,0,len);
        }

        //通知服务器，我已经结束了
        socket.shutdownOutput(); //我已经传输完了

        //确定服务器接收完毕，才能断开连接
        InputStream inputStream = socket.getInputStream();
        //String byte[] 管道流
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        byte[] buffer2 = new byte[1024];
        int len2;
        while ((len2=inputStream.read(buffer2))!=-1){
            baos.write(buffer2,0,len2);
        }
        System.out.println(baos.toString());

        //5.关闭资源  先写的后关
        baos.close();
        inputStream.close();
        fis.close();
        os.close();
        socket.close();
    }
}
```
+ 服务器
```
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class TcpServerDemo02 {
    public static void main(String[] args) throws Exception{
        //1.创建服务
        ServerSocket serverSocket = new ServerSocket(9000);
        //2.监听客户端的连接
        Socket socket = serverSocket.accept(); //阻塞式监听，会一直等待客户端连接
        //3.获取输入流
        InputStream is = socket.getInputStream();
        //4.文件输出
        FileOutputStream fos = new FileOutputStream(new File("receive.jpg"));
        byte[] buffer = new byte[1024];
        int len;
        while((len=is.read(buffer))!=-1){
            fos.write(buffer,0,len);
        }

        //通知客户端我接收完毕了
        OutputStream os = socket.getOutputStream();
        os.write("我接受完毕了，你可以断开了".getBytes());

        //关闭资源
        fos.close();
        is.close();
        socket.close();
        serverSocket.close();
    }
}
```
### Tomcat
+ 服务端
自定义 S
Tomcat服务器 S java开发
+ 客户端
自定义 C
浏览器 B
### UDP
发短信：不用连接，
+ 发消息
```
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

//不需要连接服务器
public class UdpClientDemo01 {
    public static void main(String[] args) throws Exception {
        //1.建立一个socket
        DatagramSocket socket = new DatagramSocket();

        //2.建立包
        String msg = "你好a";

        //发送给谁
        InetAddress localhost = InetAddress.getByName("localhost");
        int port = 9090;
        //数据，数据的长度起始，要发送给谁
        DatagramPacket packet = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localhost,port);

        //3.发送包
        socket.send(packet);

        //4.关闭流
        socket.close();
    }
}
```
+ 接收端
```
import java.net.DatagramPacket;
import java.net.DatagramSocket;

//还是等待客户端的连接
public class UdpServerDemo01 {
    public static void main(String[] args) throws Exception{
        //开放端口
        DatagramSocket socket = new DatagramSocket(9090);
        //接收数据包
        byte[] buffer = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length);

        socket.receive(packet); //阻塞接收

        System.out.println(packet.getAddress().getHostAddress());
        System.out.println(new String(packet.getData(),0,packet.getLength()));

        //关闭连接
        socket.close();
    }
}
```
### 实现聊天
+ 发送方
```
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;

public class UdpSenderDemo01 {
    public static void main(String[] args) throws Exception{
        DatagramSocket socket = new DatagramSocket(8080);

        //准备数据
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        while (true){ //循环发送
            String data = reader.readLine();
            byte[] datas = data.getBytes();
            DatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress("localhost",666));

            socket.send(packet);
            if (data.equals("bye")){
                break;
            }
        }

        socket.close();
    }
}
```
+ 接收方
```
import java.net.DatagramPacket;
import java.net.DatagramSocket;

public class UdpReceiverDemo01 {
    public static void main(String[] args) throws Exception{
        DatagramSocket socket = new DatagramSocket(666);

        while (true){
            //准备接收包裹
            byte[] container = new byte[1024];
            DatagramPacket packet = new DatagramPacket(container,0,container.length);
            socket.receive(packet); //阻塞式接收

            //显示消息
            byte[] data = packet.getData();
            String receiveData = new String(data,0,data.length);
            System.out.println(receiveData);

            //断开连接
            if (receiveData.equals("bye")){
                break;
            }
        }

        socket.close();
    }
}
```
输出有点问题，1024位都出来了
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709125835250-607446792.png)

解决
`String receiveData = new String(data,0,data.length);`
String去掉空格，改成
`String receiveData = new String(data,0,data.length).trim();`
### 多线程在线咨询
+ 两个人都同时是发送方和接收方
写两个类 Send(fromPort,toIP,toPort) Reveice(port)
每个用户都有两个线程，分别用来发送和接收
### URL
+ 统一资源定位符
定位互联网上的某一个资源
DNS域名解析 www.baidu.com xx.xx.x.x
协议://ip地址:端口号/项目名
```
import java.net.URL;

public class URLDemo01 {
    public static void main(String[] args) throws Exception{
        URL url = new URL("http://localhost:8080/hello/index.jsp?username=peng");
        System.out.println(url.getProtocol()); //协议
        System.out.println(url.getHost()); //主机ip
        System.out.println(url.getPort()); //端口
        System.out.println(url.getPath()); //文件
        System.out.println(url.getFile()); //全路径
        System.out.println(url.getQuery()); //参数
    }
}
```
+ 下载文件
```
import java.io.FileOutputStream;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;

/**
 * Created by peng on 2020/5/7.
 */
public class URLDown {
    public static void main(String[] args) throws Exception {
        //1.下载地址
        URL url = new URL("https://www.baidu.com/project/name.txt"); //随便输入的

        //2.连接到这个资源 HTTP
        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();

        InputStream inputStream = urlConnection.getInputStream();

        FileOutputStream fos = new FileOutputStream("name.txt");

        byte[] buffer = new byte[1024];
        int len;
        while ((len=inputStream.read())!=-1){
            fos.write(buffer,0,len);
        }

        fos.close();
        inputStream.close();
        urlConnection.disconnect();
    }
}
```]]></description></item><item><title>Java多线程以及三种实现方式</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/09/java_01.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 09 Jul 2020 02:33:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/09/java_01.html</guid><description><![CDATA[### 线程简介
+ 程序Process（静态）、进程（动态）、线程Thread
程序：在操作系统中运行的程序就是进程，比如你的QQ，播放器，游戏，IDE等等
进程：执行程序的一次过程，是系统资源分配的单位，main()
线程：一个进程有若干线程，一个进程至少有一个线程，是CPU调度和执行的单位
+ 一些概念
1. 线程就是独立的执行路径;
2. 在程序运行时，即使没有自己创建线程,后台也会有多个线程，如主线程，gc线程;
3. main()称之为主线程，为系统的入口，用于执行整个程序;
3. 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度,调度器是与操作系统紧密相关的，先后顺序是不能认为的干预的。
4. 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制;
5. 线程会带来额外的开销，如cpu调度时间，并发控制开销。
6. 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致
+ 多线程
一个游戏，一堆玩家同时在线
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709102716713-1851779499.png)

### 线程实现※ 
#### 1.Thread class：继承Thread类
```
//创建线程方式一：继承Thread类，重写run()方法，调用start开启线程

//总结：注意，线程开启不一定立即执行，由CPU调度执行

public class TestThread1 extends Thread {
    @Override
    public void run() {
        //run方法线程体
        for (int i = 0; i < 200; i++) {
            System.out.println("我在看代码---" + i);
        }
    }

    public static void main(String[] args) {
        //main线程 主线程

        //创建一个线程对象
        TestThread1 testThread1 = new TestThread1();

        //调用start()方法
        testThread1.start();

        for (int i = 0; i < 200; i++) {
            System.out.println("我在学习多线程---"+i);
        }
    }
}
```
部分输出
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709102751323-201820380.png)

```
//多线程下载
public class TestThread2 extends Thread{
    private String url;

    public TestThread2(String url) {
        this.url = url;
    }

    //下载图片线程的执行体
    @Override
    public void run() {
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.download(url);
    }

    public static void main(String[] args) {
        TestThread2 t1 = new TestThread2("URL1");
        TestThread2 t2 = new TestThread2("URL2");
        TestThread2 t3 = new TestThread2("URL3");

        //同时执行，不是按顺序的
        t1.start();
        t2.start();
        t3.start();
    }
}

//下载器
class WebDownloader{
    //下载方法
    public void download(String url){}
}
```
#### 2.Runnable接口，实现Runnable接口（推荐使用的方法）
```
//创建线程方式二：实现runnable接口，重写run()方法,
//执行线程需要丢人runnable接口实现类，调用start方法
public class TestThread3 implements Runnable{
    @Override
    public void run() {
        //run方法线程体
        for (int i = 0; i < 200; i++) {
            System.out.println("我在看代码---" + i);
        }
    }

    public static void main(String[] args) {
        //创建runnable接口的实现类对象
        TestThread3 testThread3 = new TestThread3();
        //创建线程对象,通过线程对象来开启我们的线程，代理
        //Thread thread = new Thread();
        //thread.start();
        new Thread(testThread3).start();

        for (int i = 0; i < 200; i++) {
            System.out.println("我在学习多线程---"+i);
        }
    }
}
```
+ 并发问题
```
//多个线程操作同一个对象
//买火车票

//发现问题：多个线程操作同一个资源，线程不安全，数据紊乱
public class TestThread4 implements Runnable {

    //票数
    private int ticketNums = 10;

    @Override
    public void run() {
        while (true){
            if (ticketNums<=0){
                break;
            }

            try { //模拟延时
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName()+"-->拿到了第"+ticketNums--+"张票");
        }
    }

    public static void main(String[] args) {
        TestThread4 ticket = new TestThread4();

        new Thread(ticket,"小明").start();
        new Thread(ticket,"老师").start();
        new Thread(ticket,"黄牛").start();
    }
}
```
+ 龟兔赛跑
```
//模拟龟兔赛跑
public class Race implements Runnable{

    //胜利者
    private static String winner;

    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {

            //模拟兔子休息
            if (Thread.currentThread().getName().equals("兔子") && i%50==0){
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            //判断比赛是否结束
            boolean flag = gameOver(i);
            //如果比赛结束了，就停止程序
            if (flag){
                break;
            }

            System.out.println(Thread.currentThread().getName()+"跑了"+i+"步");
        }
    }

    //判断是否完成比赛
    private boolean gameOver(int steps){
        //判断是否有胜利者
        if (winner!=null){
            return true;
        }{
            if (steps>=100){
                winner = Thread.currentThread().getName();
                System.out.println(winner+"赢了！");
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        Race race = new Race();

        new Thread(race,"兔子").start();
        new Thread(race,"乌龟").start();
    }
}
```
#### 3.Callable接口：实现Callable接口
```
import java.util.concurrent.*;

//线程创建方式三：实现Callable接口
public class TestCallable implements Callable<Boolean> { //必须有返回值

    private String url;

    public TestCallable(String url) {
        this.url = url;
    }

    //下载图片线程的执行体
    @Override
    public Boolean call() {
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.download(url);
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        TestCallable t1 = new TestCallable("URL1");
        TestCallable t2 = new TestCallable("URL2");
        TestCallable t3 = new TestCallable("URL3");

        //创建执行服务,线程池
        ExecutorService ser = Executors.newFixedThreadPool(3);

        //提交执行
        Future<Boolean> r1 = ser.submit(t1);
        Future<Boolean> r2 = ser.submit(t2);
        Future<Boolean> r3 = ser.submit(t3);

        //获取结果
        boolean rs1 = r1.get();
        boolean rs2 = r2.get();
        boolean rs3 = r3.get();

        //关闭服务
        ser.shutdown();

    }
}

//下载器
class WebDownloader{
    //下载方法
    public void download(String url){}
}
```
#### 静态代理
```
//静态代理模式
//真实对象和代理对象都要实现同一个接口
//代理对象要代理真实对象
//好处：代理对象可以做很多真实对象做不了的事情，真实对象专注于自己的事情
public class StaticProxy {
    public static void main(String[] args) {

        //静态代理 与 线程  相似原理
        //new Thread(()-> System.out.println("我爱你")).start();
        //new WeddingCompany(new You()).HappyMarry();

        //真正结婚的人
        You you = new You();

        //把事情交给代理做
        WeddingCompany weddingCompany = new WeddingCompany(you);
        weddingCompany.HappyMarry();
    }
}

interface Marry{
    void HappyMarry();
}

//真实角色
class You implements Marry{
    @Override
    public void HappyMarry() {
        System.out.println("结婚了");
    }
}

//代理
class WeddingCompany implements Marry{

    //代理真实目标角色
    private Marry target;

    public WeddingCompany(Marry target) {
        this.target = target;
    }

    @Override
    public void HappyMarry() {
        before();
        this.target.HappyMarry(); //真实对象
        after();
    }

    private void after() {
        System.out.println("收尾款");
    }

    private void before() {
        System.out.println("布置现场");
    }
}
```
#### Lambda表达式
+ 简化了程序，简洁，只留下逻辑
+ 函数式接口（前提）
任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口，如
```
public interface Runnable{
    public abstract void run();
}
```
对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。
```
//推导lambda表达式
public class TestLambda1 {

    //3.静态内部类
    static class Like2 implements ILike{
        @Override
        public void lambda() {
            System.out.println("i like lambda2");
        }
    }

    public static void main(String[] args) {
        ILike like = new Like();
        like.lambda();

        like = new Like2();
        like.lambda();

        //4.局部内部类
        class Like3 implements ILike{
            @Override
            public void lambda() {
                System.out.println("i like lambda3");
            }
        }

        like = new Like3();
        like.lambda();

        //5.匿名内部类,没有类的名称，必须借助接口或父类
        like = new ILike() {
            @Override
            public void lambda() {
                System.out.println("i like lambda4");
            }
        };
        like.lambda();

        //6.用lambda简化
        like = ()->{System.out.println("i like lambda5");};
        like.lambda();
        
        //7.只有一行可以不加大括号
        like = ()-> System.out.println("i like lambda5");
        like.lambda();
    }
}

//1.定义一个函数式接口
interface ILike{
    void lambda();
}

//2.实现类
class Like implements ILike{
    @Override
    public void lambda() {
        System.out.println("i like lambda");
    }
}
```
### 线程状态
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709103000855-1287679890.png)

+ 线程方法
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709103016247-1715804124.png)

+ 线程停止
```
//测试停止线程
//1.建议线程正常停止--->利用次数,不建议死循环。
//2.建议使用标志位--->设置一个标志位
//3.不要使用stop或都destroy等过时或者JDK不建议使用的方法
public class TestStop implements Runnable{

    //1.设置一个标识位
    private boolean flag = true;

    @Override
    public void run() {
        int i = 0;
        while (flag){
            System.out.println("run...Thread"+i++);
        }
    }

    //2.设置一个公开的方法停止线程，转换标识位
    public void stop(){
        this.flag = false;
    }

    public static void main(String[] args) {
        TestStop testStop = new TestStop();
        new Thread(testStop).start();

        for (int i = 0; i < 1000; i++) {
            System.out.println("main "+i);
            if (i==900){
                //调用我们的stop切换标识位，让线程停止
                testStop.stop();
                System.out.println("线程该停止了");
            }
        }
    }
}
```
+ 线程休眠
sleep 1000ms=1s
每一个对象都有一个锁，sleep不会释放锁
```
import java.text.SimpleDateFormat;
import java.util.Date;

//模拟倒计时
public class TestSleep2 {

    public static void main(String[] args) {
        //打印当前系统时间
        Date startTime = new Date(System.currentTimeMillis()); //获取系统当前时间
        while (true){
            try {
                Thread.sleep(1000);
                System.out.println(new SimpleDateFormat("HH:mm:ss").format(startTime));
                startTime = new Date(System.currentTimeMillis());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    //模拟倒计时
    public static void tenDown() throws InterruptedException {
        int num = 10;
        while (true){
            Thread.sleep(1000);
            System.out.println(num--);
            if (num<=0){
                break;
            }
        }
    }
}
```
+ 线程礼让（出来重新竞争）
礼让线程，让当前正在执行的线程暂停，但不阻塞
将线程从运行状态转为就绪状态
让cpu重新调度，礼让不一定成功，看CPU心情
```
//测试礼让
public class TestYield {
    public static void main(String[] args) {
        MyYield myYield = new MyYield();

        new Thread(myYield,"a").start();
        new Thread(myYield,"b").start();
    }
}

class MyYield implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"线程开始执行");
        Thread.yield();
        System.out.println(Thread.currentThread().getName()+"线程停止执行");
    }
}
```
+ Join插队
Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞
```
//Join插队，把别人阻塞了，少用
public class TestJoin implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("线程vip来了 "+i);
        }
    }

    public static void main(String[] args) throws InterruptedException {

        //启动我们的线程
        TestJoin testJoin = new TestJoin();
        Thread thread = new Thread(testJoin);
        thread.start();

        //主线程
        for (int i = 0; i < 1000; i++) {
            if (i==200){
                thread.join(); //插队
            }
            System.out.println("main "+i);
        }
    }
}
```
+ 线程状态观测
Thread.State 线程状态。线程可以处于以下状态之一:
●NEW 尚未启动的线程处于此状态
●RUNNABLE 在Java虛拟机中执行的线程处于此状态
●BLOCKED 被阻塞等待监视器锁定的线程处于此状态
●WAITING 正在等待另一个线程执行特定动作的线程处于此状态
●TIMED WAITING 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态
●TERMINATED 已退出的线程处于此状态。
死亡之后的线程不能再start了
```
//观察测试线程的状态
public class TestState {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(()->{
            for (int i = 0; i < 5; i++) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("+++++++");
        });

        //观察状态
        Thread.State state = thread.getState();
        System.out.println(state); //NEW

        //观察启动后
        thread.start(); //启动线程
        state = thread.getState();
        System.out.println(state); //RUNNABLE

        while (state!=Thread.State.TERMINATED){
            Thread.sleep(200);
            state = thread.getState(); //更新线程状态
            System.out.println(state); //输出状态
        }
    }
}
```
+ 线程优先级（调度概率）
```
//测试线程优先级 1-10，默认5
public class TestPriority {
    public static void main(String[] args) {
        //主线程默认优先级
        System.out.println(Thread.currentThread().getName()+"-->"+Thread.currentThread().getPriority());

        MyPriority myPriority = new MyPriority();

        Thread t1 = new Thread(myPriority);
        Thread t2 = new Thread(myPriority);
        Thread t3 = new Thread(myPriority);
        Thread t4 = new Thread(myPriority);
        Thread t5 = new Thread(myPriority);
        Thread t6 = new Thread(myPriority);

        //先设置优先级，再启动
        t1.start();
        t2.setPriority(1);
        t2.start();
        t3.setPriority(4);
        t3.start();
        t4.setPriority(10);
        t4.start();
        t5.setPriority(8);
        t5.start();
        t6.setPriority(7);
        t6.start();
    }
}

class MyPriority implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"-->"+Thread.currentThread().getPriority());
    }
}
```
输出 优先级高的不一定先跑
```
main-->5
Thread-0-->5
Thread-3-->10
Thread-2-->4
Thread-4-->8
Thread-5-->7
Thread-1-->1
```
+ 守护(daemon)线程
线程分为**用户线程**和**守护线程**
虚拟机必须确保用户线程执行完毕
虚拟机不用等待守护线程执行完毕
如，后台记录操作日志，监控内存，垃圾回收等待
```
public class TestDaemon {
    public static void main(String[] args) {
        God god = new God();
        You you = new You();

        Thread thread = new Thread(god);
        thread.setDaemon(true); //默认false,表示用户线程,正常的线程都是用户线程

        thread.start(); //上帝 守护线程启动

        new Thread(you).start(); //你 用户线程启动
        //用户线程结束，守护线程也跟着结束了
    }
}

//上帝
class God implements Runnable{
    @Override
    public void run() {
        while (true){
            System.out.println("上帝保佑着你");
        }
    }
}

//你
class You implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 30000; i++) {
            System.out.println("你开心的活着");
        }
        System.out.println("==goodbye==world==");
    }
}
```
### 线程同步※
+ 并发
多个线程操作同一个资源
解决：排队，队列
+ 队列和锁
进去后上锁，解决完了再释放
由于同一进程的多个线程共享同一块存储空间,在带来方便的同时也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入**锁机制**synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可.存在以下问题:
◆ 一个线程持有锁会导致其他所有需要此锁的线程挂起
◆ 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题
◆ 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题
#### 三个不安全的线程案例
+ 不安全的买票
```
//线程不安全，有重合的，还有负数
public class UnsafeBuyTicket {
    public static void main(String[] args) {
        BuyTicket station = new BuyTicket();

        new Thread(station,"小明").start();
        new Thread(station,"老师").start();
        new Thread(station,"黄牛").start();
    }
}

class BuyTicket implements Runnable{

    //票
    private int tickerNums =10;
    boolean flag = true; //外部停止方式

    @Override
    public void run() {
        //买票
        while (flag){
            try {
                buy();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private void buy() throws InterruptedException {
        //判断是否有票
        if (tickerNums<=0){
            flag = false;
            return;
        }

        //模拟延时
        Thread.sleep(100);

        //买票
        System.out.println(Thread.currentThread().getName()+"拿到票"+tickerNums--);
    }
}
```
+ 不安全的取钱
```
//两个人用同一账户去银行取钱
public class UnsafeBank {
    public static void main(String[] args) {
        //账户
        Account account = new Account("peng",100);

        Drawing byPhone = new Drawing(account,50,"peng-1");
        Drawing byBank = new Drawing(account,100,"peng-2");

        byPhone.start();
        byBank.start();
    }
}

//账户
class Account{
    String name;
    int money;

    public Account() {
    }

    public Account(String name, int money) {
        this.name = name;
        this.money = money;
    }
}

//银行：模拟取款
class Drawing extends Thread{

    Account account; //账户
    int drawingMoney; //取多少钱
    int nowMoney; //还有多少钱

    public Drawing(Account account, int drawingMoney, String name) {
        super(name);
        this.account = account;
        this.drawingMoney = drawingMoney;
    }

    //取钱
    @Override
    public void run() {
        //判断有没有钱
        if (account.money-drawingMoney<0){
            System.out.println(Thread.currentThread().getName()+"钱不够，取不了");
            return;
        }

        try {
            Thread.sleep(1000); //模拟延时
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        //卡内余额
        account.money = account.money - drawingMoney;
        //手里的钱
        nowMoney = nowMoney + drawingMoney;

        System.out.println(account.name+"余额为"+account.money);
        //this.getName() = Thread.currentThread().getName() 因为继承了Thread
        System.out.println(this.getName()+"手里的钱"+nowMoney);
    }
}
```
+ 不安全的集合
```
import java.util.ArrayList;
import java.util.List;

public class UnsafeList {
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        for (int i = 0; i < 1000; i++) {
            new Thread(()->{
                list.add(Thread.currentThread().getName());
            }).start();
        }
        System.out.println(list.size());
        //发现不够1000，一瞬间操作多个，覆盖掉了一些线程
    }
}
```
#### 同步方法
+ 由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized方法和synchronized块.
同步方法: `public synchronized void method(int args) {}`
同步块：`synchronized (Obj ){ }`
+ synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行,否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行
缺陷：若将一个大的方法申明为synchronized将会影响效率
+ 同步块
`synchronized (Obj ){ }`
Obj称之为同步监视器
◆ Obj可以是任何对象，但是推荐使用共享资源作为同步监视器
◆ 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class [反射中讲解]
同步监视器的执行过程
1. 第一个线程访问，锁定同步监视器，执行其中代码
2. 第二个线程访问，发现同步监视器被锁定，无法访问
3. 第一个线程访问完毕，解锁同步监视器.
4. 第二个线程访问，发现同步监视器没有锁，然后锁定并访问
+ 同步后的买票等
```
public class UnsafeBuyTicket {
    public static void main(String[] args) {
        BuyTicket station = new BuyTicket();

        new Thread(station,"小明").start();
        new Thread(station,"老师").start();
        new Thread(station,"黄牛").start();
    }
}

class BuyTicket implements Runnable{

    //票
    private int tickerNums =10;
    boolean flag = true; //外部停止方式

    @Override
    public void run() {
        //买票
        while (flag){
            try {
                buy();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    //synchronized同步方法，锁的是this
    private  synchronized void buy() throws InterruptedException {
        //判断是否有票
        if (tickerNums<=0){
            flag = false;
            return;
        }

        //模拟延时
        Thread.sleep(100);

        //买票
        System.out.println(Thread.currentThread().getName()+"拿到票"+tickerNums--);
    }
}
```
```
public class UnsafeBank {
    public static void main(String[] args) {
        //账户
        Account account = new Account("peng",100);

        Drawing byPhone = new Drawing(account,50,"peng-1");
        Drawing byBank = new Drawing(account,100,"peng-2");

        byPhone.start();
        byBank.start();
    }
}

//账户
class Account{
    String name;
    int money;

    public Account() {
    }

    public Account(String name, int money) {
        this.name = name;
        this.money = money;
    }
}

//银行：模拟取款
class Drawing extends Thread{

    Account account; //账户
    int drawingMoney; //取多少钱
    int nowMoney; //还有多少钱

    public Drawing(Account account, int drawingMoney, String name) {
        super(name);
        this.account = account;
        this.drawingMoney = drawingMoney;
    }

    //取钱
    //synchronized默认锁的是this
    @Override
    public void run() {
        //account是需要锁的变化的量，即需要增删改的对象
        synchronized (account){
            //判断有没有钱
            if (account.money-drawingMoney<0){
                System.out.println(Thread.currentThread().getName()+"钱不够，取不了");
                return;
            }

            try {
                Thread.sleep(1000); //模拟延时
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            //卡内余额
            account.money = account.money - drawingMoney;
            //手里的钱
            nowMoney = nowMoney + drawingMoney;

            System.out.println(account.name+"余额为"+account.money);
            //this.getName() = Thread.currentThread().getName() 因为继承了Thread
            System.out.println(this.getName()+"手里的钱"+nowMoney);
        }
    }
}
```
```
import java.util.ArrayList;
import java.util.List;

//不安全的集合
public class UnsafeList {
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        for (int i = 0; i < 1000; i++) {
            new Thread(()->{
                synchronized (list){
                    list.add(Thread.currentThread().getName());
                }
            }).start();
        }

        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(list.size());
        //发现不够1000，一瞬间操作多个，覆盖掉了一些线程
    }
}
```
#### CopyOnWriteArray
```
import java.util.concurrent.CopyOnWriteArrayList;

//测试JUC安全类型的集合
public class TestJUC {
    public static void main(String[] args) {
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<String>();
        for (int i = 0; i < 1000; i++) {
            new Thread(()->{
                list.add(Thread.currentThread().getName());
            }).start();
        }

        try {
            Thread.sleep(20);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(list.size());
    }
}
```
#### 死锁
多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有**两个以上对象的锁**时，就可能会发生“**死锁**”的问题
+ 死锁现象
```
//死锁：多个线程互相抱着对方需要的资源，然后形成僵持
public class DeadLock {
    public static void main(String[] args) {
        Makeup g1 = new Makeup(0,"g1");
        Makeup g2 = new Makeup(1,"g2");

        g1.start();
        g2.start();
    }
}

//口红
class Lipstick{}

//镜子
class Mirror{}

class Makeup extends Thread{

    //需要的资源只有一份，用statuc来保证只有一份
    static Lipstick lipstick = new Lipstick();
    static Mirror mirror = new Mirror();

    int choice; //选择
    String girlName; //使用化妆品的人

    public Makeup(int choice, String girlName) {
        this.choice = choice;
        this.girlName = girlName;
    }

    @Override
    public void run() {
        //化妆
        try {
            makeup();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    //化妆，互相持有对方的资源，就是需要拿到对方的资源
    private void makeup() throws InterruptedException {
        if (choice==0){
            synchronized (lipstick){ //获得口红的锁
                System.out.println(this.girlName+"获得口红的锁");
                Thread.sleep(1000);
                synchronized (mirror){ //一秒钟后想获得镜子
                    System.out.println(this.girlName+"获得镜子的锁");
                }
            }
        }else {
            synchronized (mirror){ //获得镜子的锁
                System.out.println(this.girlName+"获得镜子的锁");
                Thread.sleep(2000);
                synchronized (lipstick){ //一秒钟后想获得口红
                    System.out.println(this.girlName+"获得口红的锁");
                }
            }
        }
    }
}
```
两个线程互相卡住了
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709103133515-970288244.png)

解决死锁：自己用完的资源赶紧释放，别拿着这个想着那个
```
public class DeadLock {
    public static void main(String[] args) {
        Makeup g1 = new Makeup(0,"g1");
        Makeup g2 = new Makeup(1,"g2");

        g1.start();
        g2.start();
    }
}

//口红
class Lipstick{}

//镜子
class Mirror{}

class Makeup extends Thread{

    //需要的资源只有一份，用statuc来保证只有一份
    static Lipstick lipstick = new Lipstick();
    static Mirror mirror = new Mirror();

    int choice; //选择
    String girlName; //使用化妆品的人

    public Makeup(int choice, String girlName) {
        this.choice = choice;
        this.girlName = girlName;
    }

    @Override
    public void run() {
        //化妆
        try {
            makeup();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    //化妆，互相持有对方的资源，就是需要拿到对方的资源
    private void makeup() throws InterruptedException {
        if (choice==0){
            synchronized (lipstick){ //获得口红的锁
                System.out.println(this.girlName+"获得口红的锁");
                Thread.sleep(1000);
            }
            synchronized (mirror){ //一秒钟后想获得镜子
                System.out.println(this.girlName+"获得镜子的锁");
            }
        }else {
            synchronized (mirror){ //获得镜子的锁
                System.out.println(this.girlName+"获得镜子的锁");
                Thread.sleep(2000);
            }
            synchronized (lipstick){ //一秒钟后想获得口红
                System.out.println(this.girlName+"获得口红的锁");
            }
        }
    }
}
```
+ 产生死锁的四个必要条件（缺一个都锁不上）
1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
#### Lock 锁
+ 显示定义**同步锁对象**来实现同步
+ java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象
+ ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。
+ 用法
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709103213869-1401789520.png)

```
import java.util.concurrent.locks.ReentrantLock;

public class TestLock {
    public static void main(String[] args) {
        TestLock2 testLock2 = new TestLock2();

        new Thread(testLock2).start();
        new Thread(testLock2).start();
        new Thread(testLock2).start();
    }
}

class TestLock2 implements Runnable{
    int ticketNums = 10;

    //定义lock锁
    private final ReentrantLock lock = new ReentrantLock();

    @Override
    public void run() {
        while (true){

            try {
                lock.lock(); //加锁
                if (ticketNums>0){
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(ticketNums--);
                }else {
                    break;
                }
            } finally {
                lock.unlock();
            }
        }
    }
}
```
+ synchronized与Lock的对比
◆ Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放
◆ Lock只有代码块锁，synchronized有代码块锁和方法锁
◆ 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类)
◆ 优先使用顺序：Lock > 同步代码块(已经进入了方法体，分配了相应资源) > 同步方法(在方法体之外)
### 线程通信协作
+ 应用场景：生产者和消费者问题
◆ 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费
◆ 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止
◆ 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止
+ 相关Java方法
![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200709103234013-375621615.png)

#### 管程法
```
//测试生产者和消费者模型-->利用缓冲区：管程法
public class TestPC {
    public static void main(String[] args) {
        SynContainer container = new SynContainer();

        new Productor(container).start();
        new Customer(container).start();
    }
}

//生产者
class Productor extends Thread{
    SynContainer container;

    public Productor(SynContainer container){
        this.container = container;
    }

    //生产
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            container.push(new Chicken(i));
            System.out.println("生产了"+i+"只鸡");
        }
    }
}

//消费者
class Customer extends Thread{
    SynContainer container;

    public Customer(SynContainer container) {
        this.container = container;
    }
    
    //消费

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("消费了->"+container.pop().id+"只鸡");
        }
    }
}

//产品
class Chicken{
    int id; //产品编号

    public Chicken(int id) {
        this.id = id;
    }
}

//容器
class SynContainer{
    //需要一个容器大小
    Chicken[] chickens = new Chicken[10];
    //容器计数器
    int count = 0;

    //生产者放入产品
    public synchronized void push(Chicken chicken){
        //如果容器满了，就需要等待消费者消费
        if (count==chickens.length){
            //通知消费者消费，生产等待
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        //如果没有满，我们需要丢入产品
        chickens[count]=chicken;
        count++;

        //可以通知消费者消费了
        this.notifyAll();
    }

    //消费者消费产品
    public synchronized Chicken pop(){
        //判断能否消费
        if (count==0){
            //等待生产者生产，消费者等待
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        //如果可以消费
        count--;
        Chicken chicken = chickens[count];

        //吃完了，通知生产者生产
        this.notifyAll();
        return chicken;
    }
}
```
#### 信号灯法
```
//测试生产者消费者问题2：信号灯法，标志位解决
public class TestPC2 {
    public static void main(String[] args) {
        TV tv = new TV();
        new Player(tv).start();
        new Watcher(tv).start();
    }
}

//生产者--演员
class Player extends Thread{
    TV tv;
    public Player(TV tv) {
        this.tv = tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            if (i%2==0){
                this.tv.play("节目播放中");
            }else {
                this.tv.play("广告中");
            }
        }
    }
}

//消费者--观众
class Watcher extends Thread{
    TV tv;
    public Watcher(TV tv) {
        this.tv = tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            tv.watch();
        }
    }
}
//产品--节目
class TV{
    //演员表演，观众等待 T
    //观众观看，演员等待 F
    String voice; //节目
    boolean flag = true;

    //表演
    public synchronized void play(String voice){
        if (!flag){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("演员表演了："+voice);
        //通知观众观看
        this.notifyAll(); //通知唤醒
        this.voice = voice;
        this.flag = !this.flag;
    }

    //观看
    public synchronized void watch(){
        if (flag){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("观看了："+voice);
        //通知演员表演
        this.notifyAll();
        this.flag = !this.flag;
    }
}
```
### 线程池
+ 背景
经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。
+ 思路
提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。
可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。
+ 好处
◆ 提高响应速度(减少了创建新线程的时间)
◆ 降低资源消耗(重复利用线程池中线程，不需要每次都创建)
◆ 便于线程管理...
◆  corePoolSize：核心池的大小
 ◆    maximumPoolSize：最大线程数
◆ keepAliveTime：线程没有任务时最多保持多长时间后会终止
+ 相关类
JDK 5.0起提供了线程池相关API：ExecutorService 和 Executors
1. ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor
◆ void execute(Runnable command) :执行任务/命令,没有返回值，一般用来执行Runnable
◆ <T> Future<T> submit(Callable<T> task)：执行任务，有返回值，一般又来执行Callable
◆ void shutdown()：关闭连接池
2. Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池
```
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

//测试线程池
public class TestPool {
    public static void main(String[] args) {
        //1.创建服务，创建线程池
        //newFixedThreadPool 参数为 池子大小
        ExecutorService service = Executors.newFixedThreadPool(10);

        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());

        //2.关闭连接
        service.shutdown();

    }
}

class MyThread implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
```]]></description></item><item><title>转载：解决org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)问题</title><link>http://www.cnblogs.com/peng8098/archive/2020/07/04/springboot02.html</link><dc:creator>Tony小学生</dc:creator><author>Tony小学生</author><pubDate>Sat, 04 Jul 2020 08:12:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/07/04/springboot02.html</guid><description><![CDATA[org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)问题，即在mybatis中dao接口与mapper配置文件在做映射绑定的时候出现问题，简单说，就是接口与xml要么是找不到，要么是找到了却匹配不到。

截图为网络中搜索到的常见原因：

![](https://img2020.cnblogs.com/blog/1205669/202007/1205669-20200704160920830-1859761029.png)


照着修改之后，问题依旧存在。最终花费了好大的力气才找到自己代码问题的根源。dao接口与xml的文件名不一致。

接口名与接口文件名都是DepartmentDao, 而配置文件名为DeparmentDao.xml，费了很大的劲才看到两者名字查一个t字母。修改后就一切正常了。

这是一个很容易忽视的点，记住：接口名与Mybatis的映射文件名一定要一模一样。
————————————————
版权声明：本文为CSDN博主「孙大诚_SunRobin」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/sundacheng1989/article/details/81630370

=======================================================================

当时用了第一种方法即解决，错误原因：xml从官网复制下来没有修改成自己的路径]]></description></item><item><title>自动配置的Springboot内junit测试单元不能运行</title><link>http://www.cnblogs.com/peng8098/archive/2020/05/17/spring01.html</link><dc:creator>Tony小学生</dc:creator><author>Tony小学生</author><pubDate>Sun, 17 May 2020 05:11:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2020/05/17/spring01.html</guid><description><![CDATA[#### 解决测试单元不能运行

+ 问题：测试单元的 @Test 前面没有运行图标

+ 解决

  1. IDEA内：File - Setting - Plugins：搜到JUnitGenerator2.0，安装，重启IDEA

  2. 光标点击到主类上，Alt+Enter，选择 Create Test

     ![](https://img2020.cnblogs.com/blog/1205669/202005/1205669-20200517130757391-2046800730.png)

  3. 在类上写两个注解：

     ```java
     @RunWith(SpringJUnit4ClassRunner.class)
     @SpringBootTest
     ```

  4. 在类中写的方法上加上 @Test 注解，运行标志出现，可以运行

     ```java
     @RunWith(SpringJUnit4ClassRunner.class)
     @SpringBootTest
     public class Spring02ConfigApplicationTest {
     
         @Autowired //将之前的value自动注入
         private Dog dog;
     
         @Test
         public void a(){
             System.out.println(dog);
         }
     }
     ```

     ![](https://img2020.cnblogs.com/blog/1205669/202005/1205669-20200517130820161-57083036.png)

  5. 输出

     ![](https://img2020.cnblogs.com/blog/1205669/202005/1205669-20200517130835735-1109205144.png)

  =======================================================

   又遇到这个问题了，junit4.13换成4.12版本，暂时解决
]]></description></item><item><title>机器学习算法笔记（零）</title><link>http://www.cnblogs.com/peng8098/archive/2019/09/12/ml_1.html</link><dc:creator>Tony小学生</dc:creator><author>Tony小学生</author><pubDate>Wed, 11 Sep 2019 17:44:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/09/12/ml_1.html</guid><description><![CDATA[机器学习算法笔记（零） 
+ 简介
机器学习的定义：对于某类任务 T 和性能度量 P，一个计算机程序被认为可以从经验 E 中学习是指，通过经验 E 改进后，它在任务 T 上由性能度量 P 衡量的性能有所提升。
虽然吴恩达老师说过，这个定义这么绕口是为了押韵，我还是要解释一下：任务 T 指常见的机器学习任务，比如文本分类，股票预测等；性能度量 P 用来衡量模型的好坏，通常为准确率或错误率；经验 E 是给计算机的学习数据。
+ 机器学习与深度学习，人工智能
![](https://img2018.cnblogs.com/blog/1205669/201909/1205669-20190912014205278-1673200370.png)
深度学习是从机器学习中的神经网络算法延申出来的，主要表现在神经网络的层数多而复杂。等机器学习的笔记更完之后，我们再学习深度学习，以及后面的强化学习。
+ 学习路线
数学基础和python基础的笔记在主菜单的学习笔记中都有链接，需要的可以自行学习。
![](https://img2018.cnblogs.com/blog/1205669/201909/1205669-20190912014225253-2104023410.png)
+ 零碎的知识点
1. 深度学习能提取更多的特征，更深层的特征
2. 数据、信息，清洗后的数据、知识，有一点有用的东西、智慧
3. 监督学习，带有标签的学习，可以分类
4. 无监督学习，不带有标签，聚类
5. 半监督学习是无监督学习和监督学习相结合，解决部分标签缺失问题
6. 回归，预测数据为连续型数值
7. 分类，预测数据是类别型数据，类别已知
8. 聚类，预测数据是类别型数据，类别未知​]]></description></item><item><title>深度学习（一）TensorFlow</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/29/dl_1.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 29 Jul 2019 06:35:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/29/dl_1.html</guid><description><![CDATA[### 深度学习（一）TensorFlow
+ 简介
数值计算的软件库 by using **data flow graphs** 
中文官网：https://tensorflow.google.cn/
**data flow graphs**：
节点 nodes：操作
边 edges：表示张量 tensor，一般都有输入和输出
特性：自动求微分，可移植性，支持CPU和GPU的运算
底层开发语言：c++，cuda，python
tensorboard是tensorflow的一个可视化界面
+ 一个简单的神经网络案例
features(input) -> neurons -> output
扩维：(x1,x2) => (x1,x2,x1+x2)或者(x1^2,x2^2)等等
+ tensorflow基本概念
图（Graph）：描述了计算的过程，用图表示计算任务
张量（Tensor）：用来表示数据的多维数组
操作（op）：有0或多个张量输入，0或多个张量输出
会话（Session）：图必须在会话的上下文中执行，将图中的op分发到CPU或GPU上运行
变量（Variable）：运行过程中可以被改变，用于维护状态
+ 边有两种连接关系
数据依赖：实线边。从前往后流，前向传播；从后往前流，后向传播
控制依赖：虚线边。用于控制操作的运行确保happens-before关系
+ 数据属性
不同属性不能运算，不存在 float+int => float
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190729143414029-1833501115.png)
+ 节点
又叫算子，代表一个操作，一般表示施加的数字运算，也可以表示数据输入的起点以及输出的终点，或是读取/写出持久化变量的终点
常用：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190729143427191-548352140.png)
+ 基本用法
1.使用图来表示计算任务
2.在会话的上下文中执行图
3.使用tensor表示数据
4.通过变量来维护状态
5.使用feed和fetch可以为任意的操作赋值或者从其中获取数据
+ 程序结构
构建阶段：op的执行步骤被描述为一个图，然后使用tensorflow提供的API构建这个图
执行阶段：将构建好的执行图（operation graph）在会话中执行，并得到结果
+ tensorflow图
执行图，有向无环图
一个会话支持多个图，但是两张图无法同时使用同一tensor变量，所以不建议这样用
```
import tensorflow as tf

## 默认图有三个节点，两个constant op和一个matmul op，计算两个矩阵相乘

# 定义常量矩阵
a = tf.constant([[1,2],[3,4]],dtype=tf.int32,name='a')
b = tf.constant([5,6,7,8],dtype=tf.int32,shape=[2,2])
print('a的类型：',type(a)) # 类型为tensor

# 以a和b作为输入，进行矩阵的乘法操作
c = tf.matmul(a,b)
print('c的类型：',type(c)) # 类型为tensor

print('变量a是否在默认图中：{}'.format(a.graph is tf.get_default_graph()))

# 上面都是使用默认图，接下来使用新的构建的图
graph = tf.Graph()
with graph.as_default():
    # 此时在这个代码块中，使用的是新定义的图
    # 只在这个代码块中，graph是默认图
    d = tf.constant(1.0)
    print('变量d是否在新图graph中：{}'.format(d.graph is graph))
    print('d.graph是默认图吗',d.graph is tf.get_default_graph())
print('d.graph拿出来还是默认图吗',d.graph is tf.get_default_graph())

# 换一种方法新建图
with tf.Graph().as_default() as g2:
    e = tf.constant(1)
    print('变量e是否在新图g2中：{}'.format(e.graph is g2))
```
输出：
```
a的类型： <class 'tensorflow.python.framework.ops.Tensor'>
c的类型： <class 'tensorflow.python.framework.ops.Tensor'>
变量a是否在默认图中：True
变量d是否在新图graph中：True
d.graph是默认图吗 True
d.graph拿出来还是默认图吗 False
变量e是否在新图g2中：True
```
+ tensorflow会话
一个图里可以有多个对话
创建Session对象启动图，无参数情况下构造器启动默认图
会话的构建和启动
`sess = tf.Session()`
会话的关闭
`sess.close()`
如果op之间没有依赖关系，则op自动并行
```
import tensorflow as tf

a = tf.constant([[1,2],[3,4]],dtype=tf.int32,name='a')
b = tf.constant([5,6,7,8],dtype=tf.int32,shape=[2,2])
c = tf.matmul(a,b)
g = tf.add(a,c,name='ADD')

# 会话的构建和启动
sess = tf.Session()
print(sess)

# 调用sess的run方法来执行矩阵的乘法，得到c的结果值
# 不需要考虑图中间的运算，在运行时只需要关注最终结果对应的对象以及所需要的输入数据值
# 只需要传递进去结果对象，会自动根据图中的依赖关系触发所有op操作的执行
# result = sess.run(c)
# print('type:{},value:{}'.format(type(result),result))
result = sess.run(g)
print('type:{},value:{}'.format(type(result),result))
result = sess.run(fetches=[c,g]) 
# 传递列表，返回列表,若列表中要执行的op是并行的，则计算优化
print('type:{},value:{}'.format(type(result),result))

# 会话的关闭
sess.close()

# 会话关闭后，不能再使用了
```
输出：
```
<tensorflow.python.client.session.Session object at 0x000001AA004336A0>
type:<class 'numpy.ndarray'>,value:[[20 24]
 [46 54]]
type:<class 'list'>,value:[array([[19, 22],
      [43, 50]]), array([[20, 24],
      [46, 54]])]
```
还可以：
```
with tf.Session() as sess2:
    print(sess2)
    # 获取张量c的结果，通过Session的run方法获取
    print('sess2 run:{}'.format(sess2.run(c)))
    # 获取张量c的结果，通过张量对象的eval方法获取，结果和Session的run方法一直
    print('c eval:{}'.format(c.eval())) # 用with写才能调用这个方法
```
用with方式构建，Session会自动关闭
会话的参数：
target：给定url，分布式时会用到
graph：给定图，默认为默认图
config：相关一系列参数，其中`config=tf.ConfigProto()`里的参数常用如下
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190729143453191-1304039823.png)
+ tensor张量
一个tensor由一个静态数据类型和动态类型的维数（Rank、Shape）
一个n维tensor可以看成一个n维数组

| 阶 | 形状 | 维数 | 实例 |
| --- | --- | --- | --- |
| 0 | [ ] | 0-D | 一个标量，常数 |
| 1 | [D0] | 1-D | [5] |
| 2 | [D0,D1] | 2-D | [3,4] |
| 3 | [D0,D1,D2] | 3-D | [11,2,3] |
| n | D0,D1...Dn | n-D |[1,2...,n]  |
+ Variables变量
`a = tf.Variable(1.0,dtype=tf.float32)`
也可以这样创建：
`w1 = tf.Variable(1.0,dtype=tf.float32),name='w1')`
`a = tf.constant(2,dtype=tf.float32)`
`w2 = tf.Variable(w1 * a,name='w2')` 错误
`w2 = tf.Variable(w1.initalized_value() * a,name='w2')` 正确
+ feed
两种方法结果一样
```
import tensorflow as tf

# 构建一个矩阵的乘法，但是矩阵在运行的时候给定
m1 = tf.placeholder(dtype=tf.float32,shape=[2,3],name='placeholder_m1')
m2 = tf.placeholder(dtype=tf.float32,shape=[3,2],name='placeholder_m2')
m3 = tf.matmul(m1,m2)

with tf.Session(config=tf.ConfigProto(log_device_placement=True,allow_soft_placement=True)) as sess:
    print('result:\b{}'.format(sess.run(fetches=[m3],feed_dict={m1:[[1,2,3],[4,5,6]],m2:[[1,2],[3,4],[5,6]]})))
    print('result:\n{}'.format(m3.eval(feed_dict={m1:[[1,2,3],[4,5,6]],m2:[[1,2],[3,4],[5,6]]})))
```
输出：
```
result:[array([[22., 28.],
       [49., 64.]], dtype=float32)]
result:
[[22. 28.]
 [49. 64.]]
```
+ 设备
"/cpu:0"：CPU计算
"/gpu:0"：第0个GPU计算
"/gpu:1"：第1个GPU计算
```
import tensorflow as tf

aa = tf.constant([1,2,3])
a = tf.Variable(aa,dtype=tf.int32,name='a')
b = tf.constant(2,dtype=tf.int32,name='b')
c = tf.add(a,b,name='c')

with tf.Session(config=tf.ConfigProto(log_device_placement=True,allow_soft_placement=True)) as sess:
    tf.global_variables_initializer().run() # 初始化
    print(c.eval())
```
输出日志：
```
Device mapping:
/job:localhost/replica:0/task:0/device:GPU:0 -> device: 0, name: GeForce GTX 950M, pci bus id: 0000:01:00.0, compute capability: 5.0

a: (VariableV2): /job:localhost/replica:0/task:0/device:CPU:0
a/Assign: (Assign): /job:localhost/replica:0/task:0/device:CPU:0
a/read: (Identity): /job:localhost/replica:0/task:0/device:CPU:0
c: (Add): /job:localhost/replica:0/task:0/device:GPU:0
init: (NoOp): /job:localhost/replica:0/task:0/device:GPU:0
Const: (Const): /job:localhost/replica:0/task:0/device:CPU:0
b: (Const): /job:localhost/replica:0/task:0/device:GPU:0
```
指定用哪个设备：
```
with tf.device('/cpu:0'):
    各种操作。。。
```
有些操作只能在cpu运行，即使指定gpu也没用
+ 三个简单的实例
```
import tensorflow as tf

## 实例一：累加器
# 1.定义一个变量
x = tf.Variable(0,dtype=tf.int32,name='v_x')

# 2.变量的更新
# x = x + 1 # 不行的，只加一次就没了，输出一堆'1'
assign_op = tf.assign(ref=x,value=x+1)

# 3.变量初始化操作
x_init_op = tf.global_variables_initializer()

# 4.运行
with tf.Session(config=tf.ConfigProto(log_device_placement=True,allow_soft_placement=True)) as sess:
    # 变量初始化
    sess.run(x_init_op)

    # 模拟迭代更新累加器
    for i in range(5):
        r_x = sess.run(x)
        print(r_x)
        # 进行更新操作
        sess.run(assign_op)

## 实列二：动态更新变量的维数
# 1.定义一个不定形状的变量
x = tf.Variable(
    initial_value=[], # 给定一个空值
    dtype=tf.float32,
    trainable=False, # 不固定形状，不把它加到内存中间而单独处理
    validate_shape=False, # 默认为True，表示变量更新时会进行shape的检查
    name='v_x',
)

# 2.变量更改
concat = tf.concat([x,[0.0,0.0]],axis=0) # 按行添加
assign_op = tf.assign(x,concat,validate_shape=False)

# 3.变量初始化操作
x_init_op = tf.global_variables_initializer()

# 3.运行
with tf.Session(config=tf.ConfigProto(log_device_placement=True,allow_soft_placement=True)) as sess:
    # 变量初始化
    sess.run(x_init_op)

    # 模拟迭代更新累加器
    for i in range(5):
        r_x = sess.run(x)
        print(r_x)
        # 进行更新操作
        sess.run(assign_op)

## 实列三：求阶乘
# 1.定义一个变量
sum = tf.Variable(1,dtype=tf.int32)

# 2.定义一个占位符
i = tf.placeholder(dtype=tf.int32)

# 3.更新操作
tmp_sum = sum * i
assign_op = tf.assign(sum,value=tmp_sum)
# 也可以：
with tf.control_dependencies([assign_op]):
    # 要执行这个代码块，必须先执行control_dependencies给定的op/tensor
    sum = tf.Print(sum,data=[sum,sum.read_value()],message='sum:')

# 4.初始化
x_init_op = tf.global_variables_initializer()

# 5.运行
with tf.Session(config=tf.ConfigProto(log_device_placement=True,allow_soft_placement=True)) as sess:
    # 变量初始化
    sess.run(x_init_op)

    # 模拟迭代更新累加器
    for j in range(1,6):
        # 进行更新操作
        # sess.run(assign_op,feed_dict={i:j})
        # 通过control_dependencies可以指定依赖关系，这样就不用管内部的更新操作了
        r = sess.run(sum,feed_dict={i:j})
    # print('5! = {}'.format(sess.run(sum)))
    print('5! = {}'.format(r))
```
输出：
```
0
1
2
3
4

[]
[0. 0.]
[0. 0. 0. 0.]
[0. 0. 0. 0. 0. 0.]
[0. 0. 0. 0. 0. 0. 0. 0.]

5! = 120
```]]></description></item><item><title>Keras（七）Keras.layers各种层介绍</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/16/keras_7.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 16 Jul 2019 08:09:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/16/keras_7.html</guid><description><![CDATA[<div class="markdown_views" id="content_views">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" stroke-linecap="round" d="M 5 0 L 0 2.5 L 5 5 Z" />
                    </svg>
                                            


<p>原文链接：http://www.one2know.cn/keras8/</p>


<h2 id="一网络层"><a name="t0"></a>一、网络层</h2>

<p>keras的层主要包括：</p>

<p>常用层（Core）、卷积层（Convolutional）、池化层（Pooling）、局部连接层、递归层（Recurrent）、嵌入层（ Embedding）、高级激活层、规范层、噪声层、包装层，当然也可以编写自己的层。</p>

<p>对于层的操作</p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">layer<span class="hljs-preprocessor">.get</span>_weights() <span class="hljs-preprocessor">#返回该层的权重（numpy array）</span>
layer<span class="hljs-preprocessor">.set</span>_weights(weights)<span class="hljs-preprocessor">#将权重加载到该层</span>
config = layer<span class="hljs-preprocessor">.get</span>_config()<span class="hljs-preprocessor">#保存该层的配置</span>
layer = layer_from_config(config)<span class="hljs-preprocessor">#加载一个配置到该层</span>

<span class="hljs-preprocessor">#如果层仅有一个计算节点（即该层不是共享层），则可以通过下列方法获得输入张量、输出张量、输入数据的形状和输出数据的形状：</span>
layer<span class="hljs-preprocessor">.input</span>
layer<span class="hljs-preprocessor">.output</span>
layer<span class="hljs-preprocessor">.input</span>_shape
layer<span class="hljs-preprocessor">.output</span>_shape

<span class="hljs-preprocessor">#如果该层有多个计算节点。可以使用下面的方法</span>
layer<span class="hljs-preprocessor">.get</span>_input_at(node_index)
layer<span class="hljs-preprocessor">.get</span>_output_at(node_index)
layer<span class="hljs-preprocessor">.get</span>_input_shape_at(node_index)
layer<span class="hljs-preprocessor">.get</span>_output_shape_at(node_index)<div class="hljs-button signin" data-title="登录后复制"></div></code></pre>



<h2 id="1常用网络层"><a name="t1"></a>1、常用网络层</h2>

<p><strong>1.1、Dense层(全连接层）</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.core.Dense(units,activation=<span class="hljs-keyword">None</span>,use_bias=<span class="hljs-keyword">True</span>,kernel_initializer=<span class="hljs-string">'glorot_uniform'</span>,bias_initializer=<span class="hljs-string">'zeros'</span>,kernel_regularizer=<span class="hljs-keyword">None</span>,bias_regularizer=<span class="hljs-keyword">None</span>,activity_regularizer=<span class="hljs-keyword">None</span>,kernel_constraint=<span class="hljs-keyword">None</span>,bias_constraint=<span class="hljs-keyword">None</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>参数：</p>

<ul>
<li>units：大于0的整数，代表该层的输出维度。</li>
<li>use_bias：布尔值，是否使用偏置项</li>
<li>kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。</li>
<li>bias_initializer：偏置向量初始化方法，为预定义初始化方法名的字符串，或用于初始化偏置向量的初始化器。</li>
<li>regularizer：正则项，kernel为权重的、bias为偏执的，activity为输出的</li>
<li>constraints：约束项，kernel为权重的，bias为偏执的。</li>
<li>activation：激活函数，为预定义的激活函数名（参考激活函数），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）</li>
<li>input_dim：该层输入的维度</li>
</ul>

<p>本层实现的运算为</p>

<p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span tabindex="0" class="MathJax" id="MathJax-Element-3-Frame" role="presentation" style="position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>o</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi><mo>=</mo><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>o</mi><mi>t</mi><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi><mo>,</mo><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mo stretchy="false">)</mo><mo>+</mo><mi>b</mi><mi>i</mi><mi>a</mi><mi>s</mi><mo stretchy="false">)</mo></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-1" style="width: 25.25em; display: inline-block;"><span style="width: 20.2em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.35em; position: absolute; clip: rect(1.45em, 1020.1em, 2.75em, -1000em);"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math; font-style: italic;">o</span><span class="mi" id="MathJax-Span-4" style="font-family: MathJax_Math; font-style: italic;">u</span><span class="mi" id="MathJax-Span-5" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mi" id="MathJax-Span-6" style="font-family: MathJax_Math; font-style: italic;">p</span><span class="mi" id="MathJax-Span-7" style="font-family: MathJax_Math; font-style: italic;">u</span><span class="mi" id="MathJax-Span-8" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mo" id="MathJax-Span-9" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="mi" id="MathJax-Span-10" style="padding-left: 0.27em; font-family: MathJax_Math; font-style: italic;">a</span><span class="mi" id="MathJax-Span-11" style="font-family: MathJax_Math; font-style: italic;">c</span><span class="mi" id="MathJax-Span-12" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mi" id="MathJax-Span-13" style="font-family: MathJax_Math; font-style: italic;">i</span><span class="mi" id="MathJax-Span-14" style="font-family: MathJax_Math; font-style: italic;">v</span><span class="mi" id="MathJax-Span-15" style="font-family: MathJax_Math; font-style: italic;">a</span><span class="mi" id="MathJax-Span-16" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mi" id="MathJax-Span-17" style="font-family: MathJax_Math; font-style: italic;">i</span><span class="mi" id="MathJax-Span-18" style="font-family: MathJax_Math; font-style: italic;">o</span><span class="mi" id="MathJax-Span-19" style="font-family: MathJax_Math; font-style: italic;">n</span><span class="mo" id="MathJax-Span-20" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-21" style="font-family: MathJax_Math; font-style: italic;">d<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mi" id="MathJax-Span-22" style="font-family: MathJax_Math; font-style: italic;">o</span><span class="mi" id="MathJax-Span-23" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mo" id="MathJax-Span-24" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-25" style="font-family: MathJax_Math; font-style: italic;">i</span><span class="mi" id="MathJax-Span-26" style="font-family: MathJax_Math; font-style: italic;">n</span><span class="mi" id="MathJax-Span-27" style="font-family: MathJax_Math; font-style: italic;">p</span><span class="mi" id="MathJax-Span-28" style="font-family: MathJax_Math; font-style: italic;">u</span><span class="mi" id="MathJax-Span-29" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mo" id="MathJax-Span-30" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-31" style="padding-left: 0.16em; font-family: MathJax_Math; font-style: italic;">k</span><span class="mi" id="MathJax-Span-32" style="font-family: MathJax_Math; font-style: italic;">e</span><span class="mi" id="MathJax-Span-33" style="font-family: MathJax_Math; font-style: italic;">r</span><span class="mi" id="MathJax-Span-34" style="font-family: MathJax_Math; font-style: italic;">n</span><span class="mi" id="MathJax-Span-35" style="font-family: MathJax_Math; font-style: italic;">e</span><span class="mi" id="MathJax-Span-36" style="font-family: MathJax_Math; font-style: italic;">l</span><span class="mo" id="MathJax-Span-37" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-38" style="padding-left: 0.22em; font-family: MathJax_Main;">+</span><span class="mi" id="MathJax-Span-39" style="padding-left: 0.22em; font-family: MathJax_Math; font-style: italic;">b</span><span class="mi" id="MathJax-Span-40" style="font-family: MathJax_Math; font-style: italic;">i</span><span class="mi" id="MathJax-Span-41" style="font-family: MathJax_Math; font-style: italic;">a</span><span class="mi" id="MathJax-Span-42" style="font-family: MathJax_Math; font-style: italic;">s</span><span class="mo" id="MathJax-Span-43" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 2.35em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.37em; overflow: hidden; vertical-align: -0.37em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>o</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi><mo>=</mo><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>o</mi><mi>t</mi><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi><mo>,</mo><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mo stretchy="false">)</mo><mo>+</mo><mi>b</mi><mi>i</mi><mi>a</mi><mi>s</mi><mo stretchy="false">)</mo></math></span></span><script id="MathJax-Element-3" type="math/tex">output = activation(dot(input, kernel)+bias)</script></p>

<p><strong>1.2、Activation层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.core</span><span class="hljs-preprocessor">.Activation</span>(activation)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>激活层对一个层的输出施加激活函数</p>

<p>参数：</p>

<ul>
<li>activation：将要使用的激活函数，为预定义激活函数名或一个Tensorflow/Theano的函数。参考激活函数</li>
</ul>

<p>输入shape：任意，当使用激活层作为第一层时，要指定input_shape <br>
输出shape：与输入shape相同</p>

<p><strong>1.3、dropout层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.core</span><span class="hljs-preprocessor">.Dropout</span>(rate, noise_shape=None, seed=None)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>为输入数据施加Dropout。Dropout将在训练过程中每次更新参数时按一定概率（rate）随机断开输入神经元，Dropout层用于防止过拟合。</p>

<p>参数</p>

<ul>
<li>rate：0~1的浮点数，控制需要断开的神经元的比例</li>
<li>noise_shape：整数张量，为将要应用在输入上的二值Dropout mask的shape，例如你的输入为(batch_size, timesteps, features)，并且你希望在各个时间步上的Dropout mask都相同，则可传入noise_shape=(batch_size, 1, features)。</li>
<li>seed：整数，使用的随机数种子</li>
</ul>

<p><strong>1.4、Flatten层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.core</span><span class="hljs-preprocessor">.Flatten</span>()<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>Flatten层用来将输入“压平”，即把多维的输入一维化，常用在从卷积层到全连接层的过渡。Flatten不影响batch的大小。</p>

<p>demo：</p>



<pre class="prettyprint" name="code"><code class="hljs vala has-numbering" onclick="mdcp.signin(event)">model = Sequential()
model.add(Convolution2D(<span class="hljs-number">64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>,
            border_mode=<span class="hljs-string">'same'</span>,
            input_shape=(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>)))
<span class="hljs-preprocessor"># now: model.output_shape == (None, 64, 32, 32)</span>

model.add(Flatten())
<span class="hljs-preprocessor"># now: model.output_shape == (None, 65536)</span><div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p><strong>1.5、Reshape层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.core</span><span class="hljs-preprocessor">.Reshape</span>(target_shape)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>Reshape层用来将输入shape转换为特定的shape</p>

<p>参数</p>

<ul>
<li>target_shape：目标shape，为整数的tuple，不包含样本数目的维度（batch大小）</li>
</ul>

<p>输入shape：任意，但输入的shape必须固定。当使用该层为模型首层时，需要指定input_shape参数 <br>
输出shape：(batch_size,)+target_shape</p>

<p>demo：</p>



<pre class="prettyprint" name="code"><code class="hljs vala has-numbering" onclick="mdcp.signin(event)"><span class="hljs-preprocessor"># as first layer in a Sequential model</span>
model = Sequential()
model.add(Reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), input_shape=(<span class="hljs-number">12</span>,)))
<span class="hljs-preprocessor"># now: model.output_shape == (None, 3, 4)</span>
<span class="hljs-preprocessor"># note: `None` is the batch dimension</span>

<span class="hljs-preprocessor"># as intermediate layer in a Sequential model</span>
model.add(Reshape((<span class="hljs-number">6</span>, <span class="hljs-number">2</span>)))
<span class="hljs-preprocessor"># now: model.output_shape == (None, 6, 2)</span>

<span class="hljs-preprocessor"># also supports shape inference using `-1` as dimension</span>
model.add(Reshape((-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))
<span class="hljs-preprocessor"># now: model.output_shape == (None, 3, 2, 2)</span><div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p><strong>1.6、Permute层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.core</span><span class="hljs-preprocessor">.Permute</span>(dims)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>Permute层将输入的维度按照给定模式进行重排，例如，当需要将RNN和CNN网络连接时，可能会用到该层。所谓的重排也就是交换两行</p>

<p>参数</p>

<ul>
<li>dims：整数tuple，指定重排的模式，不包含样本数的维度。重拍模式的下标从1开始。例如（2，1）代表将输入的第二个维度重排到输出的第一个维度，而将输入的第一个维度重排到第二个维度</li>
</ul>



<pre class="prettyprint" name="code"><code class="hljs vala has-numbering" onclick="mdcp.signin(event)">model = Sequential()
model.add(Permute((<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), input_shape=(<span class="hljs-number">10</span>, <span class="hljs-number">64</span>)))
<span class="hljs-preprocessor"># now: model.output_shape == (None, 64, 10)</span>
<span class="hljs-preprocessor"># note: `None` is the batch dimension</span><div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>输入shape：任意，当使用激活层作为第一层时，要指定input_shape <br>
输出shape：与输入相同，但是其维度按照指定的模式重新排列</p>

<p><strong>1.7、RepeatVector层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.core</span><span class="hljs-preprocessor">.RepeatVector</span>(n)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>RepeatVector层将输入重复n次</p>

<p>参数</p>

<ul>
<li>n：整数，重复的次数</li>
</ul>

<p>输入shape：形如（nb_samples, features）的2D张量 <br>
输出shape：形如（nb_samples, n, features）的3D张量</p>

<p>例子</p>



<pre class="prettyprint" name="code"><code class="hljs vala has-numbering" onclick="mdcp.signin(event)">model = Sequential()
model.add(Dense(<span class="hljs-number">32</span>, input_dim=<span class="hljs-number">32</span>))
<span class="hljs-preprocessor"># now: model.output_shape == (None, 32)</span>
<span class="hljs-preprocessor"># note: `None` is the batch dimension</span>

model.add(RepeatVector(<span class="hljs-number">3</span>))
<span class="hljs-preprocessor"># now: model.output_shape == (None, 3, 32)</span><div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p><strong>1.8、Lambda层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.core.Lambda(function, output_shape=<span class="hljs-keyword">None</span>, mask=<span class="hljs-keyword">None</span>, arguments=<span class="hljs-keyword">None</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>本函数用以对上一层的输出施以任何Theano/TensorFlow表达式</p>

<p>参数</p>

<ul>
<li>function：要实现的函数，该函数仅接受一个变量，即上一层的输出</li>
<li>output_shape：函数应该返回的值的shape，可以是一个tuple，也可以是一个根据输入</li>
<li>shape计算输出shape的函数</li>
<li>mask: 掩膜</li>
<li>arguments：可选，字典，用来记录向函数中传递的其他关键字参数</li>
</ul>

<p>输入shape：任意，当使用该层作为第一层时，要指定input_shape <br>
输出shape：由output_shape参数指定的输出shape，当使用tensorflow时可自动推断</p>



<pre class="prettyprint" name="code"><code class="hljs python has-numbering" onclick="mdcp.signin(event)"><span class="hljs-comment"># add a x -&gt; x^2 layer</span>
model.add(Lambda(<span class="hljs-keyword">lambda</span> x: x ** <span class="hljs-number">2</span>))

<span class="hljs-comment"># add a layer that returns the concatenation</span>
<span class="hljs-comment"># of the positive part of the input and</span>
<span class="hljs-comment"># the opposite of the negative part</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">antirectifier</span><span class="hljs-params">(x)</span>:</span>
    x -= K.mean(x, axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-keyword">True</span>)
    x = K.l2_normalize(x, axis=<span class="hljs-number">1</span>)
    pos = K.relu(x)
    neg = K.relu(-x)
    <span class="hljs-keyword">return</span> K.concatenate([pos, neg], axis=<span class="hljs-number">1</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">antirectifier_output_shape</span><span class="hljs-params">(input_shape)</span>:</span>
    shape = list(input_shape)
    <span class="hljs-keyword">assert</span> len(shape) == <span class="hljs-number">2</span>  <span class="hljs-comment"># only valid for 2D tensors</span>
    shape[-<span class="hljs-number">1</span>] *= <span class="hljs-number">2</span>
    <span class="hljs-keyword">return</span> tuple(shape)

model.add(Lambda(antirectifier,
         output_shape=antirectifier_output_shape))<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p><strong>1.9、ActivityRegularizer层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.core</span><span class="hljs-preprocessor">.ActivityRegularization</span>(l1=<span class="hljs-number">0.0</span>, l2=<span class="hljs-number">0.0</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>经过本层的数据不会有任何变化，但会基于其激活值更新损失函数值</p>

<p>参数</p>

<ul>
<li>l1：1范数正则因子（正浮点数）</li>
<li>l2：2范数正则因子（正浮点数）</li>
</ul>

<p>输入shape：任意，当使用该层作为第一层时，要指定input_shape <br>
输出shape：与输入shape相同</p>

<p><strong>2.0、Masking层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.core</span><span class="hljs-preprocessor">.Masking</span>(mask_value=<span class="hljs-number">0.0</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>



<h2 id="2卷积层convolutional"><a name="t2"></a>2、卷积层Convolutional</h2>

<p><strong>2.1、Conv1D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.convolutional.Conv1D(filters, kernel_size, strides=<span class="hljs-number">1</span>, padding=<span class="hljs-string">'valid'</span>, dilation_rate=<span class="hljs-number">1</span>, activation=<span class="hljs-keyword">None</span>, use_bias=<span class="hljs-keyword">True</span>, kernel_initializer=<span class="hljs-string">'glorot_uniform'</span>, bias_initializer=<span class="hljs-string">'zeros'</span>, kernel_regularizer=<span class="hljs-keyword">None</span>, bias_regularizer=<span class="hljs-keyword">None</span>, activity_regularizer=<span class="hljs-keyword">None</span>, kernel_constraint=<span class="hljs-keyword">None</span>, bias_constraint=<span class="hljs-keyword">None</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>一维卷积层（即时域卷积），用以在一维输入信号上进行邻域滤波。当使用该层作为首层时，需要提供关键字参数input_shape。例如(10,128)代表一个长为10的序列，序列中每个信号为128向量。而(None, 128)代表变长的128维向量序列。</p>

<p>该层生成将输入信号与卷积核按照单一的空域（或时域）方向进行卷积。如果use_bias=True，则还会加上一个偏置项，若activation不为None，则输出为经过激活函数的输出。</p>

<p>参数</p>

<ul>
<li>filters：卷积核的数目（即输出的维度）</li>
<li>kernel_size：整数或由单个整数构成的list/tuple，卷积核的空域或时域窗长度</li>
<li>strides：整数或由单个整数构成的list/tuple，为卷积的步长。任何不为1的strides均与任何不为1的dilation_rate均不兼容</li>
<li>padding：补0策略，为“valid”, “same” 或“causal”，“causal”将产生因果（膨胀的）卷积，即output[t]不依赖于input[t+1：]。当对不能违反时间顺序的时序信号建模时有用。参考WaveNet: A Generative Model for Raw Audio, section 2.1.。“valid”代表只进行有效的卷积，即对边界数据不处理。“same”代表保留边界处的卷积结果，通常会导致输出shape与输入shape相同。</li>
<li>activation：激活函数，为预定义的激活函数名（参考激活函数），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）</li>
<li>dilation_rate：整数或由单个整数构成的list/tuple，指定dilated convolution中的膨胀比例。任何不为1的dilation_rate均与任何不为1的strides均不兼容。</li>
<li>use_bias:布尔值，是否使用偏置项</li>
<li>kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers</li>
<li>bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers</li>
<li>kernel_regularizer：施加在权重上的正则项，为Regularizer对象</li>
<li>bias_regularizer：施加在偏置向量上的正则项，为Regularizer对象</li>
<li>activity_regularizer：施加在输出上的正则项，为Regularizer对象</li>
<li>kernel_constraints：施加在权重上的约束项，为Constraints对象</li>
<li>bias_constraints：施加在偏置上的约束项，为Constraints对象</li>
</ul>

<p>输入shape：形如（samples，steps，input_dim）的3D张量 <br>
输出shape：形如（samples，new_steps，nb_filter）的3D张量，因为有向量填充的原因，steps的值会改变</p>

<p>【Tips】可以将Convolution1D看作Convolution2D的快捷版，对例子中（10，32）的信号进行1D卷积相当于对其进行卷积核为（filter_length, 32）的2D卷积。</p>

<p><strong>2.2、Conv2D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.convolutional.Conv2D(filters, kernel_size, strides=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), padding=<span class="hljs-string">'valid'</span>, data_format=<span class="hljs-keyword">None</span>, dilation_rate=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), activation=<span class="hljs-keyword">None</span>, use_bias=<span class="hljs-keyword">True</span>, kernel_initializer=<span class="hljs-string">'glorot_uniform'</span>, bias_initializer=<span class="hljs-string">'zeros'</span>, kernel_regularizer=<span class="hljs-keyword">None</span>, bias_regularizer=<span class="hljs-keyword">None</span>, activity_regularizer=<span class="hljs-keyword">None</span>, kernel_constraint=<span class="hljs-keyword">None</span>, bias_constraint=<span class="hljs-keyword">None</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>二维卷积层，即对图像的空域卷积。该层对二维输入进行滑动窗卷积，当使用该层作为第一层时，应提供<code>input_shape</code>参数。例如<code>input_shape = (128,128,3)</code>代表128*128的彩色RGB图像（<code>data_format='channels_last'</code>）</p>

<p>参数</p>

<ul>
<li>filters：卷积核的数目（即输出的维度）</li>
<li>kernel_size：单个整数或由两个整数构成的list/tuple，卷积核的宽度和长度。如为单个整数，则表示在各个空间维度的相同长度。</li>
<li>strides：单个整数或由两个整数构成的list/tuple，为卷积的步长。如为单个整数，则表示在各个空间维度的相同步长。任何不为1的strides均与任何不为1的dilation_rate均不兼容</li>
<li>padding：补0策略，为“valid”, “same” 。“valid”代表只进行有效的卷积，即对边界数据不处理。“same”代表保留边界处的卷积结果，通常会导致输出shape与输入shape相同。</li>
<li>activation：激活函数，为预定义的激活函数名（参考激活函数），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）</li>
<li>dilation_rate：单个整数或由两个整数构成的list/tuple，指定dilated convolution中的膨胀比例。任何不为1的dilation_rate均与任何不为1的strides均不兼容。</li>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
<li>use_bias:布尔值，是否使用偏置项</li>
<li>kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers</li>
<li>bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers</li>
<li>kernel_regularizer：施加在权重上的正则项，为Regularizer对象</li>
<li>bias_regularizer：施加在偏置向量上的正则项，为Regularizer对象</li>
<li>activity_regularizer：施加在输出上的正则项，为Regularizer对象</li>
<li>kernel_constraints：施加在权重上的约束项，为Constraints对象</li>
<li>bias_constraints：施加在偏置上的约束项，为Constraints对象</li>
</ul>

<p>输入shape： <br>
‘channels_first’模式下，输入形如（samples,channels，rows，cols）的4D张量。 <br>
‘channels_last’模式下，输入形如（samples，rows，cols，channels）的4D张量。</p>

<p>注意这里的输入shape指的是函数内部实现的输入shape，而非函数接口应指定的input_shape，请参考下面提供的例子。</p>

<p>输出shape： <br>
 ‘channels_first’模式下，为形如（samples，nb_filter, new_rows, new_cols）的4D张量。 <br>
 ‘channels_last’模式下，为形如（samples，new_rows, new_cols，nb_filter）的4D张。量</p>

<p>输出的行列数可能会因为填充方法而改变。</p>

<p><strong>2.3、SeparableConv2D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.convolutional.SeparableConv2D(filters, kernel_size, strides=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), padding=<span class="hljs-string">'valid'</span>, data_format=<span class="hljs-keyword">None</span>, depth_multiplier=<span class="hljs-number">1</span>, activation=<span class="hljs-keyword">None</span>, use_bias=<span class="hljs-keyword">True</span>, depthwise_initializer=<span class="hljs-string">'glorot_uniform'</span>, pointwise_initializer=<span class="hljs-string">'glorot_uniform'</span>, bias_initializer=<span class="hljs-string">'zeros'</span>, depthwise_regularizer=<span class="hljs-keyword">None</span>, pointwise_regularizer=<span class="hljs-keyword">None</span>, bias_regularizer=<span class="hljs-keyword">None</span>, activity_regularizer=<span class="hljs-keyword">None</span>, depthwise_constraint=<span class="hljs-keyword">None</span>, pointwise_constraint=<span class="hljs-keyword">None</span>, bias_constraint=<span class="hljs-keyword">None</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>该层是在深度方向上的可分离卷积。</p>

<p>可分离卷积首先按深度方向进行卷积（对每个输入通道分别卷积），然后逐点进行卷积，将上一步的卷积结果混合到输出通道中。参数depth_multiplier控制了在depthwise卷积（第一步）的过程中，每个输入通道信号产生多少个输出通道。</p>

<p>直观来说，可分离卷积可以看做讲一个卷积核分解为两个小的卷积核，或看作Inception模块的一种极端情况。</p>

<p>当使用该层作为第一层时，应提供input_shape参数。例如input_shape = (3,128,128)代表128*128的彩色RGB图像。</p>

<p>参数</p>

<ul>
<li>filters：卷积核的数目（即输出的维度）</li>
<li>kernel_size：单个整数或由两个个整数构成的list/tuple，卷积核的宽度和长度。如为单个整数，则表示在各个空间维度的相同长度。</li>
<li>strides：单个整数或由两个整数构成的list/tuple，为卷积的步长。如为单个整数，则表示在各个空间维度的相同步长。任何不为1的strides均与任何不为1的dilation_rate均不兼容</li>
<li>padding：补0策略，为“valid”, “same” <br>
。“valid”代表只进行有效的卷积，即对边界数据不处理。“same”代表保留边界处的卷积结果，通常会导致输出shape与输入shape相同。</li>
<li>activation：激活函数，为预定义的激活函数名（参考激活函数），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）</li>
<li>dilation_rate：单个整数或由两个整数构成的list/tuple，指定dilated</li>
<li>convolution中的膨胀比例。任何不为1的dilation_rate均与任何不为1的strides均不兼容。</li>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
<li>use_bias:布尔值，是否使用偏置项 depth_multiplier：在按深度卷积的步骤中，每个输入通道使用多少个输出通道</li>
<li>kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers</li>
<li>bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers</li>
<li>depthwise_regularizer：施加在按深度卷积的权重上的正则项，为Regularizer对象</li>
<li>pointwise_regularizer：施加在按点卷积的权重上的正则项，为Regularizer对象</li>
<li>kernel_regularizer：施加在权重上的正则项，为Regularizer对象</li>
<li>bias_regularizer：施加在偏置向量上的正则项，为Regularizer对象</li>
<li>activity_regularizer：施加在输出上的正则项，为Regularizer对象</li>
<li>kernel_constraints：施加在权重上的约束项，为Constraints对象</li>
<li>bias_constraints：施加在偏置上的约束项，为Constraints对象</li>
<li>depthwise_constraint：施加在按深度卷积权重上的约束项，为Constraints对象</li>
<li>pointwise_constraint施加在按点卷积权重的约束项，为Constraints对象</li>
</ul>

<p>输入shape <br>
‘channels_first’模式下，输入形如（samples,channels，rows，cols）的4D张量。 <br>
‘channels_last’模式下，输入形如（samples，rows，cols，channels）的4D张量。</p>

<p>注意这里的输入shape指的是函数内部实现的输入shape，而非函数接口应指定的input_shape，请参考下面提供的例子。</p>

<p>输出shape <br>
‘channels_first’模式下，为形如（samples，nb_filter, new_rows, new_cols）的4D张量。 <br>
‘channels_last’模式下，为形如（samples，new_rows, new_cols，nb_filter）的4D张量。</p>

<p>输出的行列数可能会因为填充方法而改变</p>

<p><strong>2.4、Conv2DTranspose层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.convolutional.Conv2DTranspose(filters, kernel_size, strides=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), padding=<span class="hljs-string">'valid'</span>, data_format=<span class="hljs-keyword">None</span>, activation=<span class="hljs-keyword">None</span>, use_bias=<span class="hljs-keyword">True</span>, kernel_initializer=<span class="hljs-string">'glorot_uniform'</span>, bias_initializer=<span class="hljs-string">'zeros'</span>, kernel_regularizer=<span class="hljs-keyword">None</span>, bias_regularizer=<span class="hljs-keyword">None</span>, activity_regularizer=<span class="hljs-keyword">None</span>, kernel_constraint=<span class="hljs-keyword">None</span>, bias_constraint=<span class="hljs-keyword">None</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>该层是转置的卷积操作（反卷积）。需要反卷积的情况通常发生在用户想要对一个普通卷积的结果做反方向的变换。例如，将具有该卷积层输出shape的tensor转换为具有该卷积层输入shape的tensor。同时保留与卷积层兼容的连接模式。</p>

<p>当使用该层作为第一层时，应提供input_shape参数。例如input_shape = (3,128,128)代表128*128的彩色RGB图像。</p>

<p>参数</p>

<ul>
<li>filters：卷积核的数目（即输出的维度）</li>
<li>kernel_size：单个整数或由两个个整数构成的list/tuple，卷积核的宽度和长度。如为单个整数，则表示在各个空间维度的相同长度。</li>
<li>strides：单个整数或由两个整数构成的list/tuple，为卷积的步长。如为单个整数，则表示在各个空间维度的相同步长。任何不为1的strides均与任何不为1的dilation_rate均不兼容</li>
<li>padding：补0策略，为“valid”, “same” 。“valid”代表只进行有效的卷积，即对边界数据不处理。“same”代表保留边界处的卷积结果，通常会导致输出shape与输入shape相同。</li>
<li>activation：激活函数，为预定义的激活函数名（参考激活函数），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）</li>
<li>dilation_rate：单个整数或由两个个整数构成的list/tuple，指定dilated convolution中的膨胀比例。任何不为1的dilation_rate均与任何不为1的strides均不兼容。</li>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
<li>use_bias:布尔值，是否使用偏置项</li>
<li>kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers</li>
<li>bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers</li>
<li>kernel_regularizer：施加在权重上的正则项，为Regularizer对象</li>
<li>bias_regularizer：施加在偏置向量上的正则项，为Regularizer对象</li>
<li>activity_regularizer：施加在输出上的正则项，为Regularizer对象</li>
<li>kernel_constraints：施加在权重上的约束项，为Constraints对象</li>
<li>bias_constraints：施加在偏置上的约束项，为Constraints对象</li>
</ul>

<p>输入shape <br>
‘channels_first’模式下，输入形如（samples,channels，rows，cols）的4D张量。 <br>
‘channels_last’模式下，输入形如（samples，rows，cols，channels）的4D张量。</p>

<p>注意这里的输入shape指的是函数内部实现的输入shape，而非函数接口应指定的input_shape，请参考下面提供的例子。</p>

<p>输出shape <br>
‘channels_first’模式下，为形如（samples，nb_filter, new_rows, new_cols）的4D张量。 <br>
‘channels_last’模式下，为形如（samples，new_rows, new_cols，nb_filter）的4D张量。</p>

<p>输出的行列数可能会因为填充方法而改变</p>

<p><strong>2.5、Conv3D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.convolutional.Conv3D(filters, kernel_size, strides=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), padding=<span class="hljs-string">'valid'</span>, data_format=<span class="hljs-keyword">None</span>, dilation_rate=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), activation=<span class="hljs-keyword">None</span>, use_bias=<span class="hljs-keyword">True</span>, kernel_initializer=<span class="hljs-string">'glorot_uniform'</span>, bias_initializer=<span class="hljs-string">'zeros'</span>, kernel_regularizer=<span class="hljs-keyword">None</span>, bias_regularizer=<span class="hljs-keyword">None</span>, activity_regularizer=<span class="hljs-keyword">None</span>, kernel_constraint=<span class="hljs-keyword">None</span>, bias_constraint=<span class="hljs-keyword">None</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>三维卷积对三维的输入进行滑动窗卷积，当使用该层作为第一层时，应提供input_shape参数。例如input_shape = (3,10,128,128)代表对10帧128*128的彩色RGB图像进行卷积。数据的通道位置仍然有data_format参数指定。</p>

<p>参数</p>

<ul>
<li>filters：卷积核的数目（即输出的维度）</li>
<li>kernel_size：单个整数或由3个整数构成的list/tuple，卷积核的宽度和长度。如为单个整数，则表示在各个空间维度的相同长度。</li>
<li>strides：单个整数或由3个整数构成的list/tuple，为卷积的步长。如为单个整数，则表示在各个空间维度的相同步长。任何不为1的strides均与任何不为1的dilation_rate均不兼容</li>
<li>padding：补0策略，为“valid”, “same” 。“valid”代表只进行有效的卷积，即对边界数据不处理。“same”代表保留边界处的卷积结果，通常会导致输出shape与输入shape相同。</li>
<li>activation：激活函数，为预定义的激活函数名（参考激活函数），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）</li>
<li>dilation_rate：单个整数或由3个个整数构成的list/tuple，指定dilated convolution中的膨胀比例。任何不为1的dilation_rate均与任何不为1的strides均不兼容。</li>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表数据的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128x128的数据为例，“channels_first”应将数据组织为（3,128,128,128），而“channels_last”应将数据组织为（128,128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
<li>use_bias:布尔值，是否使用偏置项</li>
<li>kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers</li>
<li>bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers</li>
<li>kernel_regularizer：施加在权重上的正则项，为Regularizer对象</li>
<li>bias_regularizer：施加在偏置向量上的正则项，为Regularizer对象</li>
<li>activity_regularizer：施加在输出上的正则项，为Regularizer对象</li>
<li>kernel_constraints：施加在权重上的约束项，为Constraints对象</li>
<li>bias_constraints：施加在偏置上的约束项，为Constraints对象</li>
</ul>

<p>输入shape <br>
‘channels_first’模式下，输入应为形如（samples，channels，input_dim1，input_dim2, input_dim3）的5D张量 <br>
‘channels_last’模式下，输入应为形如（samples，input_dim1，input_dim2, input_dim3，channels）的5D张量</p>

<p>这里的输入shape指的是函数内部实现的输入shape，而非函数接口应指定的input_shape。</p>

<p><strong>2.6、Cropping1D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.convolutional</span><span class="hljs-preprocessor">.Cropping</span>1D(cropping=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>在时间轴（axis1）上对1D输入（即时间序列）进行裁剪</p>

<p>参数</p>

<ul>
<li>cropping：长为2的tuple，指定在序列的首尾要裁剪掉多少个元素</li>
</ul>

<p>输入shape：形如（samples，axis_to_crop，features）的3D张量 <br>
输出shape：形如（samples，cropped_axis，features）的3D张量。</p>

<p><strong>2.7、Cropping2D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.convolutional</span><span class="hljs-preprocessor">.Cropping</span>2D(cropping=((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)), data_format=None)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>对2D输入（图像）进行裁剪，将在空域维度，即宽和高的方向上裁剪</p>

<p>参数</p>

<ul>
<li>cropping：长为2的整数tuple，分别为宽和高方向上头部与尾部需要裁剪掉的元素数</li>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
</ul>

<p>输入shape：形如（samples，depth, first_axis_to_crop, second_axis_to_crop） <br>
输出shape：形如(samples, depth, first_cropped_axis, second_cropped_axis)的4D张量。</p>

<p><strong>2.8、Cropping3D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.convolutional</span><span class="hljs-preprocessor">.Cropping</span>3D(cropping=((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)), data_format=None)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>对2D输入（图像）进行裁剪</p>

<p>参数</p>

<ul>
<li>cropping：长为3的整数tuple，分别为三个方向上头部与尾部需要裁剪掉的元素数</li>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表数据的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128x128的数据为例，“channels_first”应将数据组织为（3,128,128,128），而“channels_last”应将数据组织为（128,128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
</ul>

<p>输入shape：形如 (samples, depth, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop)的5D张量。 <br>
输出shape：形如(samples, depth, first_cropped_axis, second_cropped_axis, third_cropped_axis)的5D张量。</p>

<p><strong>2.9、UpSampling1D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.convolutional</span><span class="hljs-preprocessor">.UpSampling</span>1D(size=<span class="hljs-number">2</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>在时间轴上，将每个时间步重复length次</p>

<p>参数</p>

<ul>
<li>size：上采样因子</li>
</ul>

<p>输入shape：形如（samples，steps，features）的3D张量 <br>
输出shape：形如（samples，upsampled_steps，features）的3D张量</p>

<p><strong>3.0、UpSampling2D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.convolutional</span><span class="hljs-preprocessor">.UpSampling</span>2D(size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), data_format=None)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>将数据的行和列分别重复size[0]和size[1]次</p>

<p>参数</p>

<ul>
<li><p>size：整数tuple，分别为行和列上采样因子</p></li>
<li><p>data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</p></li>
</ul>

<p>输入shape： <br>
‘channels_first’模式下，为形如（samples，channels, rows，cols）的4D张量。 <br>
‘channels_last’模式下，为形如（samples，rows, cols，channels）的4D张量。</p>

<p>输出shape： <br>
‘channels_first’模式下，为形如（samples，channels, upsampled_rows, upsampled_cols）的4D张量。 <br>
‘channels_last’模式下，为形如（samples，upsampled_rows, upsampled_cols，channels）的4D张量。</p>

<p><strong>3.1、UpSampling3D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.convolutional</span><span class="hljs-preprocessor">.UpSampling</span>3D(size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>), data_format=None)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>将数据的三个维度上分别重复size[0]、size[1]和ize[2]次</p>

<p>本层目前只能在使用Theano为后端时可用</p>

<p>参数</p>

<ul>
<li>size：长为3的整数tuple，代表在三个维度上的上采样因子</li>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表数据的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128x128的数据为例，“channels_first”应将数据组织为（3,128,128,128），而“channels_last”应将数据组织为（128,128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
</ul>

<p>输入shape： <br>
‘channels_first’模式下，为形如（samples, channels, len_pool_dim1, len_pool_dim2, len_pool_dim3）的5D张量 <br>
‘channels_last’模式下，为形如（samples, len_pool_dim1, len_pool_dim2, len_pool_dim3，channels, ）的5D张量</p>

<p>输出shape： <br>
‘channels_first’模式下，为形如（samples, channels, dim1, dim2, dim3）的5D张量 <br>
‘channels_last’模式下，为形如（samples, upsampled_dim1, upsampled_dim2, upsampled_dim3,channels,）的5D张量。</p>

<p><strong>3.2、ZeroPadding1D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.convolutional</span><span class="hljs-preprocessor">.ZeroPadding</span>1D(padding=<span class="hljs-number">1</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>对1D输入的首尾端（如时域序列）填充0，以控制卷积以后向量的长度</p>

<p>参数</p>

<ul>
<li>padding：整数，表示在要填充的轴的起始和结束处填充0的数目，这里要填充的轴是轴1（第1维，第0维是样本数）</li>
</ul>

<p>输入shape：形如（samples，axis_to_pad，features）的3D张量 <br>
输出shape：形如（samples，paded_axis，features）的3D张量</p>

<p><strong>3.3、ZeroPadding2D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.convolutional</span><span class="hljs-preprocessor">.ZeroPadding</span>2D(padding=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), data_format=None)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>对2D输入（如图片）的边界填充0，以控制卷积以后特征图的大小</p>

<p>参数</p>

<ul>
<li>padding：整数tuple，表示在要填充的轴的起始和结束处填充0的数目，这里要填充的轴是轴3和轴4（即在’th’模式下图像的行和列，在‘channels_last’模式下要填充的则是轴2，3）</li>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
</ul>

<p>输入shape： <br>
‘channels_first’模式下，形如（samples，channels，first_axis_to_pad，second_axis_to_pad）的4D张量。 <br>
‘channels_last’模式下，形如（samples，first_axis_to_pad，second_axis_to_pad, channels）的4D张量。</p>

<p>输出shape： <br>
‘channels_first’模式下，形如（samples，channels，first_paded_axis，second_paded_axis）的4D张量 <br>
‘channels_last’模式下，形如（samples，first_paded_axis，second_paded_axis, channels）的4D张量</p>

<p><strong>3.4、ZeroPadding3D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.convolutional</span><span class="hljs-preprocessor">.ZeroPadding</span>3D(padding=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), data_format=None)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>将数据的三个维度上填充0</p>

<p>本层目前只能在使用Theano为后端时可用</p>

<p>参数</p>

<ul>
<li>padding：整数tuple，表示在要填充的轴的起始和结束处填充0的数目，这里要填充的轴是轴3，轴4和轴5，‘channels_last’模式下则是轴2，3和4</li>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表数据的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128x128的数据为例，“channels_first”应将数据组织为（3,128,128,128），而“channels_last”应将数据组织为（128,128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
</ul>

<p>输入shape： <br>
‘channels_first’模式下，为形如（samples, channels, first_axis_to_pad，first_axis_to_pad, first_axis_to_pad,）的5D张量。 <br>
‘channels_last’模式下，为形如（samples, first_axis_to_pad，first_axis_to_pad, first_axis_to_pad, channels）的5D张量。</p>

<p>输出shape： <br>
‘channels_first’模式下，为形如（samples, channels, first_paded_axis，second_paded_axis, third_paded_axis,）的5D张量 <br>
‘channels_last’模式下，为形如（samples, len_pool_dim1, len_pool_dim2, len_pool_dim3，channels, ）的5D张量</p>



<h2 id="3池化层pooling"><a name="t3"></a>3、池化层Pooling</h2>

<p><strong>3.1、MaxPooling1D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.pooling.MaxPooling1D(pool_size=<span class="hljs-number">2</span>, strides=<span class="hljs-keyword">None</span>, padding=<span class="hljs-string">'valid'</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>对时域1D信号进行最大值池化</p>

<p>参数</p>

<ul>
<li>pool_size：整数，池化窗口大小</li>
<li>strides：整数或None，下采样因子，例如设2将会使得输出shape为输入的一半，若为None则默认值为pool_size。</li>
<li>padding：‘valid’或者‘same’</li>
</ul>

<p>输入shape：形如（samples，steps，features）的3D张量 <br>
输出shape：形如（samples，downsampled_steps，features）的3D张量</p>

<p><strong>3.2、MaxPooling2D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.pooling.MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), strides=<span class="hljs-keyword">None</span>, padding=<span class="hljs-string">'valid'</span>, data_format=<span class="hljs-keyword">None</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>为空域信号施加最大值池化</p>

<p>参数</p>

<ul>
<li>pool_size：整数或长为2的整数tuple，代表在两个方向（竖直，水平）上的下采样因子，如取（2，2）将使图片在两个维度上均变为原长的一半。为整数意为各个维度值相同且为该数字。</li>
<li>strides：整数或长为2的整数tuple，或者None，步长值。</li>
<li>border_mode：‘valid’或者‘same’</li>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
</ul>

<p>输入shape <br>
‘channels_first’模式下，为形如（samples，channels, rows，cols）的4D张量 <br>
‘channels_last’模式下，为形如（samples，rows, cols，channels）的4D张量</p>

<p>输出shape <br>
‘channels_first’模式下，为形如（samples，channels, pooled_rows, pooled_cols）的4D张量 <br>
‘channels_last’模式下，为形如（samples，pooled_rows, pooled_cols，channels）的4D张量</p>

<p><strong>3.3、MaxPooling3D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.pooling.MaxPooling3D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>), strides=<span class="hljs-keyword">None</span>, padding=<span class="hljs-string">'valid'</span>, data_format=<span class="hljs-keyword">None</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>为3D信号（空域或时空域）施加最大值池化。本层目前只能在使用Theano为后端时可用</p>

<p>参数</p>

<ul>
<li>pool_size：整数或长为3的整数tuple，代表在三个维度上的下采样因子，如取（2，2，2）将使信号在每个维度都变为原来的一半长。</li>
<li>strides：整数或长为3的整数tuple，或者None，步长值。</li>
<li>padding：‘valid’或者‘same’</li>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表数据的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128x128的数据为例，“channels_first”应将数据组织为（3,128,128,128），而“channels_last”应将数据组织为（128,128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
</ul>

<p>输入shape <br>
‘channels_first’模式下，为形如（samples, channels, len_pool_dim1, len_pool_dim2, len_pool_dim3）的5D张量 <br>
‘channels_last’模式下，为形如（samples, len_pool_dim1, len_pool_dim2, len_pool_dim3，channels, ）的5D张量</p>

<p>输出shape <br>
‘channels_first’模式下，为形如（samples, channels, pooled_dim1, pooled_dim2, pooled_dim3）的5D张量 <br>
‘channels_last’模式下，为形如（samples, pooled_dim1, pooled_dim2, pooled_dim3,channels,）的5D张量</p>

<p><strong>3.4、AveragePooling1D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.pooling.AveragePooling1D(pool_size=<span class="hljs-number">2</span>, strides=<span class="hljs-keyword">None</span>, padding=<span class="hljs-string">'valid'</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>对时域1D信号进行平均值池化</p>

<p>参数</p>

<ul>
<li>pool_size：整数，池化窗口大小</li>
<li>strides：整数或None，下采样因子，例如设2将会使得输出shape为输入的一半，若为None则默认值为pool_size。</li>
<li>padding：‘valid’或者‘same’</li>
</ul>

<p>输入shape：形如（samples，steps，features）的3D张量 <br>
输出shape：形如（samples，downsampled_steps，features）的3D张量</p>

<p><strong>3.5、AveragePooling2D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.pooling.AveragePooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), strides=<span class="hljs-keyword">None</span>, padding=<span class="hljs-string">'valid'</span>, data_format=<span class="hljs-keyword">None</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>为空域信号施加平均值池化</p>

<p>参数</p>

<ul>
<li>pool_size：整数或长为2的整数tuple，代表在两个方向（竖直，水平）上的下采样因子，如取（2，2）将使图片在两个维度上均变为原长的一半。为整数意为各个维度值相同且为该数字。</li>
<li>strides：整数或长为2的整数tuple，或者None，步长值。</li>
<li>border_mode：‘valid’或者‘same’</li>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
</ul>

<p>输入shape <br>
‘channels_first’模式下，为形如（samples，channels, rows，cols）的4D张量。 <br>
‘channels_last’模式下，为形如（samples，rows, cols，channels）的4D张量。</p>

<p>输出shape <br>
‘channels_first’模式下，为形如（samples，channels, pooled_rows, pooled_cols）的4D张量。 <br>
‘channels_last’模式下，为形如（samples，pooled_rows, pooled_cols，channels）的4D张量。</p>

<p><strong>3.6、AveragePooling3D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.pooling.AveragePooling3D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>), strides=<span class="hljs-keyword">None</span>, padding=<span class="hljs-string">'valid'</span>, data_format=<span class="hljs-keyword">None</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>为3D信号（空域或时空域）施加平均值池化。本层目前只能在使用Theano为后端时可用</p>

<p>参数</p>

<ul>
<li>pool_size：整数或长为3的整数tuple，代表在三个维度上的下采样因子，如取（2，2，2）将使信号在每个维度都变为原来的一半长。</li>
<li>strides：整数或长为3的整数tuple，或者None，步长值。</li>
<li>padding：‘valid’或者‘same’</li>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表数据的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128x128的数据为例，“channels_first”应将数据组织为（3,128,128,128），而“channels_last”应将数据组织为（128,128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
</ul>

<p>输入shape： <br>
‘channels_first’模式下，为形如（samples, channels, len_pool_dim1, len_pool_dim2, len_pool_dim3）的5D张量 <br>
‘channels_last’模式下，为形如（samples, len_pool_dim1, len_pool_dim2, len_pool_dim3，channels, ）的5D张量</p>

<p>输出shape： <br>
‘channels_first’模式下，为形如（samples, channels, pooled_dim1, pooled_dim2, pooled_dim3）的5D张量 <br>
‘channels_last’模式下，为形如（samples, pooled_dim1, pooled_dim2, pooled_dim3,channels,）的5D张量</p>

<p><strong>3.7、GlobalMaxPooling1D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.pooling</span><span class="hljs-preprocessor">.GlobalMaxPooling</span>1D()<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>对于时间信号的全局最大池化</p>

<p>输入shape：形如（samples，steps，features）的3D张量。 <br>
输出shape：形如(samples, features)的2D张量。</p>

<p><strong>3.8、GlobalAveragePooling1D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering" onclick="mdcp.signin(event)">keras<span class="hljs-preprocessor">.layers</span><span class="hljs-preprocessor">.pooling</span><span class="hljs-preprocessor">.GlobalAveragePooling</span>1D()<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>为时域信号施加全局平均值池化</p>

<p>输入shape：形如（samples，steps，features）的3D张量 <br>
输出shape：形如(samples, features)的2D张量</p>

<p><strong>3.9、GlobalMaxPooling2D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs haskell has-numbering" onclick="mdcp.signin(event)"><span class="hljs-title">keras</span>.layers.pooling.<span class="hljs-type">GlobalMaxPooling2D</span>(dim_ordering='<span class="hljs-default"><span class="hljs-keyword">default</span>')</span>
<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>为空域信号施加全局最大值池化</p>

<p>参数</p>

<ul>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras <br>
1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
</ul>

<p>输入shape： <br>
‘channels_first’模式下，为形如（samples，channels, rows，cols）的4D张量 <br>
‘channels_last’模式下，为形如（samples，rows, cols，channels）的4D张量</p>

<p>输出shape：形如(nb_samples, channels)的2D张量</p>

<p><strong>3.10、GlobalAveragePooling2D层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs haskell has-numbering" onclick="mdcp.signin(event)"><span class="hljs-title">keras</span>.layers.pooling.<span class="hljs-type">GlobalAveragePooling2D</span>(dim_ordering='<span class="hljs-default"><span class="hljs-keyword">default</span>')</span><div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>为空域信号施加全局平均值池化</p>

<p>参数</p>

<ul>
<li>data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras <br>
1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。</li>
</ul>

<p>输入shape： <br>
‘channels_first’模式下，为形如（samples，channels, rows，cols）的4D张量 <br>
‘channels_last’模式下，为形如（samples，rows, cols，channels）的4D张量</p>

<p>输出shape：形如(nb_samples, channels)的2D张量</p>



<h2 id="4局部连接层locallyconnceted"><a name="t4"></a>4、局部连接层LocallyConnceted</h2>



<h2 id="4循环层recurrent"><a name="t5"></a>4、循环层Recurrent</h2>

<p><strong>2.4、递归层（Recurrent）</strong></p>

<p>递归层包含三种模型：LSTM、GRU和SimpleRNN</p>

<p><strong>2.4.1抽象层，不能直接使用</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.recurrent.Recurrent(weights=<span class="hljs-keyword">None</span>, return_sequences=<span class="hljs-keyword">False</span>, go_backwards=<span class="hljs-keyword">False</span>, stateful=<span class="hljs-keyword">False</span>, unroll=<span class="hljs-keyword">False</span>, consume_less=<span class="hljs-string">'cpu'</span>, input_dim=<span class="hljs-keyword">None</span>, input_length=<span class="hljs-keyword">None</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>return_sequences：True返回整个序列，false返回输出序列的最后一个输出</p>

<p>go_backwards：True，逆向处理输入序列，默认为False</p>

<p>stateful：布尔值，默认为False，若为True，则一个batch中下标为i的样本的最终状态将会用作下一个batch同样下标的样本的初始状态</p>

<p><strong>2.4.2、全连接RNN网络</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.recurrent.SimpleRNN(output_dim, init=<span class="hljs-string">'glorot_uniform'</span>, inner_init=<span class="hljs-string">'orthogonal'</span>, activation=<span class="hljs-string">'tanh'</span>, W_regularizer=<span class="hljs-keyword">None</span>, U_regularizer=<span class="hljs-keyword">None</span>, b_regularizer=<span class="hljs-keyword">None</span>, dropout_W=<span class="hljs-number">0.0</span>, dropout_U=<span class="hljs-number">0.0</span>)
<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>inner_init：内部单元的初始化方法</p>

<p>dropout_W：0~1之间的浮点数，控制输入单元到输入门的连接断开比例</p>

<p>dropout_U：0~1之间的浮点数，控制输入单元到递归连接的断开比例</p>

<p><strong>2.4.3、LSTM层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.recurrent.LSTM(output_dim, init=<span class="hljs-string">'glorot_uniform'</span>, inner_init=<span class="hljs-string">'orthogonal'</span>, forget_bias_init=<span class="hljs-string">'one'</span>, activation=<span class="hljs-string">'tanh'</span>, inner_activation=<span class="hljs-string">'hard_sigmoid'</span>, W_regularizer=<span class="hljs-keyword">None</span>, U_regularizer=<span class="hljs-keyword">None</span>, b_regularizer=<span class="hljs-keyword">None</span>, dropout_W=<span class="hljs-number">0.0</span>, dropout_U=<span class="hljs-number">0.0</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>forget_bias_init：遗忘门偏置的初始化函数，Jozefowicz et al.建议初始化为全1元素</p>

<p>inner_activation：内部单元激活函数</p>



<h2 id="嵌入层-embedding"><a name="t6"></a>嵌入层 Embedding</h2>

<p><strong>2.5 Embedding层</strong></p>



<pre class="prettyprint" name="code"><code class="hljs mathematica has-numbering" onclick="mdcp.signin(event)">keras.layers.embeddings.Embedding(input_dim, output_dim, init=<span class="hljs-string">'uniform'</span>, input_length=<span class="hljs-keyword">None</span>, W_regularizer=<span class="hljs-keyword">None</span>, activity_regularizer=<span class="hljs-keyword">None</span>, W_constraint=<span class="hljs-keyword">None</span>, mask_zero=<span class="hljs-keyword">False</span>, weights=<span class="hljs-keyword">None</span>, dropout=<span class="hljs-number">0.0</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>只能作为模型第一层</p>

<p>mask_zero：布尔值，确定是否将输入中的‘0’看作是应该被忽略的‘填充’（padding）值，该参数在使用递归层处理变长输入时有用。设置为True的话，模型中后续的层必须都支持masking，否则会抛出异常</p>



<h2 id="merge层"><a name="t7"></a>Merge层</h2>



<h2 id="网络模型"><a name="t8"></a>网络模型</h2>

<p>网络模型可以将上面定义了各种基本网络层组合起来。</p>

<p>Keras有两种类型的模型，序贯模型（Sequential）和函数式模型（Model），函数式模型应用更为广泛，序贯模型是函数式模型的一种特殊情况。</p>

<p>两类模型有一些方法是相同的：</p>

<p>model的方法：</p>

<p>model.summary() ： 打印出模型概况，它实际调用的是keras.utils.print_summary</p>

<p>model.get_config() ：返回包含模型配置信息的Python字典</p>

<p>model = Model.from_config(config)   模型从它的config信息中重构回去 <br>
model = Sequential.from_config(config)   模型从它的config信息中重构回去</p>

<p>model.get_weights()：返回模型权重张量的列表，类型为numpy array</p>

<p>model.set_weights()：从numpy array里将权重载入给模型</p>

<p>model.to_json：返回代表模型的JSON字符串，仅包含网络结构，不包含权值。可以从JSON字符串中重构原模型：</p>



<pre class="prettyprint" name="code"><code class="hljs python has-numbering" onclick="mdcp.signin(event)"><span class="hljs-keyword">from</span> models <span class="hljs-keyword">import</span> model_from_json

json_string = model.to_json()
model = model_from_json(json_string)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>model.to_yaml：与model.to_json类似，同样可以从产生的YAML字符串中重构模型</p>



<pre class="prettyprint" name="code"><code class="hljs python has-numbering" onclick="mdcp.signin(event)"><span class="hljs-keyword">from</span> models <span class="hljs-keyword">import</span> model_from_yaml

yaml_string = model.to_yaml()
model = model_from_yaml(yaml_string)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>model.save_weights(filepath)：将模型权重保存到指定路径，文件类型是HDF5（后缀是.h5）</p>

<p>model.load_weights(filepath, by_name=False)：从HDF5文件中加载权重到当前模型中, 默认情况下模型的结构将保持不变。如果想将权重载入不同的模型（有些层相同）中，则设置by_name=True，只有名字匹配的层才会载入权重</p>

<p>keras有两种model，分别是Sequential模型和泛型模型</p>

<p><strong>2.1 Sequential模型</strong></p>

<p>Sequential是多个网络层的线性堆叠</p>

<p>可以通过向Sequential模型传递一个layer的list来构造该模型：</p>



<pre class="prettyprint" name="code"><code class="hljs python has-numbering" onclick="mdcp.signin(event)"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense, Activation

model = Sequential([
Dense(<span class="hljs-number">32</span>, input_dim=<span class="hljs-number">784</span>),
Activation(<span class="hljs-string">'relu'</span>),
Dense(<span class="hljs-number">10</span>),
Activation(<span class="hljs-string">'softmax'</span>),
])<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>也可以通过.add()方法一个个的将layer加入模型中：</p>



<pre class="prettyprint" name="code"><code class="hljs livecodeserver has-numbering" onclick="mdcp.signin(event)">model = Sequential()
model.<span class="hljs-built_in">add</span>(Dense(<span class="hljs-number">32</span>, input_dim=<span class="hljs-number">784</span>))
model.<span class="hljs-built_in">add</span>(Activation(<span class="hljs-string">'relu'</span>))<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p>还可以通过merge将两个Sequential模型通过某种方式合并</p>

<p>Sequential模型的方法：</p>



<pre class="prettyprint" name="code"><code class="hljs php has-numbering" onclick="mdcp.signin(event)">compile(<span class="hljs-keyword">self</span>, optimizer, loss, metrics=[], sample_weight_mode=None)

fit(<span class="hljs-keyword">self</span>, x, y, batch_size=<span class="hljs-number">32</span>, nb_epoch=<span class="hljs-number">10</span>, verbose=<span class="hljs-number">1</span>, callbacks=[], validation_split=<span class="hljs-number">0.0</span>, validation_data=None, shuffle=<span class="hljs-keyword">True</span>, class_weight=None, sample_weight=None)

evaluate(<span class="hljs-keyword">self</span>, x, y, batch_size=<span class="hljs-number">32</span>, verbose=<span class="hljs-number">1</span>, sample_weight=None)

<span class="hljs-comment">#按batch获得输入数据对应的输出，函数的返回值是预测值的numpy array</span>
predict(<span class="hljs-keyword">self</span>, x, batch_size=<span class="hljs-number">32</span>, verbose=<span class="hljs-number">0</span>)

<span class="hljs-comment">#按batch产生输入数据的类别预测结果,函数的返回值是类别预测结果的numpy array或numpy</span>
predict_classes(<span class="hljs-keyword">self</span>, x, batch_size=<span class="hljs-number">32</span>, verbose=<span class="hljs-number">1</span>)

<span class="hljs-comment">#本函数按batch产生输入数据属于各个类别的概率，函数的返回值是类别概率的numpy array</span>
predict_proba(<span class="hljs-keyword">self</span>, x, batch_size=<span class="hljs-number">32</span>, verbose=<span class="hljs-number">1</span>)

train_on_batch(<span class="hljs-keyword">self</span>, x, y, class_weight=None, sample_weight=None)

test_on_batch(<span class="hljs-keyword">self</span>, x, y, sample_weight=None)

predict_on_batch(<span class="hljs-keyword">self</span>, x)


fit_generator(<span class="hljs-keyword">self</span>, generator, samples_per_epoch, nb_epoch, verbose=<span class="hljs-number">1</span>, callbacks=[], validation_data=None, nb_val_samples=None, class_weight=None, max_q_size=<span class="hljs-number">10</span>)

evaluate_generator(<span class="hljs-keyword">self</span>, generator, val_samples, max_q_size=<span class="hljs-number">10</span>)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>

<p><strong>2.2 泛型模型</strong></p>

<p>Keras泛型模型接口是：</p>

<p>用户定义多输出模型、非循环有向模型或具有共享层的模型等复杂模型的途径</p>

<p>适用于实现：全连接网络和多输入多输出模型</p>

<p>多输入多输出，官方例子给出：预测一条新闻的点赞转发数，主要输入是新闻本身，还可以加入额外输入，比如新闻发布日期，新闻作者等，具体的实现还是看官网文档吧： <br>
<a href="http://keras-cn.readthedocs.io/en/latest/getting_started/functional_API/" rel="nofollow">http://keras-cn.readthedocs.io/en/latest/getting_started/functional_API/</a></p>

<p>所以感觉这个模型可以针对特定task搞一些创新哦</p>

<p>泛型模型model的属性：</p>

<p>model.layers：组成模型图的各个层 <br>
model.inputs：模型的输入张量列表 <br>
model.outputs：模型的输出张量列表</p>

<p>方法：类似序列模型的方法 <br>
补充get_layer</p>

<p>get_layer(self, name=None, index=None) <br>
本函数依据模型中层的下标或名字获得层对象，泛型模型中层的下标依据自底向上，水平遍历的顺序。</p>

<p>name：字符串，层的名字 <br>
index： 整数，层的下标 <br>
函数的返回值是层对象</p>



<pre class="prettyprint" name="code"><code class="hljs livecodeserver has-numbering" onclick="mdcp.signin(event)"><span class="hljs-built_in">from</span> keras.models import Model
<span class="hljs-built_in">from</span> keras.layers import Input, Dense

<span class="hljs-operator">a</span> = Input(shape=(<span class="hljs-number">32</span>,))
b = Dense(<span class="hljs-number">32</span>)(<span class="hljs-operator">a</span>)
model = Model(inputs=<span class="hljs-operator">a</span>, outputs=b)<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering"></ul></pre>                                    </div>]]></description></item><item><title>NLP（二十四）使用LSTM构建生成式聊天机器人</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/16/nlp_24.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 16 Jul 2019 07:23:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/16/nlp_24.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp24/
+ 准备
数据集：AIML数据集
下载数据集并用Notepad++打开，复制到txt文件中方便打开
+ 代码实现
数据很少，训练轮次不多，结果不好，仅当示例
```
import numpy as np
import pandas as pd

with open('bot.txt','r') as content_file:
    botdata = content_file.read()
Questions = []
Answers = []

for line in botdata.split('</pattern>'):
    if '<pattern>' in line:
        Quesn = line[line.find('<pattern>')+len('<pattern>'):]
        Questions.append(Quesn.lower())
for line in botdata.split('</template>'):
    if '<template>' in line:
        Ans = line[line.find('<template>')+len('<template>'):]
        Answers.append(Ans.lower())
QnAdata = pd.DataFrame(np.column_stack([Questions,Answers]),columns=['Questions','Answers'])
QnAdata['QnAcomb'] = QnAdata['Questions'] + ' ' + QnAdata['Answers']
print(QnAdata[:5])

import nltk
import collections

## 向量化
counter = collections.Counter()
for i in range(len(QnAdata)):
    for word in nltk.word_tokenize(QnAdata.iloc[i][2]):
        counter[word] += 1
word2idx = {w:(i+1) for i,(w,_) in enumerate(counter.most_common())}
idx2word = {v:k for k,v in word2idx.items()}
idx2word[0] = 'PAD'
vocab_size = len(word2idx) + 1
print('\nVocabulary size:',vocab_size)

def encode(sentence, maxlen,vocab_size):
    indices = np.zeros((maxlen, vocab_size))
    for i, w in enumerate(nltk.word_tokenize(sentence)):
        if i == maxlen: break
        indices[i, word2idx[w]] = 1
    return indices

def decode(indices, calc_argmax=True):
    if calc_argmax:
        indices = np.argmax(indices, axis=-1)
    return ' '.join(idx2word[x] for x in indices)

question_maxlen = 10
answer_maxlen = 20

def create_questions(question_maxlen,vocab_size):
    question_idx = np.zeros(shape=(len(Questions),question_maxlen,vocab_size))
    for q in range(len(Questions)):
        question = encode(Questions[q],question_maxlen,vocab_size)
        question_idx[i] = question
    return question_idx

quesns_train = create_questions(question_maxlen=question_maxlen,vocab_size=vocab_size)

def create_answers(answer_maxlen,vocab_size):
    answer_idx = np.zeros(shape=(len(Answers),answer_maxlen,vocab_size))
    for q in range(len(Answers)):
        answer = encode(Answers[q],answer_maxlen,vocab_size)
        answer_idx[i] = answer
    return answer_idx

answs_train = create_answers(answer_maxlen=answer_maxlen,vocab_size=vocab_size)

from keras.layers import Input,Dense,Dropout,Activation
from keras.models import Model
from keras.layers.recurrent import LSTM
from keras.layers.wrappers import Bidirectional
from keras.layers import RepeatVector,TimeDistributed,ActivityRegularization

n_hidden = 128

question_layer = Input(shape=(question_maxlen,vocab_size))

encoder_rnn = LSTM(n_hidden,dropout=0.2,recurrent_dropout=0.2)(question_layer)
# encoder_rnn = Bidirectional(LSTM(n_hidden,dropout=0.2,recurrent_dropout=0.2),merge_mode='concat')(question_layer)
# RNN的双向包装 向前和向后RNN的输出将合并
# merge_mode（合并模型）参数：{'sum', 'mul', 'concat', 'ave', None}

repeat_encode = RepeatVector(answer_maxlen)(encoder_rnn)
# 重复输入n次 shape加了一维 比如(a,b,c)=>(n,a,b,c)

dense_layer = TimeDistributed(Dense(vocab_size))(repeat_encode)
# TimeDistributed和Dense一起使用,
# 在静态形状中查找非特定维度,并用张量的相应动态形状代替它们

regularized_layer = ActivityRegularization(l2=1)(dense_layer)
# 对基于代价函数的输入活动应用更新的层

softmax_layer = Activation('softmax')(regularized_layer)

model = Model([question_layer],[softmax_layer])

model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

print(model.summary())

# 模型训练
quesns_train_2 = quesns_train.astype('float32')
answs_train_2 = answs_train.astype('float32')

model.fit(quesns_train_2, answs_train_2,batch_size=32,epochs=30,validation_split=0.05)

# 模型预测
ans_pred = model.predict(quesns_train_2[0:3])
print(decode(ans_pred[0]))
print(decode(ans_pred[1]))
```]]></description></item><item><title>NLP（二十三）使用LSTM进行语言建模以预测最优词</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/16/nlp_23.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 16 Jul 2019 07:22:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/16/nlp_23.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp23/
+ N元模型
预测要输入的连续词，比如
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190716152044279-1759669643.png)
如果抽取两个连续的词汇，则称之为二元模型
+ 准备工作
数据集使用 Alice in Wonderland
将初始数据提取N-grams
```
import nltk
import string

with open('alice_in_wonderland.txt', 'r') as content_file:
    content = content_file.read()
content2 = " ".join("".join([" " if ch in string.punctuation else ch for ch in content]).split())
tokens = nltk.word_tokenize(content2)
tokens = [word.lower() for word in tokens if len(word)>=2]

N = 3
quads = list(nltk.ngrams(tokens,N))
"""
    Return the ngrams generated from a sequence of items, as an iterator.
    For example:
        >>> from nltk.util import ngrams
        >>> list(ngrams([1,2,3,4,5], 3))
        [(1, 2, 3), (2, 3, 4), (3, 4, 5)]
"""
newl_app = []
for ln in quads:
    new1 = ' '.join(ln)
    newl_app.append(new1)
print(newl_app[:3])
```
输出：
```
['alice adventures in', 'adventures in wonderland', 'in wonderland alice']
```
+ 如何实现
1.预处理：词转换为词向量
2.创建模型和验证：将输入映射到输出的收敛-发散模型（convergent-divergent）
3.预测：最优词预测
+ 代码
```
from __future__ import print_function

from sklearn.model_selection import train_test_split
import nltk
import numpy as np
import string

with open('alice_in_wonderland.txt', 'r') as content_file:
    content = content_file.read()
content2 = " ".join("".join([" " if ch in string.punctuation else ch for ch in content]).split())
tokens = nltk.word_tokenize(content2)
tokens = [word.lower() for word in tokens if len(word)>=2]

N = 3
quads = list(nltk.ngrams(tokens,N))
"""
    Return the ngrams generated from a sequence of items, as an iterator.
    For example:
        >>> from nltk.util import ngrams
        >>> list(ngrams([1,2,3,4,5], 3))
        [(1, 2, 3), (2, 3, 4), (3, 4, 5)]
"""
newl_app = []
for ln in quads:
    new1 = ' '.join(ln)
    newl_app.append(new1)
# print(newl_app[:3])

# 将单词向量化
from sklearn.feature_extraction.text import CountVectorizer
vectorizer = CountVectorizer() # 词=>词向量
"""
    >>> corpus = [
    ...     'This is the first document.',
    ...     'This document is the second document.',
    ...     'And this is the third one.',
    ...     'Is this the first document?',
    ... ]
    >>> vectorizer = CountVectorizer()
    >>> X = vectorizer.fit_transform(corpus)
    >>> print(vectorizer.get_feature_names())
    ['and', 'document', 'first', 'is', 'one', 'second', 'the', 'third', 'this']
    >>> print(X.toarray())  # doctest: +NORMALIZE_WHITESPACE
    [[0 1 1 1 0 0 1 0 1]
     [0 2 0 1 0 1 1 0 1]
     [1 0 0 1 1 0 1 1 1]
     [0 1 1 1 0 0 1 0 1]]
"""

x_trigm = []
y_trigm = []

for l in newl_app:
    x_str = " ".join(l.split()[0:N-1])
    y_str = l.split()[N-1]
    x_trigm.append(x_str)
    y_trigm.append(y_str)

x_trigm_check = vectorizer.fit_transform(x_trigm).todense()
y_trigm_check = vectorizer.fit_transform(y_trigm).todense()

# Dictionaries from word to integer and integer to word
dictnry = vectorizer.vocabulary_
rev_dictnry = {v:k for k,v in dictnry.items()}

X = np.array(x_trigm_check)
Y = np.array(y_trigm_check)

Xtrain, Xtest, Ytrain, Ytest,xtrain_tg,xtest_tg = train_test_split(X, Y,x_trigm, test_size=0.3,random_state=1)

print("X Train shape",Xtrain.shape, "Y Train shape" , Ytrain.shape)
print("X Test shape",Xtest.shape, "Y Test shape" , Ytest.shape)

# Model Building
from keras.layers import Input,Dense,Dropout
from keras.models import Model

np.random.seed(1)

BATCH_SIZE = 128
NUM_EPOCHS = 20

input_layer = Input(shape = (Xtrain.shape[1],),name="input")
first_layer = Dense(1000,activation='relu',name = "first")(input_layer)
first_dropout = Dropout(0.5,name="firstdout")(first_layer)

second_layer = Dense(800,activation='relu',name="second")(first_dropout)

third_layer = Dense(1000,activation='relu',name="third")(second_layer)
third_dropout = Dropout(0.5,name="thirdout")(third_layer)

fourth_layer = Dense(Ytrain.shape[1],activation='softmax',name = "fourth")(third_dropout)


history = Model(input_layer,fourth_layer)
history.compile(optimizer = "adam",loss="categorical_crossentropy",metrics=["accuracy"])

print (history.summary())

# Model Training
history.fit(Xtrain, Ytrain, batch_size=BATCH_SIZE,epochs=NUM_EPOCHS, verbose=1,validation_split = 0.2)

# Model Prediction
Y_pred = history.predict(Xtest)

# 测试
print ("Prior bigram words","|Actual","|Predicted","\n")
import random
NUM_DISPLAY = 10
for i in random.sample(range(len(xtest_tg)),NUM_DISPLAY):
    print (i,xtest_tg[i],"|",rev_dictnry[np.argmax(Ytest[i])],"|",rev_dictnry[np.argmax(Y_pred[i])])
```
输出：
```
X Train shape (17947, 2559) Y Train shape (17947, 2559)
X Test shape (7692, 2559) Y Test shape (7692, 2559)

_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
input (InputLayer)           (None, 2559)              0         
_________________________________________________________________
first (Dense)                (None, 1000)              2560000   
_________________________________________________________________
firstdout (Dropout)          (None, 1000)              0         
_________________________________________________________________
second (Dense)               (None, 800)               800800    
_________________________________________________________________
third (Dense)                (None, 1000)              801000    
_________________________________________________________________
thirdout (Dropout)           (None, 1000)              0         
_________________________________________________________________
fourth (Dense)               (None, 2559)              2561559   
=================================================================
Total params: 6,723,359
Trainable params: 6,723,359
Non-trainable params: 0
_________________________________________________________________
None

Prior bigram words |Actual |Predicted 
595 words don | fit | know
3816 in tone | of | of
5792 queen had | only | been
2757 who seemed | to | to
5393 her and | she | she
4197 heard of | one | its
2464 sneeze were | the | of
1590 done with | said | whiting
3039 and most | things | of
4226 the queen | of | said
```
训练结果不好，因为单词向量维度太大，为2559，相对而言总数据集的单词太少；除了单词预测，还可以字符预测，每碰到一个空格算一个单词]]></description></item><item><title>NLP（二十二）使用LSTM进行语言建模以预测最优词</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/16/nlp_22.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 16 Jul 2019 07:20:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/16/nlp_22.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp22/
+ 预处理
数据集使用Facebook上的BABI数据集
将文件提取成可训练的数据集，包括：文章 问题 答案
```
def get_data(infile):
    stories,questions,answers = [],[],[]
    story_text = []
    fin = open(infile,'rb')
    for line in fin:
        line = line.decode('utf-8').strip()
        lno,text = line.split(' ',1)
        if '\t' in text:
            question,answer,_ = text.split('\t')
            stories.append(story_text)
            questions.append(question)
            answers.append(answer)
            story_text = []
        else:
            story_text.append(text)
    fin.close()
    return stories,questions,answers

data_train = get_data('qa1_single-supporting-fact_train.txt')
data_test = get_data('qa1_single-supporting-fact_test.txt')
print('\nTrain observations:',len(data_train[0]),
      'Test observations:',len(data_test[0]),'\n')
```
输出：
```
Train observations: 10000 Test observations: 1000
```
+ 如何实现
1.预处理：创建字典并将文章，问题和答案映射到词表，进一步映射成向量形式
2.模型创建和验证：训练模型并在验证数据集上测试
3.预测结果：测试集测试数据的结果
+ 代码
```
from __future__ import division,print_function
import collections
import itertools
import nltk
import numpy as np
import matplotlib.pyplot as plt
import os
import random

def get_data(infile):
    stories,questions,answers = [],[],[]
    story_text = []
    fin = open(infile,'rb')
    for line in fin:
        line = line.decode('utf-8').strip()
        lno,text = line.split(' ',1) # 去掉前面的数字标记
        if '\t' in text: # 有制表符的是 问题 和 答案
            question,answer,_ = text.split('\t')
            stories.append(story_text)
            questions.append(question)
            answers.append(answer)
            story_text = []
        else: # 没制表符的是文章
            story_text.append(text)
    fin.close()
    return stories,questions,answers

data_train = get_data('qa1_single-supporting-fact_train.txt')
data_test = get_data('qa1_single-supporting-fact_test.txt')
print('\nTrain observations:',len(data_train[0]),
      'Test observations:',len(data_test[0]),'\n')
print(data_train[0][1],data_train[1][1],data_train[2][1])
# ['Daniel went back to the hallway.', 'Sandra moved to the garden.'] Where is Daniel?  hallway
print(np.array(data_train).shape)
# (3, 10000)

dictnry = collections.Counter() # 返回列表元素出现次数的 字典，这里没有参数是一个空字典
for stories,questions,answers in [data_train,data_test]:
    for story in stories:
        for sent in story:
            for word in nltk.word_tokenize(sent):
                dictnry[word.lower()] += 1
    for question in questions:
        for word in nltk.word_tokenize(question):
            dictnry[word.lower()] += 1
    for answer in answers:
        for word in nltk.word_tokenize(answer):
            dictnry[word.lower()] += 1

word2indx = {w:(i+1) for i,(w,_) in enumerate(dictnry.most_common())} # 按词频排序
word2indx['PAD'] = 0
indx2word = {v:k for k,v in word2indx.items()}

vocab_size = len(word2indx) # 一共有22个不重复单词
print('vocabulary size:',len(word2indx))

story_maxlen = 0
question_maxlen = 0
for stories,questions,answers in [data_train,data_test]:
    for story in stories:
        story_len = 0
        for sent in story:
            swords = nltk.word_tokenize(sent)
            story_len += len(swords)
        if story_len > story_maxlen:
            story_maxlen = story_len
    for question in questions:
        question_len = len(nltk.word_tokenize(question))
        if question_len > question_maxlen:
            question_maxlen = question_len
print('Story maximum length:',story_maxlen,'Question maximum length:',question_maxlen)
# 文章单词最大长度为14，问题中的单词最大长度为4，长度不够的补0，维度相同便于并向计算

from keras.layers import Input
from keras.layers.core import Activation,Dense,Dropout,Permute
from keras.layers.embeddings import Embedding
from keras.layers.merge import add,concatenate,dot
from keras.layers.recurrent import LSTM
from keras.models import Model
from keras.preprocessing.sequence import pad_sequences
from keras.utils import np_utils

def data_vectorization(data,word2indx,story_maxlen,question_maxlen): # 词 => 词向量
    Xs,Xq,Y = [],[],[]
    stories,questions,answers = data
    for story,question,answer in zip(stories,questions,answers):
        xs = [[word2indx[w.lower()] for w in nltk.word_tokenize(s)] for s in story] #
        xs = list(itertools.chain.from_iterable(xs))
        xq = [word2indx[w.lower()] for w in nltk.word_tokenize(question)]
        Xs.append(xs)
        Xq.append(xq)
        Y.append(word2indx[answer.lower()])
    return pad_sequences(Xs,maxlen=story_maxlen),pad_sequences(Xq,maxlen=question_maxlen),\
           np_utils.to_categorical(Y,num_classes=len(word2indx))

Xstrain,Xqtrain,Ytrain = data_vectorization(data_train,word2indx,story_maxlen,question_maxlen)
Xstest,Xqtest,Ytest = data_vectorization(data_test,word2indx,story_maxlen,question_maxlen)
print('Train story',Xstrain.shape,'Train question',Xqtrain.shape,'Train answer',Ytrain.shape)
print('Test story',Xstest.shape,'Test question',Xqtest.shape,'Test answer',Ytest.shape)

# 超参数
EMBEDDING_SIZE = 128
LATENT_SIZE = 64
BATCH_SIZE = 64
NUM_EPOCHS = 40

# 输入层
story_input = Input(shape=(story_maxlen,))
question_input = Input(shape=(question_maxlen,))

# Story encoder embedding
# 将正整数（索引）转换为固定大小的密集向量。
# 例如，[[4]，[20]]->[[0.25，0.1]，[0.6，-0.2]] 此层只能用作模型中的第一层
story_encoder = Embedding(input_dim=vocab_size,output_dim=EMBEDDING_SIZE,input_length=story_maxlen)(story_input)
story_encoder = Dropout(0.2)(story_encoder)

# Question encoder embedding
question_encoder = Embedding(input_dim=vocab_size,output_dim=EMBEDDING_SIZE,input_length=question_maxlen)(question_input)
question_encoder = Dropout(0.3)(question_encoder)

# 返回两个张量的点积
match = dot([story_encoder,question_encoder],axes=[2,2])

# 将故事编码为问题的向量空间
story_encoder_c = Embedding(input_dim=vocab_size,output_dim=question_maxlen,input_length=story_maxlen)(story_input)
story_encoder_c = Dropout(0.3)(story_encoder_c)

# 结合两个向量 match和story_encoder_c
response = add([match,story_encoder_c])
response = Permute((2,1))(response)

# 结合两个向量 response和question_encoder
answer = concatenate([response, question_encoder], axis=-1)
answer = LSTM(LATENT_SIZE)(answer)
answer = Dropout(0.2)(answer)
answer = Dense(vocab_size)(answer)
output = Activation("softmax")(answer)

model = Model(inputs=[story_input, question_input], outputs=output)
model.compile(optimizer="adam", loss="categorical_crossentropy",metrics=["accuracy"])

print(model.summary())

# 模型训练
history = model.fit([Xstrain,Xqtrain],[Ytrain],batch_size=BATCH_SIZE,epochs=NUM_EPOCHS,
                    validation_data=([Xstest,Xqtest],[Ytest]))

# 画出准确率和损失函数
plt.title('Episodic Memory Q&A Accuracy')
plt.plot(history.history['acc'],color='g',label='train')
plt.plot(history.history['val_acc'],color='r',label='validation')
plt.legend(loc='best')
plt.show()

# get predictions of labels

ytest = np.argmax(Ytest, axis=1)
Ytest_ = model.predict([Xstest, Xqtest])
ytest_ = np.argmax(Ytest_, axis=1)

# 随机选择几个问题测试
NUM_DISPLAY = 10
for i in random.sample(range(Xstest.shape[0]),NUM_DISPLAY):
    story = " ".join([indx2word[x] for x in Xstest[i].tolist() if x != 0])
    question = " ".join([indx2word[x] for x in Xqtest[i].tolist()])
    label = indx2word[ytest[i]]
    prediction = indx2word[ytest_[i]]
    print(story, question, label, prediction)
```
输出：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190716151903363-774549510.png)]]></description></item><item><title>NLP（二十一）根据已有文本LSTM自动生成文本</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/16/nlp_21.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 16 Jul 2019 07:17:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/16/nlp_21.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp21/
#### 根据已有文本LSTM自动生成文本
+ 原理
与股票预测类似，用前面的n个字符预测下一个字符
https://www.cnblogs.com/peng8098/p/keras_5.html
+ 代码
```
from __future__ import print_function
import numpy as np
import random
import sys

path = r'shakespeare_final.txt'
text = open(path).read().lower() # 打开文档 读成字符串 然后都变小写
characters = sorted(list(set(text))) # 去掉重复字符 方便下面编码
print('corpus length:',len(text))
print('total chars:',len(characters))

char2indices = dict((c,i) for i,c in enumerate(characters)) # 字符(字母等)=>索引(数字)
indices2char = dict((i,c) for i,c in enumerate(characters)) # 索引(数字)=>字符(字母等)

maxlen = 40 # 40个字符长度预测下一个字符
step = 3 # 一次预测3个
sentences = []
next_chars = []
for i in range(0,len(text)-maxlen,step):
    sentences.append(text[i:i+maxlen])
    next_chars.append(text[i+maxlen])
print('nb sentences:',len(sentences)) # 40个字符串作为特征句子的个数 即训练数据大小

## 构造数据集 类似one-hot编码
X = np.zeros((len(sentences),maxlen,len(characters)),dtype=np.bool)
y = np.zeros((len(sentences),len(characters)),dtype=np.bool)
for i,sentence in enumerate(sentences):
    for t,char in enumerate(sentence):
        X[i,t,char2indices[char]] = 1
    y[i,char2indices[next_chars[i]]] = 1

# 构建神经网路
from keras.models import Sequential
from keras.layers import Dense,LSTM,Activation,Dropout
from keras.optimizers import RMSprop
model = Sequential()
model.add(LSTM(128,input_shape=(maxlen,len(characters))))
model.add(Dense(len(characters)))
model.add(Activation('softmax'))
model.compile(loss='categorical_crossentropy',optimizer=RMSprop(lr=0.01))
print(model.summary())

def pred_indices(preds,metric=1.0):
    preds = np.asarray(preds).astype('float64')
    preds = np.log(preds) / metric
    exp_preds = np.exp(preds)
    preds = exp_preds / np.sum(exp_preds)
    probs = np.random.multinomial(1,preds,1)
    return np.argmax(probs)

for iteration in range(1,30): # 便于观察每一轮的训练结构
    print('-' * 40)
    print('Iteration',iteration)
    model.fit(X,y,batch_size=128,epochs=1)
    start_index = random.randint(0,len(text)-maxlen-1)
    for diversity in [0.2,0.7,1.2]:
        print('\n----- diversity:',diversity)
        generated = ''
        sentence = text[start_index:start_index+maxlen]
        generated += sentence
        print('----- Generating with seed: "'+sentence+'"')
        sys.stdout.write(generated)
        for i in range(400):
            x = np.zeros((1,maxlen,len(characters)))
            for t,char in enumerate(sentence): # 数字索引=>字母
                x[0,t,char2indices[char]] = 1
            preds = model.predict(x,verbose=0)[0]
            next_index = pred_indices(preds,diversity)
            pred_char = indices2char[next_index]
            generated += pred_char
            sentence = sentence[1:] + pred_char
            sys.stdout.write(pred_char)
            sys.stdout.flush()
        print('\nOne combination completed \n')
```
输出：
```
corpus length: 581432
total chars: 61
nb sentences: 193798
Using TensorFlow backend.
WARNING:tensorflow:From D:\Anaconda3\lib\site-packages\tensorflow\python\framework\op_def_library.py:263: colocate_with (from tensorflow.python.framework.ops) is deprecated and will be removed in a future version.
Instructions for updating:
Colocations handled automatically by placer.
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
lstm_1 (LSTM)                (None, 128)               97280     
_________________________________________________________________
dense_1 (Dense)              (None, 61)                7869      
_________________________________________________________________
activation_1 (Activation)    (None, 61)                0         
=================================================================
Total params: 105,149
Trainable params: 105,149
Non-trainable params: 0
_________________________________________________________________
None
----------------------------------------
Iteration 1
WARNING:tensorflow:From D:\Anaconda3\lib\site-packages\tensorflow\python\ops\math_ops.py:3066: to_int32 (from tensorflow.python.ops.math_ops) is deprecated and will be removed in a future version.
Instructions for updating:
Use tf.cast instead.
Epoch 1/1
2019-07-15 17:04:03.721908: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX AVX2
2019-07-15 17:04:04.438003: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1433] Found device 0 with properties: 
name: GeForce GTX 950M major: 5 minor: 0 memoryClockRate(GHz): 1.124
pciBusID: 0000:01:00.0
totalMemory: 2.00GiB freeMemory: 1.64GiB
2019-07-15 17:04:04.438676: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1512] Adding visible gpu devices: 0
2019-07-15 17:04:07.352274: I tensorflow/core/common_runtime/gpu/gpu_device.cc:984] Device interconnect StreamExecutor with strength 1 edge matrix:
2019-07-15 17:04:07.352543: I tensorflow/core/common_runtime/gpu/gpu_device.cc:990]      0 
2019-07-15 17:04:07.352701: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1003] 0:   N 
2019-07-15 17:04:07.357455: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1115] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 1386 MB memory) -> physical GPU (device: 0, name: GeForce GTX 950M, pci bus id: 0000:01:00.0, compute capability: 5.0)
2019-07-15 17:04:08.415227: I tensorflow/stream_executor/dso_loader.cc:152] successfully opened CUDA library cublas64_100.dll locally

   128/193798 [..............................] - ETA: 2:16:56 - loss: 4.1095
   256/193798 [..............................] - ETA: 1:09:23 - loss: 3.6938
   384/193798 [..............................] - ETA: 46:52 - loss: 3.8312 
   。。。
```]]></description></item><item><title>Keras（五）LSTM 长短期记忆模型 原理及实例</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/13/keras_5.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 13 Jul 2019 02:49:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/13/keras_5.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/keras6/
+ LSTM 是 long-short term memory 的简称, 中文叫做 长短期记忆. 是当下最流行的 RNN 形式之一
+ RNN 的弊端
RNN没有长久的记忆，比如一个句子太长时开头部分可能会忘记，从而给出错误的答案。
时间远的记忆要进过长途跋涉才能抵达最后一个时间点. 然后我们得到误差, 而且在 反向传递 得到的误差的时候, 他在每一步都会 乘以一个自己的参数 W. 如果这个 W 是一个小于1 的数, 比如0.9. 这个0.9 不断乘以误差, 误差传到初始时间点也会是一个接近于零的数, 所以对于初始时刻, 误差相当于就消失了. 我们把这个问题叫做梯度消失或者梯度弥散 Gradient vanishing. 反之如果 W 是一个大于1 的数, 比如1.1 不断累乘, 则到最后变成了无穷大的数, RNN被这无穷大的数撑死了, 这种情况我们叫做梯度爆炸, Gradient exploding. 这就是普通 RNN 没有办法回忆起久远记忆的原因。
+ LSTM网络
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190711170403994-977622735.png)
在上图中，每一行携带一个完整的向量，从一个节点的输出到另一个节点的输入。粉红的圆圈代表逐点操作，如矢量加法，而黄色的方框是学习神经网络层。行合并表示连接，而行分叉表示复制的内容以及复制到不同位置的内容。 
+ 核心理念
LSTM的关键是单元状态，即贯穿图顶部的水平线。单元状态有点像传送带。它沿着整个链条直行，只有一些微小的线性相互作用。信息很容易保持不变地沿着它流动。 
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190711170418171-1356638009.png)
LSTM可以去除或增加单元状态的信息,并被称为门(gates)的结构仔细调控，它们由一个sigmoid神经网络层和一个逐点乘法运算组成。sigmoid输出层的输出介于0和1之间的数字，描述每个组件应该通过多少，0表示不让任何东西通过，1表示可以通过。
+ 遗忘门
遗忘门（forget gate）顾名思义，是控制是否遗忘的，在LSTM中即以一定的概率控制是否遗忘上一层的隐藏细胞状态。遗忘门子结构如下图：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190711170431679-1219573301.png)
图中输入的有上一序列的隐藏状态h(t−1)和本序列数据x(t)，通过一个激活函数，一般是sigmoid，得到遗忘门的输出f(t)。由于sigmoid的输出f(t)在[0,1]之间，因此这里的输出f^{(t)}代表了遗忘上一层隐藏细胞状态的概率。用数学表达式即为：
`f(t)=σ(Wfh(t−1)+Ufx(t)+bf)f(t)=σ(Wfh(t−1)+Ufx(t)+bf)`
其中Wf,Uf,bfWf,Uf,bf为线性关系的系数和偏倚，和RNN中的类似，σ为sigmoid激活函数。
+ 输入门
输入门（input gate）负责处理当前序列位置的输入，它的子结构如下图：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190711170456356-2053745831.png)
从图中可以看到输入门由两部分组成，第一部分使用了sigmoid激活函数，输出为i(t),第二部分使用了tanh激活函数，输出为a(t), 两者的结果后面会相乘再去更新细胞状态。用数学表达式即为：
`i(t)=σ(Wih(t−1)+Uix(t)+bi)i(t)=σ(Wih(t−1)+Uix(t)+bi)`
`a(t)=tanh(Wah(t−1)+Uax(t)+ba)a(t)=tanh(Wah(t−1)+Uax(t)+ba)`
其中Wi,Ui,bi,Wa,Ua,ba,Wi,Ui,bi,Wa,Ua,ba,为线性关系的系数和偏倚，和RNN中的类似，σσ为sigmoid激活函数。
+ 细胞状态更新
在研究LSTM输出门之前，我们要先看看LSTM之细胞状态。前面的遗忘门和输入门的结果都会作用于细胞状态C(t)。我们来看看从细胞状态C(t−1)如何得到C(t)。如下图所示：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190711170511263-2084888223.png)
细胞状态C(t)由两部分组成，第一部分是C(t−1)和遗忘门输出f(t)f(t)的乘积，第二部分是输入门的i(t)和a(t)的乘积，即：
`C(t)=C(t−1)⊙f(t)+i(t)⊙a(t)C(t)=C(t−1)⊙f(t)+i(t)⊙a(t)`
其中，⊙为Hadamard积（对应位置相乘），在DNN中也用到过。
+ 输出门
有了新的隐藏细胞状态C(t)，我们就可以来看输出门了，子结构如下：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190711170529998-1945939906.png)
从图中可以看出，隐藏状态h(t)的更新由两部分组成，第一部分是o(t), 它由上一序列的隐藏状态h(t−1)和本序列数据x(t)，以及激活函数sigmoid得到，第二部分由隐藏状态C(t)和tanh激活函数组成, 即：
`o(t)=σ(Woh(t−1)+Uox(t)+bo)o(t)=σ(Woh(t−1)+Uox(t)+bo)`
`h(t)=o(t)⊙tanh(C(t))h(t)=o(t)⊙tanh(C(t))`
通过本节的剖析，相信大家对于LSTM的模型结构已经有了解了。当然，有些LSTM的结构和上面的LSTM图稍有不同，但是原理是完全一样的。
+ LSTM前向传播算法
LSTM模型有两个隐藏状态h(t),C(t)，模型参数几乎是RNN的4倍，因为现在多了Wf,Uf,bf,Wa,Ua,ba,Wi,Ui,bi,Wo,Uo,boWf,Uf,bf,Wa,Ua,ba,Wi,Ui,bi,Wo,Uo,bo这些参数。
前向传播过程在每个序列索引位置的过程为：
1）更新遗忘门输出：
`f(t)=σ(Wfh(t−1)+Ufx(t)+bf)f(t)=σ(Wfh(t−1)+Ufx(t)+bf)`
2）更新输入门两部分输出：
`i(t)=σ(Wih(t−1)+Uix(t)+bi)i(t)=σ(Wih(t−1)+Uix(t)+bi)`
`a(t)=tanh(Wah(t−1)+Uax(t)+ba)a(t)=tanh(Wah(t−1)+Uax(t)+ba)`
3）更新细胞状态：
`C(t)=C(t−1)⊙f(t)+i(t)⊙a(t)C(t)=C(t−1)⊙f(t)+i(t)⊙a(t)`
4）更新输出门输出：
`o(t)=σ(Woh(t−1)+Uox(t)+bo)o(t)=σ(Woh(t−1)+Uox(t)+bo)`
`h(t)=o(t)⊙tanh(C(t))h(t)=o(t)⊙tanh(C(t))`
5）更新当前序列索引预测输出：
`ŷ (t)=σ(Vh(t)+c)y^(t)=σ(Vh(t)+c)`
+ LSTM反向传播算法
有了LSTM前向传播算法，推导反向传播算法就很容易了， 思路和RNN的反向传播算法思路一致，也是通过梯度下降法迭代更新我们所有的参数，关键点在于计算所有参数基于损失函数的偏导数。
在RNN中，为了反向传播误差，我们通过隐藏状态h(t)的梯度δ(t)一步步向前传播。在LSTM这里也类似，只不过我们这里有两个隐藏状态h(t)和C(t)，这里我们定义两个δ，即：
`δ(t)h=∂L∂h(t)δh(t)=∂L∂h(t)`
`δ(t)C=∂L∂C(t)δC(t)=∂L∂C(t)`
反向传播时只使用了δ(t)CδC(t),变量δ(t)hδh(t)仅为帮助我们在某一层计算用，并没有参与反向传播，这里要注意。如下图所示：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190711170545023-1999104135.png)
而在最后的序列索引位置ττ的δ(τ)hδh(τ)和 δ(τ)CδC(τ)为：
`δ(τ)h=∂L∂O(τ)∂O(τ)∂h(τ)=VT(ŷ (τ)−y(τ))δh(τ)=∂L∂O(τ)∂O(τ)∂h(τ)=VT(y^(τ)−y(τ))`
`δ(τ)C=∂L∂h(τ)∂h(τ)∂C(τ)=δ(τ)h⊙o(τ)⊙(1−tanh2(C(τ)))δC(τ)=∂L∂h(τ)∂h(τ)∂C(τ)=δh(τ)⊙o(τ)⊙(1−tanh2(C(τ)))`
接着我们由δ(t+1)CδC(t+1)反向推导δ(t)CδC(t)。
δ(t)hδh(t)的梯度由本层的输出梯度误差决定，即：
`δ(t)h=∂L∂h(t)=VT(ŷ (t)−y(t))δh(t)=∂L∂h(t)=VT(y^(t)−y(t))`
而δ(t)CδC(t)的反向梯度误差由前一层δ(t+1)CδC(t+1)的梯度误差和本层的从h(t)h(t)传回来的梯度误差两部分组成，即：
`δ(t)C=∂L∂C(t+1)∂C(t+1)∂C(t)+∂L∂h(t)∂h(t)∂C(t)=δ(t+1)C⊙f(t+1)+δ(t)h⊙o(t)⊙(1−tanh2(C(t)))`
`δC(t)=∂L∂C(t+1)∂C(t+1)∂C(t)+∂L∂h(t)∂h(t)∂C(t)=δC(t+1)⊙f(t+1)+δh(t)⊙o(t)⊙(1−tanh2(C(t)))`
有了δ(t)hδh(t)和δ(t)CδC(t)， 计算这一大堆参数的梯度就很容易了，这里只给出WfWf的梯度计算过程，其他的Uf,bf,Wa,Ua,ba,Wi,Ui,bi,Wo,Uo,bo，V,cUf,bf,Wa,Ua,ba,Wi,Ui,bi,Wo,Uo,bo，V,c的梯度大家只要照搬就可以了。
`∂L∂Wf=∑t=1τ∂L∂C(t)∂C(t)∂f(t)∂f(t)∂Wf=∑t=1τδ(t)C⊙C(t−1)⊙f(t)⊙(1−f(t))(h(t−1))`
`T∂L∂Wf=∑t=1τ∂L∂C(t)∂C(t)∂f(t)∂f(t)∂Wf=∑t=1τδC(t)⊙C(t−1)⊙f(t)⊙(1−f(t))(h(t−1))T`
### LSTM 实例
```
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# 加载数据集
dataset_train = pd.read_csv('平安银行.csv',encoding='gb18030')
training_set = dataset_train.iloc[:,1:2].values
print(dataset_train.head()) # 查看一下数据的格式

# 特征缩放
from sklearn.preprocessing import MinMaxScaler
sc = MinMaxScaler(feature_range=(0,1))
training_set_scaled = sc.fit_transform(training_set)

# 使用Timesteps创建数据
X_train = []
y_train = []
for i in range(60, 2035):
    X_train.append(training_set_scaled[i-60:i, 0]) # 训练集为早60个的数据
    y_train.append(training_set_scaled[i, 0])
X_train, y_train = np.array(X_train), np.array(y_train)

X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))

# 构建LSTM
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.layers import Dropout

regressor = Sequential()

regressor.add(LSTM(units = 50, return_sequences = True, input_shape = (X_train.shape[1], 1)))
regressor.add(Dropout(0.2))

regressor.add(LSTM(units = 50, return_sequences = True))
regressor.add(Dropout(0.2))

regressor.add(LSTM(units = 50, return_sequences = True))
regressor.add(Dropout(0.2))

regressor.add(LSTM(units = 50))
regressor.add(Dropout(0.2))

regressor.add(Dense(units = 1))

regressor.compile(optimizer = 'adam', loss = 'mean_squared_error')

regressor.fit(X_train, y_train, epochs = 20, batch_size = 32)

# 预测未来的股票
dataset_test = pd.read_csv('平安银行.csv',encoding='gb18030')
y_test = dataset_test.iloc[:, 1:2].values

dataset_total = pd.concat((dataset_train['开盘价(元)'], dataset_test['开盘价(元)']), axis = 0)
inputs = dataset_total[len(dataset_total) - len(dataset_test) - 60:].values
inputs = inputs.reshape(-1,1)
inputs = sc.transform(inputs)
X_test = []
for i in range(60, 76):
    X_test.append(inputs[i-60:i, 0])
X_test = np.array(X_test)
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))
y_pred = regressor.predict(X_test)
predicted_stock_price = sc.inverse_transform(y_pred)

# 可视化
plt.plot(y_test, color = 'black', label = 'SZ000001 Price')
plt.plot(y_pred, color = 'green', label = 'Predicted SZ000001 Price')
plt.title('SZ000001 Price Prediction')
plt.xlabel('Time')
plt.ylabel('SZ000001 Price')
plt.legend()
plt.show()
```
输出：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190713104830637-602107542.png)]]></description></item><item><title>Keras（六）Autoencoder 自编码 原理及实例 Save&amp;reload 模型的保存和提取</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/13/keras_6.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 13 Jul 2019 02:49:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/13/keras_6.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/keras7/
### Autoencoder 自编码
+ 压缩与解压
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190711170826653-1083383433.png)
原来有时神经网络要接受大量的输入信息, 比如输入信息是高清图片时, 输入信息量可能达到上千万, 让神经网络直接从上千万个信息源中学习是一件很吃力的工作. 所以, 何不压缩一下, 提取出原图片中的最具代表性的信息, 缩减输入信息量, 再把缩减过后的信息放进神经网络学习. 这样学习起来就简单轻松了. 所以, 自编码就能在这时发挥作用. 通过将原数据白色的X 压缩, 解压 成黑色的X, 然后通过对比黑白 X ,求出预测误差, 进行反向传递, 逐步提升自编码的准确性. 训练好的自编码中间这一部分就是能总结原数据的精髓. 可以看出, 从头到尾, 我们只用到了输入数据 X, 并没有用到 X 对应的数据标签, 所以也可以说自编码是一种非监督学习. 到了真正使用自编码的时候. 通常只会用到自编码前半部分
+ Encoder 编码器
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190711170837715-2049032251.png)
编码器能得到原数据的精髓, 然后我们只需要再创建一个小的神经网络学习这个精髓的数据,不仅减少了神经网络的负担, 而且同样能达到很好的效果
自编码能从原数据中总结出每种类型数据的特征, 如果把这些特征类型都放在一张二维的图片上, 每种类型都已经被很好的用原数据的精髓区分开来. 如果你了解 PCA 主成分分析, 再提取主要特征时, 自编码和它一样,甚至超越了 PCA. 换句话说, 自编码 可以像 PCA 一样 给特征属性降维
+ Decoder 解码器
将精髓信息解压成原始信息
+ 实例
把 datasets.mnist 数据的 28×28＝784 维的数据，压缩成 2 维的数据，然后在一个二维空间中可视化出分类的效果
```
import numpy as np
np.random.seed(1)
from keras.datasets import mnist
from keras.models import Model
from keras.layers import Dense, Input
import matplotlib.pyplot as plt

# 获取数据 非监督学习 不用y
(x_train, _), (x_test, y_test) = mnist.load_data()

# 预处理
x_train = x_train.astype('float32') / 255. - 0.5 # 标准化 -0.5~0.5
x_test = x_test.astype('float32') / 255. - 0.5
x_train = x_train.reshape((x_train.shape[0], -1))
x_test = x_test.reshape((x_test.shape[0], -1))
# print(x_train.shape)
# print(x_test.shape)

# 要压成的维度
encoding_dim = 2

# 原来的图片数据大小
input_img = Input(shape=(784,))

## 建立神经网路
# 编码层
encoded = Dense(128, activation='relu')(input_img)
encoded = Dense(64, activation='relu')(encoded)
encoded = Dense(10, activation='relu')(encoded)
encoder_output = Dense(encoding_dim)(encoded)
# 解码层
decoded = Dense(10, activation='relu')(encoder_output)
decoded = Dense(64, activation='relu')(decoded)
decoded = Dense(128, activation='relu')(decoded)
decoded = Dense(784, activation='tanh')(decoded)
# 构建自动编码模型
autoencoder = Model(input=input_img, output=decoded)

# 激活模型
autoencoder.compile(optimizer='adam', loss='mse')

# 训练 非监督学习 经历压缩和解压的自己跟原来的自己比较
autoencoder.fit(x_train, x_train,epochs=20,batch_size=256,shuffle=True)

# 可视化结果
encoded_imgs = autoencoder.predict(x_test)
plt.scatter(encoded_imgs[:, 0], encoded_imgs[:, 1], c=y_test)
plt.colorbar()
plt.show()
```
输出：
```
Epoch 1/20

  256/60000 [..............................] - ETA: 1:41 - loss: 0.2318
 1280/60000 [..............................] - ETA: 22s - loss: 0.2211 
。。。
59648/60000 [============================>.] - ETA: 0s - loss: 0.0393
60000/60000 [==============================] - 2s 41us/step - loss: 0.0393
```
### Save&reload 保存提取
+ 保存模型
训练完模型之后
`from keras.models import save_model`
`model.save('my_model.h5)`
+ 导入模型
导入保存好的模型
`from keras.models import load_model`
`model = load_model(my_model.h5)`
还可以只保存权重，不保存模型结构
`model.save_weights('my_model_weights.h5')`
`model.load_weights('my_model_weights.h5')`
还可以用model.to_json 保存完结构之后，然后再去加载这个json_string，只保存结构，没保存权重
`from keras.models import model_from_json`
`json_string = model.to_json()`
`model = model_from_json(json_string)`]]></description></item><item><title>NLP（二十） 利用词向量实现高维词在二维空间的可视化</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/11/nlp_20.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 11 Jul 2019 12:54:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/11/nlp_20.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp20/
+ 准备
Alice in Wonderland数据集可用于单词抽取，结合稠密网络可实现其单词的可视化，这与编码器-解码器架构类似。
+ 代码
```
from __future__ import print_function
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
import matplotlib.pyplot as plt
import nltk
import numpy as np
import pandas as pd
import random
from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
import string
from nltk import pos_tag
from nltk.stem import PorterStemmer

def preprocessing(text):
    text2 = " ".join("".join([" " if ch in string.punctuation else ch for ch in text]).split())
    tokens = [word for sent in nltk.sent_tokenize(text2) for word in nltk.word_tokenize(sent)]
    tokens = [word.lower() for word in tokens]
    stopwds = stopwords.words('english')
    tokens = [token for token in tokens if token not in stopwds]
    tokens = [word for word in tokens if len(word)>=3]
    stemmer = PorterStemmer()
    tokens = [stemmer.stem(word) for word in tokens]
    tagged_corpus = pos_tag(tokens)
    Noun_tags = ['NN','NNP','NNPS','NNS']
    Verb_tags = ['VB','VBD','VBG','VBN','VBP','VBZ']
    lemmatizer = WordNetLemmatizer()

    def prat_lemmatize(token,tag):
        if tag in Noun_tags:
            return lemmatizer.lemmatize(token,'n')
        elif tag in Verb_tags:
            return lemmatizer.lemmatize(token,'v')
        else:
            return lemmatizer.lemmatize(token,'n')

    pre_proc_text =  " ".join([prat_lemmatize(token,tag) for token,tag in tagged_corpus])
    return pre_proc_text

lines = []
fin = open("alice_in_wonderland.txt", "r") # fin = open("alice_in_wonderland.txt", "rb")
for line in fin:
    # line = line.strip().decode("ascii", "ignore").encode("utf-8")
    if len(line) == 0:
        continue
    lines.append(preprocessing(line))
fin.close()

import collections
counter = collections.Counter()

for line in lines:
    for word in nltk.word_tokenize(line):
        counter[word.lower()]+=1

word2idx = {w:(i+1) for i,(w,_) in enumerate(counter.most_common())}
idx2word = {v:k for k,v in word2idx.items()}

xs = []
ys = []

for line in lines:
    embedding = [word2idx[w.lower()] for w in nltk.word_tokenize(line)]
    triples = list(nltk.trigrams(embedding))
    w_lefts = [x[0] for x in triples]
    w_centers = [x[1] for x in triples]
    w_rights = [x[2] for x in triples]
    xs.extend(w_centers)
    ys.extend(w_lefts)
    xs.extend(w_centers)
    ys.extend(w_rights)

print (len(word2idx))

vocab_size = len(word2idx)+1

ohe = OneHotEncoder(n_values=vocab_size)
X = ohe.fit_transform(np.array(xs).reshape(-1, 1)).todense()
Y = ohe.fit_transform(np.array(ys).reshape(-1, 1)).todense()
Xtrain, Xtest, Ytrain, Ytest,xstr,xsts = train_test_split(X, Y,xs, test_size=0.3,random_state=42)
print(Xtrain.shape, Xtest.shape, Ytrain.shape, Ytest.shape)

from keras.layers import Input,Dense,Dropout
from keras.models import Model

np.random.seed(1)

BATCH_SIZE = 128
NUM_EPOCHS = 1

input_layer = Input(shape = (Xtrain.shape[1],),name="input")
first_layer = Dense(300,activation='relu',name = "first")(input_layer)
first_dropout = Dropout(0.5,name="firstdout")(first_layer)

second_layer = Dense(2,activation='relu',name="second")(first_dropout)

third_layer = Dense(300,activation='relu',name="third")(second_layer)
third_dropout = Dropout(0.5,name="thirdout")(third_layer)

fourth_layer = Dense(Ytrain.shape[1],activation='softmax',name = "fourth")(third_dropout)

history = Model(input_layer,fourth_layer)
history.compile(optimizer = "rmsprop",loss="categorical_crossentropy",metrics=["accuracy"])

history.fit(Xtrain, Ytrain, batch_size=BATCH_SIZE,epochs=NUM_EPOCHS, verbose=1,validation_split = 0.2)

# Extracting Encoder section of the Model for prediction of latent variables
encoder = Model(history.input,history.get_layer("second").output)

# Predicting latent variables with extracted Encoder model
reduced_X = encoder.predict(Xtest)

final_pdframe = pd.DataFrame(reduced_X)
final_pdframe.columns = ["xaxis","yaxis"]
final_pdframe["word_indx"] = xsts
final_pdframe["word"] = final_pdframe["word_indx"].map(idx2word)

rows = random.sample(list(final_pdframe.index), 100)
vis_df = final_pdframe.loc[rows]

labels = list(vis_df["word"])
xvals = list(vis_df["xaxis"])
yvals = list(vis_df["yaxis"])

plt.figure(figsize=(10, 10))

for i, label in enumerate(labels):
    x = xvals[i]
    y = yvals[i]
    plt.scatter(x, y)
    plt.annotate(label,xy=(x, y),xytext=(5, 2),textcoords='offset points',ha='right',va='bottom')

plt.xlabel("Dimension 1")
plt.ylabel("Dimension 2")
plt.show()
```
输出：不是二维的，为什么！！！看了两天不明白！
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190711205238958-1438888733.png)]]></description></item><item><title>TypeError: 'in ' requires string as left operand, not int</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/11/11171596.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 11 Jul 2019 09:46:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/11/11171596.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/bug11/
+ 报错
```
Traceback (most recent call last):
  File "D:/PyCharm 5.0.3/WorkSpace/2.NLP/9.DL在NLP中的应用/4. VectorizerVisualization.py", line 45, in <module>
    lines.append(preprocessing(line))
  File "D:/PyCharm 5.0.3/WorkSpace/2.NLP/9.DL在NLP中的应用/4. VectorizerVisualization.py", line 18, in preprocessing
    text2 = ' '.join(' '.join([' ' if ch in string.punctuation else ch for ch in text]).split())
  File "D:/PyCharm 5.0.3/WorkSpace/2.NLP/9.DL在NLP中的应用/4. VectorizerVisualization.py", line 18, in <listcomp>
    text2 = ' '.join(' '.join([' ' if ch in string.punctuation else ch for ch in text]).split())
TypeError: 'in <string>' requires string as left operand, not int
```
+ 原因
需要字符串作为左操作数，而不是int 
+ 解决
`line = line.strip().decode("ascii", "ignore").encode("utf-8")`
这句话不知道为什么有问题，所以将打开文件的`'rb'`改成`'r'`,并注释掉了这句话]]></description></item><item><title>Keras（四）CNN 卷积神经网络 RNN 循环神经网络 原理及实例</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/11/keras_4.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 11 Jul 2019 06:36:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/11/keras_4.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/keras5/
### CNN 卷积神经网络
+ 卷积 池化
https://www.cnblogs.com/peng8098/p/nlp_16.html 中有介绍
+ 以数据集MNIST构建一个卷积神经网路
```
from keras.layers import Dense,Activation,Conv2D,MaxPooling2D,Flatten
from keras.models import Model,Sequential
from keras.datasets import mnist
from keras.utils import np_utils

# 构建数据集
(x_train,y_train),(x_test,y_test) = mnist.load_data()
x_train = x_train.reshape(x_train.shape[0],1,28,28)/255
x_test = x_test.reshape(x_test.shape[0],1,28,28)/255
y_train = np_utils.to_categorical(y_train,num_classes=10)
y_test = np_utils.to_categorical(y_test,num_classes=10)
print(x_train[0].shape)
print(y_train[:3])

## 构建模型
model = Sequential()

# 第一层 卷积层
model.add(Conv2D(
    # input_shape=(60000,1,28,28),
    batch_input_shape=(32,1,28,28), # 输入数据的shape
    filters=32, # 滤波器数量为32
    kernel_size=5,
    strides=1,
    padding='same', # same即不改变原来数据的长度和宽度
    data_format='channels_first'
))
model.add(Activation('relu')) # 激励函数为relu

# 第二层 池化层
model.add(MaxPooling2D(
    pool_size=2, # 分辨率长宽各降低一半，输出数据shape为（32，14，14）
    strides=2,
    padding='same',
    data_format='channels_first'
))

# 再加一遍卷积层和池化层 输出数据shape为（64，7，7）
model.add(Conv2D(64, 5, strides=1, padding='same', data_format='channels_first'))
model.add(Activation('relu'))
model.add(MaxPooling2D(2, 2, 'same', data_format='channels_first'))

# 将数据抹平 再加一层全连接层
model.add(Flatten())
model.add(Dense(1024))
model.add(Activation('relu'))

# 再加一层全连接层 作为输出层
model.add(Dense(10))
model.add(Activation('softmax'))

# 设置adam优化方法，loss函数, metrics方法来观察输出结果
model.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])

# 训练模型
model.fit(x_train, y_train, epochs=1, batch_size=32)

# 预测
loss,accuracy = model.evaluate(x_test,y_test)
print('test loss:',loss)
print('test accuracy:',accuracy)
```
输出：
```
Epoch 1/1

   32/60000 [..............................] - ETA: 31:05 - loss: 2.2981 - acc: 0.1562
   64/60000 [..............................] - ETA: 19:05 - loss: 2.2658 - acc: 0.2344

   32/10000 [..............................] - ETA: 35s
   96/10000 [..............................] - ETA: 21s
   
test loss: 0.03328929296457209
test accuracy: 0.9897
```
### RNN 循环神经网络
+ 序列数据
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190711143523083-1918308518.png)
我们想象现在有一组序列数据 data 0,1,2,3. 在当预测 result0 的时候,我们基于的是 data0, 同样在预测其他数据的时候, 我们也都只单单基于单个的数据. 每次使用的神经网络都是同一个 NN. 不过这些数据是有关联 顺序的 , 就像在厨房做菜, 酱料 A要比酱料 B 早放, 不然就串味了. 所以普通的神经网络结构并不能让 NN 了解这些数据之间的关联
+ 处理序列数据的神经网路
最基本的方式,就是记住之前发生的事情. 那我们让神经网络也具备这种记住之前发生的事的能力. 再分析 Data0 的时候, 我们把分析结果存入记忆. 然后当分析 data1的时候, NN会产生新的记忆, 但是新记忆和老记忆是没有联系的. 我们就简单的把老记忆调用过来, 一起分析. 如果继续分析更多的有序数据 , RNN就会把之前的记忆都累积起来, 一起分析
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190711143540067-1381424020.png)
每次 RNN 运算完之后都会产生一个对于当前状态的描述 , state. 我们用简写 S( t) 代替, 然后这个 RNN开始分析 x(t+1) , 他会根据 x(t+1)产生s(t+1), 不过此时 y(t+1) 是由 s(t) 和 s(t+1) 共同创造的. 所以我们通常看到的 RNN 也可以表达成这种样子
#### RNN Classifier 实例
+ 依然使用MNIST数据集
```
import numpy as np
np.random.seed(1)

from keras.datasets import mnist
from keras.utils import np_utils
from keras.models import Sequential
from keras.layers import SimpleRNN, Activation, Dense
from keras.optimizers import Adam

# 超参数
TIME_STEPS = 28
INPUT_SIZE = 28
BATCH_INDEX = 0 # 从第0个开始训练
BATCH_SIZE = 50 # 一个batch50个数据
CELL_SIZE = 50 # 输出50个神经元
OUTPUT_SIZE = 10 # 输出10个类：0~9
LR = 0.001 # 学习速度

(x_train, y_train), (x_test, y_test) = mnist.load_data()

# data pre-processing
x_train = x_train.reshape(-1, 28, 28) / 255.      # 标准化
x_test = x_test.reshape(-1, 28, 28) / 255.
y_train = np_utils.to_categorical(y_train, num_classes=10)
y_test = np_utils.to_categorical(y_test, num_classes=10)

## 搭建模型
model = Sequential()

# 添加RNN层
model.add(SimpleRNN(
    batch_input_shape=(None, TIME_STEPS, INPUT_SIZE),
    output_dim=CELL_SIZE,
    unroll=True,
))

# 添加输出层
model.add(Dense(OUTPUT_SIZE))
model.add(Activation('softmax'))

# 设置优化器
adam = Adam(LR)
model.compile(optimizer=adam,loss='categorical_crossentropy',metrics=['accuracy'])

# 训练
for step in range(40001):
    X_batch = x_train[BATCH_INDEX: BATCH_INDEX+BATCH_SIZE, :, :]
    Y_batch = y_train[BATCH_INDEX: BATCH_INDEX+BATCH_SIZE, :]
    cost = model.train_on_batch(X_batch, Y_batch)
    BATCH_INDEX += BATCH_SIZE
    BATCH_INDEX = 0 if BATCH_INDEX >= x_train.shape[0] else BATCH_INDEX

    if step % 500 == 0: # 每训练500进行一次测试
        cost, accuracy = model.evaluate(x_test, y_test, batch_size=y_test.shape[0], verbose=False)
        print('test cost: ', cost, 'test accuracy: ', accuracy)
```
输出：
```
test cost:  2.3316211700439453 test accuracy:  0.12210000306367874
test cost:  0.5586103200912476 test accuracy:  0.8342999815940857
test cost:  0.4080776870250702 test accuracy:  0.8806999921798706
。。。。。。
test cost:  0.12420056015253067 test accuracy:  0.9653000235557556
test cost:  0.13435833156108856 test accuracy:  0.9632999897003174
test cost:  0.12595564126968384 test accuracy:  0.9653000235557556
```
#### RNN Regressor 实例
```
import numpy as np
np.random.seed(1)
from keras.models import Sequential
from keras.layers import Dense,TimeDistributed,SimpleRNN
from keras.optimizers import Adam
import matplotlib.pyplot as plt

# 超参数
BATCH_START = 0
TIME_STEPS = 20 # 时间步长 前面20个数据对下一个有影响
BATCH_SIZE = 50
INPUT_SIZE = 1
OUTPUT_SIZE = 1
CELL_SIZE = 20
LR = 0.01

# 生成数据
def get_batch():
    global BATCH_START, TIME_STEPS
    xs = np.arange(BATCH_START, BATCH_START+TIME_STEPS*BATCH_SIZE).reshape((BATCH_SIZE, TIME_STEPS)) / (10*np.pi)
    seq = np.sin(xs)
    res = np.cos(xs)
    BATCH_START += TIME_STEPS
    return [seq[:, :, np.newaxis], res[:, :, np.newaxis], xs]

# 查看数据
# get_batch()
# exit()

## 搭建网络
model = Sequential()
# 添加RNN层
model.add(SimpleRNN(
    batch_input_shape=(BATCH_SIZE, TIME_STEPS, INPUT_SIZE),
    output_dim=CELL_SIZE,
    return_sequences=True,  # 对于每一个时间点需不需要输出对应的output,True每个时刻都输出，False最后的输出output
    stateful=True,  # batch与batch之间是否有联系，需不需要将状态进行传递
))
# 添加输出层
model.add(TimeDistributed(Dense(OUTPUT_SIZE))) # TimeDistributed：对每一个output进行全连接的计算

# 优化器
adam = Adam()
model.compile(
    optimizer=adam,
    loss='mse',
)

# 训练
print('Training ------------')
for step in range(501):
    # data shape = (batch_num, steps, inputs/outputs)
    X_batch, Y_batch, xs = get_batch()
    cost = model.train_on_batch(X_batch, Y_batch)
    pred = model.predict(X_batch, BATCH_SIZE)
    plt.plot(xs[0, :], Y_batch[0].flatten(), 'r', xs[0, :], pred.flatten()[:TIME_STEPS], 'b--')
    plt.ylim((-1.2, 1.2))
    plt.draw()
    plt.pause(0.1)
    if step % 10 == 0:
        print('train cost: ', cost)
```]]></description></item><item><title>Keras（三）backend 兼容 Regressor 回归 Classifier 分类 原理及实例</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/11/keras_3.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 11 Jul 2019 06:30:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/11/keras_3.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/keras4/
### backend 兼容
+ backend，即基于什么来做运算
Keras 可以基于两个Backend，一个是 Theano，一个是 Tensorflow
+ 查看当前backend
`import keras`
输出：
`Using Theano Backend.`
或者
`Using TensorFlow backend.`
+ 修改backend
找到~/.keras/keras.json文件，在文件内修改，每次import的时候，keras就会检查这个文件
```
{   # 后端为theano
	"image_dim_ordering": "tf",
	"epsilon": 1e-07,
	"floatx": "float32",
	"backend": "theano"
}
{   # 后端为tensorflow
	"image_dim_ordering": "tf",
	"epsilon": 1e-07,
	"floatx": "float32",
	"backend": "tensorflow"
}
```
但这样修改后，import的时候会出现错误信息，可以在terminal中直接输入临时环境变量执行：
`KERAS_BACKEND=tensorflow python3 -c "from keras import backend"`
最好是在python代码中`import keras`前加入一个环境变量修改的语句，这种方法仅在这个脚本生效：
`import os`
`os.environ['KERAS_BACKEND']='theano' # os.environ['KERAS_BACKEND']='tensorflow'`
### Regressor 回归
+ 神经网络可以用来模拟回归问题，给出一组数据，用一条线来对数据进行拟合，并可以预测新输入 x 的输出值
+ 导入模块并创建数据
`models.Sequential` 用来一层一层的去建立神经层
`layers.Dense` 意思是这个神经层是全连接层
```
import numpy as np
np.random.seed(1)
from keras.models import Sequential
from keras.layers import Dense
import matplotlib.pyplot as plt

# 创建一组数据
x = np.linspace(-1,1,200)
np.random.shuffle(x)
y = 0.5 * x + np.random.normal(0,0.05,(200,))
plt.scatter(x,y)
plt.show()

x_train,y_train = x[:160],y[:160]
x_test,y_test = x[160:],y[160:]
```
输出：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190711142848177-704937390.png)
+ 建立模型
用 Sequential 建立 model，再用model.add添加神经层，添加的是Dense全连接神经层
参数有两个，一个是输入数据和输出数据的维度，本代码的例子中 x 和 y 是一维的
```
model = Sequential()
model.add(Dense(input_dim=1,output_dim=1))
```
+ 激活模型
参数中，误差函数loss用的是mse均方误差；优化器optimizer用的是sgd随机梯度下降法
```
model.compile(loss='mse', optimizer='sgd')
```
+ 训练模型
训练的时候用 model.train_on_batch 一批一批的训练 x_train, y_train。默认的返回值是cost，每100步输出一下结果
```
print('Training -------------')
for step in range(301):
    cost = model.train_on_batch(x_train,y_train) # 返回训练损失
    if step % 100 == 0:
        print('train cost',cost)
```
输出：
```
train cost 0.39069265
train cost 0.10105395
train cost 0.027371023
train cost 0.008624705
```
+ 检验模型
用到的函数是 model.evaluate，输入测试集的x和y， 输出 cost，weights 和 biases。其中 weights 和 biases 是取在模型的第一层 model.layers[0] 学习到的参数（一共就一层）
```
print('\nTesting ------------')
cost = model.evaluate(x_test, y_test, batch_size=40)
print('test cost:', cost)
W, b = model.layers[0].get_weights()
print('Weights=', W, '\nbiases=', b)
```
输出：
```
Testing ------------
40/40 [==============================] - 0s 900us/step
test cost: 0.011580094695091248
Weights= [[0.64299107]] 
biases= [0.00309446]
```
+ 可视化结果
```
y_pred = model.predict(x_test)
plt.scatter(x_test, y_test)
plt.plot(x_test, y_pred)
plt.show()
```
输出：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190711142922453-159537371.png)
+ 整体代码
```
import numpy as np
np.random.seed(1)
from keras.models import Sequential
from keras.layers import Dense
import matplotlib.pyplot as plt

# 创建一组数据
x = np.linspace(-1,1,200)
np.random.shuffle(x)
y = 0.5 * x + np.random.normal(0,0.05,(200,))
plt.scatter(x,y)
plt.show()

x_train,y_train = x[:160],y[:160]
x_test,y_test = x[160:],y[160:]

model = Sequential()
model.add(Dense(input_dim=1,output_dim=1))

model.compile(loss='mse', optimizer='sgd')

# 分批训练模型
print('Training -------------')
for step in range(301):
    cost = model.train_on_batch(x_train,y_train) # 返回训练损失
    if step % 100 == 0:
        print('train cost',cost)

# 测速
print('\nTesting ------------')
cost = model.evaluate(x_test, y_test, batch_size=40)
print('test cost:', cost)
W, b = model.layers[0].get_weights()
print('Weights=', W, '\nbiases=', b)

# 可视化
y_pred = model.predict(x_test)
plt.scatter(x_test, y_test)
plt.plot(x_test, y_pred)
plt.show()
```
### Classifier 分类
+ 以数据集MNIST构建一个分类神经网路
+ 数据预处理
Keras 自身就有 MNIST 这个数据包，再分成训练集和测试集。x 是一张张图片，y 是每张图片对应的标签，即它是哪个数字。
输入的 x 变成 60,000×784(28x28的矩阵) 的数据，然后除以 255 进行标准化，因为每个像素都是在 0 到 255 之间的，标准化之后就变成了 0 到 1 之间。
对于 y，要用到 Keras 改造的 numpy 的一个函数 np_utils.to_categorical，把 y 变成了 one-hot 的形式，即之前 y 是一个数值， 在 0-9 之间，现在是一个大小为 10 的向量，它属于哪个数字，就在哪个位置为 1，其他位置都是 0。
```
from keras.datasets import mnist
from keras.utils import np_utils
(x_train,y_train),(x_test,y_test) = mnist.load_data()

x_train = x_train.reshape(x_train.shape[0],-1)/255 # 标准化
x_test = x_test.reshape(x_test.shape[0],-1)/255
y_train = np_utils.to_categorical(y_train,num_classes=10)
y_test = np_utils.to_categorical(y_test,num_classes=10)

print(x_train[0].shape)
print(y_train[:3])
```
输出：
```
(784,)
[[0. 0. 0. 0. 0. 1. 0. 0. 0. 0.]
 [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.]]
```
+ 建立神经网路
相关的包：
`models.Sequential` 用来一层一层一层的去建立神经层
`layers.Dense` 意思是这个神经层是全连接层
`layers.Activation` 激励函数
`optimizers.RMSprop` 优化器采用 RMSprop，加速神经网络训练方法
+ 建立模型
在回归网络中用到的是 model.add 一层一层添加神经层，今天的方法是直接在模型的里面加多个神经层。好比一个水管，一段一段的，数据是从上面一段掉到下面一段，再掉到下面一段
第一段就是加入 Dense 神经层。32 是输出的维度，784 是输入的维度。 第一层传出的数据有 32 个 feature，传给激励单元，激励函数用到的是 relu 函数。 经过激励函数之后，就变成了非线性的数据。 然后再把这个数据传给下一个神经层，这个 Dense 我们定义它有 10 个输出的 feature。同样的，此处不需要再定义输入的维度，因为它接收的是上一层的输出。 接下来再输入给下面的 softmax 函数，用来分类
接下来用 RMSprop 作为优化器，它的参数包括学习率等，可以通过修改这些参数来看一下模型的效果
```
import numpy as np
np.random.seed(1)
from keras.models import Sequential
from keras.layers import Dense,Activation
from keras.optimizers import RMSprop

model = Sequential([
    Dense(32,input_dim=784),
    Activation('relu'),
    Dense(10),
    Activation('softmax')
])

# 优化器
rmsprop = RMSprop(lr=0.001,rho=0.9,epsilon=1e-08,decay=0.0)

# 激活模型
model.compile(optimizer=rmsprop,loss='categorical_crossentropy',metrics=['accuracy'])
```
+ 训练网络
这里用到的是 fit 函数，把训练集的 x 和 y 传入之后，nb_epoch 表示把整个数据训练多少次，batch_size 每批处理32个
```
print('Training --------------')
model.fit(x_train,y_train,epochs=2,batch_size=32)
```
+ 测试模型
接下来就是用测试集来检验一下模型，方法和回归网络中是一样的，运行代码之后，可以输出 accuracy 和 loss。
```
print('\nTesting --------------')
loss,accuracy = model.evaluate(x_test,y_test)
print('test loss:',loss)
print('test accuracy:',accuracy)
```
输出：
```
test loss: 0.19889679334759713
test accuracy: 0.9396
```
+ 完整代码
```
from keras.datasets import mnist
from keras.utils import np_utils
from keras.models import Sequential
from keras.layers import Dense,Activation
from keras.optimizers import RMSprop
(x_train,y_train),(x_test,y_test) = mnist.load_data()

x_train = x_train.reshape(x_train.shape[0],-1)/255 # 标准化
x_test = x_test.reshape(x_test.shape[0],-1)/255
y_train = np_utils.to_categorical(y_train,num_classes=10)
y_test = np_utils.to_categorical(y_test,num_classes=10)

print(x_train[0].shape)
print(y_train[:3])

# 创建模型
model = Sequential([
    Dense(32,input_dim=784),Activation('relu'),
    Dense(10),Activation('softmax'),
])

# 优化器
rmsprop = RMSprop(lr=0.001,rho=0.9,epsilon=1e-08,decay=0.0)

# 激活模型
model.compile(optimizer=rmsprop,loss='categorical_crossentropy',metrics=['accuracy'])

# 训练
print('Training --------------')
model.fit(x_train,y_train,epochs=2,batch_size=32)

# 测试
print('\nTesting --------------')
loss,accuracy = model.evaluate(x_test,y_test)
print('test loss:',loss)
print('test accuracy:',accuracy)
```]]></description></item><item><title>ValueError: Error when checking input: expected conv2d_1_input to have 4 dimensions, but got array with shape (60000, 28, 28)</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/11/11169059.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 11 Jul 2019 03:46:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/11/11169059.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/bug10/
+ 报错
```
Traceback (most recent call last):
  File "D:/PyCharm 5.0.3/WorkSpace/3.Keras/3.构建各种神经网络/3.CNN.py", line 46, in <module>
    model.fit(x_train, y_train, epochs=1, batch_size=32)
  File "D:\Anaconda3\lib\site-packages\keras\engine\training.py", line 952, in fit
    batch_size=batch_size)
  File "D:\Anaconda3\lib\site-packages\keras\engine\training.py", line 751, in _standardize_user_data
    exception_prefix='input')
  File "D:\Anaconda3\lib\site-packages\keras\engine\training_utils.py", line 128, in standardize_input_data
    'with shape ' + str(data_shape))
ValueError: Error when checking input: expected conv2d_1_input to have 4 dimensions, but got array with shape (60000, 28, 28)
```
+ 原因
输入的格式不对
+ 解决
将数据集标准化
```
x_train = x_train.reshape(x_train.shape[0],1,28,28)/255
x_test = x_test.reshape(x_test.shape[0],1,28,28)/255
y_train = np_utils.to_categorical(y_train,num_classes=10)
y_test = np_utils.to_categorical(y_test,num_classes=10)
```]]></description></item><item><title>Keras（二）Application中五款已训练模型、VGG16框架解读</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/10/keras_2.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Wed, 10 Jul 2019 08:31:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/10/keras_2.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/keras3/
### Application的五款已训练模型 + H5py简述
+ Keras的应用模块Application提供了带有预训练权重的Keras模型，这些模型可以用来进行预测、特征提取和finetune。 
后续还有对以下几个模型的参数介绍：
**Xception
VGG16
VGG19
ResNet50
InceptionV3**
所有的这些模型(除了Xception)都兼容Theano和Tensorflow，并会自动基于~/.keras/keras.json的Keras的图像维度进行自动设置。例如，如果你设置data_format=”channel_last”，则加载的模型将按照TensorFlow的维度顺序来构造，即“Width-Height-Depth”的顺序。
模型的官方下载路径：
<u>https://github.com/fchollet/deep-learning-models/releases</u>
+ th与tf的区别
**Keras提供了两套后端，Theano和Tensorflow**
th和tf的大部分功能都被backend统一包装起来了，但二者还是存在不小的冲突，有时候你需要特别注意Keras是运行在哪种后端之上，它们的主要冲突有：
dim_ordering，也就是维度顺序。比方说一张224×224的彩色图片，theano的维度顺序是(3，224，224)，即通道维在前。而tf的维度顺序是(224，224，3)，即通道维在后。
数据格式的区别，channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）
+ notop模型
是否包含最后的3个全连接层，用来做微调（fine-tuning）专用，专门开源了这类模型
+ H5py简述
keras的已训练模型是H5PY格式的，后缀是h5
h5py.File类似Python的词典对象，因此我们可以查看所有的键值
输入：
`import h5py`
`file=h5py.File('.../notop.h5','r')`
查看键值：
`f = file.attrs['nb_layers']`
`f.key()`
查看到f中各个层内有些什么：
```
for name in f:
    print(name)
```
+ 官方案例：利用ResNet50网络进行ImageNet分类
识别大象的品种：
![f8575ae9f014c34fa7ec5febfaed21c7.jpeg](en-resource://database/1339:1)
```
from keras.applications.resnet50 import ResNet50
from keras.preprocessing import image
from keras.applications.resnet50 import preprocess_input,decode_predictions
import numpy as np

model = ResNet50(weights=r'..\Model\resnet50_weights_tf_dim_ordering_tf_kernels.h5')

img_path = 'elephant.jpg'
img = image.load_img(img_path,target_size=(224,224))
# 现有模型输入shape为 (224, 224, 3)
x = image.img_to_array(img)
x = np.expand_dims(x,axis=0)
x = preprocess_input(x)

preds = model.predict(x)
print('Predicted:',decode_predictions(preds,top=3)[0])
```
输出：
```
Predicted: [('n02504458', 'African_elephant', 0.603124), ('n02504013', 'Indian_elephant', 0.334439), ('n01871265', 'tusker', 0.062180385)]
```
+ 五个模型
1.Xception模型：仅能以TensorFlow为后端使用，目前该模型只支持channels_last的维度顺序(width, height, channels)
默认输入图片大小为299x299
`keras.applications.xception.Xception(include_top=True,weights='imagenet',input_tensor=None, input_shape=None,pooling=None, classes=1000)`
2.VGG16模型：在Theano和TensorFlow后端均可使用，并接受channels_first和channels_last两种输入维度顺序
默认输入图片大小为224x224
`keras.applications.vgg16.VGG16(include_top=True, weights='imagenet',input_tensor=None, input_shape=None,pooling=None,classes=1000)`
3.VGG19模型
在Theano和TensorFlow后端均可使用,并接受channels_first和channels_last两种输入维度顺序
默认输入图片大小为224x224
`keras.applications.vgg19.VGG19(include_top=True, weights='imagenet', input_tensor=None, input_shape=None,pooling=None,classes=1000)`
4.ResNet50模型
在Theano和TensorFlow后端均可使用,并接受channels_first和channels_last两种输入维度顺序
默认输入图片大小为224x224
`keras.applications.resnet50.ResNet50(include_top=True,weights='imagenet',input_tensor=None, input_shape=None,pooling=None,classes=1000)`
5.InceptionV3模型
在Theano和TensorFlow后端均可使用,并接受channels_first和channels_last两种输入维度顺序
默认输入图片大小为299x299
`keras.applications.inception_v3.InceptionV3(include_top=True,weights='imagenet',input_tensor=None,input_shape=None,pooling=None,classes=1000)`
### keras-applications-VGG16解读：函数式
+ VGG16默认的输入数据格式应该是：channels_last
```
from __future__ import print_function

import numpy as np
import warnings

from keras.models import Model
from keras.layers import Flatten,Dense,Input,Conv2D
from keras.layers import MaxPooling2D,GlobalMaxPooling2D,GlobalAveragePooling2D
from keras.preprocessing import image
from keras.utils import layer_utils
from keras.utils.data_utils import get_file
from keras import backend as K
from keras.applications.imagenet_utils import decode_predictions
# decode_predictions 输出5个最高概率：(类名, 语义概念, 预测概率) decode_predictions(y_pred)
from keras.applications.imagenet_utils import preprocess_input
# 预处理 图像编码服从规定，譬如,RGB，GBR这一类的，preprocess_input(x)
from keras_applications.imagenet_utils import _obtain_input_shape
# 确定适当的输入形状，相当于opencv中的read.img，将图像变为数组
from keras.engine.topology import get_source_inputs

WEIGHTS_PATH = 'https://github.com/fchollet/deep-learning-models/releases/download/v0.1/vgg16_weights_tf_dim_ordering_tf_kernels.h5'
WEIGHTS_PATH_NO_TOP = 'https://github.com/fchollet/deep-learning-models/releases/download/v0.1/vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5'

def VGG16(include_top=True, weights='imagenet',
          input_tensor=None, input_shape=None,
          pooling=None,
          classes=1000):
    # 检查weight与分类设置是否正确
    if weights not in {'imagenet', None}:
        raise ValueError('The `weights` argument should be either '
                         '`None` (random initialization) or `imagenet` '
                         '(pre-training on ImageNet).')

    if weights == 'imagenet' and include_top and classes != 1000:
        raise ValueError('If using `weights` as imagenet with `include_top`'
                         ' as true, `classes` should be 1000')

    # 设置图像尺寸，类似caffe中的transform
    # Determine proper input shape
    input_shape = _obtain_input_shape(input_shape,
                                      default_size=224,
                                      min_size=48,
                                      # 模型所能接受的最小长宽
                                      data_format=K.image_data_format(),
                                      # 数据的使用格式
                                      require_flatten=include_top)
                                      #是否通过一个Flatten层再连接到分类器

    # 数据简单处理，resize
    if input_tensor is None:
        img_input = Input(shape=input_shape)
        # 这里的Input是keras的格式，可以用于转换
    else:
        if not K.is_keras_tensor(input_tensor):
            img_input = Input(tensor=input_tensor, shape=input_shape)
        else:
            img_input = input_tensor
        # 如果是tensor的数据格式，需要两步走：
        # 先判断是否是keras指定的数据类型，is_keras_tensor
        # 然后get_source_inputs(input_tensor)

    # 编写网络结构，prototxt
    # Block 1
    x = Conv2D(64, (3, 3), activation='relu', padding='same', name='block1_conv1')(img_input)
    x = Conv2D(64, (3, 3), activation='relu', padding='same', name='block1_conv2')(x)
    x = MaxPooling2D((2, 2), strides=(2, 2), name='block1_pool')(x)

    # Block 2
    x = Conv2D(128, (3, 3), activation='relu', padding='same', name='block2_conv1')(x)
    x = Conv2D(128, (3, 3), activation='relu', padding='same', name='block2_conv2')(x)
    x = MaxPooling2D((2, 2), strides=(2, 2), name='block2_pool')(x)

    # Block 3
    x = Conv2D(256, (3, 3), activation='relu', padding='same', name='block3_conv1')(x)
    x = Conv2D(256, (3, 3), activation='relu', padding='same', name='block3_conv2')(x)
    x = Conv2D(256, (3, 3), activation='relu', padding='same', name='block3_conv3')(x)
    x = MaxPooling2D((2, 2), strides=(2, 2), name='block3_pool')(x)

    # Block 4
    x = Conv2D(512, (3, 3), activation='relu', padding='same', name='block4_conv1')(x)
    x = Conv2D(512, (3, 3), activation='relu', padding='same', name='block4_conv2')(x)
    x = Conv2D(512, (3, 3), activation='relu', padding='same', name='block4_conv3')(x)
    x = MaxPooling2D((2, 2), strides=(2, 2), name='block4_pool')(x)

    # Block 5
    x = Conv2D(512, (3, 3), activation='relu', padding='same', name='block5_conv1')(x)
    x = Conv2D(512, (3, 3), activation='relu', padding='same', name='block5_conv2')(x)
    x = Conv2D(512, (3, 3), activation='relu', padding='same', name='block5_conv3')(x)
    x = MaxPooling2D((2, 2), strides=(2, 2), name='block5_pool')(x)

    if include_top:
        # Classification block
        x = Flatten(name='flatten')(x)
        x = Dense(4096, activation='relu', name='fc1')(x)
        x = Dense(4096, activation='relu', name='fc2')(x)
        x = Dense(classes, activation='softmax', name='predictions')(x)
    else:
        if pooling == 'avg':
            x = GlobalAveragePooling2D()(x)
        elif pooling == 'max':
            x = GlobalMaxPooling2D()(x)

    # 调整数据
    # Ensure that the model takes into account
    # any potential predecessors of `input_tensor`.
    if input_tensor is not None:
        inputs = get_source_inputs(input_tensor)
        # get_source_inputs 返回计算需要的数据列表，List of input tensors.
        # 如果是tensor的数据格式，需要两步走：
        # 先判断是否是keras指定的数据类型，is_keras_tensor
        # 然后get_source_inputs(input_tensor)
    else:
        inputs = img_input

    # 创建模型
    # Create model.
    model = Model(inputs, x, name='vgg16')

    # 加载权重
    # load weights
    if weights == 'imagenet':
        if include_top:
            weights_path = get_file('vgg16_weights_tf_dim_ordering_tf_kernels.h5',
                                    WEIGHTS_PATH,
                                    cache_subdir='models')
        else:
            weights_path = get_file('vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5',
                                    WEIGHTS_PATH_NO_TOP,
                                    cache_subdir='models')
        model.load_weights(weights_path)

        if K.backend() == 'theano':
            layer_utils.convert_all_kernels_in_model(model)

        if K.image_data_format() == 'channels_first':
            if include_top:
                maxpool = model.get_layer(name='block5_pool')
                shape = maxpool.output_shape[1:]
                dense = model.get_layer(name='fc1')
                layer_utils.convert_dense_weights_data_format(dense, shape, 'channels_first')

            if K.backend() == 'tensorflow':
                warnings.warn('You are using the TensorFlow backend, yet you '
                              'are using the Theano '
                              'image data format convention '
                              '(`image_data_format="channels_first"`). '
                              'For best performance, set '
                              '`image_data_format="channels_last"` in '
                              'your Keras config '
                              'at ~/.keras/keras.json.')
    return model

if __name__ == '__main__':
    model = VGG16(include_top=True, weights='imagenet')

    img_path = 'elephant.jpg'
    img = image.load_img(img_path, target_size=(224, 224))
    x = image.img_to_array(img)
    x = np.expand_dims(x, axis=0)
    x = preprocess_input(x)
    print('Input image shape:', x.shape)

    preds = model.predict(x)
    print('Predicted:', decode_predictions(preds))
    # decode_predictions 输出5个最高概率：(类名, 语义概念, 预测概率)
```
输出：
```
Input image shape: (1, 224, 224, 3)
Predicted: [[('n02504458', 'African_elephant', 0.62728244), ('n02504013', 'Indian_elephant', 0.19092941), ('n01871265', 'tusker', 0.18166111), ('n02437312', 'Arabian_camel', 4.5080957e-05), ('n07802026', 'hay', 1.7709652e-05)]]
```
+ 将model下载到本地，修改下载的代码
注释掉下面两行：
`WEIGHTS_PATH = 'https://github.com/fchollet/deep-learning-models/releases/download/v0.1/vgg16_weights_tf_dim_ordering_tf_kernels.h5'`
`WEIGHTS_PATH_NO_TOP = 'https://github.com/fchollet/deep-learning-models/releases/download/v0.1/vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5'`
修改下面两行：
`weights_path = get_file('vgg16_weights_tf_dim_ordering_tf_kernels.h5',WEIGHTS_PATH,cache_subdir='models')`
`weights_path = get_file('vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5',WEIGHTS_PATH_NO_TOP,cache_subdir='models')`
+ 几个layer中的新用法
`from keras.applications.imagenet_utils import decode_predictions`
decode_predictions 输出5个最高概率：(类名, 语义概念, 预测概率) decode_predictions(y_pred)
`from keras.applications.imagenet_utils import preprocess_input`
预处理 图像编码服从规定，譬如,RGB，GBR这一类的，preprocess_input(x)  
`from keras.applications.imagenet_utils import _obtain_input_shape` 
确定适当的输入形状，相当于opencv中的read.img，将图像变为数组
（1）decode_predictions用在最后输出结果上，比较好用【print(‘Predicted:’, decode_predictions(preds))】； 
（2）preprocess_input，改变编码，【preprocess_input(x)】； 
（3）_obtain_input_shape 
相当于caffe中的transform，在预测的时候，需要对预测的图片进行一定的预处理。
`input_shape = _obtain_input_shape(input_shape,default_size=224,min_size=48,data_format=K.image_data_format(),include_top=include_top)`
min_size=48，模型所能接受的最小长宽
data_format=K.image_data_format()，数据的使用格式
+ 当include_top=True时
`fc_model = VGG16(include_top=True)`
`notop_model = VGG16(include_top=False)`
用VGG16做fine-tuning的时候，得到的notop_model就是没有全连接层的模型，然后再去添加自己的层。 
当是健全的网络结构的时候，fc_model需要添加以下的内容以补全网络结构：
```
x = Flatten(name='flatten')(x)
x = Dense(4096, activation='relu', name='fc1')(x)
x = Dense(4096, activation='relu', name='fc2')(x)
x = Dense(classes, activation='softmax', name='predictions')(x)
```
pool层之后接一个flatten层，修改数据格式，然后接两个dense层，最后有softmax的Dense层
+ channels_first转成channels_last格式
```
 maxpool = model.get_layer(name='block5_pool')
 # model.get_layer()依据层名或下标获得层对象
 shape = maxpool.output_shape[1:]
 # 获取block5_pool层输出的数据格式
 dense = model.get_layer(name='fc1')
 layer_utils.convert_dense_weights_data_format(dense, shape, 'channels_first')
```
`convert_dense_weights_data_format`将convnet的权重从一种数据格式移植到另一种数据格式时，如果convnet包含一个平坦层（应用于最后一个卷积特征映射），然后是一个密集层，则应更新该密集层的权重，以反映新的维度顺序。]]></description></item><item><title>Python实现 下载IJCAI会议所有论文</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/10/11163188.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Wed, 10 Jul 2019 04:43:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/10/11163188.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/python10/
```
import requests
import threading

def get_file_content(num):
    savepath = '%04d.pdf' % (num)
    suburl = 'https://www.ijcai.org/proceedings/2018/%04d.pdf' % (num)
    r = requests.get(suburl)
    f = open(savepath,'wb') # 用'wb'读取非文本文件pdf
    f.write(r.content) # r.content -> requests中的二进制响应内容：以字节的方式访问请求响应体，对于非文本请求
    f.close()

def get_file_content_arange(min,max):
    for num in range(min,max+1):
        print('doanloading %04d.pdf...' % (num))
        get_file_content(num)

threads = []
t1 = threading.Thread(target=get_file_content_arange,args=(1,221))
threads.append(t1)
t2 = threading.Thread(target=get_file_content_arange, args=(221,440))
threads.append(t2)
t3 = threading.Thread(target=get_file_content_arange, args=(440,658))
threads.append(t3)
t4 = threading.Thread(target=get_file_content_arange, args=(658,870,))
threads.append(t4)
for t in threads:
    t.start()
```]]></description></item><item><title>Keras 实例 MNIST</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/09/11158315.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 09 Jul 2019 08:34:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/09/11158315.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/keras_mnist/
```
import numpy
from keras.datasets import mnist
from keras.models import Sequential
from keras.layers import Dense # 稠密层
from keras.layers import Dropout # Dropout将在训练过程中每次更新参数时按一定概率（rate）随机断开输入神经元，Dropout层用于防止过拟合。
from keras.layers import Flatten # Flatten层用来将输入“压平”，即把多维的输入一维化，常用在从卷积层到全连接层的过渡。Flatten不影响batch的大小。
from keras.layers.convolutional import Conv2D # 二维卷积层，即对图像的空域卷积。
from keras.layers.convolutional import MaxPooling2D # 空间池化（也叫亚采样或下采样）降低了每个特征映射的维度，但是保留了最重要的信息
from keras.utils import np_utils
from keras import backend as K
K.set_image_dim_ordering('th') # 设置图像的维度顺序（‘tf’或‘th’）
# 当前的维度顺序如果为'th'，则输入图片数据时的顺序为：channels,rows,cols，否则:rows,cols,channels

seed = 7
numpy.random.seed(seed)
#将数据reshape，CNN的输入是4维的张量（可看做多维的向量），第一维是样本规模，第二维是像素通道，第三维和第四维是长度和宽度。并将数值归一化和类别标签向量化。

# load data
(X_train, y_train), (X_test, y_test) = mnist.load_data()
# reshape to be [samples][pixels][width][height]
X_train = X_train.reshape(X_train.shape[0], 1, 28, 28).astype('float32')
X_test = X_test.reshape(X_test.shape[0], 1, 28, 28).astype('float32')

X_train = X_train / 255
X_test = X_test / 255
# 将标签转化成one-hot编码
y_train = np_utils.to_categorical(y_train)
y_test = np_utils.to_categorical(y_test)
num_classes = y_test.shape[1]

## 接下来构造CNN
# 第一层是卷积层。该层有32个feature map,或者叫滤波器，作为模型的输入层，接受[pixels][width][height]大小的输入数据。feature_map的大小是5*5，其输出接一个‘relu’激活函数。
# 下一层是pooling层，使用了MaxPooling，大小为2*2。
# 下一层是Dropout层，该层的作用相当于对参数进行正则化来防止模型过拟合。
# Flatten层用来将输入“压平”，即把多维的输入一维化，常用在从卷积层到全连接层的过渡。Flatten不影响batch的大小。
# 接下来是全连接层，有128个神经元，激活函数采用‘relu’。
# 最后一层是输出层，有10个神经元，每个神经元对应一个类别，输出值表示样本属于该类别的概率大小。
def baseline_model():
    # create model
    model = Sequential()
    model.add(Conv2D(32, (5, 5), input_shape=(1, 28, 28), activation='relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(0.2))
    model.add(Flatten())
    model.add(Dense(128, activation='relu'))
    model.add(Dense(num_classes, activation='softmax'))
    # Compile model
    model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
    return model

# 建立模型
model = baseline_model()

# 训练模型
model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=10, batch_size=200, verbose=2)

# 模型概要打印
model.summary()

# 模型评估
scores = model.evaluate(X_test, y_test, verbose=0)
print("Baseline Error: %.2f%%" % (100-scores[1]*100))
```
输出：
```
Train on 60000 samples, validate on 10000 samples
Epoch 1/10
 - 68s - loss: 0.2247 - acc: 0.9358 - val_loss: 0.0776 - val_acc: 0.9754
Epoch 2/10
 - 66s - loss: 0.0709 - acc: 0.9787 - val_loss: 0.0444 - val_acc: 0.9853
Epoch 3/10
 - 67s - loss: 0.0511 - acc: 0.9843 - val_loss: 0.0435 - val_acc: 0.9855
Epoch 4/10
 - 66s - loss: 0.0392 - acc: 0.9880 - val_loss: 0.0391 - val_acc: 0.9873
Epoch 5/10
 - 66s - loss: 0.0325 - acc: 0.9898 - val_loss: 0.0341 - val_acc: 0.9893
Epoch 6/10
 - 65s - loss: 0.0266 - acc: 0.9918 - val_loss: 0.0318 - val_acc: 0.9890
Epoch 7/10
 - 65s - loss: 0.0221 - acc: 0.9929 - val_loss: 0.0348 - val_acc: 0.9886
Epoch 8/10
 - 65s - loss: 0.0191 - acc: 0.9941 - val_loss: 0.0308 - val_acc: 0.9890
Epoch 9/10
 - 66s - loss: 0.0153 - acc: 0.9951 - val_loss: 0.0325 - val_acc: 0.9897
Epoch 10/10
 - 65s - loss: 0.0143 - acc: 0.9957 - val_loss: 0.0301 - val_acc: 0.9903
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
conv2d_1 (Conv2D)            (None, 32, 24, 24)        832       
_________________________________________________________________
max_pooling2d_1 (MaxPooling2 (None, 32, 12, 12)        0         
_________________________________________________________________
dropout_1 (Dropout)          (None, 32, 12, 12)        0         
_________________________________________________________________
flatten_1 (Flatten)          (None, 4608)              0         
_________________________________________________________________
dense_1 (Dense)              (None, 128)               589952    
_________________________________________________________________
dense_2 (Dense)              (None, 10)                1290      
=================================================================
Total params: 592,074
Trainable params: 592,074
Non-trainable params: 0
_________________________________________________________________
Baseline Error: 0.97%
```]]></description></item><item><title>TypeError: _obtain_input_shape() got an unexpected keyword argument 'include_top'</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/09/11157479.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 09 Jul 2019 07:08:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/09/11157479.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/bug9/
+ 报错
```
Traceback (most recent call last):
  File "D:/PyCharm 5.0.3/WorkSpace/3.Keras/2.Application中五款已训练模型、VGG16框架（Sequential式、Model式）解读/2.py", line 159, in <module>
    model = VGG16(include_top=True, weights='imagenet')
  File "D:/PyCharm 5.0.3/WorkSpace/3.Keras/2.Application中五款已训练模型、VGG16框架（Sequential式、Model式）解读/2.py", line 51, in VGG16
    include_top=include_top)
TypeError: _obtain_input_shape() got an unexpected keyword argument 'include_top'
```
+ 原因
没有叫include_top的参数
+ 解决
打开keras.applications.imagenet_utils找到preprocess_input()函数，`def _obtain_input_shape(input_shape, default_size, min_size, data_format, require_flatten, weights=None):`
将参数`include_top`改成`require_flatten`]]></description></item><item><title>ImportError: cannot import name '_obtain_input_shape' from 'keras.applications.imagenet_utils'</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/09/11157412.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 09 Jul 2019 07:00:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/09/11157412.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/bug8/
+ 报错
```
Using TensorFlow backend.
Traceback (most recent call last):
  File "D:/PyCharm 5.0.3/WorkSpace/3.Keras/2.Application中五款已训练模型、VGG16框架（Sequential式、Model式）解读/2.py", line 22, in <module>
    from keras.applications.imagenet_utils import _obtain_input_shape

ImportError: cannot import name '_obtain_input_shape' from 'keras.applications.imagenet_utils' (D:\Anaconda3\lib\site-packages\keras\applications\imagenet_utils.py)
```
+ 原因
`_obtain_input_shape`换地方了
+ 解决
`from keras.applications.imagenet_utils import _obtain_input_shape`
改成
`from keras_applications.imagenet_utils import _obtain_input_shape`]]></description></item><item><title>ValueError: Cannot create group in read only mode.</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/09/11157096.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 09 Jul 2019 06:26:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/09/11157096.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/bug7/
+ 报错
```
Using TensorFlow backend.
Traceback (most recent call last):
  File "D:/PyCharm 5.0.3/WorkSpace/3.Keras/2.Application中五款已训练模型、VGG16框架（Sequential式、Model式）解读/1.py", line 8, in <module>
    model = load_model(r'..\Model\resnet50_weights_tf_dim_ordering_tf_kernels.h5','rw')
  File "D:\Anaconda3\lib\site-packages\keras\engine\saving.py", line 419, in load_model
    model = _deserialize_model(f, custom_objects, compile)
  File "D:\Anaconda3\lib\site-packages\keras\engine\saving.py", line 221, in _deserialize_model
    model_config = f['model_config']
  File "D:\Anaconda3\lib\site-packages\keras\utils\io_utils.py", line 302, in __getitem__
    raise ValueError('Cannot create group in read only mode.')
ValueError: Cannot create group in read only mode.
```
+ 原因
单纯的没有结构一个model不能导入那么多参数
+ 解决
`model = AModel(weights=r'模型的路径\model_name.h5')`
也可以：
先加载model的layers，再加载模型]]></description></item><item><title>Keras（一）Sequential与Model模型、Keras基本结构功能</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/08/keras_1.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 08 Jul 2019 11:27:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/08/keras_1.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/keras1/
原文链接：http://www.one2know.cn/keras2/
### keras介绍与基本的模型保存
+ 思维导图
1.keras网络结构
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190708192459202-596765921.jpg)
2.keras网络配置
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190708192510293-623763429.jpg)
3.keras预处理功能
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190708192520136-906626865.jpg)
+ 模型的节点信息提取
`config = model.get_config()` 把model中的信息,solver.prototext和train.prototext信息提取出来
`model = Model.from_config(config)` 用信息建立新的模型对象
`model = Sequential.from_config(config)` 用信息建立新的Sequential模型对象
+ 模型概况查询
1.模型概况打印
model.summary()
2.返回代表模型的JSON字符串，仅包含网络结构，不包含权值
`from keras.models import model_from_json`
`json_string = model.to_json()`
`model = model_from_json(json_string)`
3.model.to_yaml:与model.to_json类似，同样可以从产生的YAML字符串中重构模型
`from keras.models import model_from_yaml`
`yaml_string = model.to_yaml()`
`model = model_from_yaml(yaml_string)`
4.权重获取
`model.get_layer()` 依据层名或下标获得层对象
`model.get_weights()` 返回模型权重张量的列表，类型为numpy.array
`model.set_weights()` 从numpy.array里将权重载入给模型，要求数组具有与model.get_weights()相同的形状
`model.layers` 查看layer信息
+ 模型保存与加载
`model.save_weights(filepath=filepath)` 保存权重，文件类型HDF5，后缀.h5
`model.load_weights(filepath, by_name=False)` 加载权重到当前模型，设置`by_name=True`，则只有名字匹配的层才会载入权重
+ 在keras中设置GPU使用的大小，使用keras时候会出现总是占满GPU显存的情况，可以通过重设backend的GPU占用情况来进行调节
`import tensorflow as tf`
`from keras.backend.tensorflow_backend import set_session`
`config = tf.ConfigProto()`
`config.gpu_options.per_process_gpu_memory_fraction = 0.3`
`set_session(tf.Session(config=config))`
+ 更科学地模型训练与模型保存
`filepath = 'model-ep{epoch:03d}-loss{loss:.3f}-val_loss{val_loss:.3f}.h5'`
`from keras.callbacks import ModelCheckpoint`
`checkpoint = ModelCheckpoint(filepath, monitor='val_loss', verbose=1, save_best_only=True, mode='min')`
`model.fit(x, y, epochs=20, verbose=2, callbacks=[checkpoint], validation_data=(x, y))`
如果val_loss 提高了就会保存，没有提高就不会保存
+ 在keras中使用tensorboard
tensorboard能将keras的训练过程动态的、直观的显示出来
原理：keras的在训练（fit）的过程中，显式地生成log日志；使用tf的tensorboard来解析这个log日志，并且通过网站的形式显示出来
RUN = RUN + 1 if 'RUN' in locals() else 1   # locals() 函数会以字典类型返回当前位置的全部局部变量。
```
LOG_DIR = model_save_path + '/training_logs/run{}'.format(RUN)
LOG_FILE_PATH = LOG_DIR + '/checkpoint-{epoch:02d}-{val_loss:.4f}.hdf5'   # 模型Log文件以及.h5模型文件存放地址
tensorboard = TensorBoard(log_dir=LOG_DIR, write_images=True)
checkpoint = ModelCheckpoint(filepath=LOG_FILE_PATH, monitor='val_loss', verbose=1, save_best_only=True)
early_stopping = EarlyStopping(monitor='val_loss', patience=5, verbose=1)
history = model.fit_generator(generator=gen.generate(True),steps_per_epoch=int(gen.train_batches / 4),validation_data=gen.generate(False), validation_steps=int(gen.val_batches / 4),epochs=EPOCHS, verbose=1,callbacks=[tensorboard, checkpoint, early_stopping])
```
EarlyStopping patience：当early 
（1）stop被激活（如发现loss相比上一个epoch训练没有下降），则经过patience个epoch后停止训练。 
（2）mode：‘auto’，‘min’，‘max’之一，在min模式下，如果检测值停止下降则中止训练。在max模式下，当检测值不再上升则停止训练。
模型检查点ModelCheckpoint  
（1）save_best_only：当设置为True时，将只保存在验证集上性能最好的模型 
（2）mode：‘auto’，‘min’，‘max’之一，在save_best_only=True时决定性能最佳模型的评判准则，例如，当监测值为val_acc时，模式应为max，当检测值为val_loss时，模式应为min。在auto模式下，评价准则由被监测值的名字自动推断。 
（3）save_weights_only：若设置为True，则只保存模型权重，否则将保存整个模型（包括模型结构，配置信息等） 
（4）period：CheckPoint之间的间隔的epoch数
可视化tensorboard write_images: 是否将模型权重以图片的形式可视化
### Sequential模型
+ Sequential模型，即序贯模型，为最简单的线性、从头到脚的结构顺序，不分叉
+ 基本组件
1. `model.add` 添加层
2. `model.compile` 模型训练的BP模式设置
3. `model.fit` 模型训练参数设置和训练
4. 模型评估
5. 模型预测
+ add：添加层，train_val.prototxt文件
`add(self,layer)`
例子：
`model.add(Dense(32,activation='relu',input_dim=100))`
`model.add(Dropout(0.25))`
除了加层layer，还可以加其他模型`add(self,other_model)`
+ compile：训练模式，solver.prototxt文件
`compile(self, optimizer, loss, metrics=None, sample_weight_mode=None)`
参数：
optimizer：字符串（预定义优化器名）或优化器对象，参考优化器 
loss：字符串（预定义损失函数名）或目标函数，参考损失函数 
metrics：列表，包含评估模型在训练和测试时的网络性能的指标，典型用法是metrics=[‘accuracy’] 
sample_weight_mode：如果你需要按时间步为样本赋权（2D权矩阵），将该值设为“temporal”。默认为“None”，代表按样本赋权（1D权）。在下面fit函数的解释中有相关的参考内容。
kwargs： 使用TensorFlow作为后端请忽略该参数，若使用Theano作为后端，kwargs的值将会传递给 K.function
+ fit：模型训练，train.sh+soler.prototxt（部分）
`fit(self, x, y, batch_size=32, epochs=10, verbose=1, callbacks=None, validation_split=0.0, validation_data=None, shuffle=True, class_weight=None, sample_weight=None, initial_epoch=0)`
参数：
x：输入数据，如果模型只有一个输入，那么x的类型是numpy.array，如果模型有多个输入，那么x的类型应当为list，list的元素是对应于各个输入的numpy.array
y：标签，numpy.array
batch_size：整数，指定进行梯度下降时每个batch包含的样本数。训练时一个batch的样本会被计算一次梯度下降，使目标函数优化一步。
epochs：整数，训练的轮数，每个epoch会把训练集轮一遍。
verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录
callbacks：list，其中的元素是keras.callbacks.Callback的对象。这个list中的回调函数将会在训练过程中的适当时机被调用，参考回调函数
validation_split：0~1之间的浮点数，用来指定训练集的一定比例数据作为验证集。验证集将不参与训练，并在每个epoch结束后测试的模型的指标，如损失函数、精确度等。注意，validation_split的划分在shuffle之前，因此如果你的数据本身是有序的，需要先手工打乱再指定validation_split，否则可能会出现验证集样本不均匀。
validation_data：形式为（X，y）的tuple，是指定的验证集，**此参数将覆盖validation_spilt**
shuffle：布尔值或字符串，一般为布尔值，表示是否在训练过程中随机打乱输入样本的顺序。若为字符串“batch”，则是用来处理HDF5数据的特殊情况，它将在batch内部将数据打乱。
class_weight：字典，将不同的类别映射为不同的权值，该参数用来在训练过程中调整损失函数（只能用于训练）
sample_weight：权值的numpy.array，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（samples，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加sample_weight_mode=’temporal’。
initial_epoch: 从该参数指定的epoch开始训练，在继续之前的训练时有用。
+ evaluate：模型评估
`evaluate(self, x, y, batch_size=32, verbose=1, sample_weight=None)`
本函数按batch计算在某些输入数据上模型的误差，其参数有：
x：输入数据，与fit一样，是numpy.array或numpy.array的list
y：标签，numpy.array
batch_size：整数，含义同fit的同名参数
verbose：含义同fit的同名参数，但只能取0或1
sample_weight：numpy.array，含义同fit的同名参数
+ predict：模型评估
`predict(self, x, batch_size=32, verbose=0)`
`predict_classes(self, x, batch_size=32, verbose=1)`
`predict_proba(self, x, batch_size=32, verbose=1)`
本函数按batch获得输入数据对应的输出，其参数有：
函数的返回值是预测值的numpy.array 
predict_classes：本函数按batch产生输入数据的类别预测结果 
predict_proba：本函数按batch产生输入数据属于各个类别的概率
+ on_batch：batch的结果，检查
`train_on_batch(self, x, y, class_weight=None, sample_weight=None)`
`test_on_batch(self, x, y, sample_weight=None)`
`predict_on_batch(self, x)`
参数：
train_on_batch：本函数在一个batch的数据上进行一次参数更新，函数返回训练误差的标量值或标量值的list，与evaluate的情形相同。
test_on_batch：本函数在一个batch的样本上对模型进行评估，函数的返回与evaluate的情形相同
predict_on_batch：本函数在一个batch的样本上对模型进行测试，函数返回模型在一个batch上的预测结果
+ fit_generator，利用迭代器训练
利用Python的生成器，逐个生成数据的batch并进行训练。
生成器与模型将并行执行以提高效率。
例如，该函数允许我们在CPU上进行实时的数据提升，同时在GPU上进行模型训练
参考链接：<u>http://keras-cn.readthedocs.io/en/latest/models/sequential/</u>
有了该函数，图像分类训练任务变得很简单。
```
fit_generator(self, generator, steps_per_epoch, epochs=1, verbose=1, callbacks=None, validation_data=None, validation_steps=None, class_weight=None, max_q_size=10, workers=1, pickle_safe=False, initial_epoch=0)

def generate_arrays_from_file(path):
    while 1:
            f = open(path)
            for line in f:
                # 在每行 创建输入数据和标签的array数组
                x, y = process_line(line)
                yield (x, y)
        f.close()

model.fit_generator(generate_arrays_from_file('/my_file.txt'),samples_per_epoch=10000, epochs=10)
 
```
其他的两个辅助的内容：
`evaluate_generator(self, generator, steps, max_q_size=10, workers=1, pickle_safe=False)`
`predict_generator(self, generator, steps, max_q_size=10, workers=1, pickle_safe=False, verbose=0)`
evaluate_generator：本函数使用一个生成器作为数据源评估模型，生成器应返回与test_on_batch的输入数据相同类型的数据。该函数的参数与fit_generator同名参数含义相同，steps是生成器要返回数据的轮数。 
predcit_generator：本函数使用一个生成器作为数据源预测模型，生成器应返回与test_on_batch的输入数据相同类型的数据。该函数的参数与fit_generator同名参数含义相同，steps是生成器要返回数据的轮数。
#### 案例一：简单的二分类
```
from keras.models import Sequential
from keras.layers import Dense,Activation

# 建立模型
model = Sequential() # 初始化
model.add(Dense(32,activation='relu',input_dim=100))
# Dense代表全连接，有32个全连接层，最后接relu，输入的是100维
model.add(Dense(1,activation='sigmoid')) # 添加新的全连接层
model.compile(optimizer='rmsprop',loss='binary_crossentropy',metrics=['accuracy'])
# compile，跟prototxt一样，一些训练参数，solver.prototxt

# 生成数据
import numpy as np
data = np.random.random((1000, 100))
labels = np.random.randint(2, size=(1000, 1))

# 训练数据
model.fit(data, labels, batch_size=32, nb_epoch =10,verbose=1)
# 版本1.2里面是nb_epoch ，而keras2.0是epochs

print(model.summary())
```
输出：
```
Using TensorFlow backend.
WARNING:tensorflow:From D:\Python37\Lib\site-packages\tensorflow\python\framework\op_def_library.py:263: colocate_with (from tensorflow.python.framework.ops) is deprecated and will be removed in a future version.
Instructions for updating:
Colocations handled automatically by placer.
D:/PyCharm 5.0.3/WorkSpace/3.Keras/1.Sequential与Model模型、Keras基本结构功能/1.py:18: UserWarning: The `nb_epoch` argument in `fit` has been renamed `epochs`.
  model.fit(data, labels, batch_size=32, nb_epoch =10,verbose=1)
WARNING:tensorflow:From D:\Python37\Lib\site-packages\tensorflow\python\ops\math_ops.py:3066: to_int32 (from tensorflow.python.ops.math_ops) is deprecated and will be removed in a future version.
Instructions for updating:
Use tf.cast instead.
Epoch 1/10
2019-07-08 12:12:29.800285: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2

  32/1000 [..............................] - ETA: 6s - loss: 0.7047 - acc: 0.5000
1000/1000 [==============================] - 0s 229us/step - loss: 0.7101 - acc: 0.5080
Epoch 2/10

  省略了一堆epoch
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
dense_1 (Dense)              (None, 32)                3232      
_________________________________________________________________
dense_2 (Dense)              (None, 1)                 33        
=================================================================
Total params: 3,265
Trainable params: 3,265
Non-trainable params: 0
_________________________________________________________________
None
```
#### 案例二：多分类-VGG的卷积神经网络
```
import numpy as np
import keras
from keras.models import Sequential
from keras.layers import Dense,Dropout,Flatten
from keras.layers import Conv2D,MaxPooling2D
from keras.optimizers import SGD
from keras.utils import np_utils

# 生成数据
x_train = np.random.random((100,100,100,3))
# 100张图片 每张100*100*3
y_train = keras.utils.to_categorical(np.random.randint(10,size=(100,1)),num_classes=10)
# 100*10
x_test = np.random.random((20,100,100,3))
y_test = keras.utils.to_categorical(np.random.randint(10,size=(20,1)),num_classes=10)
# 20*100
# keras.utils.to_categorical 将一列数字转化为keras格式的额一堆类

model = Sequential()
# input: 100x100 images with 3 channels -> (110,100,3) tensore.
# this applies 32 convolution filters of size 3x3 each.
model.add(Conv2D(32,(3,3),activation='relu',input_shape=(100,100,3)))
model.add(Conv2D(32,(3,3),activation='relu'))
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.25))

model.add(Conv2D(64,(3,3),activation='relu'))
model.add(Conv2D(64,(3,3),activation='relu'))
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.25))

model.add(Flatten())
model.add(Dense(256,activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(10,activation='softmax'))

sgd = SGD(lr=0.01,decay=1e-6,momentum=0.9,nesterov=True)
model.compile(loss='categorical_crossentropy',optimizer=sgd)

model.fit(x_train,y_train,batch_size=32,epochs=10)
score = model.evaluate(x_test,y_test,batch_size=32)
```
### Model式模型
+ 比序贯模型要复杂，但是效果很好，可以同时/分阶段输入变量，分阶段输出想要的模型，函数式模型
+ 函数式模型基本属性与训练流程
1. model.layers，添加层信息
2. model.compile，模型训练的BP模式设置
3. model.fit，模型训练参数设置和训练
4. evaluate，模型评估
5. predict，模型预测
+ 常用Model属性
`model.layers`：组成模型图的各个层
`model.inputs`：模型的输入张量列表
`model.outputs`：模型的输出张量列表
+ compile 训练模式设置——solver.prototxt
`compile(self, optimizer, loss, metrics=None, loss_weights=None, sample_weight_mode=None)`
参数：
optimizer：优化器，为预定义优化器名或优化器对象，参考优化器 
loss：损失函数，为预定义损失函数名或一个目标函数，参考损失函数 
metrics：列表，包含评估模型在训练和测试时的性能的指标，典型用法是metrics=[‘accuracy’]如果要在多输出模型中为不同的输出指定不同的指标，可像该参数传递一个字典，例如metrics={‘ouput_a’: ‘accuracy’} 
sample_weight_mode：如果你需要按时间步为样本赋权（2D权矩阵），将该值设为“temporal”。默认为“None”，代表按样本赋权（1D权）
+ fit 模型训练参数设置和训练
`fit(self, x=None, y=None, batch_size=32, epochs=1, verbose=1, callbacks=None, validation_split=0.0, validation_data=None, shuffle=True, class_weight=None, sample_weight=None, initial_epoch=0)`
参数：
x：输入数据，如果模型只有一个输入，那么x的类型是numpy.array，如果模型有多个输入，那么x的类型应当为list，list的元素是对应于各个输入的numpy.array，如果模型的每个输入都有名字，则可以传入一个字典，将输入名与其输入数据对应起来。
y：标签，numpy.array。如果模型有多个输出，可以传入一个numpy.array的list。如果模型的输出拥有名字，则可以传入一个字典，将输出名与其标签对应起来。
batch_size：整数，指定进行梯度下降时每个batch包含的样本数。训练时一个batch的样本会被计算一次梯度下降，使目标函数优化一步。
nb_epoch：整数，训练的轮数，训练数据将会被遍历nb_epoch次。Keras中nb开头的变量均为”number of”的意思
verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录
callbacks：list，其中的元素是keras.callbacks.Callback的对象。这个list中的回调函数将会在训练过程中的适当时机被调用，参考回调函数
validation_split：0~1之间的浮点数，用来指定训练集的一定比例数据作为验证集。验证集将不参与训练，并在每个epoch结束后测试的模型的指标，如损失函数、精确度等。注意，validation_split的划分在shuffle之后，因此如果你的数据本身是有序的，需要先手工打乱再指定validation_split，否则可能会出现验证集样本不均匀。
validation_data：形式为（X，y）或（X，y，sample_weights）的tuple，是指定的验证集。此参数将覆盖validation_spilt。
shuffle：布尔值，表示是否在训练过程中每个epoch前随机打乱输入样本的顺序。
class_weight：字典，将不同的类别映射为不同的权值，该参数用来在训练过程中调整损失函数（只能用于训练）。该参数在处理非平衡的训练数据（某些类的训练样本数很少）时，可以使得损失函数对样本数不足的数据更加关注。
sample_weight：权值的numpy.array，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（samples，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加了sample_weight_mode=’temporal’。
initial_epoch: 从该参数指定的epoch开始训练，在继续之前的训练时有用。
输入数据与规定数据不匹配时会抛出错误
fit函数返回一个History的对象，其History.history属性记录了损失函数和其他指标的数值随epoch变化的情况，如果有验证集的话，也包含了验证集的这些指标变化情况
+ evaluate，模型评估
`evaluate(self, x, y, batch_size=32, verbose=1, sample_weight=None)`
参数：
x：输入数据，与fit一样，是numpy.array或numpy.array的list
y：标签，numpy.array
batch_size：整数，含义同fit的同名参数
verbose：含义同fit的同名参数，但只能取0或1
sample_weight：numpy.array，含义同fit的同名参数
本函数返回一个测试误差的标量值（如果模型没有其他评价指标），或一个标量的list（如果模型还有其他的评价指标），model.metrics_names将给出list中各个值的含义
+ predict 模型预测
`predict(self, x, batch_size=32, verbose=0)`
+ 模型检查 `_on_batch`
`train_on_batch(self, x, y, class_weight=None, sample_weight=None)`
`test_on_batch(self, x, y, sample_weight=None)`
`predict_on_batch(self, x)`
train_on_batch：本函数在一个batch的数据上进行一次参数更新，函数返回训练误差的标量值或标量值的list，与evaluate的情形相同。 
test_on_batch：本函数在一个batch的样本上对模型进行评估，函数的返回与evaluate的情形相同； 
predict_on_batch：本函数在一个batch的样本上对模型进行测试，函数返回模型在一个batch上的预测结果
+ `_generator`
`fit_generator(self, generator, steps_per_epoch, epochs=1, verbose=1, callbacks=None, validation_data=None, validation_steps=None, class_weight=None, max_q_size=10, workers=1, pickle_safe=False, initial_epoch=0)`
`evaluate_generator(self, generator, steps, max_q_size=10, workers=1, pickle_safe=False)`
#### 案例一：简单的单层-全连接网络
```
from keras.layers import Input,Dense
from keras.models import Model
from keras.utils import to_categorical
import numpy as np

data = np.random.random((100,100,3))
data = data.reshape(len(data),-1)
labels = to_categorical(np.random.randint(10,size=(100,1)),num_classes=10)

inputs = Input(shape=(300,)) # 返回一个张量

x = Dense(64,activation='relu')(inputs) # inputs代表输入，x代表输出

x = Dense(64,activation='relu')(x) #输入x，输出x

predictions = Dense(10,activation='softmax')(x) # 输入x，输出分类

# This creates a model that includes the Input layer and three Dense layers
model = Model(inputs=inputs,outputs=predictions)
# 该句是函数式模型的经典，可以同时输入两个input，然后输出output两个模型
model.compile(optimizer='rmsprop',loss='categorical_crossentropy',metrics=['accuracy'])

# 开始训练
model.fit(data,labels,epochs=3,batch_size=32)
```
输出：
```
Using TensorFlow backend.
WARNING:tensorflow:From D:\Python37\Lib\site-packages\tensorflow\python\framework\op_def_library.py:263: colocate_with (from tensorflow.python.framework.ops) is deprecated and will be removed in a future version.
Instructions for updating:
Colocations handled automatically by placer.
WARNING:tensorflow:From D:\Python37\Lib\site-packages\tensorflow\python\ops\math_ops.py:3066: to_int32 (from tensorflow.python.ops.math_ops) is deprecated and will be removed in a future version.
Instructions for updating:
Use tf.cast instead.
2019-07-08 16:47:48.627213: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2
Epoch 1/3

 32/100 [========>.....................] - ETA: 0s - loss: 2.4095 - acc: 0.0625
100/100 [==============================] - 0s 2ms/step - loss: 2.3387 - acc: 0.1000
Epoch 2/3

 32/100 [========>.....................] - ETA: 0s - loss: 2.2108 - acc: 0.2188
100/100 [==============================] - 0s 50us/step - loss: 2.2436 - acc: 0.1900
Epoch 3/3

 32/100 [========>.....................] - ETA: 0s - loss: 2.1684 - acc: 0.1250
100/100 [==============================] - 0s 50us/step - loss: 2.1797 - acc: 0.2300
```
#### 案例二：视频处理
```
from keras.layers import Input,Dense
from keras.models import load_model

model = load_model('xxxx.h5')

x = Input(shape=(784,)) # This works, and returns the 10-way softmax we defined above.
y = model(x) # model是训练好的，现在用来做迁移学习
# model里存着权重，输入x，输出结果，用来作fine-tuning

from keras.layers import TimeDistributed

input_sequences = Input(shape=(20,784))

processed_sequences = TimeDistributed(model)(input_sequences)
```
#### 案例三：双输入、双模型输出：LSTM 时序预测
通过本案例可以了解到Model的精髓在于他的任意性，给编译者很多的便利。
输入： 
新闻语料；新闻语料对应的时间 
输出： 
新闻语料的预测模型；新闻语料+对应时间的预测模型 
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190708193025390-523904055.png)
```
### 模型一：只针对新闻语料的LSTM模型

from keras.layers import Input,Embedding,LSTM,Dense
from keras.datasets import reuters
from keras.utils import to_categorical

(headline_data, additional_data), (labels, labels) = reuters.load_data(num_words=10000)
labels = to_categorical(labels,num_classes=46)

# 标题输入：用于接收100个整数的序列，介于1和10000之间
main_input = Input(shape=(1,),dtype='int32',name='main_input')
# 注意：我们可以通过传递一个“name”参数来命名任何层
# 一个100词的BOW序列

# 这个嵌入层将输入序列编码成一个密集的512维向量序列
# Embedding层，把100维度再encode成512的句向量，10000指的是词典单词总数
x = Embedding(output_dim=512,input_dim=10000,input_length=1)(main_input)

# LSTM将把向量序列转换为单个向量，包含关于整个序列的信息。
lstm_out = LSTM(32)(x) # units=32，正整数，输出空间的维数

#然后，我们插入一个额外的损失，使得即使在主损失很高的情况下，LSTM和Embedding层也可以平滑的训练

auxiliary_output = Dense(1,activation='sigmoid',name='aux_output')(lstm_out)
#再然后，我们将LSTM与额外的输入数据串联起来组成输入，送入模型中

### 模型二：组合模型 新闻语料+时序

import keras
from keras.models import Model

auxiliary_output = Input(shape=(5,),name='aux_input') # 新加入的一个Input，维度=5
x = keras.layers.concatenate([lstm_out,auxiliary_output]) # 组合起来，对应起来

# 我们在上面堆了一个深度密集连接的网络 组合模型的形式
x = Dense(64,activation='relu')(x)
x = Dense(64,activation='relu')(x)
x = Dense(64,activation='relu')(x)
# 最后我们添加了主要的逻辑回归层
main_output = Dense(1,activation='sigmoid',name='main_output')(x)

# 最后，我们定义整个2输入，2输出的模型
model = Model(inputs=[main_input,auxiliary_output],outputs=[main_output,auxiliary_output])

# 模型定义完毕，下一步编译模型
# 我们给额外的损失赋0.2的权重，我们可以通过关键字参数loss_weights或loss来为不同的输出设置不同的损失函数或权值
# 这两个参数均可为Python的列表或字典，这里我们给loss传递单个损失函数，这个损失函数会被应用于所有输出上

# 训练方式一：两个模型 一个loss
model.compile(optimizer='rmsprop', loss='binary_crossentropy',loss_weights=[1., 0.2])
model.fit([headline_data, additional_data], [labels, labels],epochs=50, batch_size=32)

# # 训练方式二：两个模型 两个Loss
# model.compile(optimizer='rmsprop',
#                 loss={'main_output': 'binary_crossentropy', 'aux_output': 'binary_crossentropy'},
#               loss_weights={'main_output': 1., 'aux_output': 0.2})
# # And trained it via:
# model.fit({'main_input': headline_data, 'aux_input': additional_data},
#           {'main_output': labels, 'aux_output': labels},
#           epochs=50, batch_size=32)
```
#### 案例四：共享层：对应关系、相似性
+ 一个节点，分成两个分支出去
```
import keras
from keras.layers import Input,LSTM,Dense
from keras.models import Model

tweet_a = Input(shape=(140,256)) # 140个单词，每个单词256维度，词向量
tweet_b = Input(shape=(140,256))
# 若要对不同的输入共享同一层，就初始化该层一次，然后多次调用它

# 该层可以将矩阵作为输入，并返回大小为64的向量
shared_lstm = LSTM(64)

# 当我们多次重用同一层实例时，层的权重也将被重用（有效相同层）
encoded_a = shared_lstm(tweet_a)
encoded_b = shared_lstm(tweet_b)

# 连接两个结果
merged_vector = keras.layers.concatenate([encoded_a, encoded_b], axis=-1)

# 在顶部添加逻辑回归
predictions = Dense(1, activation='sigmoid')(merged_vector)

# 我们定义了一个可训练的模型，将tweet输入与预测相连接
model = Model(inputs=[tweet_a, tweet_b], outputs=predictions)

model.compile(optimizer='rmsprop',loss='binary_crossentropy',metrics=['accuracy'])
model.fit([data_a, data_b], labels, epochs=10) # 训练
```
#### 案例五：抽取层节点内容
```
# 1.单节点
from keras.layers import Input,LSTM,Dense
from keras.layers import Conv2D
a = Input(shape=(140,256))
lstm = LSTM(32)
encoded_a = lstm(a)
assert lstm.output == encoded_a
# 抽取获得encoded_a的输出张量

# 2.多节点
a = Input(shape=(140,256))
b = Input(shape=(140,256))

lstm = LSTM(32)
encoded_a = lstm(a)
encoded_b = lstm(b)

assert lstm.get_output_at(0) == encoded_a
assert lstm.get_output_at(1) == encoded_b

# 3.图像层节点
# 对于input_shape和output_shape也是一样，如果一个层只有一个节点，或所有的节点都有相同的输入或输出shape，那么input_shape和output_shape都是没有歧义的，并也只返回一个值。但是，例如你把一个相同的Conv2D应用于一个大小为(3,32,32)的数据，然后又将其应用于一个(3,64,64)的数据，那么此时该层就具有了多个输入和输出的shape，你就需要显式的指定节点的下标，来表明你想取的是哪个了
a = Input(shape=(3, 32, 32))
b = Input(shape=(3, 64, 64))
conv = Conv2D(16, (3, 3), padding='same')
conved_a = conv(a)

# Only one input so far, the following will work:
assert conv.input_shape == (None, 3, 32, 32)

conved_b = conv(b)
# now the `.input_shape` property wouldn't work, but this does:
assert conv.get_input_shape_at(0) == (None, 3, 32, 32)
assert conv.get_input_shape_at(1) == (None, 3, 64, 64)
```
#### 案例六：视觉问答模型
```
# 这个模型将自然语言的问题和图片分别映射为特征向量，
# 将二者合并后训练一个logistic回归层，从一系列可能的回答中挑选一个。
from keras.layers import Conv2D,MaxPooling2D,Flatten
from keras.layers import Input,LSTM,Embedding,Dense
from keras.models import Model,Sequential
import keras

# 首先，让我们使用顺序模型定义一个视觉模型。
# 该模型将图像编码为矢量。
vision_model = Sequential()
vision_model.add(Conv2D(64, (3, 3),activation='relu', padding='same', input_shape=(3, 224, 224)))
vision_model.add(Conv2D(64, (3, 3), activation='relu'))
vision_model.add(MaxPooling2D((2, 2)))
vision_model.add(Conv2D(128, (3, 3), activation='relu', padding='same'))
vision_model.add(Conv2D(128, (3, 3), activation='relu'))
vision_model.add(MaxPooling2D((2, 2)))
vision_model.add(Conv2D(256, (3, 3), activation='relu', padding='same'))
vision_model.add(Conv2D(256, (3, 3), activation='relu'))
vision_model.add(Conv2D(256, (3, 3), activation='relu'))
vision_model.add(MaxPooling2D((2, 2)))
vision_model.add(Flatten())

# 视觉模型的输出得到张量:
image_input = Input(shape=(3, 224, 224))
encoded_image = vision_model(image_input)

# 接下来，我们定义一个语言模型，将问题编码为向量。
# 每个问题的长度最多为100个字，我们将把单词索引为1到9999之间的整数。
question_input = Input(shape=(100,), dtype='int32')
embedded_question = Embedding(input_dim=10000, output_dim=256, input_length=100)(question_input)
encoded_question = LSTM(256)(embedded_question)

# 将问题向量和图像向量连接起来:
merged = keras.layers.concatenate([encoded_question, encoded_image])

# 训练一个超过1000个单词的逻辑回归:
output = Dense(1000, activation='softmax')(merged)

# 最终的模型:
vqa_model = Model(inputs=[image_input, question_input], outputs=output)
```
### fine-tuning时如何加载No_top的权重
+ 如果你需要加载权重到不同的网络结构（有些层一样）中，例如fine-tune或transfer-learning，你可以通过层名字来加载模型： 
`model.load_weights(‘my_model_weights.h5’, by_name=True)`
原模型：
```
model = Sequential()
model.add(Dense(2, input_dim=3, name="dense_1"))
model.add(Dense(3, name="dense_2"))
...
model.save_weights(fname)
```
新模型：
```
# new model
model = Sequential()
model.add(Dense(2, input_dim=3, name="dense_1"))  # will be loaded
model.add(Dense(10, name="new_dense"))  # will not be loaded

# load weights from first model; will only affect the first layer, dense_1.
model.load_weights(fname, by_name=True)
```]]></description></item><item><title>ValueError: Error when checking input: expected input_1 to have 2 dimensions, but got array with shape (100, 100, 100, 3)</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/08/11151953.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 08 Jul 2019 08:19:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/08/11151953.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/bug6/
+ 报错
```
Traceback (most recent call last):
  File "D:/PyCharm 5.0.3/WorkSpace/3.Keras/1.Sequential与Model模型、Keras基本结构功能/2_1.py", line 22, in <module>
    model.fit(data,labels,epochs=3)
  File "D:\Anaconda3\lib\site-packages\keras\engine\training.py", line 952, in fit
    batch_size=batch_size)
  File "D:\Anaconda3\lib\site-packages\keras\engine\training.py", line 751, in _standardize_user_data
    exception_prefix='input')
  File "D:\Anaconda3\lib\site-packages\keras\engine\training_utils.py", line 128, in standardize_input_data
    'with shape ' + str(data_shape))
ValueError: Error when checking input: expected input_1 to have 2 dimensions, but got array with shape (100, 100, 100, 3)
```
+ 原因
输入第一层的张量与数据集的shape不同
+ 解决
将data转置：
`data = data.reshape(len(data),-1)` 
然后会报错：
```
ValueError: Error when checking input: expected input_1 to have shape (784,) but got array with shape (300,)
```
再把shape按照提示改正：
`inputs = Input(shape=(300,))`]]></description></item><item><title>NLP（十九） 双向LSTM情感分类模型</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/07/nlp_19.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 07 Jul 2019 13:11:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/07/nlp_19.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp19/
+ 使用IMDB情绪数据来比较CNN和RNN两种方法，预处理与上节相同
```
from __future__ import print_function
import numpy as np
import pandas as pd
from keras.preprocessing import sequence
from keras.models import Sequential
from keras.layers import Dense,Dropout,Embedding,LSTM,Bidirectional
from keras.datasets import imdb
from sklearn.metrics import accuracy_score,classification_report

# 限制最大的特征数
max_features = 15000
max_len = 300
batch_size = 64

# 加载数据
(x_train,y_train),(x_test,y_test) = imdb.load_data(num_words=max_features)
print(len(x_train),'train observations')
print(len(x_test),'test observations')
```
输出：
```
Using TensorFlow backend.
25000 train observations
25000 test observations
```
+ 如何实现
1.预处理
2.LSTM模型的构建和验证
3.模型评估
+ 代码
```
from __future__ import print_function
import numpy as np
import pandas as pd
from keras.preprocessing import sequence
from keras.models import Sequential
from keras.layers import Dense,Dropout,Embedding,LSTM,Bidirectional
from keras.datasets import imdb
from sklearn.metrics import accuracy_score,classification_report

# 限制最大的特征数
max_features = 15000
max_len = 300
batch_size = 64

# 加载数据
(x_train,y_train),(x_test,y_test) = imdb.load_data(num_words=max_features)
# print(len(x_train),'train observations')
# print(len(x_test),'test observations')

# 通过序列填充将所有的数据整合为一个固定维度，提高运行效率
x_train_2 = sequence.pad_sequences(x_train,maxlen=max_len)
x_test_2 = sequence.pad_sequences(x_test,maxlen=max_len)
print('x_train_2.shape:',x_train_2.shape)
print('x_test_2.shape:',x_test_2.shape)
y_train = np.array(y_train)
y_test = np.array(y_test)

# keras框架 => 双向LSTM模型
# 双向LSTM网络有前向和后向连接，使句子中的单词可以同时与左右词汇产生连接
model = Sequential()
model.add(Embedding(max_features,128,input_length=max_len)) # 嵌入层将维数降到128
model.add(Bidirectional(LSTM(64))) # 双向LSTM层
model.add(Dropout(0.5)) # 随机失活
model.add(Dense(1,activation='sigmoid')) # 稠密层 将情感分类0或1
model.compile('adam','binary_crossentropy',metrics=['accuracy']) # 二元交叉熵
print(model.summary())

model.fit(x_train_2,y_train,batch_size=batch_size,epochs=4,validation_split=0.2)

# 预测及结果
y_train_predclass = model.predict_classes(x_train_2,batch_size=1000)
y_test_predclass = model.predict_classes(x_test_2,batch_size=1000)
y_train_predclass.shape = y_train.shape
y_test_predclass.shape = y_test.shape
print('\n\nLSTM Bidirectional Sentiment Classification - Train accuracy:',
      round(accuracy_score(y_train,y_train_predclass),3))
print('\nLSTM Bidirectional Sentiment Classification of Training data\n',
      classification_report(y_train,y_train_predclass))
print('\nLSTM Bidirectional Sentiment Classification - Train Confusion Matrix\n\n',
      pd.crosstab(y_train,y_train_predclass,rownames=['Actuall'],colnames=['Predicted']))
print('\nLSTM Bidirectional Sentiment Classification - Test accuracy:',
      round(accuracy_score(y_test,y_test_predclass),3))
print('\nLSTM Bidirectional Sentiment Classification of Test data\n',
      classification_report(y_test,y_test_predclass))
print('\nLSTM Bidirectional Sentiment Classification - Test Confusion Matrix\n\n',
      pd.crosstab(y_test,y_test_predclass,rownames=['Actuall'],colnames=['Predicted']))
```
输出：
```
Using TensorFlow backend.
x_train_2.shape: (25000, 300)
x_test_2.shape: (25000, 300)
WARNING:tensorflow:From D:\Python37\Lib\site-packages\tensorflow\python\framework\op_def_library.py:263: colocate_with (from tensorflow.python.framework.ops) is deprecated and will be removed in a future version.
Instructions for updating:
Colocations handled automatically by placer.
WARNING:tensorflow:From D:\Anaconda3\lib\site-packages\keras\backend\tensorflow_backend.py:3445: calling dropout (from tensorflow.python.ops.nn_ops) with keep_prob is deprecated and will be removed in a future version.
Instructions for updating:
Please use `rate` instead of `keep_prob`. Rate should be set to `rate = 1 - keep_prob`.
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
embedding_1 (Embedding)      (None, 300, 128)          1920000   
_________________________________________________________________
bidirectional_1 (Bidirection (None, 128)               98816     
_________________________________________________________________
dropout_1 (Dropout)          (None, 128)               0         
_________________________________________________________________
dense_1 (Dense)              (None, 1)                 129       
=================================================================
Total params: 2,018,945
Trainable params: 2,018,945
Non-trainable params: 0
_________________________________________________________________
None
WARNING:tensorflow:From D:\Python37\Lib\site-packages\tensorflow\python\ops\math_ops.py:3066: to_int32 (from tensorflow.python.ops.math_ops) is deprecated and will be removed in a future version.
Instructions for updating:
Use tf.cast instead.
Train on 20000 samples, validate on 5000 samples
Epoch 1/4
2019-07-07 20:03:45.649853: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2

   64/20000 [..............................] - ETA: 18:21 - loss: 0.6915 - acc: 0.5781
  128/20000 [..............................] - ETA: 13:04 - loss: 0.6918 - acc: 0.5938
  192/20000 [..............................] - ETA: 11:14 - loss: 0.6915 - acc: 0.5729
  256/20000 [..............................] - ETA: 10:19 - loss: 0.6917 - acc: 0.5469
  320/20000 [..............................] - ETA: 9:45 - loss: 0.6915 - acc: 0.5469 
  此处省略一堆epoch的一堆操作

LSTM Bidirectional Sentiment Classification - Train accuracy: 0.955

LSTM Bidirectional Sentiment Classification of Training data
               precision    recall  f1-score   support

           0       0.96      0.95      0.95     12500
           1       0.95      0.96      0.95     12500

    accuracy                           0.95     25000
   macro avg       0.95      0.95      0.95     25000
weighted avg       0.95      0.95      0.95     25000

LSTM Bidirectional Sentiment Classification - Train Confusion Matrix

 Predicted      0      1
Actuall                
0          11928    572
1            561  11939

LSTM Bidirectional Sentiment Classification - Test accuracy: 0.859

LSTM Bidirectional Sentiment Classification of Test data
               precision    recall  f1-score   support

           0       0.86      0.86      0.86     12500
           1       0.86      0.85      0.86     12500

    accuracy                           0.86     25000
   macro avg       0.86      0.86      0.86     25000
weighted avg       0.86      0.86      0.86     25000


LSTM Bidirectional Sentiment Classification - Test Confusion Matrix

 Predicted      0      1
Actuall                
0          10809   1691
1           1829  10671
time============== 2080.618681907654
```]]></description></item><item><title>NLP（十八） 一维卷积网络IMDB情感分析</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/07/nlp_18.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 07 Jul 2019 11:21:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/07/nlp_18.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp18/
+ 准备
Keras的IMDB数据集，包含一个词集和对应的情感标签
```
import pandas as pd
from keras.preprocessing import sequence
from keras.models import Sequential
from keras.layers import Dense,Dropout,Activation
from keras.layers import Embedding
from keras.layers import Conv1D,GlobalAveragePooling1D
from keras.datasets import imdb
from sklearn.metrics import accuracy_score,classification_report

# 参数 最大特征数6000 单个句子最大长度400
max_features = 6000
max_length = 400
(x_train,y_train),(x_test,y_test) = imdb.load_data(num_words=max_features)
print(len(x_train),'train observations')
print(len(x_test),'test observations')

wind = imdb.get_word_index() # 给单词编号，用数字代替单词
revind = dict((k,v) for k,v in enumerate(wind))
# 单词编号:情感词性编号 字典 => 情感词性编号:一堆该词性的单词编号列表
print(x_train[0])
print(y_train[0])

def decode(sent_list): # 逆映射字典解码 数字=>单词
    new_words = []
    for i in sent_list:
        new_words.append(revind[i])
    comb_words = " ".join(new_words)
    return comb_words
print(decode(x_train[0]))
```
输出：
```
25000 train observations
25000 test observations
[1, 14, 22, 16, 43, 530, 973, 1622, 1385, 。。。]
1
tsukino 'royale rumbustious canet thrace bellow headbanger 。。。
```
+ 如何实现
1.预处理，数据整合到一个固定的维度
2.一维CNN模型的构建和验证
3.模型评估
+ 代码
```
import pandas as pd
from keras.preprocessing import sequence
from keras.models import Sequential
from keras.layers import Dense,Dropout,Activation
from keras.layers import Embedding
from keras.layers import Conv1D,GlobalAveragePooling1D
from keras.datasets import imdb
from sklearn.metrics import accuracy_score,classification_report

# 参数 最大特征数6000 单个句子最大长度400
max_features = 6000
max_length = 400
(x_train,y_train),(x_test,y_test) = imdb.load_data(num_words=max_features)
# print(x_train) # 一堆句子，每个句子有有一堆单词编码
# print(y_train) # 一堆0或1
# print(len(x_train),'train observations')
# print(len(x_test),'test observations')

wind = imdb.get_word_index() # 给单词编号，用数字代替单词
revind = dict((k, v) for k, v in enumerate(wind))
# 单词编号:情感词性编号 字典 => 情感词性编号:一堆该词性的单词编号列表
# print(x_train[0])
# print(y_train[0])

def decode(sent_list): # 逆映射字典解码 数字=>单词
    new_words = []
    for i in sent_list:
        new_words.append(revind[i])
    comb_words = " ".join(new_words)
    return comb_words
# print(decode(x_train[0]))

# 将句子填充到最大长度400 使数据长度保持一致
x_train = sequence.pad_sequences(x_train,maxlen=max_length)
x_test = sequence.pad_sequences(x_test,maxlen=max_length)
print('x_train.shape:',x_train.shape)
print('x_test.shape:',x_test.shape)

## Keras框架 深度学习 一维CNN模型
# 参数
batch_size = 32
embedding_dims = 60
num_kernels = 260
kernel_size = 3
hidden_dims = 300
epochs = 3
# 建立模型
model = Sequential()
model.add(Embedding(max_features,embedding_dims,input_length=max_length))
model.add(Dropout(0.2))
model.add(Conv1D(num_kernels,kernel_size,padding='valid',activation='relu',strides=1))
model.add(GlobalAveragePooling1D())
model.add(Dense(hidden_dims))
model.add(Dropout(0.5))
model.add(Activation('relu'))
model.add(Dense(1))
model.add(Activation('sigmoid'))
model.compile(loss='binary_crossentropy',optimizer='adam',metrics=['accuracy'])
print(model.summary())

model.fit(x_train,y_train,batch_size=batch_size,epochs=epochs,validation_split=0.2)

# 模型预测
y_train_predclass = model.predict_classes(x_train,batch_size=batch_size)
y_test_preclass = model.predict_classes(x_test,batch_size=batch_size)
y_train_predclass.shape = y_train.shape
y_test_preclass.shape = y_test.shape

print('\n\nCNN 1D - Train accuracy:',round(accuracy_score(y_train,y_train_predclass),3))
print('\nCNN 1D of Training data\n',classification_report(y_train,y_train_predclass))
print('\nCNN 1D - Train Confusion Matrix\n\n',pd.crosstab(y_train,y_train_predclass,
                    rownames=['Actuall'],colnames=['Predicted']))
print('\nCNN 1D - Test accuracy:',round(accuracy_score(y_test,y_test_preclass),3))
print('\nCNN 1D of Test data\n',classification_report(y_test,y_test_preclass))
print('\nCNN 1D - Test Confusion Matrix\n\n',pd.crosstab(y_test,y_test_preclass,
                    rownames=['Actuall'],colnames=['Predicted']))
```
输出：
```
Using TensorFlow backend.
x_train.shape: (25000, 400)
x_test.shape: (25000, 400)
WARNING:tensorflow:From 
D:\Python37\Lib\site-packages\tensorflow\python\framework\op_def_library.py:263: 
colocate_with (from tensorflow.python.framework.ops) is deprecated and will be removed in a 
future version.
Instructions for updating:
Colocations handled automatically by placer.
WARNING:tensorflow:From 
D:\Anaconda3\lib\site-packages\keras\backend\tensorflow_backend.py:3445: calling dropout 
(from tensorflow.python.ops.nn_ops) with keep_prob is deprecated and will be removed in a 
future version.
Instructions for updating:
Please use `rate` instead of `keep_prob`. Rate should be set to `rate = 1 - keep_prob`.
_________________________________________________________________
Layer (type)                 Output Shape              Param #   

=================================================================
embedding_1 (Embedding)      (None, 400, 60)           360000    
_________________________________________________________________
dropout_1 (Dropout)          (None, 400, 60)           0         
_________________________________________________________________
conv1d_1 (Conv1D)            (None, 398, 260)          47060     
_________________________________________________________________
global_average_pooling1d_1 ( (None, 260)               0         
_________________________________________________________________
dense_1 (Dense)              (None, 300)               78300     
_________________________________________________________________
dropout_2 (Dropout)          (None, 300)               0         
_________________________________________________________________
activation_1 (Activation)    (None, 300)               0         
_________________________________________________________________
dense_2 (Dense)              (None, 1)                 301       
_________________________________________________________________
activation_2 (Activation)    (None, 1)                 0         

=================================================================
Total params: 485,661
Trainable params: 485,661
Non-trainable params: 0
_________________________________________________________________
None
WARNING:tensorflow:From 
D:\Python37\Lib\site-packages\tensorflow\python\ops\math_ops.py:3066: to_int32 (from 
tensorflow.python.ops.math_ops) is deprecated and will be removed in a future version.
Instructions for updating:
Use tf.cast instead.
Train on 20000 samples, validate on 5000 samples
Epoch 1/3
2019-07-07 15:27:37.848057: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU 
supports instructions that this TensorFlow binary was not compiled to use: AVX2

   32/20000 [..............................] - ETA: 7:03 - loss: 0.6929 - acc: 0.5000
   64/20000 [..............................] - ETA: 4:13 - loss: 0.6927 - acc: 0.5156
   96/20000 [..............................] - ETA: 3:19 - loss: 0.6933 - acc: 0.5000
  128/20000 [..............................] - ETA: 2:50 - loss: 0.6935 - acc: 0.4844
  160/20000 [..............................] - ETA: 2:32 - loss: 0.6931 - acc: 0.4813
  此处省略一堆epoch的一堆操作
  
CNN 1D - Train accuracy: 0.949

CNN 1D of Training data
               precision    recall  f1-score   support

           0       0.94      0.96      0.95     12500
           1       0.95      0.94      0.95     12500

    accuracy                           0.95     25000
   macro avg       0.95      0.95      0.95     25000
weighted avg       0.95      0.95      0.95     25000

CNN 1D - Train Confusion Matrix

 Predicted      0      1
Actuall                
0          11938    562
1            715  11785

CNN 1D - Test accuracy: 0.876

CNN 1D of Test data
               precision    recall  f1-score   support

           0       0.86      0.89      0.88     12500
           1       0.89      0.86      0.87     12500

    accuracy                           0.88     25000
   macro avg       0.88      0.88      0.88     25000
weighted avg       0.88      0.88      0.88     25000

CNN 1D - Test Confusion Matrix

 Predicted      0      1
Actuall                
0          11144   1356
1           1744  10756

```]]></description></item><item><title>keras系列︱迁移学习：利用InceptionV3进行fine-tuning及预测、完美案例（五）</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/07/11146779.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 07 Jul 2019 08:53:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/07/11146779.html</guid><description><![CDATA[<div class="blogpost-body" id="cnblogs_post_body"><p>引自：<a href="http://blog.csdn.net/sinat_26917383/article/details/72982230" target="_blank">http://blog.csdn.net/sinat_26917383/article/details/72982230</a></p>
<p>&nbsp;</p>
<blockquote>
<p>之前在博客《<a href="http://blog.csdn.net/sinat_26917383/article/details/72861152" target="_blank">keras系列︱图像多分类训练与利用bottleneck features进行微调（三）</a>》一直在倒腾VGG16的fine-tuning，然后因为其中的Flatten层一直没有真的实现最后一个模块的fine-tuning。&nbsp;<br>看到github上有一份<a href="https://github.com/DeepLearningSandbox/DeepLearningSandbox/blob/master/transfer_learning" target="_blank">InceptionV3</a>的fine-tuning并且可以实现。</p>
<p>我看到的keras微调的方式分为以下两种：&nbsp;<br>fine-tuning方式一：使用预训练网络的bottleneck特征&nbsp;<br>fine-tuning方式二：要调整权重，并训练</p>


</blockquote>
<p>.</p>
<hr>
<h4 id="整个流程分为以下几个步骤">整个流程分为以下几个步骤：</h4>
<ul>
<li><strong>一、定义函数以及加载模块</strong></li>
<li><strong>二、数据准备</strong></li>
<li><strong>三、 fine-tuning方式一：使用预训练网络的bottleneck特征</strong></li>
<li><strong>四、fine-tuning方式二：要调整权重，并训练</strong></li>
<li><strong>五、画图函数</strong></li>
<li><strong>六、预测</strong></li>


</ul>
<p>.</p>
<hr>
<p>.</p>
<h3 id="keras系列"><a name="t0"></a>Keras系列：</h3>
<p>1、<a href="https://www.cnblogs.com/peng8098/articles/11146719.html" target="_blank">keras系列︱Sequential与Model模型、keras基本结构功能（一）</a>&nbsp;<br>2、<a href="https://www.cnblogs.com/peng8098/articles/11146752.html" target="_blank">keras系列︱Application中五款已训练模型、VGG16框架（Sequential式、Model式）解读（二）</a>&nbsp;<br>3、<a href="https://www.cnblogs.com/peng8098/articles/11146766.html" target="_blank">keras系列︱图像多分类训练与利用bottleneck features进行微调（三）</a>&nbsp;<br>4、<a href="https://www.cnblogs.com/peng8098/articles/11146774.html" target="_blank">keras系列︱人脸表情分类与识别：opencv人脸检测+Keras情绪分类（四）</a>&nbsp;<br>5、<a href="https://www.cnblogs.com/peng8098/articles/11146779.html" target="_blank">keras系列︱迁移学习：利用InceptionV3进行fine-tuning及预测、完整案例（五）</a></p>
<hr>
<h2 id="一定义函数以及加载模块"><a name="t0"></a>一、定义函数以及加载模块</h2>
<p>其中的get_nb_files函数为得到文件数量，个数。&nbsp;<br>其中，from keras.applications.inception_v3_matt import InceptionV3中，我有自己改，不然就会每次都从网上下载。</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword"><span class="hljs-keyword">import</span> sys
<span class="hljs-keyword"><span class="hljs-keyword">import</span> glob
<span class="hljs-keyword"><span class="hljs-keyword">import</span> argparse
<span class="hljs-keyword"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span> plt

<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras <span class="hljs-keyword"><span class="hljs-keyword">import</span> __version__
<span class="hljs-comment"><span class="hljs-comment"># from keras.applications.inception_v3 import InceptionV3, preprocess_input</span>
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.applications.inception_v3_matt <span class="hljs-keyword"><span class="hljs-keyword">import</span> InceptionV3, preprocess_input

<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> Model
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Dense, GlobalAveragePooling2D
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword"><span class="hljs-keyword">import</span> ImageDataGenerator
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.optimizers <span class="hljs-keyword"><span class="hljs-keyword">import</span> SGD

<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nb_files</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(directory)</span>:</span>
  <span class="hljs-string"><span class="hljs-string">"""Get number of files by searching directory recursively"""</span>
  <span class="hljs-keyword"><span class="hljs-keyword">if</span> <span class="hljs-keyword"><span class="hljs-keyword">not</span> os.path.exists(directory):
    <span class="hljs-keyword"><span class="hljs-keyword">return</span> <span class="hljs-number"><span class="hljs-number">0</span>
  cnt = <span class="hljs-number"><span class="hljs-number">0</span>
  <span class="hljs-keyword"><span class="hljs-keyword">for</span> r, dirs, files <span class="hljs-keyword"><span class="hljs-keyword">in</span> os.walk(directory):
    <span class="hljs-keyword"><span class="hljs-keyword">for</span> dr <span class="hljs-keyword"><span class="hljs-keyword">in</span> dirs:
      cnt += len(glob.glob(os.path.join(r, dr + <span class="hljs-string"><span class="hljs-string">"/*"</span>)))
  <span class="hljs-keyword"><span class="hljs-keyword">return</span> cnt
<span class="hljs-comment"><span class="hljs-comment"># get_nb_files('/home/ubuntu/keras/animal5/train')</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>.</p>
<hr>
<h2 id="二数据准备"><a name="t1"></a>二、数据准备</h2>
<p>数据放在不同的文件夹下即可，很方便。本文实践的数据是我上次博客的数据<a href="http://blog.csdn.net/sinat_26917383/article/details/72861152" target="_blank">《keras系列︱图像多分类训练与利用bottleneck features进行微调（三）》</a>的第二节。&nbsp;<br><img title="" alt="" src="http://img.blog.csdn.net/20170604203601030?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMjY5MTczODM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>同时原作者在.flow_from_directory函数中，好像漏写了class_mode=’categorical’，一开始导致最后训练的时候，val_acc一直在0.2徘徊。</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># 数据准备</span>
IM_WIDTH, IM_HEIGHT = <span class="hljs-number"><span class="hljs-number">299</span>, <span class="hljs-number"><span class="hljs-number">299</span> <span class="hljs-comment"><span class="hljs-comment">#InceptionV3指定的图片尺寸</span>
FC_SIZE = <span class="hljs-number"><span class="hljs-number">1024</span>                <span class="hljs-comment"><span class="hljs-comment"># 全连接层的节点个数</span>
NB_IV3_LAYERS_TO_FREEZE = <span class="hljs-number"><span class="hljs-number">172</span>  <span class="hljs-comment"><span class="hljs-comment"># 冻结层的数量</span>


train_dir = <span class="hljs-string"><span class="hljs-string">'/home/ubuntu/keras/animal5/train'</span>  <span class="hljs-comment"><span class="hljs-comment"># 训练集数据</span>
val_dir = <span class="hljs-string"><span class="hljs-string">'/home/ubuntu/keras/animal5/validation'</span> <span class="hljs-comment"><span class="hljs-comment"># 验证集数据</span>
nb_classes= <span class="hljs-number"><span class="hljs-number">5</span>
nb_epoch = <span class="hljs-number"><span class="hljs-number">3</span>
batch_size = <span class="hljs-number"><span class="hljs-number">16</span>

nb_train_samples = get_nb_files(train_dir)      <span class="hljs-comment"><span class="hljs-comment"># 训练样本个数</span>
nb_classes = len(glob.glob(train_dir + <span class="hljs-string"><span class="hljs-string">"/*"</span>))  <span class="hljs-comment"><span class="hljs-comment"># 分类数</span>
nb_val_samples = get_nb_files(val_dir)       <span class="hljs-comment"><span class="hljs-comment">#验证集样本个数</span>
nb_epoch = int(nb_epoch)                <span class="hljs-comment"><span class="hljs-comment"># epoch数量</span>
batch_size = int(batch_size)           

<span class="hljs-comment"><span class="hljs-comment">#　图片生成器</span>
train_datagen =  ImageDataGenerator(
  preprocessing_function=preprocess_input,
  rotation_range=<span class="hljs-number"><span class="hljs-number">30</span>,
  width_shift_range=<span class="hljs-number"><span class="hljs-number">0.2</span>,
  height_shift_range=<span class="hljs-number"><span class="hljs-number">0.2</span>,
  shear_range=<span class="hljs-number"><span class="hljs-number">0.2</span>,
  zoom_range=<span class="hljs-number"><span class="hljs-number">0.2</span>,
  horizontal_flip=<span class="hljs-keyword"><span class="hljs-keyword">True</span>
)
test_datagen = ImageDataGenerator(
  preprocessing_function=preprocess_input,
  rotation_range=<span class="hljs-number"><span class="hljs-number">30</span>,
  width_shift_range=<span class="hljs-number"><span class="hljs-number">0.2</span>,
  height_shift_range=<span class="hljs-number"><span class="hljs-number">0.2</span>,
  shear_range=<span class="hljs-number"><span class="hljs-number">0.2</span>,
  zoom_range=<span class="hljs-number"><span class="hljs-number">0.2</span>,
  horizontal_flip=<span class="hljs-keyword"><span class="hljs-keyword">True</span>
)

<span class="hljs-comment"><span class="hljs-comment"># 训练数据与测试数据</span>
train_generator = train_datagen.flow_from_directory(
train_dir,
target_size=(IM_WIDTH, IM_HEIGHT),
batch_size=batch_size,class_mode=<span class="hljs-string"><span class="hljs-string">'categorical'</span>)

validation_generator = test_datagen.flow_from_directory(
val_dir,
target_size=(IM_WIDTH, IM_HEIGHT),
batch_size=batch_size,class_mode=<span class="hljs-string"><span class="hljs-string">'categorical'</span>)
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>.</p>
<hr>
<h2 id="三-fine-tuning方式一使用预训练网络的bottleneck特征"><a name="t2"></a>三、 fine-tuning方式一：使用预训练网络的bottleneck特征</h2>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># 添加新层</span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_new_last_layer</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base_model, nb_classes)</span>:</span>
  <span class="hljs-string"><span class="hljs-string">"""
  添加最后的层
  输入
  base_model和分类数量
  输出
  新的keras的model
  """</span>
  x = base_model.output
  x = GlobalAveragePooling2D()(x)
  x = Dense(FC_SIZE, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>)(x) <span class="hljs-comment"><span class="hljs-comment">#new FC layer, random init</span>
  predictions = Dense(nb_classes, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span>)(x) <span class="hljs-comment"><span class="hljs-comment">#new softmax layer</span>
  model = Model(input=base_model.input, output=predictions)
  <span class="hljs-keyword"><span class="hljs-keyword">return</span> model

<span class="hljs-comment"><span class="hljs-comment"># 冻上base_model所有层，这样就可以正确获得bottleneck特征</span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_to_transfer_learn</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model, base_model)</span>:</span>
  <span class="hljs-string"><span class="hljs-string">"""Freeze all layers and compile the model"""</span>
  <span class="hljs-keyword"><span class="hljs-keyword">for</span> layer <span class="hljs-keyword"><span class="hljs-keyword">in</span> base_model.layers:
    layer.trainable = <span class="hljs-keyword"><span class="hljs-keyword">False</span>
  model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">'rmsprop'</span>, loss=<span class="hljs-string"><span class="hljs-string">'categorical_crossentropy'</span>, metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span>])

<span class="hljs-comment"><span class="hljs-comment"># 定义网络框架</span>
base_model = InceptionV3(weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span>, include_top=<span class="hljs-keyword"><span class="hljs-keyword">False</span>) <span class="hljs-comment"><span class="hljs-comment"># 预先要下载no_top模型</span>
model = add_new_last_layer(base_model, nb_classes)              <span class="hljs-comment"><span class="hljs-comment"># 从基本no_top模型上添加新层</span>
setup_to_transfer_learn(model, base_model)                      <span class="hljs-comment"><span class="hljs-comment"># 冻结base_model所有层</span>

<span class="hljs-comment"><span class="hljs-comment"># 模式一训练</span>
history_tl = model.fit_generator(
train_generator,
nb_epoch=nb_epoch,
samples_per_epoch=nb_train_samples,
validation_data=validation_generator,
nb_val_samples=nb_val_samples,
class_weight=<span class="hljs-string"><span class="hljs-string">'auto'</span>)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h4 id="训练时候报错">训练时候报错：</h4>
<p><strong>main</strong>:15: UserWarning: Update your&nbsp;<code>Model</code>&nbsp;call to the Keras 2 API:&nbsp;<code>Model(outputs=Tensor("de..., inputs=Tensor("in...)</code>&nbsp;<br>没有关系。</p>
<h4 id="有过这样的报错">有过这样的报错 ：</h4>
<p>Epoch 1/3&nbsp;<br>25/25 [==============================] - 37s - loss: 12.6398 - acc: 0.1900 - val_loss: 12.8990 - val_acc: 0.1997&nbsp;<br>Epoch 2/3&nbsp;<br>25/25 [==============================] - 34s - loss: 12.8945 - acc: 0.2000 - val_loss: 12.8718 - val_acc: 0.2014&nbsp;<br>Epoch 3/3&nbsp;<br>25/25 [==============================] - 34s - loss: 12.8945 - acc: 0.2000 - val_loss: 12.8877 - val_acc: 0.2004&nbsp;<br>一般是我在设置错了分类时候会出现的情况</p>
<h4 id="出错在之前少加了classmode">出错在：之前少加了class_mode</h4>
<p>train_generator = train_datagen.flow_from_directory(&nbsp;<br>train_dir,&nbsp;<br>target_size=(IM_WIDTH, IM_HEIGHT),&nbsp;<br>batch_size=batch_size,class_mode=’categorical’)&nbsp;<br>.</p>
<hr>
<h2 id="四fine-tuning方式二要调整权重并训练"><a name="t3"></a>四、fine-tuning方式二：要调整权重，并训练</h2>
<p>那么fine-tuning模式一与模式二区别在于，模式一冻结了base_model所有层，只有新添加的层才能训练，调整权重。但是模式二，在base_model内开放了一部分。&nbsp;<br>类似的可以看到官方VGG16的两种模式的区别：&nbsp;<br><img title="" alt="" src="http://keras-cn.readthedocs.io/en/latest/images/vgg16_original.png">&nbsp;<br><img title="" alt="" src="http://keras-cn.readthedocs.io/en/latest/images/vgg16_modified.png">&nbsp;<br>第一张图就是模式一，冻结了base_model层；第二张图就是模式二，base_model一些层都开放了。</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">
<span class="hljs-comment"><span class="hljs-comment"># 冻上NB_IV3_LAYERS之前的层</span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_to_finetune</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model)</span>:</span>
  <span class="hljs-string"><span class="hljs-string">"""Freeze the bottom NB_IV3_LAYERS and retrain the remaining top layers.

  note: NB_IV3_LAYERS corresponds to the top 2 inception blocks in the inceptionv3 arch

  Args:
    model: keras model
  """</span>
  <span class="hljs-keyword"><span class="hljs-keyword">for</span> layer <span class="hljs-keyword"><span class="hljs-keyword">in</span> model.layers[:NB_IV3_LAYERS_TO_FREEZE]:
     layer.trainable = <span class="hljs-keyword"><span class="hljs-keyword">False</span>
  <span class="hljs-keyword"><span class="hljs-keyword">for</span> layer <span class="hljs-keyword"><span class="hljs-keyword">in</span> model.layers[NB_IV3_LAYERS_TO_FREEZE:]:
     layer.trainable = <span class="hljs-keyword"><span class="hljs-keyword">True</span>
  model.compile(optimizer=SGD(lr=<span class="hljs-number"><span class="hljs-number">0.0001</span>, momentum=<span class="hljs-number"><span class="hljs-number">0.9</span>), loss=<span class="hljs-string"><span class="hljs-string">'categorical_crossentropy'</span>, metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span>])

<span class="hljs-comment"><span class="hljs-comment"># 设置网络结构</span>
setup_to_finetune(model)

<span class="hljs-comment"><span class="hljs-comment"># 模式二训练</span>
history_ft = model.fit_generator(
train_generator,
samples_per_epoch=nb_train_samples,
nb_epoch=nb_epoch,
validation_data=validation_generator,
nb_val_samples=nb_val_samples,
class_weight=<span class="hljs-string"><span class="hljs-string">'auto'</span>)

<span class="hljs-comment"><span class="hljs-comment"># 模型保存</span>
model.save(args.output_model_file)
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># 正确</span>
Epoch <span class="hljs-number"><span class="hljs-number">1</span>/<span class="hljs-number"><span class="hljs-number">3</span>

<span class="hljs-number"><span class="hljs-number">25</span>/<span class="hljs-number"><span class="hljs-number">25</span> [==============================] - <span class="hljs-number"><span class="hljs-number">38</span>s - loss: <span class="hljs-number"><span class="hljs-number">0.0589</span> - acc: <span class="hljs-number"><span class="hljs-number">0.9850</span> - val_loss: <span class="hljs-number"><span class="hljs-number">0.0084</span> - val_acc: <span class="hljs-number"><span class="hljs-number">0.9986</span>
Epoch <span class="hljs-number"><span class="hljs-number">2</span>/<span class="hljs-number"><span class="hljs-number">3</span>
<span class="hljs-number"><span class="hljs-number">25</span>/<span class="hljs-number"><span class="hljs-number">25</span> [==============================] - <span class="hljs-number"><span class="hljs-number">37</span>s - loss: <span class="hljs-number"><span class="hljs-number">0.0196</span> - acc: <span class="hljs-number"><span class="hljs-number">0.9925</span> - val_loss: <span class="hljs-number"><span class="hljs-number">0.0150</span> - val_acc: <span class="hljs-number"><span class="hljs-number">0.9965</span>
Epoch <span class="hljs-number"><span class="hljs-number">3</span>/<span class="hljs-number"><span class="hljs-number">3</span>
<span class="hljs-number"><span class="hljs-number">25</span>/<span class="hljs-number"><span class="hljs-number">25</span> [==============================] - <span class="hljs-number"><span class="hljs-number">37</span>s - loss: <span class="hljs-number"><span class="hljs-number">0.0349</span> - acc: <span class="hljs-number"><span class="hljs-number">0.9875</span> - val_loss: <span class="hljs-number"><span class="hljs-number">0.0101</span> - val_acc: <span class="hljs-number"><span class="hljs-number">0.9979</span>
<br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>.</p>
<hr>
<h2 id="五画图函数"><a name="t4"></a>五、画图函数</h2>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># 画图</span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plot_training</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(history)</span>:</span>
  acc = history.history[<span class="hljs-string"><span class="hljs-string">'acc'</span>]
  val_acc = history.history[<span class="hljs-string"><span class="hljs-string">'val_acc'</span>]
  loss = history.history[<span class="hljs-string"><span class="hljs-string">'loss'</span>]
  val_loss = history.history[<span class="hljs-string"><span class="hljs-string">'val_loss'</span>]
  epochs = range(len(acc))
  plt.plot(epochs, acc, <span class="hljs-string"><span class="hljs-string">'r.'</span>)
  plt.plot(epochs, val_acc, <span class="hljs-string"><span class="hljs-string">'r'</span>)
  plt.title(<span class="hljs-string"><span class="hljs-string">'Training and validation accuracy'</span>)
  plt.figure()
  plt.plot(epochs, loss, <span class="hljs-string"><span class="hljs-string">'r.'</span>)
  plt.plot(epochs, val_loss, <span class="hljs-string"><span class="hljs-string">'r-'</span>)
  plt.title(<span class="hljs-string"><span class="hljs-string">'Training and validation loss'</span>)
  plt.show()

<span class="hljs-comment"><span class="hljs-comment"># 训练的acc_loss图</span>
plot_training(history_ft)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>.</p>
<hr>
<h2 id="六预测"><a name="t5"></a>六、预测</h2>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># 定义层</span>
<span class="hljs-keyword"><span class="hljs-keyword">import</span> sys
<span class="hljs-keyword"><span class="hljs-keyword">import</span> argparse
<span class="hljs-keyword"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span> np
<span class="hljs-keyword"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span> Image
<span class="hljs-keyword"><span class="hljs-keyword">import</span> requests
<span class="hljs-keyword"><span class="hljs-keyword">from</span> io <span class="hljs-keyword"><span class="hljs-keyword">import</span> BytesIO
<span class="hljs-keyword"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span> plt

<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.preprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span> image
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> load_model
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.applications.inception_v3 <span class="hljs-keyword"><span class="hljs-keyword">import</span> preprocess_input

<span class="hljs-comment"><span class="hljs-comment"># 狂阶图片指定尺寸</span>
target_size = (<span class="hljs-number"><span class="hljs-number">229</span>, <span class="hljs-number"><span class="hljs-number">229</span>) <span class="hljs-comment"><span class="hljs-comment">#fixed size for InceptionV3 architecture</span>

<span class="hljs-comment"><span class="hljs-comment"># 预测函数</span>
<span class="hljs-comment"><span class="hljs-comment"># 输入：model，图片，目标尺寸</span>
<span class="hljs-comment"><span class="hljs-comment"># 输出：预测predict</span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predict</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model, img, target_size)</span>:</span>
  <span class="hljs-string"><span class="hljs-string">"""Run model prediction on image
  Args:
    model: keras model
    img: PIL format image
    target_size: (w,h) tuple
  Returns:
    list of predicted labels and their probabilities
  """</span>
  <span class="hljs-keyword"><span class="hljs-keyword">if</span> img.size != target_size:
    img = img.resize(target_size)

  x = image.img_to_array(img)
  x = np.expand_dims(x, axis=<span class="hljs-number"><span class="hljs-number">0</span>)
  x = preprocess_input(x)
  preds = model.predict(x)
  <span class="hljs-keyword"><span class="hljs-keyword">return</span> preds[<span class="hljs-number"><span class="hljs-number">0</span>]

<span class="hljs-comment"><span class="hljs-comment"># 画图函数</span>
<span class="hljs-comment"><span class="hljs-comment"># 预测之后画图，这里默认是猫狗，当然可以修改label</span>

labels = (<span class="hljs-string"><span class="hljs-string">"cat"</span>, <span class="hljs-string"><span class="hljs-string">"dog"</span>)
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plot_preds</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image, preds,labels)</span>:</span>
  <span class="hljs-string"><span class="hljs-string">"""Displays image and the top-n predicted probabilities in a bar graph
  Args:
    image: PIL image
    preds: list of predicted labels and their probabilities
  """</span>
  plt.imshow(image)
  plt.axis(<span class="hljs-string"><span class="hljs-string">'off'</span>)
  plt.figure()
  plt.barh([<span class="hljs-number"><span class="hljs-number">0</span>, <span class="hljs-number"><span class="hljs-number">1</span>], preds, alpha=<span class="hljs-number"><span class="hljs-number">0.5</span>)
  plt.yticks([<span class="hljs-number"><span class="hljs-number">0</span>, <span class="hljs-number"><span class="hljs-number">1</span>], labels)
  plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Probability'</span>)
  plt.xlim(<span class="hljs-number"><span class="hljs-number">0</span>,<span class="hljs-number"><span class="hljs-number">1.01</span>)
  plt.tight_layout()
  plt.show()

<span class="hljs-comment"><span class="hljs-comment"># 载入模型</span>
model = load_model(args.model)

<span class="hljs-comment"><span class="hljs-comment"># 本地图片</span>
img = Image.open(image)
preds = predict(model, img, target_size)
plot_preds(img, preds)

<span class="hljs-comment"><span class="hljs-comment"># 图片URL</span>
response = requests.get(image_url)
img = Image.open(BytesIO(response.content))
preds = predict(model, img, target_size)
plot_preds(img, preds)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<h2 id="延伸一fine-tuning时如何加载notop的权重"><a name="t6"></a>延伸一：fine-tuning时如何加载No_top的权重</h2>
<p>场景：你要用自己的训练完的模型，作为下一个模型初始化的权重，譬如inceptionv3中的no_top版本。&nbsp;<br>如果你需要加载权重到不同的网络结构（有些层一样）中，例如fine-tune或transfer-learning，你可以通过层名字来加载模型：&nbsp;<br>model.load_weights(‘my_model_weights.h5’, by_name=True)&nbsp;<br>例如：</p>
<p>假如原模型为：</p>
<pre class="prettyprint"><code class="hljs r has-numbering">    model = Sequential()
    model.add(Dense(<span class="hljs-number"><span class="hljs-number">2</span>, input_dim=<span class="hljs-number"><span class="hljs-number">3</span>, name=<span class="hljs-string"><span class="hljs-string">"dense_1"</span>))
    model.add(Dense(<span class="hljs-number"><span class="hljs-number">3</span>, name=<span class="hljs-string"><span class="hljs-string">"dense_2"</span>))
    <span class="hljs-keyword"><span class="hljs-keyword">...</span>
    model.save_weights(fname)</span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<pre class="prettyprint"><code class="hljs avrasm has-numbering makefile"><span class="hljs-preprocessor"><span class="hljs-comment"># new model</span>
model = Sequential()
model<span class="hljs-preprocessor">.add(Dense(<span class="hljs-number">2, input_dim=<span class="hljs-number">3, name=<span class="hljs-string"><span class="hljs-string">"dense_1"</span>))  <span class="hljs-preprocessor"><span class="hljs-comment"># will be loaded</span>
model<span class="hljs-preprocessor">.add(Dense(<span class="hljs-number">10, name=<span class="hljs-string"><span class="hljs-string">"new_dense"</span>))  <span class="hljs-preprocessor"><span class="hljs-comment"># will not be loaded</span>

<span class="hljs-preprocessor"><span class="hljs-comment"># load weights from first model; will only affect the first layer, dense_1.</span>
model<span class="hljs-preprocessor">.load_weights(fname, by_name=True)</span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div>]]></description></item><item><title>keras系列︱人脸表情分类与识别：opencv人脸检测+Keras情绪分类（四）</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/07/11146774.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 07 Jul 2019 08:52:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/07/11146774.html</guid><description><![CDATA[<div class="blogpost-body" id="cnblogs_post_body"><p>引自：<a href="http://blog.csdn.net/sinat_26917383/article/details/72885715" target="_blank">http://blog.csdn.net/sinat_26917383/article/details/72885715</a></p>
<blockquote>
<p>人脸识别热门，表情识别更加。但是表情识别很难，因为人脸的微表情很多，本节介绍一种比较粗线条的表情分类与识别的办法。</p>
</blockquote>
<h3 id="keras系列"><a name="t0"></a>Keras系列：</h3>
<hr>
<p>.</p>
<h3 id="keras系列"><a name="t0"></a>Keras系列：</h3>
<p>1、<a href="https://www.cnblogs.com/peng8098/articles/11146719.html" target="_blank">keras系列︱Sequential与Model模型、keras基本结构功能（一）</a>&nbsp;<br>2、<a href="https://www.cnblogs.com/peng8098/articles/11146752.html" target="_blank">keras系列︱Application中五款已训练模型、VGG16框架（Sequential式、Model式）解读（二）</a>&nbsp;<br>3、<a href="https://www.cnblogs.com/peng8098/articles/11146766.html" target="_blank">keras系列︱图像多分类训练与利用bottleneck features进行微调（三）</a>&nbsp;<br>4、<a href="https://www.cnblogs.com/peng8098/articles/11146774.html" target="_blank">keras系列︱人脸表情分类与识别：opencv人脸检测+Keras情绪分类（四）</a>&nbsp;<br>5、<a href="https://www.cnblogs.com/peng8098/articles/11146779.html" target="_blank">keras系列︱迁移学习：利用InceptionV3进行fine-tuning及预测、完整案例（五）</a></p>
<hr>
<h4 id="本次讲述的表情分类是识别的分析流程分为">本次讲述的表情分类是识别的分析流程分为：</h4>
<ul>
<li>1、加载pre-model网络与权重；</li>
<li>2、利用opencv的函数进行简单的人脸检测；</li>
<li>3、抠出人脸的图并灰化；</li>
<li>4、表情分类器检测</li>



</ul>
<p>.</p>
<hr>
<h1 id="一表情数据集"><a name="t1"></a>一、表情数据集</h1>
<p>主要来源于kaggle比赛，<a href="https://www.kaggle.com/c/challenges-in-representation-learning-facial-expression-recognition-challenge/data" target="_blank">下载地址</a>。&nbsp;<br>有七种表情类别： (0=Angry, 1=Disgust, 2=Fear, 3=Happy, 4=Sad, 5=Surprise, 6=Neutral).&nbsp;<br>数据是48x48 灰度图，格式比较奇葩。&nbsp;<br>第一列是情绪分类，第二列是图像的numpy，第三列是train or test。&nbsp;&nbsp;<br><img title="" alt="这里写图片描述" src="http://img.blog.csdn.net/20170606171044342?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMjY5MTczODM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><br>.</p>
<hr>
<h1 id="二opencv的人脸识别"><a name="t2"></a>二、opencv的人脸识别</h1>
<p>参考<a href="http://blog.csdn.net/sinat_26917383/article/details/69831495" target="_blank">《opencv+Recorder︱OpenCV 中使用 Haar 分类器进行面部检测》</a>&nbsp;<br>理论略过，直接来看重点：&nbsp;<br>（1）加载人脸检测器，haarcascade_frontalface_default.xml；&nbsp;<br>（2）图片加载并灰化，cvtColor，可参考：&nbsp;<a href="http://blog.csdn.net/sinat_26917383/article/details/70860910" target="_blank">opencv︱图像的色彩空間cvtColor（HSV、HSL、HSB 、BGR）</a>&nbsp;<br>（2）人脸探测，detectMultiScale.</p>
<pre class="prettyprint"><code class="hljs makefile has-numbering"><span class="hljs-comment"><span class="hljs-comment"># （1）加载人脸检测器</span>
<span class="hljs-constant">cascPath = '/.../haarcascade_frontalface_default.xml'
<span class="hljs-constant">faceCascade = cv2.CascadeClassifier(cascPath)

<span class="hljs-comment"><span class="hljs-comment"># （2）图片加载并灰化</span>
<span class="hljs-constant">jpg_file = '/home/ubuntu/keras/image/8c80abb4gw1f3b5hxd3aaj20jg0cx411.jpg'
<span class="hljs-constant">img_gray = cv2.imread(jpg_file)
<span class="hljs-constant">img_gray = cv2.cvtColor(img_gray, cv2.COLOR_BGR2GRAY)

<span class="hljs-comment"><span class="hljs-comment"># 人脸探测</span>
<span class="hljs-constant">faces = faceCascade.detectMultiScale(
        img_gray,
        scaleFactor=1.1,
        minNeighbors=1,<span class="hljs-comment"><span class="hljs-comment"># minNeighbors=5比较难检测</span>
        minSize=(30, 30),
        flags=cv2.cv.CV_HAAR_SCALE_IMAGE
    )</span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>其中minNeighbors设置小一些，容易检测出来。这个检测器还是有点粗糙。&nbsp;<br>.</p>
<hr>
<h1 id="三表情分类与识别"><a name="t3"></a>三、表情分类与识别</h1>
<p>本节源自github的<a href="https://github.com/JostineHo/mememoji" target="_blank">mememoji</a>。&nbsp;<br>网络结构：&nbsp;<br><img title="" alt="这里写图片描述" src="http://img.blog.csdn.net/20170606183551463?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMjY5MTczODM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p><img title="" alt="这里写图片描述" src="https://github.com/JostineHo/mememoji/raw/master/figures/mynetarch.png"></p>
<blockquote>
<p>opencv中的人脸检测的pre-model文件（haarcascade_frontalface_default.xml）和表情识别pre-model文件（model.h5）都在<a href="https://github.com/JostineHo/real-time_emotion_analyzer" target="_blank">作者的github</a>下载。</p>



</blockquote>
<p>是利用Keras实现的。直接来看完整的代码：</p>
<pre class="prettyprint"><code class="hljs python has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">import</span> cv2
<span class="hljs-keyword"><span class="hljs-keyword">import</span> sys
<span class="hljs-keyword"><span class="hljs-keyword">import</span> json
<span class="hljs-keyword"><span class="hljs-keyword">import</span> time
<span class="hljs-keyword"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span> np
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> model_from_json


emotion_labels = [<span class="hljs-string"><span class="hljs-string">'angry'</span>, <span class="hljs-string"><span class="hljs-string">'fear'</span>, <span class="hljs-string"><span class="hljs-string">'happy'</span>, <span class="hljs-string"><span class="hljs-string">'sad'</span>, <span class="hljs-string"><span class="hljs-string">'surprise'</span>, <span class="hljs-string"><span class="hljs-string">'neutral'</span>]

<span class="hljs-comment"><span class="hljs-comment"># load json and create model arch</span>
json_file = open(<span class="hljs-string"><span class="hljs-string">'/.../model.json'</span>,<span class="hljs-string"><span class="hljs-string">'r'</span>)
loaded_model_json = json_file.read()
json_file.close()
model = model_from_json(loaded_model_json)

<span class="hljs-comment"><span class="hljs-comment"># load weights into new model</span>
model.load_weights(<span class="hljs-string"><span class="hljs-string">'/.../model.h5'</span>)

<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predict_emotion</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(face_image_gray)</span>:</span> <span class="hljs-comment"><span class="hljs-comment"># a single cropped face</span>
    resized_img = cv2.resize(face_image_gray, (<span class="hljs-number"><span class="hljs-number">48</span>,<span class="hljs-number"><span class="hljs-number">48</span>), interpolation = cv2.INTER_AREA)
    <span class="hljs-comment"><span class="hljs-comment"># cv2.imwrite(str(index)+'.png', resized_img)</span>
    image = resized_img.reshape(<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">48</span>, <span class="hljs-number"><span class="hljs-number">48</span>)
    list_of_list = model.predict(image, batch_size=<span class="hljs-number"><span class="hljs-number">1</span>, verbose=<span class="hljs-number"><span class="hljs-number">1</span>)
    angry, fear, happy, sad, surprise, neutral = [prob <span class="hljs-keyword"><span class="hljs-keyword">for</span> lst <span class="hljs-keyword"><span class="hljs-keyword">in</span> list_of_list <span class="hljs-keyword"><span class="hljs-keyword">for</span> prob <span class="hljs-keyword"><span class="hljs-keyword">in</span> lst]
    <span class="hljs-keyword"><span class="hljs-keyword">return</span> [angry, fear, happy, sad, surprise, neutral]


<span class="hljs-comment"><span class="hljs-comment"># -------------------直接预测-----------------------</span>
img_gray = cv2.imread(<span class="hljs-string"><span class="hljs-string">'/.../real-time_emotion_analyzer-master/meme_faces/angry-angry.png'</span>)
img_gray = cv2.cvtColor(img_gray, cv2.COLOR_BGR2GRAY)
angry, fear, happy, sad, surprise, neutral = predict_emotion(img_gray)


<span class="hljs-comment"><span class="hljs-comment"># -------------------人脸预测-----------------------</span>
<span class="hljs-comment"><span class="hljs-comment"># 加载检测器</span>
cascPath = <span class="hljs-string"><span class="hljs-string">'/.../real-time_emotion_analyzer-master/haarcascade_frontalface_default.xml'</span>
faceCascade = cv2.CascadeClassifier(cascPath)

<span class="hljs-comment"><span class="hljs-comment"># 图像灰化</span>
jpg_file = <span class="hljs-string"><span class="hljs-string">'/.../001.jpg'</span>
img_gray = cv2.imread(jpg_file)
img_gray = cv2.cvtColor(img_gray, cv2.COLOR_BGR2GRAY)

<span class="hljs-comment"><span class="hljs-comment"># 人脸检测</span>
faces = faceCascade.detectMultiScale(
        img_gray,
        scaleFactor=<span class="hljs-number"><span class="hljs-number">1.1</span>,
        minNeighbors=<span class="hljs-number"><span class="hljs-number">1</span>,<span class="hljs-comment"><span class="hljs-comment"># minNeighbors=5比较难检测</span>
        minSize=(<span class="hljs-number"><span class="hljs-number">30</span>, <span class="hljs-number"><span class="hljs-number">30</span>),
        flags=cv2.cv.CV_HAAR_SCALE_IMAGE
    )

<span class="hljs-comment"><span class="hljs-comment"># 表情画框</span>
<span class="hljs-keyword"><span class="hljs-keyword">for</span> (x, y, w, h) <span class="hljs-keyword"><span class="hljs-keyword">in</span> faces:
    face_image_gray = img_gray[y:y+h, x:x+w]
    cv2.rectangle(frame, (x, y), (x+w, y+h), (<span class="hljs-number"><span class="hljs-number">0</span>, <span class="hljs-number"><span class="hljs-number">255</span>, <span class="hljs-number"><span class="hljs-number">0</span>), <span class="hljs-number"><span class="hljs-number">2</span>)
    angry, fear, happy, sad, surprise, neutral = predict_emotion(face_image_gray)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div>]]></description></item><item><title>keras系列︱图像多分类训练与利用bottleneck features进行微调（三）</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/07/11146766.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 07 Jul 2019 08:51:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/07/11146766.html</guid><description><![CDATA[<div class="blogpost-body" id="cnblogs_post_body"><p>引自：<a href="http://blog.csdn.net/sinat_26917383/article/details/72861152" target="_blank">http://blog.csdn.net/sinat_26917383/article/details/72861152</a></p>
<p>中文文档：<a href="http://keras-cn.readthedocs.io/en/latest/" target="_blank">http://keras-cn.readthedocs.io/en/latest/</a>&nbsp; <br>官方文档：<a href="https://keras.io/" target="_blank">https://keras.io/</a>&nbsp; <br>文档主要是以keras2.0。</p>
<p>训练、训练主要就”练“嘛，所以堆几个案例就知道怎么做了。&nbsp;<br>.</p>
<hr>
<p>.</p>
<h3 id="keras系列"><a name="t0"></a>Keras系列：</h3>
<p>1、<a href="https://www.cnblogs.com/peng8098/articles/11146719.html" target="_blank">keras系列︱Sequential与Model模型、keras基本结构功能（一）</a>&nbsp;<br>2、<a href="https://www.cnblogs.com/peng8098/articles/11146752.html" target="_blank">keras系列︱Application中五款已训练模型、VGG16框架（Sequential式、Model式）解读（二）</a>&nbsp;<br>3、<a href="https://www.cnblogs.com/peng8098/articles/11146766.html" target="_blank">keras系列︱图像多分类训练与利用bottleneck features进行微调（三）</a>&nbsp;<br>4、<a href="https://www.cnblogs.com/peng8098/articles/11146774.html" target="_blank">keras系列︱人脸表情分类与识别：opencv人脸检测+Keras情绪分类（四）</a>&nbsp;<br>5、<a href="https://www.cnblogs.com/peng8098/articles/11146779.html" target="_blank">keras系列︱迁移学习：利用InceptionV3进行fine-tuning及预测、完整案例（五）</a></p>
<hr>
<h1 id="一cifar10-小图片分类示例sequential式"><a name="t1"></a>一、CIFAR10 小图片分类示例（Sequential式）</h1>
<hr>
<p>要训练模型，首先得知道数据长啥样。先来看看经典的cifar10是如何进行训练的。&nbsp;<br>示例中CIFAR10采用的是Sequential式来编译网络结构。</p>
<pre class="prettyprint"><code class="hljs livecodeserver has-numbering python"><span class="hljs-built_in"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function
<span class="hljs-keyword">import</span> keras
<span class="hljs-built_in"><span class="hljs-keyword">from</span> keras.datasets <span class="hljs-keyword">import</span> cifar10
<span class="hljs-built_in"><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword">import</span> ImageDataGenerator
<span class="hljs-built_in"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential
<span class="hljs-built_in"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense, Dropout, Activation, Flatten
<span class="hljs-built_in"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Conv2D, MaxPooling2D

batch_size = <span class="hljs-number"><span class="hljs-number">32</span>
num_classes = <span class="hljs-number"><span class="hljs-number">10</span>
epochs = <span class="hljs-number"><span class="hljs-number">200</span>
data_augmentation = <span class="hljs-keyword">True</span>

<span class="hljs-comment"><span class="hljs-comment"># 数据载入</span>
(x_train, y_train), (x_test, y_test) = cifar10.load_data()

<span class="hljs-comment"><span class="hljs-comment"># 多分类标签生成</span>
y_train = keras.utils.to_categorical(y_train, num_classes)
y_test = keras.utils.to_categorical(y_test, num_classes)

<span class="hljs-comment"><span class="hljs-comment"># 网络结构配置</span>
model = Sequential()
model.<span class="hljs-built_in">add(Conv2D(<span class="hljs-number"><span class="hljs-number">32</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span>,
                 input_shape=x_train.shape[<span class="hljs-number"><span class="hljs-number">1</span>:]))
model.<span class="hljs-built_in">add(Activation(<span class="hljs-string"><span class="hljs-string">'relu'</span>))
model.<span class="hljs-built_in">add(Conv2D(<span class="hljs-number"><span class="hljs-number">32</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>)))
model.<span class="hljs-built_in">add(Activation(<span class="hljs-string"><span class="hljs-string">'relu'</span>))
model.<span class="hljs-built_in">add(MaxPooling2D(pool_size=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))
model.<span class="hljs-built_in">add(Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span>))

model.<span class="hljs-built_in">add(Conv2D(<span class="hljs-number"><span class="hljs-number">64</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span>))
model.<span class="hljs-built_in">add(Activation(<span class="hljs-string"><span class="hljs-string">'relu'</span>))
model.<span class="hljs-built_in">add(Conv2D(<span class="hljs-number"><span class="hljs-number">64</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>)))
model.<span class="hljs-built_in">add(Activation(<span class="hljs-string"><span class="hljs-string">'relu'</span>))
model.<span class="hljs-built_in">add(MaxPooling2D(pool_size=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))
model.<span class="hljs-built_in">add(Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span>))

model.<span class="hljs-built_in">add(Flatten())
model.<span class="hljs-built_in">add(Dense(<span class="hljs-number"><span class="hljs-number">512</span>))
model.<span class="hljs-built_in">add(Activation(<span class="hljs-string"><span class="hljs-string">'relu'</span>))
model.<span class="hljs-built_in">add(Dropout(<span class="hljs-number"><span class="hljs-number">0.5</span>))
model.<span class="hljs-built_in">add(Dense(num_classes))
model.<span class="hljs-built_in">add(Activation(<span class="hljs-string"><span class="hljs-string">'softmax'</span>))

<span class="hljs-comment"><span class="hljs-comment"># 训练参数设置</span>
<span class="hljs-comment"><span class="hljs-comment"># initiate RMSprop optimizer</span>
opt = keras.optimizers.rmsprop(lr=<span class="hljs-number"><span class="hljs-number">0.0001</span>, decay=<span class="hljs-number"><span class="hljs-number">1e-6</span>)

<span class="hljs-comment"><span class="hljs-comment"># Let's train the model using RMSprop</span>
model.compile(loss=<span class="hljs-string"><span class="hljs-string">'categorical_crossentropy'</span>,
              optimizer=opt,
              metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span>])

<span class="hljs-comment"><span class="hljs-comment"># 生成训练数据</span>
x_train = x_train.astype(<span class="hljs-string"><span class="hljs-string">'float32'</span>)
x_test = x_test.astype(<span class="hljs-string"><span class="hljs-string">'float32'</span>)
x_train /= <span class="hljs-number"><span class="hljs-number">255</span>
x_test /= <span class="hljs-number"><span class="hljs-number">255</span>

<span class="hljs-keyword"><span class="hljs-keyword">if</span> <span class="hljs-operator"><span class="hljs-keyword">not</span> data_augmentation:
    print(<span class="hljs-string"><span class="hljs-string">'Not using data augmentation.'</span>)
    model.fit(x_train, y_train,
              batch_size=batch_size,
              epochs=epochs,
              validation_data=(x_test, y_test),
              shuffle=<span class="hljs-keyword">True</span>)
<span class="hljs-keyword"><span class="hljs-keyword">else</span>:
    print(<span class="hljs-string"><span class="hljs-string">'Using real-time data augmentation.'</span>)
    <span class="hljs-comment"><span class="hljs-comment"># This will do preprocessing and realtime data augmentation:</span>
    datagen = ImageDataGenerator(
        featurewise_center=<span class="hljs-keyword">False</span>,  <span class="hljs-comment"><span class="hljs-comment"># set input mean to 0 over the dataset</span>
        samplewise_center=<span class="hljs-keyword">False</span>,  <span class="hljs-comment"><span class="hljs-comment"># set each sample mean to 0</span>
        featurewise_std_normalization=<span class="hljs-keyword">False</span>,  <span class="hljs-comment"><span class="hljs-comment"># divide inputs by std of the dataset</span>
        samplewise_std_normalization=<span class="hljs-keyword">False</span>,  <span class="hljs-comment"><span class="hljs-comment"># divide each input by its std</span>
        zca_whitening=<span class="hljs-keyword">False</span>,  <span class="hljs-comment"><span class="hljs-comment"># apply ZCA whitening</span>
        rotation_range=<span class="hljs-number"><span class="hljs-number">0</span>,  <span class="hljs-comment"><span class="hljs-comment"># randomly rotate images in the range (degrees, 0 to 180)</span>
        width_shift_range=<span class="hljs-number"><span class="hljs-number">0.1</span>,  <span class="hljs-comment"><span class="hljs-comment"># randomly shift images horizontally (fraction of total width)</span>
        height_shift_range=<span class="hljs-number"><span class="hljs-number">0.1</span>,  <span class="hljs-comment"><span class="hljs-comment"># randomly shift images vertically (fraction of total height)</span>
        horizontal_flip=<span class="hljs-keyword">True</span>,  <span class="hljs-comment"><span class="hljs-comment"># randomly flip images</span>
        vertical_flip=<span class="hljs-keyword">False</span>)  <span class="hljs-comment"><span class="hljs-comment"># randomly flip images</span>

    <span class="hljs-comment"><span class="hljs-comment"># Compute quantities required for feature-wise normalization</span>
    <span class="hljs-comment"><span class="hljs-comment"># (std, mean, and principal components if ZCA whitening is applied).</span>
    datagen.fit(x_train)

<span class="hljs-comment"><span class="hljs-comment"># fit训练</span>
    <span class="hljs-comment"><span class="hljs-comment"># Fit the model on the batches generated by datagen.flow().</span>
    model.fit_generator(datagen.flow(x_train, y_train,
                                     batch_size=batch_size),
                        steps_per_epoch=x_train.shape[<span class="hljs-number"><span class="hljs-number">0</span>]<span class="hljs-comment"> // batch_size,
                        epochs=epochs,
                        validation_data=(x_test, y_test))</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>就像caffe里面需要把数据编译成LMDB一样，keras也要数据服从其格式。来看看cifar10的数据格式：&nbsp;<br>.</p>
<h2 id="1载入数据"><a name="t2"></a>1、载入数据</h2>
<pre class="prettyprint"><code class="hljs fix has-numbering"><span class="hljs-attribute">(x_train, y_train), (x_test, y_test) =<span class="hljs-string"> cifar10.load_data()</span></span></code></pre>
<p>&nbsp;</p>
<p>这句用来网络上载入数据，跟之前application之中，pre-model一样，有时间需要不断的网上下载，所以等你下载完了，可以自己改一样地址，让其读取本地文件。&nbsp;<br>x_train格式例如（100,100,100,3），100张格式为100*100*3的图像集；y_train格式为（100，）</p>
<p>.</p>
<h2 id="2多分类标签指定keras格式"><a name="t3"></a>2、多分类标签指定keras格式</h2>
<p>keras对多分类的标签需要一种固定格式，所以需要按照以下的方式进行转换，num_classes为分类数量，假设此时有5类：</p>
<pre class="prettyprint"><code class="hljs avrasm has-numbering ini"><span class="hljs-attr">y_train</span> = keras<span class="hljs-preprocessor">.utils<span class="hljs-preprocessor">.to_categorical(y_train, num_classes)</span></span></code></pre>
<p>&nbsp;</p>
<p>最终输出的格式应该是(100,5)&nbsp;<br>.</p>
<h2 id="3图片预处理生成器imagedatagenerator"><a name="t4"></a>3、图片预处理生成器ImageDataGenerator</h2>
<pre class="prettyprint"><code class="hljs fix has-numbering makefile"><span class="hljs-attribute">datagen =<span class="hljs-string"> ImageDataGenerator() 
datagen.fit(x_train)</span></span></code></pre>
<p>&nbsp;</p>
<p>生成器初始化datagen ，然后datagen.fit,计算依赖于数据的变换所需要的统计信息&nbsp;<br>.</p>
<h2 id="4最终训练格式-batch"><a name="t5"></a>4、最终训练格式-batch</h2>
<p>把数据按照每个batch进行划分，这样就可以送到模型进行训练了。比caffe中要LMDB快很多。</p>
<pre class="prettyprint"><code class="hljs fix has-numbering less"><span class="hljs-attribute"><span class="hljs-selector-tag">datagen</span><span class="hljs-selector-class">.flow</span>(x_train, y_train, batch_size=<span class="hljs-string">batch_size)</span></span></code></pre>
<p>&nbsp;</p>
<p>接收numpy数组和标签为参数,生成经过数据提升或标准化后的batch数据,并在一个无限循环中不断的返回batch数据。</p>
<p>.</p>
<hr>
<h1 id="二官方改编多分类简易网络结构sequential式"><a name="t6"></a>二、官方改编——多分类简易网络结构（Sequential式）</h1>
<hr>
<p>改编自官方文档的<a href="http://keras-cn.readthedocs.io/en/latest/blog/image_classification_using_very_little_data/" target="_blank">《面向小数据集构建图像分类模型》</a>&nbsp;<br>.</p>
<h2 id="1数据来源与下载"><a name="t7"></a>1、数据来源与下载</h2>
<p>官方文档是猫狗二分类，此时变成一个5分类，由于追求效率，从网上找来一个很小的数据集。来源于博客：&nbsp;<br><a href="http://www.cnblogs.com/denny402/p/5083300.html" target="_blank">Caffe学习系列(12)：训练和测试自己的图片</a>&nbsp; <br>数据描述：&nbsp;<br>共有500张图片，分为大巴车、恐龙、大象、鲜花和马五个类，每个类100张。&nbsp;<br>下载地址：<a href="http://pan.baidu.com/s/1nuqlTnN" target="_blank">http://pan.baidu.com/s/1nuqlTnN</a>&nbsp;<br>编号分别以3，4，5，6，7开头，各为一类。我从其中每类选出20张作为测试，其余80张作为训练。因此最终训练图片400张，测试图片100张，共5类。如下图：&nbsp;<br><img title="" alt="这里写图片描述" src="http://img.blog.csdn.net/20170604203601030?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMjY5MTczODM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><br>.</p>
<h2 id="2-载入与模型网络构建"><a name="t8"></a>2、 载入与模型网络构建</h2>
<p>很坑的是Keras中文文档本节还没有及时更新，还需要看原版的网站。譬如keras中文文档是Convolution2D，但是现在是conv2D所以有点坑。</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># 载入与模型网络构建</span>
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Conv2D, MaxPooling2D
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Activation, Dropout, Flatten, Dense

model = Sequential()
model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">32</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), input_shape=(<span class="hljs-number"><span class="hljs-number">150</span>, <span class="hljs-number"><span class="hljs-number">150</span>,<span class="hljs-number"><span class="hljs-number">3</span>)))
<span class="hljs-comment"><span class="hljs-comment"># filter大小3*3，数量32个，原始图像大小3,150,150</span>
model.add(Activation(<span class="hljs-string"><span class="hljs-string">'relu'</span>))
model.add(MaxPooling2D(pool_size=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))

model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">32</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>)))
model.add(Activation(<span class="hljs-string"><span class="hljs-string">'relu'</span>))
model.add(MaxPooling2D(pool_size=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))

model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">64</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>)))
model.add(Activation(<span class="hljs-string"><span class="hljs-string">'relu'</span>))
model.add(MaxPooling2D(pool_size=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))
model.add(Flatten())  <span class="hljs-comment"><span class="hljs-comment"># this converts our 3D feature maps to 1D feature vectors</span>
model.add(Dense(<span class="hljs-number"><span class="hljs-number">64</span>))
model.add(Activation(<span class="hljs-string"><span class="hljs-string">'relu'</span>))
model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.5</span>))
model.add(Dense(<span class="hljs-number"><span class="hljs-number">5</span>))   <span class="hljs-comment"><span class="hljs-comment">#                               matt,几个分类就要有几个dense</span>
model.add(Activation(<span class="hljs-string"><span class="hljs-string">'softmax'</span>))<span class="hljs-comment"><span class="hljs-comment">#                     matt,多分类</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>二分类与多分类在前面的结构上都没有问题，就是需要改一下最后的全连接层，因为此时有5分类，所以需要Dense(5)，同时激活函数是softmax，如果是二分类就是dense(2)+sigmoid(激活函数)。</p>
<p><strong>同时出现了以下的报错：</strong></p>
<pre class="prettyprint"><code class="hljs livecodeserver has-numbering groovy">报错<span class="hljs-number"><span class="hljs-number">1</span>：model.<span class="hljs-built_in">add(Convolution2D(<span class="hljs-number"><span class="hljs-number">32</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>, input_shape=(<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">150</span>, <span class="hljs-number"><span class="hljs-number">150</span>)))
<span class="hljs-string">ValueError:</span> Negative dimension size caused <span class="hljs-keyword">by subtracting <span class="hljs-number"><span class="hljs-number">3</span> <span class="hljs-built_in">from <span class="hljs-number"><span class="hljs-number">1</span> <span class="hljs-keyword"><span class="hljs-keyword">for</span> <span class="hljs-string"><span class="hljs-string">'conv2d_6/convolution'</span> (<span class="hljs-string">op:</span> <span class="hljs-string"><span class="hljs-string">'Conv2D'</span>) <span class="hljs-operator">with input <span class="hljs-string">shapes:</span> [?,<span class="hljs-number">1,<span class="hljs-number">148,<span class="hljs-number">32], [<span class="hljs-number">3,<span class="hljs-number">3,<span class="hljs-number">32,<span class="hljs-number">32].

报错<span class="hljs-number">2：model.<span class="hljs-built_in">add(MaxPooling2D(pool_size=(<span class="hljs-number">2, <span class="hljs-number">2)))
ValueError: Negative dimension size caused <span class="hljs-keyword">by subtracting <span class="hljs-number"><span class="hljs-number">2</span> <span class="hljs-built_in">from <span class="hljs-number"><span class="hljs-number">1</span> <span class="hljs-keyword"><span class="hljs-keyword">for</span> <span class="hljs-string"><span class="hljs-string">'max_pooling2d_11/MaxPool'</span> (<span class="hljs-string">op:</span> <span class="hljs-string"><span class="hljs-string">'MaxPool'</span>) <span class="hljs-operator">with input <span class="hljs-string">shapes:</span> [?,<span class="hljs-number">1,<span class="hljs-number">148,<span class="hljs-number">32].</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p><strong>原因：</strong>&nbsp;<br>input_shape=(3,150, 150)是theano的写法，而tensorflow需要写出：(150,150,3)；&nbsp;<br>需要修改Input_size。也就是”channels_last”和”channels_first”数据格式的问题。&nbsp;<br>.</p>
<h2 id="3设置训练参数"><a name="t9"></a>3、设置训练参数</h2>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># 二分类</span>
<span class="hljs-comment"><span class="hljs-comment">#model.compile(loss='binary_crossentropy',</span>
<span class="hljs-comment"><span class="hljs-comment">#              optimizer='rmsprop',</span>
<span class="hljs-comment"><span class="hljs-comment">#              metrics=['accuracy'])</span>

<span class="hljs-comment"><span class="hljs-comment"># 多分类</span>
model.compile(loss=<span class="hljs-string"><span class="hljs-string">'categorical_crossentropy'</span>,                                 <span class="hljs-comment"><span class="hljs-comment"># matt，多分类，不是binary_crossentropy</span>
              optimizer=<span class="hljs-string"><span class="hljs-string">'rmsprop'</span>,
              metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span>])
<span class="hljs-comment"><span class="hljs-comment"># 优化器rmsprop：除学习率可调整外，建议保持优化器的其他默认参数不变</span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>二分类的参数与多分类的参数设置有些区别。</p>
<p>.</p>
<h2 id="4图像预处理"><a name="t10"></a>4、图像预处理</h2>
<p>然后我们开始准备数据，使用.flow_from_directory()来从我们的jpgs图片中直接产生数据和标签。&nbsp;<br><strong>其中值得留意的是：</strong></p>
<ul>
<li>ImageDataGenerator：用以生成一个batch的图像数据，支持实时数据提升。训练时该函数会无限生成数据，直到达到规定的epoch次数为止。</li>
<li>flow_from_directory(directory):&nbsp;<br>以文件夹路径为参数,生成经过数据提升/归一化后的数据,在一个无限循环中无限产生batch数据</li>


</ul>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">
train_datagen = ImageDataGenerator(
        rescale=<span class="hljs-number"><span class="hljs-number">1.</span>/<span class="hljs-number"><span class="hljs-number">255</span>,
        shear_range=<span class="hljs-number"><span class="hljs-number">0.2</span>,
        zoom_range=<span class="hljs-number"><span class="hljs-number">0.2</span>,
        horizontal_flip=<span class="hljs-keyword"><span class="hljs-keyword">True</span>)

test_datagen = ImageDataGenerator(rescale=<span class="hljs-number"><span class="hljs-number">1.</span>/<span class="hljs-number"><span class="hljs-number">255</span>)

train_generator = train_datagen.flow_from_directory(
        <span class="hljs-string"><span class="hljs-string">'/.../train'</span>, 
        target_size=(<span class="hljs-number"><span class="hljs-number">150</span>, <span class="hljs-number"><span class="hljs-number">150</span>),  <span class="hljs-comment"><span class="hljs-comment"># all images will be resized to 150x150</span>
        batch_size=<span class="hljs-number"><span class="hljs-number">32</span>,
        class_mode=<span class="hljs-string"><span class="hljs-string">'categorical'</span>)                               <span class="hljs-comment"><span class="hljs-comment"># matt，多分类</span>

validation_generator = test_datagen.flow_from_directory(
        <span class="hljs-string"><span class="hljs-string">'/.../validation'</span>,
        target_size=(<span class="hljs-number"><span class="hljs-number">150</span>, <span class="hljs-number"><span class="hljs-number">150</span>),
        batch_size=<span class="hljs-number"><span class="hljs-number">32</span>,
        class_mode=<span class="hljs-string"><span class="hljs-string">'categorical'</span>)                             <span class="hljs-comment"><span class="hljs-comment"># matt，多分类</span>
<span class="hljs-comment"><span class="hljs-comment"># class_mode='binary'</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>这一步骤是数据准备阶段，会比较慢，同时多分类，需要设置class_mode为“categorical”。flow_from_directory是计算数据的一些属性值，之后再训练阶段直接丢进去这些生成器。&nbsp;<br>.</p>
<h2 id="5训练阶段"><a name="t11"></a>5、训练阶段</h2>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">model.fit_generator(
        train_generator,
        samples_per_epoch=<span class="hljs-number"><span class="hljs-number">2000</span>,
        nb_epoch=<span class="hljs-number"><span class="hljs-number">50</span>,
        validation_data=validation_generator,
        nb_val_samples=<span class="hljs-number"><span class="hljs-number">800</span>)
<span class="hljs-comment"><span class="hljs-comment"># samples_per_epoch，相当于每个epoch数据量峰值，每个epoch以经过模型的样本数达到samples_per_epoch时，记一个epoch结束</span>
model.save_weights(<span class="hljs-string"><span class="hljs-string">'/.../first_try_animal5.h5'</span>)  </span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>最后的结果示范：</p>
<pre class="prettyprint"><code class="hljs scala has-numbering"><span class="hljs-type">Epoch</span> <span class="hljs-number"><span class="hljs-number">48</span>/<span class="hljs-number"><span class="hljs-number">50</span>
<span class="hljs-number"><span class="hljs-number">62</span>/<span class="hljs-number"><span class="hljs-number">62</span> [==============================] - <span class="hljs-number"><span class="hljs-number">39</span>s - loss: <span class="hljs-number"><span class="hljs-number">0.0464</span> - acc: <span class="hljs-number"><span class="hljs-number">0.9929</span> - val_loss: <span class="hljs-number"><span class="hljs-number">0.3916</span> - val_acc: <span class="hljs-number"><span class="hljs-number">0.9601</span>
<span class="hljs-type">Epoch</span> <span class="hljs-number"><span class="hljs-number">49</span>/<span class="hljs-number"><span class="hljs-number">50</span>
<span class="hljs-number"><span class="hljs-number">62</span>/<span class="hljs-number"><span class="hljs-number">62</span> [==============================] - <span class="hljs-number"><span class="hljs-number">38</span>s - loss: <span class="hljs-number"><span class="hljs-number">0.0565</span> - acc: <span class="hljs-number"><span class="hljs-number">0.9914</span> - val_loss: <span class="hljs-number"><span class="hljs-number">0.6423</span> - val_acc: <span class="hljs-number"><span class="hljs-number">0.9500</span>
<span class="hljs-type">Epoch</span> <span class="hljs-number"><span class="hljs-number">50</span>/<span class="hljs-number"><span class="hljs-number">50</span>
<span class="hljs-number"><span class="hljs-number">62</span>/<span class="hljs-number"><span class="hljs-number">62</span> [==============================] - <span class="hljs-number"><span class="hljs-number">38</span>s - loss: <span class="hljs-number"><span class="hljs-number">0.0429</span> - acc: <span class="hljs-number"><span class="hljs-number">0.9960</span> - val_loss: <span class="hljs-number"><span class="hljs-number">0.4238</span> - val_acc: <span class="hljs-number"><span class="hljs-number">0.9599</span>
&lt;keras.callbacks.<span class="hljs-type">History</span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">at</span> 0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x7f049fc6f090&gt;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>.</p>
<h2 id="6出现的问题"><a name="t12"></a>6、出现的问题</h2>
<p>问题一：loss为负数&nbsp;<br>原因:如果出现loss为负，是因为之前多分类的标签哪些设置不对，现在是5分类的，写成了2分类之后导致了Loss为负数，形如下面</p>
<pre class="prettyprint"><code class="hljs fix has-numbering groovy"><span class="hljs-attribute">Epoch <span class="hljs-number">43</span>/<span class="hljs-number">50</span>
<span class="hljs-number">62</span>/<span class="hljs-number">62</span> [==============================<span class="hljs-string">] - <span class="hljs-number">39</span>s - <span class="hljs-string">loss:</span> <span class="hljs-number">-16.0148</span> - <span class="hljs-string">acc:</span> <span class="hljs-number">0.1921</span> - <span class="hljs-string">val_loss:</span> <span class="hljs-number">-15.9440</span> - <span class="hljs-string">val_acc:</span> <span class="hljs-number">0.1998</span>
Epoch <span class="hljs-number">44</span>/<span class="hljs-number">50</span>
<span class="hljs-number">61</span>/<span class="hljs-number">62</span> [============================&gt;.] - <span class="hljs-string">ETA:</span> <span class="hljs-number">0</span>s - <span class="hljs-string">loss:</span> <span class="hljs-number">-15.8525</span> - <span class="hljs-string">acc:</span> <span class="hljs-number">0.2049</span>Segmentation fault (core dumped)</span></span></code></pre>
<p>.</p>
<hr>
<h1 id="三fine-tuning方式一使用预训练网络的bottleneck特征"><a name="t13"></a>三、fine-tuning方式一：使用预训练网络的bottleneck特征</h1>
<hr>
<p>本节主要来源于：<a href="https://github.com/mattzheng/Keras_for_Image/blob/master/cifar10_load.py" target="_blank">面向小数据集构建图像分类模型</a>&nbsp;<br>当然，keras中文版里面漏洞一大堆… 没有跟着版本更新，导致很多内容都是不对的，哎…</p>
<p>先看VGG-16的网络结构如下：&nbsp;<br><img title="" alt="图片" src="http://keras-cn.readthedocs.io/en/latest/images/vgg16_original.png"></p>
<p>本节主要是通过已经训练好的模型，把bottleneck特征抽取出来，然后滚到下一个“小”模型里面，也就是全连接层。&nbsp;<br>实施步骤为：</p>
<ul>
<li>1、把训练好的模型的权重拿来,model；</li>
<li>2、运行，提取bottleneck feature（网络在全连接之前的最后一层激活的feature&nbsp;<br>map,卷积-全连接层之间），单独拿出来，并保存</li>
<li>3、bottleneck层数据，之后 + dense全连接层，进行fine-tuning&nbsp;<br>.</li>


</ul>
<h2 id="1导入预训练权重与网络框架"><a name="t14"></a>1、导入预训练权重与网络框架</h2>
<p>这里keras中文文档是错误的，要看现在的<a href="https://blog.keras.io/how-convolutional-neural-networks-see-the-world.html" target="_blank">原作者的博客</a>，</p>
<pre class="prettyprint"><code class="hljs python has-numbering">WEIGHTS_PATH = <span class="hljs-string"><span class="hljs-string">'/home/ubuntu/keras/animal5/vgg16_weights_tf_dim_ordering_tf_kernels.h5'</span>
WEIGHTS_PATH_NO_TOP = <span class="hljs-string"><span class="hljs-string">'/home/ubuntu/keras/animal5/vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5'</span>

<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.applications.vgg16_matt <span class="hljs-keyword"><span class="hljs-keyword">import</span> VGG16
model = VGG16(include_top=<span class="hljs-keyword"><span class="hljs-keyword">False</span>, weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span>)</span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>其中WEIGHTS_PATH_NO_TOP 就是去掉了全连接层，可以用他直接提取bottleneck的特征，感谢原作者。&nbsp;<br>.</p>
<h2 id="2提取图片的bottleneck特征"><a name="t15"></a>2、提取图片的bottleneck特征</h2>
<p>需要步骤：</p>
<ul>
<li>载入图片；</li>
<li>灌入pre-model的权重；</li>
<li>得到bottleneck feature</li>


</ul>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment">#如何提取bottleneck feature</span>
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Conv2D, MaxPooling2D
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Activation, Dropout, Flatten, Dense

<span class="hljs-comment"><span class="hljs-comment"># （1）载入图片</span>
<span class="hljs-comment"><span class="hljs-comment"># 图像生成器初始化</span>
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword"><span class="hljs-keyword">import</span> ImageDataGenerator
<span class="hljs-keyword"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span> np
datagen = ImageDataGenerator(rescale=<span class="hljs-number"><span class="hljs-number">1.</span>/<span class="hljs-number"><span class="hljs-number">255</span>)

<span class="hljs-comment"><span class="hljs-comment"># 训练集图像生成器</span>
generator = datagen.flow_from_directory(
        <span class="hljs-string"><span class="hljs-string">'/home/ubuntu/keras/animal5/train'</span>,
        target_size=(<span class="hljs-number"><span class="hljs-number">150</span>, <span class="hljs-number"><span class="hljs-number">150</span>),
        batch_size=<span class="hljs-number"><span class="hljs-number">32</span>,
        class_mode=<span class="hljs-keyword"><span class="hljs-keyword">None</span>,
        shuffle=<span class="hljs-keyword"><span class="hljs-keyword">False</span>) 

<span class="hljs-comment"><span class="hljs-comment">#　验证集图像生成器</span>
generator = datagen.flow_from_directory(
        <span class="hljs-string"><span class="hljs-string">'/home/ubuntu/keras/animal5/validation'</span>,
        target_size=(<span class="hljs-number"><span class="hljs-number">150</span>, <span class="hljs-number"><span class="hljs-number">150</span>),
        batch_size=<span class="hljs-number"><span class="hljs-number">32</span>,
        class_mode=<span class="hljs-keyword"><span class="hljs-keyword">None</span>,
        shuffle=<span class="hljs-keyword"><span class="hljs-keyword">False</span>)

<span class="hljs-comment"><span class="hljs-comment">#（2）灌入pre-model的权重</span>
model.load_weights(<span class="hljs-string"><span class="hljs-string">'/.../vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5'</span>)

<span class="hljs-comment"><span class="hljs-comment">#（3）得到bottleneck feature</span>
bottleneck_features_train = model.predict_generator(generator, <span class="hljs-number"><span class="hljs-number">500</span>)
<span class="hljs-comment"><span class="hljs-comment"># 核心，steps是生成器要返回数据的轮数，每个epoch含有500张图片，与model.fit(samples_per_epoch)相对</span>
np.save(open(<span class="hljs-string"><span class="hljs-string">'bottleneck_features_train.npy'</span>, <span class="hljs-string"><span class="hljs-string">'w'</span>), bottleneck_features_train)

bottleneck_features_validation = model.predict_generator(generator, <span class="hljs-number"><span class="hljs-number">100</span>)
<span class="hljs-comment"><span class="hljs-comment"># 与model.fit(nb_val_samples)相对，一个epoch有800张图片，验证集</span>
np.save(open(<span class="hljs-string"><span class="hljs-string">'bottleneck_features_validation.npy'</span>, <span class="hljs-string"><span class="hljs-string">'w'</span>), bottleneck_features_validation)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p><strong>注意</strong></p>
<ul>
<li>class_mode，此时为预测场景，制作数据阶段，不用设置标签，因为此时是按照顺序产生；而在train_generator数据训练之前的数据准备，则需要设置标签</li>
<li>shuffle，此时为预测场景，制作数据集，不用打乱；但是在model.fit过程中需要打乱，表示是否在训练过程中每个epoch前随机打乱输入样本的顺序。</li>
</ul>
<p>.</p>
<h2 id="3-fine-tuning-小网络"><a name="t16"></a>3、 fine-tuning - “小”网络</h2>
<p>主要步骤：</p>
<ul>
<li>（1）导入bottleneck_features数据；</li>
<li>（2）设置标签，并规范成Keras默认格式；</li>
<li>（3）写“小网络”的网络结构</li>
<li>（4）设置参数并训练</li>
</ul>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># （1）导入bottleneck_features数据</span>
train_data = np.load(open(<span class="hljs-string"><span class="hljs-string">'bottleneck_features_train.npy'</span>))
<span class="hljs-comment"><span class="hljs-comment"># the features were saved in order, so recreating the labels is easy</span>
train_labels = np.array([<span class="hljs-number"><span class="hljs-number">0</span>] * <span class="hljs-number"><span class="hljs-number">100</span> + [<span class="hljs-number"><span class="hljs-number">1</span>] * <span class="hljs-number"><span class="hljs-number">100</span> + [<span class="hljs-number"><span class="hljs-number">2</span>] * <span class="hljs-number"><span class="hljs-number">100</span> + [<span class="hljs-number"><span class="hljs-number">3</span>] * <span class="hljs-number"><span class="hljs-number">100</span> + [<span class="hljs-number"><span class="hljs-number">4</span>] * <span class="hljs-number"><span class="hljs-number">96</span>)  <span class="hljs-comment"><span class="hljs-comment"># matt,打标签</span>

validation_data = np.load(open(<span class="hljs-string"><span class="hljs-string">'bottleneck_features_validation.npy'</span>))
validation_labels = np.array([<span class="hljs-number"><span class="hljs-number">0</span>] * <span class="hljs-number"><span class="hljs-number">20</span> + [<span class="hljs-number"><span class="hljs-number">1</span>] * <span class="hljs-number"><span class="hljs-number">20</span> + [<span class="hljs-number"><span class="hljs-number">2</span>] * <span class="hljs-number"><span class="hljs-number">20</span> + [<span class="hljs-number"><span class="hljs-number">3</span>] * <span class="hljs-number"><span class="hljs-number">20</span> + [<span class="hljs-number"><span class="hljs-number">4</span>] * <span class="hljs-number"><span class="hljs-number">16</span>)  <span class="hljs-comment"><span class="hljs-comment"># matt,打标签</span>

<span class="hljs-comment"><span class="hljs-comment"># （2）设置标签，并规范成Keras默认格式</span>
train_labels = keras.utils.to_categorical(train_labels, <span class="hljs-number"><span class="hljs-number">5</span>)
validation_labels = keras.utils.to_categorical(validation_labels, <span class="hljs-number"><span class="hljs-number">5</span>)

<span class="hljs-comment"><span class="hljs-comment"># （3）写“小网络”的网络结构</span>
model = Sequential()
<span class="hljs-comment"><span class="hljs-comment">#train_data.shape[1:]</span>
model.add(Flatten(input_shape=(<span class="hljs-number"><span class="hljs-number">4</span>,<span class="hljs-number"><span class="hljs-number">4</span>,<span class="hljs-number"><span class="hljs-number">512</span>)))<span class="hljs-comment"><span class="hljs-comment"># 4*4*512</span>
model.add(Dense(<span class="hljs-number"><span class="hljs-number">256</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>))
model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.5</span>))
<span class="hljs-comment"><span class="hljs-comment">#model.add(Dense(1, activation='sigmoid'))  # 二分类</span>
model.add(Dense(<span class="hljs-number"><span class="hljs-number">5</span>, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span>))  <span class="hljs-comment"><span class="hljs-comment"># matt,多分类</span>
<span class="hljs-comment"><span class="hljs-comment">#model.add(Dense(1))</span>
<span class="hljs-comment"><span class="hljs-comment">#model.add(Dense(5)) </span>
<span class="hljs-comment"><span class="hljs-comment">#model.add(Activation('softmax'))</span>

<span class="hljs-comment"><span class="hljs-comment"># （4）设置参数并训练</span>
model.compile(loss=<span class="hljs-string"><span class="hljs-string">'categorical_crossentropy'</span>,   
<span class="hljs-comment"><span class="hljs-comment"># matt，多分类，不是binary_crossentropy</span>
              optimizer=<span class="hljs-string"><span class="hljs-string">'rmsprop'</span>,
              metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span>])

model.fit(train_data, train_labels,
          nb_epoch=<span class="hljs-number"><span class="hljs-number">50</span>, batch_size=<span class="hljs-number"><span class="hljs-number">16</span>,
          validation_data=(validation_data, validation_labels))
model.save_weights(<span class="hljs-string"><span class="hljs-string">'bottleneck_fc_model.h5'</span>)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>因为特征的size很小，模型在CPU上跑的也会很快，大概1s一个epoch。</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment">#正确的结果：</span>
Epoch <span class="hljs-number"><span class="hljs-number">48</span>/<span class="hljs-number"><span class="hljs-number">50</span>
<span class="hljs-number"><span class="hljs-number">496</span>/<span class="hljs-number"><span class="hljs-number">496</span> [==============================] - <span class="hljs-number"><span class="hljs-number">0</span>s - loss: <span class="hljs-number"><span class="hljs-number">0.3071</span> - acc: <span class="hljs-number"><span class="hljs-number">0.7762</span> - val_loss: <span class="hljs-number"><span class="hljs-number">4.9337</span> - val_acc: <span class="hljs-number"><span class="hljs-number">0.3229</span>
Epoch <span class="hljs-number"><span class="hljs-number">49</span>/<span class="hljs-number"><span class="hljs-number">50</span>
<span class="hljs-number"><span class="hljs-number">496</span>/<span class="hljs-number"><span class="hljs-number">496</span> [==============================] - <span class="hljs-number"><span class="hljs-number">0</span>s - loss: <span class="hljs-number"><span class="hljs-number">0.2881</span> - acc: <span class="hljs-number"><span class="hljs-number">0.8004</span> - val_loss: <span class="hljs-number"><span class="hljs-number">4.3143</span> - val_acc: <span class="hljs-number"><span class="hljs-number">0.3750</span>
Epoch <span class="hljs-number"><span class="hljs-number">50</span>/<span class="hljs-number"><span class="hljs-number">50</span>
<span class="hljs-number"><span class="hljs-number">496</span>/<span class="hljs-number"><span class="hljs-number">496</span> [==============================] - <span class="hljs-number"><span class="hljs-number">0</span>s - loss: <span class="hljs-number"><span class="hljs-number">0.3119</span> - acc: <span class="hljs-number"><span class="hljs-number">0.7984</span> - val_loss: <span class="hljs-number"><span class="hljs-number">4.4788</span> - val_acc: <span class="hljs-number"><span class="hljs-number">0.5625</span>
&lt;keras.callbacks.History object at <span class="hljs-number"><span class="hljs-number">0x7f25d4456e10</span>&gt;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<h2 id="4遇到的问题"><a name="t17"></a>4、遇到的问题</h2>
<p><strong>（1）Flatten层——最难处理的层</strong>&nbsp;<br>其中在配置网络中，我发现Flatten是最容易出现问题的Layer了。非常多的问题，是因为输给这个层的格式不对。譬如报错：</p>
<pre class="prettyprint"><code class="hljs avrasm has-numbering groovy">语句:model<span class="hljs-preprocessor">.add(Flatten(input_shape=train_data<span class="hljs-preprocessor">.shape[<span class="hljs-number"><span class="hljs-number">1</span>:]))
<span class="hljs-label"><span class="hljs-string">ValueError:</span> Input <span class="hljs-number"><span class="hljs-number">0</span> is incompatible with layer <span class="hljs-string">flatten_5:</span> expected min_ndim=<span class="hljs-number"><span class="hljs-number">3</span>, found ndim=<span class="hljs-number"><span class="hljs-number">2</span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>于是要改成(4,4,512)，这样写（512,4,4）也不对！</p>
<p><strong>（2）标签格式问题</strong>&nbsp;<br>model.fit之后报错：</p>
<pre class="prettyprint"><code class="hljs vbnet has-numbering">ValueError: <span class="hljs-keyword"><span class="hljs-keyword">Error</span> <span class="hljs-keyword"><span class="hljs-keyword">when</span> checking target: expected dense_2 <span class="hljs-keyword"><span class="hljs-keyword">to</span> have shape (None, <span class="hljs-number"><span class="hljs-number">5</span>) but got array <span class="hljs-keyword"><span class="hljs-keyword">with</span> shape (<span class="hljs-number"><span class="hljs-number">500</span>, <span class="hljs-number"><span class="hljs-number">1</span>)</span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>标签格式没有设置，特别是多分类会遇见这样的问题。需要keras.utils.to_categorical()</p>
<pre class="prettyprint"><code class="hljs avrasm has-numbering ini"><span class="hljs-attr">train_labels</span> = keras<span class="hljs-preprocessor">.utils<span class="hljs-preprocessor">.to_categorical(train_labels, <span class="hljs-number"><span class="hljs-number">5</span>)</span></span></span></code></pre>
<p>.</p>
<hr>
<h1 id="四fine-tuning方式二要调整权重"><a name="t18"></a>四、fine-tuning方式二：要调整权重</h1>
<hr>
<p>Keras中文文档+<a href="https://blog.keras.io/building-powerful-image-classification-models-using-very-little-data.html" target="_blank">原作者文档</a>这个部分都没有写对！</p>
<p>先来看看整个结构。&nbsp;<br><img title="" alt="![][)" src="http://keras-cn.readthedocs.io/en/latest/images/vgg16_modified.png"></p>
<p>fine-tune分三个步骤：&nbsp;<br>- 搭建vgg-16并载入权重，将之前定义的全连接网络加在模型的顶部，并载入权重&nbsp;<br>- 冻结vgg16网络的一部分参数&nbsp;<br>- 模型训练</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、fine-tune,所有的层都应该以训练好的权重为初始值，例如，你不能将随机初始的全连接放在预训练的卷积层之上，这是因为由随机权重产生的大梯度将会破坏卷积层预训练的权重。</li>
<li>2、选择只fine-tune最后的卷积块，而不是整个网络，这是为了防止过拟合。整个网络具有巨大的熵容量，因此具有很高的过拟合倾向。由底层卷积模块学习到的特征更加一般，更加不具有抽象性，因此我们要保持前两个卷积块（学习一般特征）不动，只fine-tune后面的卷积块（学习特别的特征）</li>
<li>3、fine-tune应该在很低的学习率下进行，通常使用SGD优化而不是其他自适应学习率的优化算法，如RMSProp。这是为了保证更新的幅度保持在较低的程度，以免毁坏预训练的特征。&nbsp;<br>.</li>


</ul>
<h2 id="1步骤一搭建vgg-16并载入权重"><a name="t19"></a>1、步骤一：搭建vgg-16并载入权重</h2>
<h3 id="11-keras文档结果"><a name="t20"></a>1.1 Keras文档结果</h3>
<p>先看看Keras中文文档是这样的：</p>
<pre class="prettyprint"><code class="hljs python has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">from</span> keras <span class="hljs-keyword"><span class="hljs-keyword">import</span> applications
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword"><span class="hljs-keyword">import</span> ImageDataGenerator
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras <span class="hljs-keyword"><span class="hljs-keyword">import</span> optimizers
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Dropout, Flatten, Dense

<span class="hljs-comment"><span class="hljs-comment"># 网络结构</span>
top_model = Sequential()
<span class="hljs-comment"><span class="hljs-comment">#top_model.add(Flatten(input_shape=model.output_shape[1:]))</span>
top_model.add(Flatten(input_shape=(<span class="hljs-number"><span class="hljs-number">4</span>,<span class="hljs-number"><span class="hljs-number">4</span>,<span class="hljs-number"><span class="hljs-number">512</span>)))
top_model.add(Dense(<span class="hljs-number"><span class="hljs-number">256</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>))
top_model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.5</span>))
<span class="hljs-comment"><span class="hljs-comment">#top_model.add(Dense(1, activation='sigmoid'))</span>
top_model.add(Dense(<span class="hljs-number"><span class="hljs-number">5</span>, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span>)) 
<span class="hljs-comment"><span class="hljs-comment"># 加载权重</span>
top_model.load_weights(top_model_weights_path)

model.add(top_model)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>中文文档是用Sequential式写的，但是没有找到对的权重：top_model_weights_path，如果不正确的权重文件会报错：</p>
<pre class="prettyprint"><code class="hljs livecodeserver has-numbering sql">ValueError: You are trying <span class="hljs-built_in">to <span class="hljs-built_in"><span class="hljs-keyword">load</span> <span class="hljs-operator">a weight <span class="hljs-built_in"><span class="hljs-keyword">file</span> containing <span class="hljs-number"><span class="hljs-number">16</span> layers <span class="hljs-keyword"><span class="hljs-keyword">into</span> <span class="hljs-operator">a <span class="hljs-keyword">model</span> <span class="hljs-operator"><span class="hljs-keyword">with</span> <span class="hljs-number"><span class="hljs-number">2</span> layers.</span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>同时也没有交代model是什么。</p>
<h3 id="12-原作者新改"><a name="t21"></a>1.2 原作者新改</h3>
<p>当然看原作者代码知道了这里的model就是VGG16的。所以原作者改成：</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># 载入Model权重 + 网络</span>
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.applications.vgg16_matt <span class="hljs-keyword"><span class="hljs-keyword">import</span> VGG16
model = VGG16(weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span>, include_top=<span class="hljs-keyword"><span class="hljs-keyword">False</span>)

<span class="hljs-comment"><span class="hljs-comment"># “小网络”结构</span>
top_model = Sequential()
top_model.add(Flatten(input_shape=model.output_shape[<span class="hljs-number"><span class="hljs-number">1</span>:]))
<span class="hljs-comment"><span class="hljs-comment"># top_model.add(Flatten(input_shape=(4,4,512)))</span>
top_model.add(Dense(<span class="hljs-number"><span class="hljs-number">256</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>))
top_model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.5</span>))
top_model.add(Dense(<span class="hljs-number"><span class="hljs-number">5</span>, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span>)) 

<span class="hljs-comment"><span class="hljs-comment"># 加权重</span>
top_model.load_weights(top_model_weights_path)

<span class="hljs-comment"><span class="hljs-comment"># 两个网络整合</span>
model.add(top_model)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>这里又出现一个问题就是，原作者是用application中的VGG16来做的，那么VGG16原来的是Model式的，现在model.add的是Sequential,兼容不起来，报错：</p>
<pre class="prettyprint"><code class="hljs ruleslanguage has-numbering shell"><span class="hljs-array"><span class="hljs-meta">#</span><span class="bash"> AttributeError: </span><span class="hljs-string"><span class="bash"><span class="hljs-string">'Model'</span> object has no attribute </span><span class="hljs-string"><span class="bash"><span class="hljs-string">'add'</span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>于是参考了<a href="https://github.com/fchollet/keras/blob/master/keras/applications/vgg16.py" target="_blank">VGG16原来网络</a>中的结构自己写了：</p>
<pre class="prettyprint"><code class="hljs python has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">from</span> keras <span class="hljs-keyword"><span class="hljs-keyword">import</span> applications
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword"><span class="hljs-keyword">import</span> ImageDataGenerator
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras <span class="hljs-keyword"><span class="hljs-keyword">import</span> optimizers
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Dropout, Flatten, Dense

<span class="hljs-comment"><span class="hljs-comment"># 载入Model权重 + 网络</span>
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.applications.vgg16_matt <span class="hljs-keyword"><span class="hljs-keyword">import</span> VGG16
model = VGG16(weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span>, include_top=<span class="hljs-keyword"><span class="hljs-keyword">False</span>)

<span class="hljs-comment"><span class="hljs-comment"># 新加层</span>
x = model.output
<span class="hljs-comment"><span class="hljs-comment"># 最有问题的层:flatten层</span>
x = Flatten(name=<span class="hljs-string"><span class="hljs-string">'flatten'</span>)(x)
<span class="hljs-comment"><span class="hljs-comment"># 尝试一：x = Flatten()(x)</span>
<span class="hljs-comment"><span class="hljs-comment"># 尝试二：x = GlobalAveragePooling2D()(x)</span>
<span class="hljs-comment"><span class="hljs-comment"># 尝试三：from keras.layers import Reshape</span>
<span class="hljs-comment"><span class="hljs-comment">#x = Reshape((4,4, 512))(x) # TypeError: long() argument must be a string or a number, not 'NoneType'</span>

x = Dense(<span class="hljs-number"><span class="hljs-number">256</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'fc1'</span>)(x)
x = Dropout(<span class="hljs-number"><span class="hljs-number">0.5</span>)(x)
predictions = Dense(<span class="hljs-number"><span class="hljs-number">5</span>, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span>)(x)

<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> Model

vgg_model = Model(input=model.input, output=predictions)
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>其中又是遇到了Flatten()层的问题，而且做了很多尝试，这一个层的意思是把VGG16网络结构+权重的model数据输出格式输入给Flatten()进行降维，但是！&nbsp;<br>model.output输出的格式是：（?，?，?，512）&nbsp;<br>那么肯定会报错：</p>
<pre class="prettyprint"><code class="hljs livecodeserver has-numbering vbnet">ValueError: The shape <span class="hljs-operator"><span class="hljs-keyword">of</span> <span class="hljs-operator">the input <span class="hljs-built_in"><span class="hljs-keyword">to</span> <span class="hljs-string"><span class="hljs-string">"Flatten"</span> <span class="hljs-keyword">is</span> <span class="hljs-operator"><span class="hljs-keyword">not</span> fully defined (got (None, None, <span class="hljs-number"><span class="hljs-number">512</span>). Make sure <span class="hljs-built_in"><span class="hljs-keyword">to</span> pass <span class="hljs-operator">a complete <span class="hljs-string"><span class="hljs-string">"input_shape"</span> <span class="hljs-operator"><span class="hljs-keyword">or</span> <span class="hljs-string"><span class="hljs-string">"batch_input_shape"</span> argument <span class="hljs-built_in"><span class="hljs-keyword">to</span> <span class="hljs-operator">the <span class="hljs-keyword">first layer <span class="hljs-operator"><span class="hljs-keyword">in</span> your model.</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<h4 id="1其中原作者vgg16代码中是这么处理flatten层的">（1）其中原作者VGG16代码中是这么处理Flatten层的：</h4>
<pre class="prettyprint"><code class="hljs mathematica has-numbering ini"><span class="hljs-attr">x</span> = <span class="hljs-keyword">Flatten(name=<span class="hljs-string"><span class="hljs-string">'flatten'</span>)(x)</span></span></code></pre>
<p>&nbsp;</p>
<p>同样会报错。</p>
<h4 id="2借鉴keras跨领域图像分类迁移学习与微调的一部分">（2）借鉴<a href="https://pan.baidu.com/s/1gfn1xuj" target="_blank">《Keras跨领域图像分类迁移学习与微调》</a>的一部分：</h4>
<pre class="prettyprint"><code class="hljs fix has-numbering ini"><span class="hljs-attribute"><span class="hljs-attr">x</span> =<span class="hljs-string"> Reshape((<span class="hljs-number">4</span>,<span class="hljs-number">4</span>, <span class="hljs-number">512</span>))(x)</span></span></code></pre>
<p>&nbsp;</p>
<p>也没成功，应该是自己不太会如果写这个层。</p>
<h4 id="3尝试直接加了个globalaveragepooling2d层之后">（3）尝试直接加了个GlobalAveragePooling2D层之后：</h4>
<pre class="prettyprint"><code class="hljs ini has-numbering"><span class="hljs-setting"><span class="hljs-attr">x</span> = <span class="hljs-value">GlobalAveragePooling2D()(x)
<span class="hljs-setting"><span class="hljs-attr">x</span> = <span class="hljs-value">Dense(<span class="hljs-number"><span class="hljs-number">256</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'fc1'</span>)(x)
<span class="hljs-setting"><span class="hljs-attr">x</span> = <span class="hljs-value">Dropout(<span class="hljs-number"><span class="hljs-number">0.5</span>)(x)
<span class="hljs-setting"><span class="hljs-attr">predictions</span> = <span class="hljs-value">Dense(<span class="hljs-number"><span class="hljs-number">5</span>, activation=<span class="hljs-string">'softmax'</span>)(x)</span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>可以运行，但是，fit的结果是：</p>
<pre class="prettyprint"><code class="hljs r has-numbering">Epoch <span class="hljs-number"><span class="hljs-number">1</span>/<span class="hljs-number"><span class="hljs-number">50</span>
<span class="hljs-number"><span class="hljs-number">31</span>/<span class="hljs-number"><span class="hljs-number">31</span> [==============================] - 10s - loss: <span class="hljs-number"><span class="hljs-number">0.5575</span> - acc: <span class="hljs-number"><span class="hljs-number">0.7730</span> - val_loss: <span class="hljs-number"><span class="hljs-number">0.5191</span> - val_acc: <span class="hljs-number"><span class="hljs-number">0.8000</span>
Epoch <span class="hljs-number"><span class="hljs-number">2</span>/<span class="hljs-number"><span class="hljs-number">50</span>
<span class="hljs-number"><span class="hljs-number">31</span>/<span class="hljs-number"><span class="hljs-number">31</span> [==============================] - 9s - loss: <span class="hljs-number"><span class="hljs-number">0.5548</span> - acc: <span class="hljs-number"><span class="hljs-number">0.7760</span> - val_loss: <span class="hljs-number"><span class="hljs-number">0.5256</span> - val_acc: <span class="hljs-number"><span class="hljs-number">0.8000</span>
<span class="hljs-keyword"><span class="hljs-keyword">...</span>
Epoch <span class="hljs-number"><span class="hljs-number">49</span>/<span class="hljs-number"><span class="hljs-number">50</span>
<span class="hljs-number"><span class="hljs-number">31</span>/<span class="hljs-number"><span class="hljs-number">31</span> [==============================] - 9s - loss: <span class="hljs-number"><span class="hljs-number">0.5602</span> - acc: <span class="hljs-number"><span class="hljs-number">0.7730</span> - val_loss: <span class="hljs-number"><span class="hljs-number">0.5285</span> - val_acc: <span class="hljs-number"><span class="hljs-number">0.8000</span>
Epoch <span class="hljs-number"><span class="hljs-number">50</span>/<span class="hljs-number"><span class="hljs-number">50</span>
<span class="hljs-number"><span class="hljs-number">31</span>/<span class="hljs-number"><span class="hljs-number">31</span> [==============================] - 9s - loss: <span class="hljs-number"><span class="hljs-number">0.5583</span> - acc: <span class="hljs-number"><span class="hljs-number">0.7780</span> - val_loss: <span class="hljs-number"><span class="hljs-number">0.5220</span> - val_acc: <span class="hljs-number"><span class="hljs-number">0.8000</span>
&lt;keras.callbacks.History object at <span class="hljs-number"><span class="hljs-number">0x7fb90410fb10</span>&gt;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>内容结果总是一样的，所以还是不对，这块还没有解决。。&nbsp;<br>.</p>
<h2 id="2冻结vgg16网络的一部分参数"><a name="t22"></a>2、冻结vgg16网络的一部分参数</h2>
<p>然后将最后一个卷积块前的卷积层参数冻结：</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">for</span> layer <span class="hljs-keyword"><span class="hljs-keyword">in</span> vgg_model.layers[:<span class="hljs-number"><span class="hljs-number">25</span>]:
    layer.trainable = <span class="hljs-keyword"><span class="hljs-keyword">False</span>

<span class="hljs-comment"><span class="hljs-comment"># compile the model with a SGD/momentum optimizer</span>


vgg_model.compile(loss=<span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span>,
              optimizer=optimizers.SGD(lr=<span class="hljs-number"><span class="hljs-number">1e-4</span>, momentum=<span class="hljs-number"><span class="hljs-number">0.9</span>),
              metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span>])</span></span></span></span></span></span></span></span></span></code></pre>
<p>.</p>
<h2 id="3模型训练"><a name="t23"></a>3、模型训练</h2>
<p>然后以很低的学习率进行训练：</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># 准备数据</span>
train_data_dir = <span class="hljs-string"><span class="hljs-string">'/.../train'</span>
validation_data_dir = <span class="hljs-string"><span class="hljs-string">'/.../validation'</span>
img_width, img_height = <span class="hljs-number"><span class="hljs-number">150</span>, <span class="hljs-number"><span class="hljs-number">150</span>
nb_train_samples = <span class="hljs-number"><span class="hljs-number">500</span>
nb_validation_samples = <span class="hljs-number"><span class="hljs-number">100</span>
epochs = <span class="hljs-number"><span class="hljs-number">50</span>
batch_size = <span class="hljs-number"><span class="hljs-number">16</span>

<span class="hljs-comment"><span class="hljs-comment"># 图片预处理生成器</span>
train_datagen = ImageDataGenerator(
        rescale=<span class="hljs-number"><span class="hljs-number">1.</span>/<span class="hljs-number"><span class="hljs-number">255</span>,
        shear_range=<span class="hljs-number"><span class="hljs-number">0.2</span>,
        zoom_range=<span class="hljs-number"><span class="hljs-number">0.2</span>,
        horizontal_flip=<span class="hljs-keyword"><span class="hljs-keyword">True</span>)

test_datagen = ImageDataGenerator(rescale=<span class="hljs-number"><span class="hljs-number">1.</span>/<span class="hljs-number"><span class="hljs-number">255</span>)

<span class="hljs-comment"><span class="hljs-comment"># 图片generator</span>
train_generator = train_datagen.flow_from_directory(
        train_data_dir,
        target_size=(img_height, img_width),
        batch_size=<span class="hljs-number"><span class="hljs-number">32</span>,
        class_mode=<span class="hljs-string"><span class="hljs-string">'categorical'</span>)

validation_generator = test_datagen.flow_from_directory(
        validation_data_dir,
        target_size=(img_height, img_width),
        batch_size=<span class="hljs-number"><span class="hljs-number">32</span>,
        class_mode=<span class="hljs-string"><span class="hljs-string">'categorical'</span>)

<span class="hljs-comment"><span class="hljs-comment"># 训练</span>
vgg_model.fit_generator(
        train_generator,
        steps_per_epoch=nb_train_samples // batch_size,
        epochs=epochs,
        validation_data=validation_generator,
        validation_steps=nb_validation_samples // batch_size)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>如果在之前的网络结构可以正常载入的话，后面都是没有问题的，可以直接运行。</p>
<p>&nbsp;</p></div>]]></description></item><item><title>keras系列︱Application中五款已训练模型、VGG16框架（Sequential式、Model式）解读（二）</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/07/11146752.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 07 Jul 2019 08:48:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/07/11146752.html</guid><description><![CDATA[<div class="blogpost-body" id="cnblogs_post_body"><p>引自：<a href="http://blog.csdn.net/sinat_26917383/article/details/72859145" target="_blank">http://blog.csdn.net/sinat_26917383/article/details/72859145</a></p>
<p>中文文档：<a href="http://keras-cn.readthedocs.io/en/latest/" target="_blank">http://keras-cn.readthedocs.io/en/latest/</a>&nbsp; <br>官方文档：<a href="https://keras.io/" target="_blank">https://keras.io/</a>&nbsp; <br>文档主要是以keras2.0。&nbsp;<br>.</p>
<hr>
<p>.</p>
<h3 id="keras系列"><a name="t0"></a>Keras系列：</h3>
<p>1、<a href="https://www.cnblogs.com/peng8098/articles/11146719.html" target="_blank">keras系列︱Sequential与Model模型、keras基本结构功能（一）</a>&nbsp;<br>2、<a href="https://www.cnblogs.com/peng8098/articles/11146752.html" target="_blank">keras系列︱Application中五款已训练模型、VGG16框架（Sequential式、Model式）解读（二）</a>&nbsp;<br>3、<a href="https://www.cnblogs.com/peng8098/articles/11146766.html" target="_blank">keras系列︱图像多分类训练与利用bottleneck features进行微调（三）</a>&nbsp;<br>4、<a href="https://www.cnblogs.com/peng8098/articles/11146774.html" target="_blank">keras系列︱人脸表情分类与识别：opencv人脸检测+Keras情绪分类（四）</a>&nbsp;<br>5、<a href="https://www.cnblogs.com/peng8098/articles/11146779.html" target="_blank">keras系列︱迁移学习：利用InceptionV3进行fine-tuning及预测、完整案例（五）</a></p>
<hr>
<h1 id="一application的五款已训练模型-h5py简述"><a name="t1"></a>一、Application的五款已训练模型 + H5py简述</h1>
<p>Kera的应用模块Application提供了带有预训练权重的Keras模型，这些模型可以用来进行预测、特征提取和finetune。&nbsp;<br>后续还有对以下几个模型的参数介绍：</p>
<ul>
<li>Xception</li>
<li>VGG16</li>
<li>VGG19</li>
<li>ResNet50</li>
<li>InceptionV3</li>



</ul>
<p>所有的这些模型(除了Xception)都兼容Theano和Tensorflow，并会自动基于~/.keras/keras.json的Keras的图像维度进行自动设置。例如，如果你设置data_format=”channel_last”，则加载的模型将按照TensorFlow的维度顺序来构造，即“Width-Height-Depth”的顺序。</p>
<p>模型的官方下载路径：<a href="https://github.com/fchollet/deep-learning-models/releases" target="_blank">https://github.com/fchollet/deep-learning-models/releases</a></p>
<p>其中：&nbsp;<br>.</p>
<h2 id="1th与tf的区别"><a name="t2"></a>1、<strong>th</strong>与<strong>tf</strong>的区别</h2>
<p>==================</p>
<p><strong>Keras提供了两套后端，Theano和Tensorflow，</strong>&nbsp;<br>th和tf的大部分功能都被backend统一包装起来了，但二者还是存在不小的冲突，有时候你需要特别注意Keras是运行在哪种后端之上，它们的主要冲突有：</p>
<p>dim_ordering，也就是维度顺序。比方说一张224*224的彩色图片，theano的维度顺序是(3，224，224)，即通道维在前。而tf的维度顺序是(224，224，3)，即通道维在后。&nbsp;<br>卷积层权重的shape：从无到有训练一个网络，不会有任何问题。但是如果你想把一个th训练出来的卷积层权重载入风格为tf的卷积层……说多了都是泪。我一直觉得这个是个bug，数据的dim_ordering有问题就罢了，为啥卷积层权重的shape还需要变换咧？我迟早要提个PR把这个bug修掉！&nbsp;<br>然后是卷积层kernel的翻转不翻转问题，这个我们说过很多次了，就不再多提。&nbsp;<br>数据格式的区别，channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。&nbsp;<br>以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。&nbsp;<br>譬如：&nbsp;<br>vgg16_weights_th_dim_ordering_th_kernels_notop.h5&nbsp;<br>vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5&nbsp;<br>.</p>
<h2 id="2notop模型是指什么"><a name="t3"></a>2、notop模型是指什么？</h2>
<p>==============</p>
<p>是否包含最后的3个全连接层（whether to include the 3 fully-connected layers at the top of the network）。用来做fine-tuning专用，专门开源了这类模型。&nbsp;<br>.</p>
<h2 id="3h5py简述"><a name="t4"></a>3、H5py简述</h2>
<p>========</p>
<p>keras的已训练模型是H5PY格式的，不是caffe的.caffemodel&nbsp;<br>h5py.File类似Python的词典对象，因此我们可以查看所有的键值：&nbsp;<br>读入</p>
<pre class="prettyprint"><code class="hljs delphi has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">file</span>=h5py.<span class="hljs-keyword"><span class="hljs-keyword">File</span>(<span class="hljs-string"><span class="hljs-string">'.../notop.h5'</span>,<span class="hljs-string"><span class="hljs-string">'r'</span>)</span></span></span></span></code></pre>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">f.attrs[<span class="hljs-string"><span class="hljs-string">'nb_layers'</span>],代表f的属性，其中有一个属性为<span class="hljs-string"><span class="hljs-string">'nb_layers'</span></span></span></code></pre>
<p>&nbsp;</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-prompt"><span class="hljs-meta">&gt;&gt;&gt; </span>f.keys()
[<span class="hljs-string"><span class="hljs-string">u'block1_conv1'</span>, <span class="hljs-string"><span class="hljs-string">u'block1_conv2'</span>, <span class="hljs-string"><span class="hljs-string">u'block1_pool'</span>, <span class="hljs-string"><span class="hljs-string">u'block2_conv1'</span>, <span class="hljs-string"><span class="hljs-string">u'block2_conv2'</span>, <span class="hljs-string"><span class="hljs-string">u'block2_pool'</span>, <span class="hljs-string"><span class="hljs-string">u'block3_conv1'</span>, <span class="hljs-string"><span class="hljs-string">u'block3_conv2'</span>, <span class="hljs-string"><span class="hljs-string">u'block3_conv3'</span>, <span class="hljs-string"><span class="hljs-string">u'block3_pool'</span>, <span class="hljs-string"><span class="hljs-string">u'block4_conv1'</span>, <span class="hljs-string"><span class="hljs-string">u'block4_conv2'</span>, <span class="hljs-string"><span class="hljs-string">u'block4_conv3'</span>, <span class="hljs-string"><span class="hljs-string">u'block4_pool'</span>, <span class="hljs-string"><span class="hljs-string">u'block5_conv1'</span>, <span class="hljs-string"><span class="hljs-string">u'block5_conv2'</span>, <span class="hljs-string"><span class="hljs-string">u'block5_conv3'</span>, <span class="hljs-string"><span class="hljs-string">u'block5_pool'</span>]</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>可以看到f中各个层内有些什么。</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">for</span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span> f:
    print(name)
    <span class="hljs-comment"><span class="hljs-comment"># 类似f.keys()</span></span></span></span></code></pre>
<p>.</p>
<h2 id="4官方案例利用resnet50网络进行imagenet分类"><a name="t5"></a>4、官方案例——利用ResNet50网络进行ImageNet分类</h2>
<p>================================</p>
<pre class="prettyprint"><code class="hljs go has-numbering">rom keras.applications.resnet50 <span class="hljs-keyword"><span class="hljs-keyword">import</span> ResNet50
from keras.preprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span> image
from keras.applications.resnet50 <span class="hljs-keyword"><span class="hljs-keyword">import</span> preprocess_input, decode_predictions
<span class="hljs-keyword"><span class="hljs-keyword">import</span> numpy as np

model = ResNet50(weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span>)

img_path = <span class="hljs-string"><span class="hljs-string">'elephant.jpg'</span>
img = image.load_img(img_path, target_size=<span class="hljs-number">(<span class="hljs-number">224</span>,<span class="hljs-number"> <span class="hljs-number">224</span>))
x = image.img_to_array(img)
x = np.expand_dims(x, axis<span class="hljs-number">=<span class="hljs-number">0</span>)
x = preprocess_input(x)

preds = model.predict(x)
<span class="hljs-built_in"><span class="hljs-built_in">print</span>(<span class="hljs-string"><span class="hljs-string">'Predicted:'</span>, decode_predictions(preds, top<span class="hljs-number">=<span class="hljs-number">3</span>)<span class="hljs-number">[<span class="hljs-number">0</span>])
# Predicted: [(u<span class="hljs-string"><span class="hljs-string">'n02504013'</span>, u<span class="hljs-string"><span class="hljs-string">'Indian_elephant'</span>,<span class="hljs-number"> <span class="hljs-number">0.82658225</span>), (u<span class="hljs-string"><span class="hljs-string">'n01871265'</span>, u<span class="hljs-string"><span class="hljs-string">'tusker'</span>,<span class="hljs-number"> <span class="hljs-number">0.1122357</span>), (u<span class="hljs-string"><span class="hljs-string">'n02504458'</span>, u<span class="hljs-string"><span class="hljs-string">'African_elephant'</span>,<span class="hljs-number"> <span class="hljs-number">0.061040461</span>)]</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>还有的案例可见<a href="http://keras-cn.readthedocs.io/en/latest/other/application/" target="_blank">Keras官方文档</a></p>
<blockquote>
<p>利用VGG16提取特征、从VGG19的任意中间层中抽取特征、在定制的输入tensor上构建InceptionV3</p>
</blockquote>
<p>.</p>
<h2 id="5调用参数解释"><a name="t6"></a>5、调用参数解释</h2>
<p>========</p>
<p><strong>以下几类，因为调用好像都是从网站下载权重，所以可以自己修改一下源码，让其可以读取本地H5文件。</strong></p>
<h3 id="xception模型"><a name="t7"></a>Xception模型</h3>
<p>ImageNet上,该模型取得了验证集top1 0.790和top5 0.945的正确率;&nbsp;<br>,该模型目前仅能以TensorFlow为后端使用,由于它依赖于”SeparableConvolution”层,目前该模型只支持channels_last的维度顺序(width, height, channels)</p>
<p>默认输入图片大小为299x299</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">keras.applications.xception.Xception(include_top=<span class="hljs-keyword"><span class="hljs-keyword">True</span>, weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span>,
                                    input_tensor=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, input_shape=<span class="hljs-keyword"><span class="hljs-keyword">None</span>,
                                    pooling=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, classes=<span class="hljs-number"><span class="hljs-number">1000</span>)</span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<h3 id="vgg16模型"><a name="t8"></a>VGG16模型</h3>
<p>VGG16模型,权重由ImageNet训练而来</p>
<p>该模型再Theano和TensorFlow后端均可使用,并接受channels_first和channels_last两种输入维度顺序</p>
<p>模型的默认输入尺寸时224x224</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">keras.applications.vgg16.VGG16(include_top=<span class="hljs-keyword"><span class="hljs-keyword">True</span>, weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span>,
                                input_tensor=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, input_shape=<span class="hljs-keyword"><span class="hljs-keyword">None</span>,
                                pooling=<span class="hljs-keyword"><span class="hljs-keyword">None</span>,
                                classes=<span class="hljs-number"><span class="hljs-number">1000</span>)</span></span></span></span></span></span></code></pre>
<h3 id="vgg19模型"><a name="t9"></a>VGG19模型</h3>
<p>VGG19模型,权重由ImageNet训练而来</p>
<p>该模型在Theano和TensorFlow后端均可使用,并接受channels_first和channels_last两种输入维度顺序</p>
<p>模型的默认输入尺寸时224x224</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">keras.applications.vgg19.VGG19(include_top=<span class="hljs-keyword"><span class="hljs-keyword">True</span>, weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span>,
                                input_tensor=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, input_shape=<span class="hljs-keyword"><span class="hljs-keyword">None</span>,
                                pooling=<span class="hljs-keyword"><span class="hljs-keyword">None</span>,
                                classes=<span class="hljs-number"><span class="hljs-number">1000</span>)</span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<h3 id="resnet50模型"><a name="t10"></a>ResNet50模型</h3>
<p>50层残差网络模型,权重训练自ImageNet</p>
<p>该模型在Theano和TensorFlow后端均可使用,并接受channels_first和channels_last两种输入维度顺序</p>
<p>模型的默认输入尺寸时224x224</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">keras.applications.resnet50.ResNet50(include_top=<span class="hljs-keyword"><span class="hljs-keyword">True</span>, weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span>,
                                input_tensor=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, input_shape=<span class="hljs-keyword"><span class="hljs-keyword">None</span>,
                                pooling=<span class="hljs-keyword"><span class="hljs-keyword">None</span>,
                                classes=<span class="hljs-number"><span class="hljs-number">1000</span>)</span></span></span></span></span></span></code></pre>
<h3 id="inceptionv3模型"><a name="t11"></a>InceptionV3模型</h3>
<p>InceptionV3网络,权重训练自ImageNet</p>
<p>该模型在Theano和TensorFlow后端均可使用,并接受channels_first和channels_last两种输入维度顺序</p>
<p>模型的默认输入尺寸时299x299</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">keras.applications.inception_v3.InceptionV3(include_top=<span class="hljs-keyword"><span class="hljs-keyword">True</span>,
                                            weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span>,
                                            input_tensor=<span class="hljs-keyword"><span class="hljs-keyword">None</span>,
                                            input_shape=<span class="hljs-keyword"><span class="hljs-keyword">None</span>,
                                            pooling=<span class="hljs-keyword"><span class="hljs-keyword">None</span>,
                                            classes=<span class="hljs-number"><span class="hljs-number">1000</span>)</span></span></span></span></span></span></code></pre>
<p>.</p>
<hr>
<h1 id="二-keras-applications-vgg16解读函数式"><a name="t12"></a>二、 keras-applications-VGG16解读——函数式</h1>
<p>.py文件来源于：<a href="https://github.com/fchollet/deep-learning-models/blob/master/vgg16.py" target="_blank">https://github.com/fchollet/deep-learning-models/blob/master/vgg16.py</a>&nbsp;<br>VGG16默认的输入数据格式应该是：channels_last</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*-</span>
<span class="hljs-string"><span class="hljs-string">'''VGG16 model for Keras.
# Reference:
- [Very Deep Convolutional Networks for Large-Scale Image Recognition](https://arxiv.org/abs/1409.1556)
'''</span>
<span class="hljs-keyword"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span> print_function

<span class="hljs-keyword"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span> np
<span class="hljs-keyword"><span class="hljs-keyword">import</span> warnings

<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> Model
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Flatten
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Dense
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Input
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Conv2D
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> MaxPooling2D
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> GlobalMaxPooling2D
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> GlobalAveragePooling2D
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.preprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span> image
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.utils <span class="hljs-keyword"><span class="hljs-keyword">import</span> layer_utils
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.utils.data_utils <span class="hljs-keyword"><span class="hljs-keyword">import</span> get_file
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras <span class="hljs-keyword"><span class="hljs-keyword">import</span> backend <span class="hljs-keyword"><span class="hljs-keyword">as</span> K
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.applications.imagenet_utils <span class="hljs-keyword"><span class="hljs-keyword">import</span> decode_predictions
<span class="hljs-comment"><span class="hljs-comment"># decode_predictions 输出5个最高概率：(类名, 语义概念, 预测概率) decode_predictions(y_pred)</span>
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.applications.imagenet_utils <span class="hljs-keyword"><span class="hljs-keyword">import</span> preprocess_input
<span class="hljs-comment"><span class="hljs-comment">#  预处理 图像编码服从规定，譬如,RGB，GBR这一类的，preprocess_input(x)  </span>
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.applications.imagenet_utils <span class="hljs-keyword"><span class="hljs-keyword">import</span> _obtain_input_shape
<span class="hljs-comment"><span class="hljs-comment"># 确定适当的输入形状，相当于opencv中的read.img，将图像变为数组</span>
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.engine.topology <span class="hljs-keyword"><span class="hljs-keyword">import</span> get_source_inputs

WEIGHTS_PATH = <span class="hljs-string"><span class="hljs-string">'https://github.com/fchollet/deep-learning-models/releases/download/v0.1/vgg16_weights_tf_dim_ordering_tf_kernels.h5'</span>
WEIGHTS_PATH_NO_TOP = <span class="hljs-string"><span class="hljs-string">'https://github.com/fchollet/deep-learning-models/releases/download/v0.1/vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5'</span>

<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VGG16</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(include_top=True, weights=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'imagenet'</span>,
          input_tensor=None, input_shape=None,
          pooling=None,
          classes=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span>)</span>:</span>
    <span class="hljs-comment"><span class="hljs-comment"># 检查weight与分类设置是否正确</span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span> weights <span class="hljs-keyword"><span class="hljs-keyword">not</span> <span class="hljs-keyword"><span class="hljs-keyword">in</span> {<span class="hljs-string"><span class="hljs-string">'imagenet'</span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span>}:
        <span class="hljs-keyword"><span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string"><span class="hljs-string">'The `weights` argument should be either '</span>
                         <span class="hljs-string"><span class="hljs-string">'`None` (random initialization) or `imagenet` '</span>
                         <span class="hljs-string"><span class="hljs-string">'(pre-training on ImageNet).'</span>)

    <span class="hljs-keyword"><span class="hljs-keyword">if</span> weights == <span class="hljs-string"><span class="hljs-string">'imagenet'</span> <span class="hljs-keyword"><span class="hljs-keyword">and</span> include_top <span class="hljs-keyword"><span class="hljs-keyword">and</span> classes != <span class="hljs-number"><span class="hljs-number">1000</span>:
        <span class="hljs-keyword"><span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string"><span class="hljs-string">'If using `weights` as imagenet with `include_top`'</span>
                         <span class="hljs-string"><span class="hljs-string">' as true, `classes` should be 1000'</span>)

    <span class="hljs-comment"><span class="hljs-comment"># 设置图像尺寸，类似caffe中的transform</span>
    <span class="hljs-comment"><span class="hljs-comment"># Determine proper input shape</span>
    input_shape = _obtain_input_shape(input_shape,
                                      default_size=<span class="hljs-number"><span class="hljs-number">224</span>,
                                      min_size=<span class="hljs-number"><span class="hljs-number">48</span>,
                                      <span class="hljs-comment"><span class="hljs-comment"># 模型所能接受的最小长宽</span>
                                      data_format=K.image_data_format(),
                                      <span class="hljs-comment"><span class="hljs-comment"># 数据的使用格式</span>
                                      include_top=include_top)
                                      <span class="hljs-comment"><span class="hljs-comment">#是否通过一个Flatten层再连接到分类器</span>

    <span class="hljs-comment"><span class="hljs-comment"># 数据简单处理，resize</span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span> input_tensor <span class="hljs-keyword"><span class="hljs-keyword">is</span> <span class="hljs-keyword"><span class="hljs-keyword">None</span>:
        img_input = Input(shape=input_shape)
        <span class="hljs-comment"><span class="hljs-comment"># 这里的Input是keras的格式，可以用于转换</span>
    <span class="hljs-keyword"><span class="hljs-keyword">else</span>:
        <span class="hljs-keyword"><span class="hljs-keyword">if</span> <span class="hljs-keyword"><span class="hljs-keyword">not</span> K.is_keras_tensor(input_tensor):
            img_input = Input(tensor=input_tensor, shape=input_shape)
        <span class="hljs-keyword"><span class="hljs-keyword">else</span>:
            img_input = input_tensor
        <span class="hljs-comment"><span class="hljs-comment"># 如果是tensor的数据格式，需要两步走：</span>
        <span class="hljs-comment"><span class="hljs-comment"># 先判断是否是keras指定的数据类型，is_keras_tensor</span>
        <span class="hljs-comment"><span class="hljs-comment"># 然后get_source_inputs(input_tensor)</span>

    <span class="hljs-comment"><span class="hljs-comment"># 编写网络结构，prototxt</span>
    <span class="hljs-comment"><span class="hljs-comment"># Block 1</span>
    x = Conv2D(<span class="hljs-number"><span class="hljs-number">64</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>, name=<span class="hljs-string"><span class="hljs-string">'block1_conv1'</span>)(img_input)
    x = Conv2D(<span class="hljs-number"><span class="hljs-number">64</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>, name=<span class="hljs-string"><span class="hljs-string">'block1_conv2'</span>)(x)
    x = MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), strides=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), name=<span class="hljs-string"><span class="hljs-string">'block1_pool'</span>)(x)

    <span class="hljs-comment"><span class="hljs-comment"># Block 2</span>
    x = Conv2D(<span class="hljs-number"><span class="hljs-number">128</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>, name=<span class="hljs-string"><span class="hljs-string">'block2_conv1'</span>)(x)
    x = Conv2D(<span class="hljs-number"><span class="hljs-number">128</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>, name=<span class="hljs-string"><span class="hljs-string">'block2_conv2'</span>)(x)
    x = MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), strides=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), name=<span class="hljs-string"><span class="hljs-string">'block2_pool'</span>)(x)

    <span class="hljs-comment"><span class="hljs-comment"># Block 3</span>
    x = Conv2D(<span class="hljs-number"><span class="hljs-number">256</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>, name=<span class="hljs-string"><span class="hljs-string">'block3_conv1'</span>)(x)
    x = Conv2D(<span class="hljs-number"><span class="hljs-number">256</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>, name=<span class="hljs-string"><span class="hljs-string">'block3_conv2'</span>)(x)
    x = Conv2D(<span class="hljs-number"><span class="hljs-number">256</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>, name=<span class="hljs-string"><span class="hljs-string">'block3_conv3'</span>)(x)
    x = MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), strides=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), name=<span class="hljs-string"><span class="hljs-string">'block3_pool'</span>)(x)

    <span class="hljs-comment"><span class="hljs-comment"># Block 4</span>
    x = Conv2D(<span class="hljs-number"><span class="hljs-number">512</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>, name=<span class="hljs-string"><span class="hljs-string">'block4_conv1'</span>)(x)
    x = Conv2D(<span class="hljs-number"><span class="hljs-number">512</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>, name=<span class="hljs-string"><span class="hljs-string">'block4_conv2'</span>)(x)
    x = Conv2D(<span class="hljs-number"><span class="hljs-number">512</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>, name=<span class="hljs-string"><span class="hljs-string">'block4_conv3'</span>)(x)
    x = MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), strides=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), name=<span class="hljs-string"><span class="hljs-string">'block4_pool'</span>)(x)

    <span class="hljs-comment"><span class="hljs-comment"># Block 5</span>
    x = Conv2D(<span class="hljs-number"><span class="hljs-number">512</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>, name=<span class="hljs-string"><span class="hljs-string">'block5_conv1'</span>)(x)
    x = Conv2D(<span class="hljs-number"><span class="hljs-number">512</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>, name=<span class="hljs-string"><span class="hljs-string">'block5_conv2'</span>)(x)
    x = Conv2D(<span class="hljs-number"><span class="hljs-number">512</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>, name=<span class="hljs-string"><span class="hljs-string">'block5_conv3'</span>)(x)
    x = MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), strides=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), name=<span class="hljs-string"><span class="hljs-string">'block5_pool'</span>)(x)

    <span class="hljs-keyword"><span class="hljs-keyword">if</span> include_top:
        <span class="hljs-comment"><span class="hljs-comment"># Classification block</span>
        x = Flatten(name=<span class="hljs-string"><span class="hljs-string">'flatten'</span>)(x)
        x = Dense(<span class="hljs-number"><span class="hljs-number">4096</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'fc1'</span>)(x)
        x = Dense(<span class="hljs-number"><span class="hljs-number">4096</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'fc2'</span>)(x)
        x = Dense(classes, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span>, name=<span class="hljs-string"><span class="hljs-string">'predictions'</span>)(x)
    <span class="hljs-keyword"><span class="hljs-keyword">else</span>:
        <span class="hljs-keyword"><span class="hljs-keyword">if</span> pooling == <span class="hljs-string"><span class="hljs-string">'avg'</span>:
            x = GlobalAveragePooling2D()(x)
        <span class="hljs-keyword"><span class="hljs-keyword">elif</span> pooling == <span class="hljs-string"><span class="hljs-string">'max'</span>:
            x = GlobalMaxPooling2D()(x)

    <span class="hljs-comment"><span class="hljs-comment"># 调整数据      </span>
    <span class="hljs-comment"><span class="hljs-comment"># Ensure that the model takes into account</span>
    <span class="hljs-comment"><span class="hljs-comment"># any potential predecessors of `input_tensor`.</span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span> input_tensor <span class="hljs-keyword"><span class="hljs-keyword">is</span> <span class="hljs-keyword"><span class="hljs-keyword">not</span> <span class="hljs-keyword"><span class="hljs-keyword">None</span>:
        inputs = get_source_inputs(input_tensor)
        <span class="hljs-comment"><span class="hljs-comment"># get_source_inputs 返回计算需要的数据列表，List of input tensors.</span>
        <span class="hljs-comment"><span class="hljs-comment"># 如果是tensor的数据格式，需要两步走：</span>
        <span class="hljs-comment"><span class="hljs-comment"># 先判断是否是keras指定的数据类型，is_keras_tensor</span>
        <span class="hljs-comment"><span class="hljs-comment"># 然后get_source_inputs(input_tensor)</span>
    <span class="hljs-keyword"><span class="hljs-keyword">else</span>:
        inputs = img_input

    <span class="hljs-comment"><span class="hljs-comment"># 创建模型</span>
    <span class="hljs-comment"><span class="hljs-comment"># Create model.</span>
    model = Model(inputs, x, name=<span class="hljs-string"><span class="hljs-string">'vgg16'</span>)

    <span class="hljs-comment"><span class="hljs-comment"># 加载权重</span>
    <span class="hljs-comment"><span class="hljs-comment"># load weights</span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span> weights == <span class="hljs-string"><span class="hljs-string">'imagenet'</span>:
        <span class="hljs-keyword"><span class="hljs-keyword">if</span> include_top:
            weights_path = get_file(<span class="hljs-string"><span class="hljs-string">'vgg16_weights_tf_dim_ordering_tf_kernels.h5'</span>,
                                    WEIGHTS_PATH,
                                    cache_subdir=<span class="hljs-string"><span class="hljs-string">'models'</span>)
        <span class="hljs-keyword"><span class="hljs-keyword">else</span>:
            weights_path = get_file(<span class="hljs-string"><span class="hljs-string">'vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5'</span>,
                                    WEIGHTS_PATH_NO_TOP,
                                    cache_subdir=<span class="hljs-string"><span class="hljs-string">'models'</span>)
        model.load_weights(weights_path)

        <span class="hljs-keyword"><span class="hljs-keyword">if</span> K.backend() == <span class="hljs-string"><span class="hljs-string">'theano'</span>:
            layer_utils.convert_all_kernels_in_model(model)

        <span class="hljs-keyword"><span class="hljs-keyword">if</span> K.image_data_format() == <span class="hljs-string"><span class="hljs-string">'channels_first'</span>:
            <span class="hljs-keyword"><span class="hljs-keyword">if</span> include_top:
                maxpool = model.get_layer(name=<span class="hljs-string"><span class="hljs-string">'block5_pool'</span>)
                shape = maxpool.output_shape[<span class="hljs-number"><span class="hljs-number">1</span>:]
                dense = model.get_layer(name=<span class="hljs-string"><span class="hljs-string">'fc1'</span>)
                layer_utils.convert_dense_weights_data_format(dense, shape, <span class="hljs-string"><span class="hljs-string">'channels_first'</span>)

            <span class="hljs-keyword"><span class="hljs-keyword">if</span> K.backend() == <span class="hljs-string"><span class="hljs-string">'tensorflow'</span>:
                warnings.warn(<span class="hljs-string"><span class="hljs-string">'You are using the TensorFlow backend, yet you '</span>
                              <span class="hljs-string"><span class="hljs-string">'are using the Theano '</span>
                              <span class="hljs-string"><span class="hljs-string">'image data format convention '</span>
                              <span class="hljs-string"><span class="hljs-string">'(`image_data_format="channels_first"`). '</span>
                              <span class="hljs-string"><span class="hljs-string">'For best performance, set '</span>
                              <span class="hljs-string"><span class="hljs-string">'`image_data_format="channels_last"` in '</span>
                              <span class="hljs-string"><span class="hljs-string">'your Keras config '</span>
                              <span class="hljs-string"><span class="hljs-string">'at ~/.keras/keras.json.'</span>)
    <span class="hljs-keyword"><span class="hljs-keyword">return</span> model

<span class="hljs-keyword"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span>:
    model = VGG16(include_top=<span class="hljs-keyword"><span class="hljs-keyword">True</span>, weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span>)

    img_path = <span class="hljs-string"><span class="hljs-string">'elephant.jpg'</span>
    img = image.load_img(img_path, target_size=(<span class="hljs-number"><span class="hljs-number">224</span>, <span class="hljs-number"><span class="hljs-number">224</span>))
    x = image.img_to_array(img)
    x = np.expand_dims(x, axis=<span class="hljs-number"><span class="hljs-number">0</span>)
    x = preprocess_input(x)
    print(<span class="hljs-string"><span class="hljs-string">'Input image shape:'</span>, x.shape)

    preds = model.predict(x)
    print(<span class="hljs-string"><span class="hljs-string">'Predicted:'</span>, decode_predictions(preds))
    <span class="hljs-comment"><span class="hljs-comment"># decode_predictions 输出5个最高概率：(类名, 语义概念, 预测概率)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>其中：&nbsp;<br>.</p>
<h2 id="1如何已经把模型下载到本地"><a name="t13"></a>1、如何已经把模型下载到本地</h2>
<p>==============</p>
<p>模型已经下载，不再每次从网站进行加载，可以修改以下内容。</p>
<pre class="prettyprint"><code class="hljs bash has-numbering">WEIGHTS_PATH = <span class="hljs-string"><span class="hljs-string">'https://github.com/fchollet/deep-learning-models/releases/download/v0.1/vgg16_weights_tf_dim_ordering_tf_kernels.h5'</span>
WEIGHTS_PATH_NO_TOP = <span class="hljs-string"><span class="hljs-string">'https://github.com/fchollet/deep-learning-models/releases/download/v0.1/vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5'</span>

  weights_path = get_file(<span class="hljs-string"><span class="hljs-string">'vgg16_weights_tf_dim_ordering_tf_kernels.h5'</span>,
                          WEIGHTS_PATH,
                          cache_subdir=<span class="hljs-string"><span class="hljs-string">'models'</span>)
            weights_path = get_file(<span class="hljs-string"><span class="hljs-string">'vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5'</span>,
                                    WEIGHTS_PATH_NO_TOP,
                                    cache_subdir=<span class="hljs-string"><span class="hljs-string">'models'</span>)</span></span></span></span></span></span></code></pre>
<p>.</p>
<h2 id="2几个layer中的新用法"><a name="t14"></a>2、几个layer中的新用法</h2>
<p>==============</p>
<pre class="prettyprint"><code class="hljs avrasm has-numbering css"><span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">keras</span><span class="hljs-preprocessor"><span class="hljs-selector-class">.applications</span><span class="hljs-preprocessor"><span class="hljs-selector-class">.imagenet_utils</span> <span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">decode_predictions</span>
<span class="hljs-selector-tag">decode_predictions</span> 输出<span class="hljs-number">5个最高概率：(类名, 语义概念, 预测概率) <span class="hljs-selector-tag">decode_predictions</span>(<span class="hljs-selector-tag">y_pred</span>)

<span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">keras</span><span class="hljs-preprocessor"><span class="hljs-selector-class">.applications</span><span class="hljs-preprocessor"><span class="hljs-selector-class">.imagenet_utils</span> <span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">preprocess_input</span>
预处理 图像编码服从规定，譬如,<span class="hljs-selector-tag">RGB</span>，<span class="hljs-selector-tag">GBR</span>这一类的，<span class="hljs-selector-tag">preprocess_input</span>(<span class="hljs-built_in"><span class="hljs-selector-tag">x</span>)  

<span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">keras</span><span class="hljs-preprocessor"><span class="hljs-selector-class">.applications</span><span class="hljs-preprocessor"><span class="hljs-selector-class">.imagenet_utils</span> <span class="hljs-selector-tag">import</span> _<span class="hljs-selector-tag">obtain_input_shape</span> 
确定适当的输入形状，相当于<span class="hljs-selector-tag">opencv</span>中的<span class="hljs-selector-tag">read</span><span class="hljs-preprocessor"><span class="hljs-selector-class">.img</span>，将图像变为数组</span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>（1）decode_predictions用在最后输出结果上，比较好用【print(‘Predicted:’, decode_predictions(preds))】；&nbsp;<br>（2）preprocess_input，改变编码，【preprocess_input(x)】；&nbsp;<br>（3）_obtain_input_shape&nbsp;<br>相当于caffe中的transform，在预测的时候，需要对预测的图片进行一定的预处理。</p>
<pre class="prettyprint"><code class="hljs avrasm has-numbering nginx"> <span class="hljs-attribute">input_shape</span> = _obtain_input_shape(input_shape,
                                      default_size=<span class="hljs-number"><span class="hljs-number">224</span>,
                                      min_size=<span class="hljs-number"><span class="hljs-number">48</span>,
                                      <span class="hljs-preprocessor"><span class="hljs-comment"># 模型所能接受的最小长宽</span>
                                      data_format=K<span class="hljs-preprocessor">.image_data_format(),
                                      <span class="hljs-preprocessor"><span class="hljs-comment"># 数据的使用格式</span>
                                      include_top=include_top)</span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>.</p>
<h2 id="3当includetoptrue时"><a name="t15"></a>3、当include_top=True时</h2>
<p>====================</p>
<pre class="prettyprint"><code class="hljs ini has-numbering"><span class="hljs-setting"><span class="hljs-attr">fc_model</span> = <span class="hljs-value">VGG16(include_top=<span class="hljs-keyword"><span class="hljs-literal">True</span>)
<span class="hljs-setting"><span class="hljs-attr">notop_model</span> = <span class="hljs-value">VGG16(include_top=<span class="hljs-keyword"><span class="hljs-literal">False</span>)</span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>之前提到过用VGG16做fine-tuning的时候，得到的notop_model就是没有全连接层的模型。然后再去添加自己的层。&nbsp;<br>当时健全的网络结构的时候，fc_model需要添加以下的内容以补全网络结构：</p>
<pre class="prettyprint"><code class="hljs mathematica has-numbering ini"><span class="hljs-attr">x</span> = <span class="hljs-keyword">Flatten(name=<span class="hljs-string"><span class="hljs-string">'flatten'</span>)(x)
<span class="hljs-attr">x</span> = Dense(<span class="hljs-number"><span class="hljs-number">4096</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'fc1'</span>)(x)
<span class="hljs-attr">x</span> = Dense(<span class="hljs-number"><span class="hljs-number">4096</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'fc2'</span>)(x)
<span class="hljs-attr">x</span> = Dense(classes, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span>, name=<span class="hljs-string"><span class="hljs-string">'predictions'</span>)(x)</span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>pool层之后接一个flatten层，修改数据格式，然后接两个dense层，最后有softmax的Dense层。&nbsp;<br>.</p>
<h2 id="4如果输入的数据格式是channelsfirst"><a name="t16"></a>4、如果输入的数据格式是channels_first？</h2>
<p>===========================</p>
<p>如果input的格式是’channels_first’，fc_model还需要修改一下格式，因为VGG16源码是以’channels_last’定义的，所以需要转换一下输出格式。</p>
<pre class="prettyprint"><code class="hljs bash has-numbering"> maxpool = model.get_layer(name=<span class="hljs-string"><span class="hljs-string">'block5_pool'</span>)
 <span class="hljs-comment"><span class="hljs-comment"># model.get_layer()依据层名或下标获得层对象</span>
 shape = maxpool.output_shape[<span class="hljs-number">1:]
 <span class="hljs-comment"><span class="hljs-comment"># 获取block5_pool层输出的数据格式</span>
 dense = model.get_layer(name=<span class="hljs-string"><span class="hljs-string">'fc1'</span>)
 layer_utils.convert_dense_weights_data_format(dense, shape, <span class="hljs-string"><span class="hljs-string">'channels_first'</span>)</span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>其中layer_utils.convert_dense_weights_data_format的作用很特殊，官方文档中没有说明，本质用来修改数据格式，因为层中有Flatter层把数据格式换了，所以需要再修改一下。&nbsp;<br>原文：</p>
<blockquote>
<p>When porting the weights of a convnet from one data format to the other,if the convnet includes a&nbsp;<code>Flatten</code>&nbsp;layer (applied to the last convolutional feature map) followed by a&nbsp;<code>Dense</code>&nbsp;layer, the weights of that&nbsp;<code>Dense</code>&nbsp;layer should be updated to reflect the new dimension ordering.</p>



</blockquote>
<p>.</p>
<hr>
<h1 id="三keras-sequential-vgg16源码解读序列式"><a name="t17"></a>三、keras-Sequential-VGG16源码解读：序列式</h1>
<p>本节节选自Keras中文文档<a href="http://keras-cn.readthedocs.io/en/latest/blog/cnn_see_world/" target="_blank">《CNN眼中的世界：利用Keras解释CNN的滤波器》</a></p>
<p>已训练好VGG16和VGG19模型的权重：&nbsp;<br>国外：<a href="https://gist.github.com/baraldilorenzo/07d7802847aaad0a35d3" target="_blank">https://gist.github.com/baraldilorenzo/07d7802847aaad0a35d3</a>&nbsp;<br>国内：<a href="http://files.heuritech.com/weights/vgg16_weights.h5" target="_blank">http://files.heuritech.com/weights/vgg16_weights.h5</a></p>
<p>前面是VGG16架构的函数式模型的结构，那么在官方文档这个案例中，也有VGG16架构的序列式，都拿来比对一下比较好。&nbsp;<br>.</p>
<h2 id="1vgg16的sequential-网络结构"><a name="t18"></a>1、VGG16的Sequential-网络结构</h2>
<hr>
<p>首先，我们在Keras中定义VGG网络的结构：</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Convolution2D, ZeroPadding2D, MaxPooling2D

img_width, img_height = <span class="hljs-number"><span class="hljs-number">128</span>, <span class="hljs-number"><span class="hljs-number">128</span>

<span class="hljs-comment"><span class="hljs-comment"># build the VGG16 network</span>
model = Sequential()
model.add(ZeroPadding2D((<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">1</span>), batch_input_shape=(<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">3</span>, img_width, img_height)))
first_layer = model.layers[<span class="hljs-number">-</span><span class="hljs-number"><span class="hljs-number">1</span>]
<span class="hljs-comment"><span class="hljs-comment"># this is a placeholder tensor that will contain our generated images</span>
input_img = first_layer.input

<span class="hljs-comment"><span class="hljs-comment"># build the rest of the network</span>
model.add(Convolution2D(<span class="hljs-number"><span class="hljs-number">64</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'conv1_1'</span>))
model.add(ZeroPadding2D((<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">1</span>)))
model.add(Convolution2D(<span class="hljs-number"><span class="hljs-number">64</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'conv1_2'</span>))
model.add(MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), strides=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))

model.add(ZeroPadding2D((<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">1</span>)))
model.add(Convolution2D(<span class="hljs-number"><span class="hljs-number">128</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'conv2_1'</span>))
model.add(ZeroPadding2D((<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">1</span>)))
model.add(Convolution2D(<span class="hljs-number"><span class="hljs-number">128</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'conv2_2'</span>))
model.add(MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), strides=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))

model.add(ZeroPadding2D((<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">1</span>)))
model.add(Convolution2D(<span class="hljs-number"><span class="hljs-number">256</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'conv3_1'</span>))
model.add(ZeroPadding2D((<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">1</span>)))
model.add(Convolution2D(<span class="hljs-number"><span class="hljs-number">256</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'conv3_2'</span>))
model.add(ZeroPadding2D((<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">1</span>)))
model.add(Convolution2D(<span class="hljs-number"><span class="hljs-number">256</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'conv3_3'</span>))
model.add(MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), strides=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))

model.add(ZeroPadding2D((<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">1</span>)))
model.add(Convolution2D(<span class="hljs-number"><span class="hljs-number">512</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'conv4_1'</span>))
model.add(ZeroPadding2D((<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">1</span>)))
model.add(Convolution2D(<span class="hljs-number"><span class="hljs-number">512</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'conv4_2'</span>))
model.add(ZeroPadding2D((<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">1</span>)))
model.add(Convolution2D(<span class="hljs-number"><span class="hljs-number">512</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'conv4_3'</span>))
model.add(MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), strides=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))

model.add(ZeroPadding2D((<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">1</span>)))
model.add(Convolution2D(<span class="hljs-number"><span class="hljs-number">512</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'conv5_1'</span>))
model.add(ZeroPadding2D((<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">1</span>)))
model.add(Convolution2D(<span class="hljs-number"><span class="hljs-number">512</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'conv5_2'</span>))
model.add(ZeroPadding2D((<span class="hljs-number"><span class="hljs-number">1</span>, <span class="hljs-number"><span class="hljs-number">1</span>)))
model.add(Convolution2D(<span class="hljs-number"><span class="hljs-number">512</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, name=<span class="hljs-string"><span class="hljs-string">'conv5_3'</span>))
model.add(MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>), strides=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))

<span class="hljs-comment"><span class="hljs-comment"># get the symbolic outputs of each "key" layer (we gave them unique names).</span>
layer_dict = dict([(layer.name, layer) <span class="hljs-keyword"><span class="hljs-keyword">for</span> layer <span class="hljs-keyword"><span class="hljs-keyword">in</span> model.layers])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>从使用Convolution2D来看，是比较早的版本写的。&nbsp;<br>.</p>
<h2 id="2sequential模型如何部分layer载入权重"><a name="t19"></a>2、Sequential模型如何部分layer载入权重</h2>
<hr>
<p>下面，我们将预训练好的权重载入模型，一般而言我们可以通过model.load_weights()载入，但这种办法是载入全部的权重，并不适用。&nbsp;<br>之前所看到的No_top模型就是用来应付此时的。&nbsp;<br>这里我们只载入一部分参数，用的是set_weights()函数，所以我们需要手工载入：</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">import</span> h5py

weights_path = <span class="hljs-string"><span class="hljs-string">'.../vgg16_weights.h5'</span>

f = h5py.File(weights_path)
<span class="hljs-keyword"><span class="hljs-keyword">for</span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span> range(f.attrs[<span class="hljs-string"><span class="hljs-string">'nb_layers'</span>]):
    <span class="hljs-keyword"><span class="hljs-keyword">if</span> k &gt;= len(model.layers):
        <span class="hljs-keyword"><span class="hljs-keyword">break</span>
    g = f[<span class="hljs-string"><span class="hljs-string">'layer_{}'</span>.format(k)]
    weights = [g[<span class="hljs-string"><span class="hljs-string">'param_{}'</span>.format(p)] <span class="hljs-keyword"><span class="hljs-keyword">for</span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span> range(g.attrs[<span class="hljs-string"><span class="hljs-string">'nb_params'</span>])]
    model.layers[k].set_weights(weights)
f.close()
print(<span class="hljs-string"><span class="hljs-string">'Model loaded.'</span>)</span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>笔者在实践过程中，并没有实践出来，因为我载入的.h5，不知道为什么没有属性f.attrs[‘nb_layers’]也没有属性g.attrs[‘nb_params’])&nbsp;<br>在寻找答案的过程中，看到有前人也跟我一样的问题，可见（<a href="http://blog.csdn.net/smuevian/article/details/60333974" target="_blank">[keras]猫狗大战的总结</a>）：</p>
<ul>
<ul>
<li>Q1.f.attrs[‘nb_layers’]是什么意思？我看h5py中没有’nb_layers’的属性啊？attrs是指向f中的属性，点击右键可以看见这个属性（在HDF5-viewer）</li>
<li>Q2.g= f[‘layer_{}’.format(k)]的含义,.format的作用&nbsp;<br>format是格式化的意思，输出g就是format（k）填充到{}上</li>
<li>Q3.weights = [g[‘param_{}’.format(p)] for p&nbsp;<br>inrange(g.attrs[‘nb_params’])]的含义 得到的是layer下param_0、param_1等&nbsp;<br>这里用到的是set_weights(weights),weights设置的大小应与该层网络大小一致，否则会报错。</li>



</ul>


</ul>
<p>&nbsp;</p></div>]]></description></item><item><title>keras系列︱Sequential与Model模型、keras基本结构功能（一）</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/07/11146719.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 07 Jul 2019 08:45:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/07/11146719.html</guid><description><![CDATA[<div class="blogpost-body" id="cnblogs_post_body"><p>引自：<a href="http://blog.csdn.net/sinat_26917383/article/details/72857454" target="_blank">http://blog.csdn.net/sinat_26917383/article/details/72857454</a></p>
<p>&nbsp;</p>
<p>中文文档：<a href="http://keras-cn.readthedocs.io/en/latest/" target="_blank">http://keras-cn.readthedocs.io/en/latest/</a>&nbsp;<br>官方文档：<a href="https://keras.io/" target="_blank">https://keras.io/</a>&nbsp;<br>文档主要是以keras2.0。</p>
<hr>
<p>.</p>
<h3 id="keras系列"><a name="t0"></a>Keras系列：</h3>
<p>1、<a href="https://www.cnblogs.com/peng8098/articles/11146719.html" target="_blank">keras系列︱Sequential与Model模型、keras基本结构功能（一）</a>&nbsp;<br>2、<a href="https://www.cnblogs.com/peng8098/articles/11146752.html" target="_blank">keras系列︱Application中五款已训练模型、VGG16框架（Sequential式、Model式）解读（二）</a>&nbsp;<br>3、<a href="https://www.cnblogs.com/peng8098/articles/11146766.html" target="_blank">keras系列︱图像多分类训练与利用bottleneck features进行微调（三）</a>&nbsp;<br>4、<a href="https://www.cnblogs.com/peng8098/articles/11146774.html" target="_blank">keras系列︱人脸表情分类与识别：opencv人脸检测+Keras情绪分类（四）</a>&nbsp;<br>5、<a href="https://www.cnblogs.com/peng8098/articles/11146779.html" target="_blank">keras系列︱迁移学习：利用InceptionV3进行fine-tuning及预测、完整案例（五）</a></p>
<hr>
<h2 id="零keras介绍与基本的模型保存"><a name="t1"></a>零、keras介绍与基本的模型保存</h2>
<p>写成了思维导图，便于观察与理解。</p>
<h3 id="1keras网络结构"><a name="t2"></a>1.keras网络结构</h3>
<p><img title="" alt="这里写图片描述" src="http://img.blog.csdn.net/20170604101316305?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMjY5MTczODM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<h3 id="2keras网络配置"><a name="t3"></a>2.keras网络配置</h3>
<p><img title="" alt="这里写图片描述" src="http://img.blog.csdn.net/20170604101328219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMjY5MTczODM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><br>其中回调函数callbacks应该是keras的精髓~</p>
<h3 id="3keras预处理功能"><a name="t4"></a>3.keras预处理功能</h3>
<p><img title="" alt="这里写图片描述" src="http://img.blog.csdn.net/20170604101335306?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMjY5MTczODM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<h3 id="4模型的节点信息提取"><a name="t5"></a>4、模型的节点信息提取</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># 节点信息提取</span>
config = model.get_config()  <span class="hljs-comment"><span class="hljs-comment"># 把model中的信息，solver.prototxt和train.prototxt信息提取出来</span>
model = Model.from_config(config)  <span class="hljs-comment"><span class="hljs-comment"># 还回去</span>
<span class="hljs-comment"><span class="hljs-comment"># or, for Sequential:</span>
model = Sequential.from_config(config) <span class="hljs-comment"><span class="hljs-comment"># 重构一个新的Model模型，用去其他训练，fine-tuning比较好用</span></span></span></span></span></span></code></pre>
<h3 id="5-模型概况查询包括权重查询"><a name="t6"></a>5、 模型概况查询（包括权重查询）</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># 1、模型概括打印</span>
model.summary()

<span class="hljs-comment"><span class="hljs-comment"># 2、返回代表模型的JSON字符串，仅包含网络结构，不包含权值。可以从JSON字符串中重构原模型：</span>
<span class="hljs-keyword"><span class="hljs-keyword">from</span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span> model_from_json

json_string = model.to_json()
model = model_from_json(json_string)

<span class="hljs-comment"><span class="hljs-comment"># 3、model.to_yaml：与model.to_json类似，同样可以从产生的YAML字符串中重构模型</span>
<span class="hljs-keyword"><span class="hljs-keyword">from</span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span> model_from_yaml

yaml_string = model.to_yaml()
model = model_from_yaml(yaml_string)

<span class="hljs-comment"><span class="hljs-comment"># 4、权重获取</span>
model.get_layer()      <span class="hljs-comment"><span class="hljs-comment">#依据层名或下标获得层对象</span>
model.get_weights()    <span class="hljs-comment"><span class="hljs-comment">#返回模型权重张量的列表，类型为numpy array</span>
model.set_weights()    <span class="hljs-comment"><span class="hljs-comment">#从numpy array里将权重载入给模型，要求数组具有与model.get_weights()相同的形状。</span>

<span class="hljs-comment"><span class="hljs-comment"># 查看model中Layer的信息</span>
model.layers 查看layer信息</span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h3 id="6模型保存与加载"><a name="t7"></a>6、模型保存与加载</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">model.save_weights(filepath)
<span class="hljs-comment"><span class="hljs-comment"># 将模型权重保存到指定路径，文件类型是HDF5（后缀是.h5）</span>

model.load_weights(filepath, by_name=<span class="hljs-keyword"><span class="hljs-keyword">False</span>)
<span class="hljs-comment"><span class="hljs-comment"># 从HDF5文件中加载权重到当前模型中, 默认情况下模型的结构将保持不变。</span>
<span class="hljs-comment"><span class="hljs-comment"># 如果想将权重载入不同的模型（有些层相同）中，则设置by_name=True，只有名字匹配的层才会载入权重</span></span></span></span></span></code>.</pre>
<h3 id="7如何在keras中设定gpu使用的大小"><a name="t8"></a>7、如何在keras中设定GPU使用的大小</h3>
<p>本节来源于：<a href="https://zhuanlan.zhihu.com/p/23250782" target="_blank">深度学习theano/tensorflow多显卡多人使用问题集</a>（参见：<a href="http://link.zhihu.com/?target=https://github.com/fchollet/keras/issues/1538" target="_blank">Limit the resource usage for tensorflow backend · Issue #1538 · fchollet/keras · GitHub</a>）&nbsp;<br>在使用keras时候会出现总是占满GPU显存的情况，可以通过重设backend的GPU占用情况来进行调节。</p>
<pre class="prettyprint"><code class="hljs avrasm has-numbering verilog"><span class="hljs-keyword">import</span> tensorflow as tf
from keras<span class="hljs-preprocessor"><span class="hljs-variable">.backend</span><span class="hljs-preprocessor"><span class="hljs-variable">.tensorflow_backend</span> <span class="hljs-keyword">import</span> set_session
<span class="hljs-keyword">config</span> = tf<span class="hljs-preprocessor"><span class="hljs-variable">.ConfigProto</span>()
<span class="hljs-keyword">config</span><span class="hljs-preprocessor"><span class="hljs-variable">.gpu_options</span><span class="hljs-preprocessor"><span class="hljs-variable">.per_process_gpu_memory_fraction</span> = <span class="hljs-number"><span class="hljs-number">0</span><span class="hljs-variable">.3</span>
set_session(tf<span class="hljs-preprocessor"><span class="hljs-variable">.Session</span>(<span class="hljs-keyword">config</span>=<span class="hljs-keyword">config</span>))</span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>需要注意的是，虽然代码或配置层面设置了对显存占用百分比阈值，但在实际运行中如果达到了这个阈值，程序有需要的话还是会突破这个阈值。换而言之如果跑在一个大数据集上还是会用到更多的显存。以上的显存限制仅仅为了在跑小数据集时避免对显存的浪费而已。（2017年2月20日补充）</p>
<h3 id="8更科学地模型训练与模型保存"><a name="t9"></a>8.更科学地模型训练与模型保存</h3>
<pre class="prettyprint"><code class="hljs php has-numbering">filepath = <span class="hljs-string"><span class="hljs-string">'model-ep{epoch:03d}-loss{loss:.3f}-val_loss{val_loss:.3f}.h5'</span>
checkpoint = ModelCheckpoint(filepath, monitor=<span class="hljs-string"><span class="hljs-string">'val_loss'</span>, verbose=<span class="hljs-number"><span class="hljs-number">1</span>, save_best_only=<span class="hljs-keyword"><span class="hljs-keyword">True</span>, mode=<span class="hljs-string"><span class="hljs-string">'min'</span>)
<span class="hljs-comment"><span class="hljs-comment"># fit model</span>
model.fit(x, y, epochs=<span class="hljs-number"><span class="hljs-number">20</span>, verbose=<span class="hljs-number"><span class="hljs-number">2</span>, callbacks=[checkpoint], validation_data=(x, y))</span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>save_best_only打开之后，会如下：</p>
<pre class="prettyprint"><code class="hljs http has-numbering"> <span class="hljs-attribute"><span class="hljs-attribute">ETA</span>: <span class="hljs-string">3s - loss: 0.5820Epoch 00017: val_loss did not improve</span></span></code></pre>
<p>&nbsp;</p>
<p>如果val_loss 提高了就会保存，没有提高就不会保存。</p>
<h3 id="9如何在keras中使用tensorboard"><a name="t10"></a>9.如何在keras中使用tensorboard</h3>
<pre class="prettyprint"><code class="hljs python has-numbering">    RUN = RUN + <span class="hljs-number"><span class="hljs-number">1</span> <span class="hljs-keyword"><span class="hljs-keyword">if</span> <span class="hljs-string"><span class="hljs-string">'RUN'</span> <span class="hljs-keyword"><span class="hljs-keyword">in</span> locals() <span class="hljs-keyword"><span class="hljs-keyword">else</span> <span class="hljs-number"><span class="hljs-number">1</span>   <span class="hljs-comment"><span class="hljs-comment"># locals() 函数会以字典类型返回当前位置的全部局部变量。</span>

    LOG_DIR = model_save_path + <span class="hljs-string"><span class="hljs-string">'/training_logs/run{}'</span>.format(RUN)
    LOG_FILE_PATH = LOG_DIR + <span class="hljs-string"><span class="hljs-string">'/checkpoint-{epoch:02d}-{val_loss:.4f}.hdf5'</span>   <span class="hljs-comment"><span class="hljs-comment"># 模型Log文件以及.h5模型文件存放地址</span>

    tensorboard = TensorBoard(log_dir=LOG_DIR, write_images=<span class="hljs-keyword"><span class="hljs-keyword">True</span>)
    checkpoint = ModelCheckpoint(filepath=LOG_FILE_PATH, monitor=<span class="hljs-string"><span class="hljs-string">'val_loss'</span>, verbose=<span class="hljs-number"><span class="hljs-number">1</span>, save_best_only=<span class="hljs-keyword"><span class="hljs-keyword">True</span>)
    early_stopping = EarlyStopping(monitor=<span class="hljs-string"><span class="hljs-string">'val_loss'</span>, patience=<span class="hljs-number"><span class="hljs-number">5</span>, verbose=<span class="hljs-number"><span class="hljs-number">1</span>)

    history = model.fit_generator(generator=gen.generate(<span class="hljs-keyword"><span class="hljs-keyword">True</span>), steps_per_epoch=int(gen.train_batches / <span class="hljs-number"><span class="hljs-number">4</span>),
                                  validation_data=gen.generate(<span class="hljs-keyword"><span class="hljs-keyword">False</span>), validation_steps=int(gen.val_batches / <span class="hljs-number"><span class="hljs-number">4</span>),
                                  epochs=EPOCHS, verbose=<span class="hljs-number"><span class="hljs-number">1</span>, callbacks=[tensorboard, checkpoint, early_stopping])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>都是在回调函数中起作用：</p>
<ul>
<li>
<p>EarlyStopping patience：当early&nbsp;<br>（1）stop被激活（如发现loss相比上一个epoch训练没有下降），则经过patience个epoch后停止训练。&nbsp;<br>（2）mode：‘auto’，‘min’，‘max’之一，在min模式下，如果检测值停止下降则中止训练。在max模式下，当检测值不再上升则停止训练。</p>








</li>
<li>
<p>模型检查点ModelCheckpoint&nbsp;&nbsp;<br>（1）save_best_only：当设置为True时，将只保存在验证集上性能最好的模型&nbsp;<br>（2） mode：‘auto’，‘min’，‘max’之一，在save_best_only=True时决定性能最佳模型的评判准则，例如，当监测值为val_acc时，模式应为max，当检测值为val_loss时，模式应为min。在auto模式下，评价准则由被监测值的名字自动推断。&nbsp;<br>（3）save_weights_only：若设置为True，则只保存模型权重，否则将保存整个模型（包括模型结构，配置信息等）&nbsp;<br>（4）period：CheckPoint之间的间隔的epoch数</p>








</li>
<li>可视化tensorboard write_images: 是否将模型权重以图片的形式可视化</li>








</ul>
<p>其他内容可参考<a href="https://keras-cn.readthedocs.io/en/latest/other/callbacks/#tensorboard" target="_blank">keras中文文档</a></p>
<p>.</p>
<hr>
<h2 id="一sequential-序贯模型"><a name="t11"></a>一、Sequential 序贯模型</h2>
<p>序贯模型是函数式模型的简略版，为最简单的线性、从头到尾的结构顺序，不分叉。</p>
<h3 id="sequential模型的基本组件"><a name="t12"></a>Sequential模型的基本组件</h3>
<p>一般需要：</p>
<ul>
<li>1、model.add，添加层；</li>
<li>2、model.compile,模型训练的BP模式设置；</li>
<li>3、model.fit，模型训练参数设置 + 训练；</li>
<li>4、模型评估</li>
<li>5、模型预测</li>








</ul>
<h4 id="1-add添加层trainvalprototxt">1. add：添加层——train_val.prototxt</h4>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">add(self, layer)

<span class="hljs-comment"><span class="hljs-comment"># 譬如：</span>
model.add(Dense(<span class="hljs-number"><span class="hljs-number">32</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, input_dim=<span class="hljs-number"><span class="hljs-number">100</span>))
model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span>))</span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>add里面只有层layer的内容，当然在序贯式里面，也可以model.add（other_model）加载另外模型，在函数式里面就不太一样，详见函数式。</p>
<h4 id="2compile-训练模式solverprototxt文件">2、compile 训练模式——solver.prototxt文件</h4>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">compile(self, optimizer, loss, metrics=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, sample_weight_mode=<span class="hljs-keyword"><span class="hljs-keyword">None</span>)</span></span></code></pre>
<p>&nbsp;</p>
<p>其中：&nbsp;<br>optimizer： 字符串（预定义优化器名）或优化器对象，参考优化器&nbsp;<br>loss： 字符串（预定义损失函数名）或目标函数，参考损失函数&nbsp;<br>metrics： 列表，包含评估模型在训练和测试时的网络性能的指标，典型用法是metrics=[‘accuracy’]&nbsp;<br>sample_weight_mode：如果你需要按时间步为样本赋权（2D权矩阵），将该值设为“temporal”。&nbsp;<br>默认为“None”，代表按样本赋权（1D权）。在下面fit函数的解释中有相关的参考内容。&nbsp;<br>kwargs： 使用TensorFlow作为后端请忽略该参数，若使用Theano作为后端，kwargs的值将会传递给 K.function</p>
<p>注意：&nbsp;<br>模型在使用前必须编译，否则在调用fit或evaluate时会抛出异常。</p>
<h4 id="3fit-模型训练参数训练trainshsolerprototxt部分">3、fit 模型训练参数+训练——train.sh+soler.prototxt（部分）</h4>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">fit(self, x, y, batch_size=<span class="hljs-number"><span class="hljs-number">32</span>, epochs=<span class="hljs-number"><span class="hljs-number">10</span>, verbose=<span class="hljs-number"><span class="hljs-number">1</span>, callbacks=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, validation_split=<span class="hljs-number"><span class="hljs-number">0.0</span>, validation_data=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, shuffle=<span class="hljs-keyword"><span class="hljs-keyword">True</span>, class_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, sample_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, initial_epoch=<span class="hljs-number"><span class="hljs-number">0</span>)</span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>本函数将模型训练nb_epoch轮，其参数有：</p>
<ul>
<li>x：输入数据。如果模型只有一个输入，那么x的类型是numpy&nbsp;<br>array，如果模型有多个输入，那么x的类型应当为list，list的元素是对应于各个输入的numpy array</li>
<li>y：标签，numpy array</li>
<li>batch_size：整数，指定进行梯度下降时每个batch包含的样本数。训练时一个batch的样本会被计算一次梯度下降，使目标函数优化一步。</li>
<li>epochs：整数，训练的轮数，每个epoch会把训练集轮一遍。</li>
<li>verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</li>
<li>callbacks：list，其中的元素是keras.callbacks.Callback的对象。这个list中的回调函数将会在训练过程中的适当时机被调用，参考回调函数</li>
<li>validation_split：0~1之间的浮点数，用来指定训练集的一定比例数据作为验证集。验证集将不参与训练，并在每个epoch结束后测试的模型的指标，如损失函数、精确度等。注意，validation_split的划分在shuffle之前，因此如果你的数据本身是有序的，需要先手工打乱再指定validation_split，否则可能会出现验证集样本不均匀。</li>
<li>validation_data：形式为（X，y）的tuple，是指定的验证集。此参数将覆盖validation_spilt。</li>
<li>shuffle：布尔值或字符串，一般为布尔值，表示是否在训练过程中随机打乱输入样本的顺序。若为字符串“batch”，则是用来处理HDF5数据的特殊情况，它将在batch内部将数据打乱。</li>
<li>class_weight：字典，将不同的类别映射为不同的权值，该参数用来在训练过程中调整损失函数（只能用于训练）</li>
<li>sample_weight：权值的numpy&nbsp;<br>array，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（samples，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加了sample_weight_mode=’temporal’。</li>
<li>initial_epoch: 从该参数指定的epoch开始训练，在继续之前的训练时有用。</li>








</ul>
<p>fit函数返回一个History的对象，其History.history属性记录了损失函数和其他指标的数值随epoch变化的情况，如果有验证集的话，也包含了验证集的这些指标变化情况&nbsp;<br><strong>注意：</strong>&nbsp;<br>要与之后的fit_generator做区别，两者输入x/y不同。</p>
<h4 id="4evaluate-模型评估">4.evaluate 模型评估</h4>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">evaluate(self, x, y, batch_size=<span class="hljs-number"><span class="hljs-number">32</span>, verbose=<span class="hljs-number"><span class="hljs-number">1</span>, sample_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span>)</span></span></span></code></pre>
<p>&nbsp;</p>
<p>本函数按batch计算在某些输入数据上模型的误差，其参数有：</p>
<ul>
<li>x：输入数据，与fit一样，是numpy array或numpy array的list</li>
<li>y：标签，numpy array</li>
<li>batch_size：整数，含义同fit的同名参数</li>
<li>verbose：含义同fit的同名参数，但只能取0或1</li>
<li>sample_weight：numpy array，含义同fit的同名参数</li>
</ul>
<p>本函数返回一个测试误差的标量值（如果模型没有其他评价指标），或一个标量的list（如果模型还有其他的评价指标）。model.metrics_names将给出list中各个值的含义。</p>
<p>如果没有特殊说明，以下函数的参数均保持与fit的同名参数相同的含义&nbsp;<br>如果没有特殊说明，以下函数的verbose参数（如果有）均只能取0或1</p>
<h4 id="5-predict-模型评估">5 predict 模型评估</h4>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">predict(self, x, batch_size=<span class="hljs-number"><span class="hljs-number">32</span>, verbose=<span class="hljs-number"><span class="hljs-number">0</span>)
predict_classes(self, x, batch_size=<span class="hljs-number"><span class="hljs-number">32</span>, verbose=<span class="hljs-number"><span class="hljs-number">1</span>)
predict_proba(self, x, batch_size=<span class="hljs-number"><span class="hljs-number">32</span>, verbose=<span class="hljs-number"><span class="hljs-number">1</span>)</span></span></span></span></span></span></code></pre>
<p>本函数按batch获得输入数据对应的输出，其参数有：</p>
<p>函数的返回值是预测值的numpy array&nbsp;<br>predict_classes：本函数按batch产生输入数据的类别预测结果；&nbsp;<br>predict_proba：本函数按batch产生输入数据属于各个类别的概率</p>
<h4 id="6-onbatch-batch的结果检查">6 on_batch 、batch的结果，检查</h4>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">train_on_batch(self, x, y, class_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, sample_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span>)
test_on_batch(self, x, y, sample_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span>)
predict_on_batch(self, x)</span></span></span></code></pre>
<ul>
<li>train_on_batch：本函数在一个batch的数据上进行一次参数更新，函数返回训练误差的标量值或标量值的list，与evaluate的情形相同。</li>
<li>test_on_batch：本函数在一个batch的样本上对模型进行评估，函数的返回与evaluate的情形相同</li>
<li>predict_on_batch：本函数在一个batch的样本上对模型进行测试，函数返回模型在一个batch上的预测结果</li>
</ul>
<h4 id="7-fitgenerator">7 fit_generator</h4>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment">#利用Python的生成器，逐个生成数据的batch并进行训练。</span>
<span class="hljs-comment"><span class="hljs-comment">#生成器与模型将并行执行以提高效率。</span>
<span class="hljs-comment"><span class="hljs-comment">#例如，该函数允许我们在CPU上进行实时的数据提升，同时在GPU上进行模型训练</span>
<span class="hljs-comment"><span class="hljs-comment"># 参考链接：http://keras-cn.readthedocs.io/en/latest/models/sequential/</span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>有了该函数，图像分类训练任务变得很简单。</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">fit_generator(self, generator, steps_per_epoch, epochs=<span class="hljs-number"><span class="hljs-number">1</span>, verbose=<span class="hljs-number"><span class="hljs-number">1</span>, callbacks=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, validation_data=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, validation_steps=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, class_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, max_q_size=<span class="hljs-number"><span class="hljs-number">10</span>, workers=<span class="hljs-number"><span class="hljs-number">1</span>, pickle_safe=<span class="hljs-keyword"><span class="hljs-keyword">False</span>, initial_epoch=<span class="hljs-number"><span class="hljs-number">0</span>)

<span class="hljs-comment"><span class="hljs-comment"># 案例：</span>
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_arrays_from_file</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path)</span>:</span>
    <span class="hljs-keyword"><span class="hljs-keyword">while</span> <span class="hljs-number"><span class="hljs-number">1</span>:
            f = open(path)
            <span class="hljs-keyword"><span class="hljs-keyword">for</span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span> f:
                <span class="hljs-comment"><span class="hljs-comment"># create Numpy arrays of input data</span>
                <span class="hljs-comment"><span class="hljs-comment"># and labels, from each line in the file</span>
                x, y = process_line(line)
                <span class="hljs-keyword"><span class="hljs-keyword">yield</span> (x, y)
        f.close()

model.fit_generator(generate_arrays_from_file(<span class="hljs-string"><span class="hljs-string">'/my_file.txt'</span>),
        samples_per_epoch=<span class="hljs-number"><span class="hljs-number">10000</span>, epochs=<span class="hljs-number"><span class="hljs-number">10</span>)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>其他的两个辅助的内容：</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">evaluate_generator(self, generator, steps, max_q_size=<span class="hljs-number"><span class="hljs-number">10</span>, workers=<span class="hljs-number"><span class="hljs-number">1</span>, pickle_safe=<span class="hljs-keyword"><span class="hljs-keyword">False</span>)
predict_generator(self, generator, steps, max_q_size=<span class="hljs-number"><span class="hljs-number">10</span>, workers=<span class="hljs-number"><span class="hljs-number">1</span>, pickle_safe=<span class="hljs-keyword"><span class="hljs-keyword">False</span>, verbose=<span class="hljs-number"><span class="hljs-number">0</span>)</span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>evaluate_generator：本函数使用一个生成器作为数据源评估模型，生成器应返回与test_on_batch的输入数据相同类型的数据。该函数的参数与fit_generator同名参数含义相同，steps是生成器要返回数据的轮数。&nbsp;<br>predcit_generator：本函数使用一个生成器作为数据源预测模型，生成器应返回与test_on_batch的输入数据相同类型的数据。该函数的参数与fit_generator同名参数含义相同，steps是生成器要返回数据的轮数。</p>
<h3 id="案例一简单的2分类"><a name="t13"></a>案例一：简单的2分类</h3>
<p>For a single-input model with 2 classes (binary classification):</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Dense, Activation</span></span></span></span></code></pre>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment">#模型搭建阶段</span>
model= Sequential()
model.add(Dense(<span class="hljs-number"><span class="hljs-number">32</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, input_dim=<span class="hljs-number"><span class="hljs-number">100</span>))
<span class="hljs-comment"><span class="hljs-comment"># Dense(32) is a fully-connected layer with 32 hidden units.</span>
model.add(Dense(<span class="hljs-number"><span class="hljs-number">1</span>, activation=<span class="hljs-string"><span class="hljs-string">'sigmoid'</span>))
model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">'rmsprop'</span>,
              loss=<span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span>,
              metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span>])</span></span></span></span></span></span></span></span></span></span></code></pre>
<p>其中：&nbsp;<br>Sequential()代表类的初始化；&nbsp;<br>Dense代表全连接层，此时有32个全连接层，最后接relu，输入的是100维度&nbsp;<br>model.add，添加新的全连接层，&nbsp;<br>compile，跟prototxt一样，一些训练参数,solver.prototxt</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># Generate dummy data</span>
<span class="hljs-keyword"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span> np
data = np.random.random((<span class="hljs-number"><span class="hljs-number">1000</span>, <span class="hljs-number"><span class="hljs-number">100</span>))
labels = np.random.randint(<span class="hljs-number"><span class="hljs-number">2</span>, size=(<span class="hljs-number"><span class="hljs-number">1000</span>, <span class="hljs-number"><span class="hljs-number">1</span>))

<span class="hljs-comment"><span class="hljs-comment"># Train the model, iterating on the data in batches of 32 samples</span>
model.fit(data, labels, nb_epoch =<span class="hljs-number"><span class="hljs-number">10</span>, batch_size=<span class="hljs-number"><span class="hljs-number">32</span>)</span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>之前报过这样的错误，是因为版本的问题。 版本1.2里面是nb_epoch ，而keras2.0是epochs = 10</p>
<pre class="prettyprint"><code class="hljs javascript has-numbering"> error:
    <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span>: Received unknown keyword <span class="hljs-built_in"><span class="hljs-built_in">arguments</span>: {<span class="hljs-string"><span class="hljs-string">'epochs'</span>: <span class="hljs-number"><span class="hljs-number">10</span>}</span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>其中：&nbsp;<br>epoch=batch_size * iteration,10次epoch代表训练十次训练集</p>
<p>最终代码是基于keras ==1.2</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="javascript:void(0);"><img alt="复制代码" src="//common.cnblogs.com/images/copycode.gif"></a></span></div>
<pre># -*- coding:utf-<span style="color: #800080;">8</span> -*-

<span style="color: #0000ff;">from</span><span style="color: #000000;"> keras.models import Sequential
</span><span style="color: #0000ff;">from</span><span style="color: #000000;"> keras.layers import Dense, Activation

#模型搭建阶段
model</span>=<span style="color: #000000;"> Sequential()#最简单的线性、从头到尾的结构顺序，不分叉
model.add(Dense(</span><span style="color: #800080;">32</span>, activation=<span style="color: #800000;">'</span><span style="color: #800000;">relu</span><span style="color: #800000;">'</span>, input_dim=<span style="color: #800080;">100</span><span style="color: #000000;">))
# Dense(</span><span style="color: #800080;">32</span>) <span style="color: #0000ff;">is</span> a fully-connected layer with <span style="color: #800080;">32</span><span style="color: #000000;"> hidden units.
model.add(Dense(</span><span style="color: #800080;">1</span>, activation=<span style="color: #800000;">'</span><span style="color: #800000;">sigmoid</span><span style="color: #800000;">'</span><span style="color: #000000;">))
model.compile(optimizer</span>=<span style="color: #800000;">'</span><span style="color: #800000;">rmsprop</span><span style="color: #800000;">'</span><span style="color: #000000;">,
              loss</span>=<span style="color: #800000;">'</span><span style="color: #800000;">binary_crossentropy</span><span style="color: #800000;">'</span><span style="color: #000000;">,
              metrics</span>=[<span style="color: #800000;">'</span><span style="color: #800000;">accuracy</span><span style="color: #800000;">'</span><span style="color: #000000;">])

# Generate dummy data
import numpy </span><span style="color: #0000ff;">as</span><span style="color: #000000;"> np
data </span>= np.random.random((<span style="color: #800080;">1000</span>, <span style="color: #800080;">100</span><span style="color: #000000;">))
labels </span>= np.random.randint(<span style="color: #800080;">2</span>, size=(<span style="color: #800080;">1000</span>, <span style="color: #800080;">1</span><span style="color: #000000;">))

# Train the model, iterating on the data </span><span style="color: #0000ff;">in</span> batches of <span style="color: #800080;">32</span><span style="color: #000000;"> samples
model.fit(data, labels, nb_epoch </span>=<span style="color: #800080;">10</span>, batch_size=<span style="color: #800080;">32</span>)</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="javascript:void(0);"><img alt="复制代码" src="//common.cnblogs.com/images/copycode.gif"></a></span></div></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="案例二多分类-vgg的卷积神经网络"><a name="t14"></a>案例二:多分类-VGG的卷积神经网络</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span> np
<span class="hljs-keyword"><span class="hljs-keyword">import</span> keras
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Dense, Dropout, Flatten
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Conv2D, MaxPooling2D
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.optimizers <span class="hljs-keyword"><span class="hljs-keyword">import</span> SGD
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.utils <span class="hljs-keyword"><span class="hljs-keyword">import</span> np_utils

<span class="hljs-comment"><span class="hljs-comment"># Generate dummy data</span>
x_train = np.random.random((<span class="hljs-number"><span class="hljs-number">100</span>, <span class="hljs-number"><span class="hljs-number">100</span>, <span class="hljs-number"><span class="hljs-number">100</span>, <span class="hljs-number"><span class="hljs-number">3</span>))
<span class="hljs-comment"><span class="hljs-comment"># 100张图片，每张100*100*3</span>
y_train = keras.utils.to_categorical(np.random.randint(<span class="hljs-number"><span class="hljs-number">10</span>, size=(<span class="hljs-number"><span class="hljs-number">100</span>, <span class="hljs-number"><span class="hljs-number">1</span>)), num_classes=<span class="hljs-number"><span class="hljs-number">10</span>)
<span class="hljs-comment"><span class="hljs-comment"># 100*10</span>
x_test = np.random.random((<span class="hljs-number"><span class="hljs-number">20</span>, <span class="hljs-number"><span class="hljs-number">100</span>, <span class="hljs-number"><span class="hljs-number">100</span>, <span class="hljs-number"><span class="hljs-number">3</span>))
y_test = keras.utils.to_categorical(np.random.randint(<span class="hljs-number"><span class="hljs-number">10</span>, size=(<span class="hljs-number"><span class="hljs-number">20</span>, <span class="hljs-number"><span class="hljs-number">1</span>)), num_classes=<span class="hljs-number"><span class="hljs-number">10</span>)
<span class="hljs-comment"><span class="hljs-comment"># 20*100</span>

model = Sequential()
<span class="hljs-comment"><span class="hljs-comment"># input: 100x100 images with 3 channels -&gt; (100, 100, 3) tensors.</span>
<span class="hljs-comment"><span class="hljs-comment"># this applies 32 convolution filters of size 3x3 each.</span>
model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">32</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, input_shape=(<span class="hljs-number"><span class="hljs-number">100</span>, <span class="hljs-number"><span class="hljs-number">100</span>, <span class="hljs-number"><span class="hljs-number">3</span>)))
model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">32</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>))
model.add(MaxPooling2D(pool_size=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))
model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span>))

model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">64</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>))
model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">64</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>))
model.add(MaxPooling2D(pool_size=(<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))
model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span>))

model.add(Flatten())
model.add(Dense(<span class="hljs-number"><span class="hljs-number">256</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>))
model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.5</span>))
model.add(Dense(<span class="hljs-number"><span class="hljs-number">10</span>, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span>))

sgd = SGD(lr=<span class="hljs-number"><span class="hljs-number">0.01</span>, decay=<span class="hljs-number"><span class="hljs-number">1e-6</span>, momentum=<span class="hljs-number"><span class="hljs-number">0.9</span>, nesterov=<span class="hljs-keyword"><span class="hljs-keyword">True</span>)
model.compile(loss=<span class="hljs-string"><span class="hljs-string">'categorical_crossentropy'</span>, optimizer=sgd)

model.fit(x_train, y_train, batch_size=<span class="hljs-number"><span class="hljs-number">32</span>, epochs=<span class="hljs-number"><span class="hljs-number">10</span>)
score = model.evaluate(x_test, y_test, batch_size=<span class="hljs-number"><span class="hljs-number">32</span>)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>标准序贯网络，标签的训练模式&nbsp;<br><strong>注意：</strong>&nbsp;<br>这里非常重要的一点，对于我这样的新手，这一步的作用？</p>
<pre class="prettyprint"><code class="hljs avrasm has-numbering css"><span class="hljs-selector-tag">keras</span><span class="hljs-preprocessor"><span class="hljs-selector-class">.utils</span><span class="hljs-preprocessor"><span class="hljs-selector-class">.to_categorical</span></span></span></code></pre>
<p>&nbsp;</p>
<p>特别是多分类时候，我之前以为输入的就是一列（100，），但是keras在多分类任务中是不认得这个的，所以需要再加上这一步，让其转化为Keras认得的数据格式。</p>
<p>&nbsp;</p>
<p>最终代码基于Keras==2.0</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="javascript:void(0);"><img alt="复制代码" src="//common.cnblogs.com/images/copycode.gif"></a></span></div>
<pre># -*- coding:utf-<span style="color: #800080;">8</span> -*-<span style="color: #000000;">


import numpy </span><span style="color: #0000ff;">as</span><span style="color: #000000;"> np
import keras
</span><span style="color: #0000ff;">from</span><span style="color: #000000;"> keras.models import Sequential
</span><span style="color: #0000ff;">from</span><span style="color: #000000;"> keras.layers import Dense, Dropout, Flatten
</span><span style="color: #0000ff;">from</span><span style="color: #000000;"> keras.layers import Conv2D, MaxPooling2D
</span><span style="color: #0000ff;">from</span><span style="color: #000000;"> keras.optimizers import SGD
</span><span style="color: #0000ff;">from</span><span style="color: #000000;"> keras.utils import np_utils

# Generate dummy data
x_train </span>= np.random.random((<span style="color: #800080;">100</span>, <span style="color: #800080;">100</span>, <span style="color: #800080;">100</span>, <span style="color: #800080;">3</span><span style="color: #000000;">))
# 100张图片，每张100</span>*<span style="color: #800080;">100</span>*<span style="color: #800080;">3</span><span style="color: #000000;">
y_train </span>= keras.utils.to_categorical(np.random.randint(<span style="color: #800080;">10</span>, size=(<span style="color: #800080;">100</span>, <span style="color: #800080;">1</span>)), num_classes=<span style="color: #800080;">10</span><span style="color: #000000;">)
# </span><span style="color: #800080;">100</span>*<span style="color: #800080;">10</span><span style="color: #000000;">
x_test </span>= np.random.random((<span style="color: #800080;">20</span>, <span style="color: #800080;">100</span>, <span style="color: #800080;">100</span>, <span style="color: #800080;">3</span><span style="color: #000000;">))
y_test </span>= keras.utils.to_categorical(np.random.randint(<span style="color: #800080;">10</span>, size=(<span style="color: #800080;">20</span>, <span style="color: #800080;">1</span>)), num_classes=<span style="color: #800080;">10</span><span style="color: #000000;">)
# </span><span style="color: #800080;">20</span>*<span style="color: #800080;">100</span><span style="color: #000000;">

model </span>=<span style="color: #000000;"> Sequential()#最简单的线性、从头到尾的结构顺序，不分叉
# input: 10</span><span style="color: #800080;">0x100</span> images with <span style="color: #800080;">3</span> channels -&gt; (<span style="color: #800080;">100</span>, <span style="color: #800080;">100</span>, <span style="color: #800080;">3</span><span style="color: #000000;">) tensors.
# </span><span style="color: #0000ff;">this</span> applies <span style="color: #800080;">32</span><span style="color: #000000;"> convolution filters of size 3x3 each.
model.add(Conv2D(</span><span style="color: #800080;">32</span>, (<span style="color: #800080;">3</span>, <span style="color: #800080;">3</span>), activation=<span style="color: #800000;">'</span><span style="color: #800000;">relu</span><span style="color: #800000;">'</span>, input_shape=(<span style="color: #800080;">100</span>, <span style="color: #800080;">100</span>, <span style="color: #800080;">3</span><span style="color: #000000;">)))
model.add(Conv2D(</span><span style="color: #800080;">32</span>, (<span style="color: #800080;">3</span>, <span style="color: #800080;">3</span>), activation=<span style="color: #800000;">'</span><span style="color: #800000;">relu</span><span style="color: #800000;">'</span><span style="color: #000000;">))
model.add(MaxPooling2D(pool_size</span>=(<span style="color: #800080;">2</span>, <span style="color: #800080;">2</span><span style="color: #000000;">)))
model.add(Dropout(</span><span style="color: #800080;">0.25</span><span style="color: #000000;">))

model.add(Conv2D(</span><span style="color: #800080;">64</span>, (<span style="color: #800080;">3</span>, <span style="color: #800080;">3</span>), activation=<span style="color: #800000;">'</span><span style="color: #800000;">relu</span><span style="color: #800000;">'</span><span style="color: #000000;">))
model.add(Conv2D(</span><span style="color: #800080;">64</span>, (<span style="color: #800080;">3</span>, <span style="color: #800080;">3</span>), activation=<span style="color: #800000;">'</span><span style="color: #800000;">relu</span><span style="color: #800000;">'</span><span style="color: #000000;">))
model.add(MaxPooling2D(pool_size</span>=(<span style="color: #800080;">2</span>, <span style="color: #800080;">2</span><span style="color: #000000;">)))
model.add(Dropout(</span><span style="color: #800080;">0.25</span><span style="color: #000000;">))

model.add(Flatten())
model.add(Dense(</span><span style="color: #800080;">256</span>, activation=<span style="color: #800000;">'</span><span style="color: #800000;">relu</span><span style="color: #800000;">'</span><span style="color: #000000;">))
model.add(Dropout(</span><span style="color: #800080;">0.5</span><span style="color: #000000;">))
model.add(Dense(</span><span style="color: #800080;">10</span>, activation=<span style="color: #800000;">'</span><span style="color: #800000;">softmax</span><span style="color: #800000;">'</span><span style="color: #000000;">))

sgd </span>= SGD(lr=<span style="color: #800080;">0.01</span>, decay=1e-<span style="color: #800080;">6</span>, momentum=<span style="color: #800080;">0.9</span>, nesterov=<span style="color: #000000;">True)
model.compile(loss</span>=<span style="color: #800000;">'</span><span style="color: #800000;">categorical_crossentropy</span><span style="color: #800000;">'</span>, optimizer=<span style="color: #000000;">sgd)

model.fit(x_train, y_train, batch_size</span>=<span style="color: #800080;">32</span>, epochs=<span style="color: #800080;">10</span><span style="color: #000000;">)
score </span>= model.evaluate(x_test, y_test, batch_size=<span style="color: #800080;">32</span>)</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="javascript:void(0);"><img alt="复制代码" src="//common.cnblogs.com/images/copycode.gif"></a></span></div></div>
<p>&nbsp;</p>
<h3 id="案例三使用lstm的序列分类"><a name="t15"></a>案例三：使用LSTM的序列分类</h3>
<pre class="prettyprint"><span style="font-family: monospace;"><a href="https://www.cnblogs.com/arkenstone/p/5794063.html" target="_blank">具体的专门有链接来写：</a><br><br></span></pre>
<p>.</p>
<hr>
<h2 id="三model式模型"><a name="t16"></a>三、Model式模型</h2>
<p>来自keras中文文档：<a href="http://keras-cn.readthedocs.io/en/latest/" target="_blank">http://keras-cn.readthedocs.io/en/latest/</a>&nbsp;<br>比序贯模型要复杂，但是效果很好，可以同时/分阶段输入变量，分阶段输出想要的模型；&nbsp;<br>一句话，只要你的模型不是类似VGG一样一条路走到黑的模型，或者你的模型需要多于一个的输出，那么你总应该选择函数式模型。</p>
<p>不同之处：&nbsp;<br>书写结构完全不一致</p>
<h2 id="函数式模型基本属性与训练流程"><a name="t17"></a>函数式模型基本属性与训练流程</h2>
<p>一般需要：&nbsp;<br>1、model.layers，添加层信息；&nbsp;&nbsp;<br>2、model.compile,模型训练的BP模式设置；&nbsp;<br>3、model.fit，模型训练参数设置 + 训练；&nbsp;<br>4、evaluate，模型评估；&nbsp;<br>5、predict 模型预测</p>
<h3 id="1-常用model属性"><a name="t18"></a>1 常用Model属性</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">model.layers：组成模型图的各个层
model.inputs：模型的输入张量列表
model.outputs：模型的输出张量列表</code></pre>
<p>&nbsp;</p>
<h3 id="2-compile-训练模式设置solverprototxt"><a name="t19"></a>2 compile 训练模式设置——solver.prototxt</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">compile(self, optimizer, loss, metrics=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, loss_weights=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, sample_weight_mode=<span class="hljs-keyword"><span class="hljs-keyword">None</span>)</span></span></span></code></pre>
<p>&nbsp;</p>
<p>本函数编译模型以供训练，参数有</p>
<p>optimizer：优化器，为预定义优化器名或优化器对象，参考优化器&nbsp;<br>loss：损失函数，为预定义损失函数名或一个目标函数，参考损失函数&nbsp;<br>metrics：列表，包含评估模型在训练和测试时的性能的指标，典型用法是metrics=[‘accuracy’]如果要在多输出模型中为不同的输出指定不同的指标，可像该参数传递一个字典，例如metrics={‘ouput_a’: ‘accuracy’}&nbsp;<br>sample_weight_mode：如果你需要按时间步为样本赋权（2D权矩阵），将该值设为“temporal”。默认为“None”，代表按样本赋权（1D权）。&nbsp;<br>如果模型有多个输出，可以向该参数传入指定sample_weight_mode的字典或列表。在下面fit函数的解释中有相关的参考内容。</p>
<p>【Tips】如果你只是载入模型并利用其predict，可以不用进行compile。在Keras中，compile主要完成损失函数和优化器的一些配置，是为训练服务的。predict会在内部进行符号函数的编译工作（通过调用_make_predict_function生成函数）</p>
<h3 id="3-fit-模型训练参数设置-训练"><a name="t20"></a>3 fit 模型训练参数设置 + 训练</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">fit(self, x=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, y=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, batch_size=<span class="hljs-number"><span class="hljs-number">32</span>, epochs=<span class="hljs-number"><span class="hljs-number">1</span>, verbose=<span class="hljs-number"><span class="hljs-number">1</span>, callbacks=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, validation_split=<span class="hljs-number"><span class="hljs-number">0.0</span>, validation_data=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, shuffle=<span class="hljs-keyword"><span class="hljs-keyword">True</span>, class_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, sample_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, initial_epoch=<span class="hljs-number"><span class="hljs-number">0</span>)</span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>本函数用以训练模型，参数有：</p>
<ul>
<li>x：输入数据。如果模型只有一个输入，那么x的类型是numpy&nbsp;<br>array，如果模型有多个输入，那么x的类型应当为list，list的元素是对应于各个输入的numpy&nbsp;<br>array。如果模型的每个输入都有名字，则可以传入一个字典，将输入名与其输入数据对应起来。</li>
<li>y：标签，numpy array。如果模型有多个输出，可以传入一个numpy&nbsp;<br>array的list。如果模型的输出拥有名字，则可以传入一个字典，将输出名与其标签对应起来。</li>
<li>batch_size：整数，指定进行梯度下降时每个batch包含的样本数。训练时一个batch的样本会被计算一次梯度下降，使目标函数优化一步。</li>
<li>nb_epoch：整数，训练的轮数，训练数据将会被遍历nb_epoch次。Keras中nb开头的变量均为”number of”的意思</li>
<li>verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</li>
<li>callbacks：list，其中的元素是keras.callbacks.Callback的对象。这个list中的回调函数将会在训练过程中的适当时机被调用，参考回调函数</li>
<li>validation_split：0~1之间的浮点数，用来指定训练集的一定比例数据作为验证集。验证集将不参与训练，并在每个epoch结束后测试的模型的指标，如损失函数、精确度等。注意，validation_split的划分在shuffle之后，因此如果你的数据本身是有序的，需要先手工打乱再指定validation_split，否则可能会出现验证集样本不均匀。</li>
<li>validation_data：形式为（X，y）或（X，y，sample_weights）的tuple，是指定的验证集。此参数将覆盖validation_spilt。</li>
<li>shuffle：布尔值，表示是否在训练过程中每个epoch前随机打乱输入样本的顺序。</li>
<li>class_weight：字典，将不同的类别映射为不同的权值，该参数用来在训练过程中调整损失函数（只能用于训练）。该参数在处理非平衡的训练数据（某些类的训练样本数很少）时，可以使得损失函数对样本数不足的数据更加关注。</li>
<li>sample_weight：权值的numpy&nbsp;<br>array，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（samples，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加了sample_weight_mode=’temporal’。</li>
<li>initial_epoch: 从该参数指定的epoch开始训练，在继续之前的训练时有用。</li>








</ul>
<p>输入数据与规定数据不匹配时会抛出错误</p>
<p>fit函数返回一个History的对象，其History.history属性记录了损失函数和其他指标的数值随epoch变化的情况，如果有验证集的话，也包含了验证集的这些指标变化情况</p>
<h3 id="4evaluate模型评估"><a name="t21"></a>4.evaluate，模型评估</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">evaluate(self, x, y, batch_size=<span class="hljs-number"><span class="hljs-number">32</span>, verbose=<span class="hljs-number"><span class="hljs-number">1</span>, sample_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span>)</span></span></span></code></pre>
<p>&nbsp;</p>
<p>本函数按batch计算在某些输入数据上模型的误差，其参数有：</p>
<ul>
<li>x：输入数据，与fit一样，是numpy array或numpy array的list</li>
<li>y：标签，numpy array</li>
<li>batch_size：整数，含义同fit的同名参数</li>
<li>verbose：含义同fit的同名参数，但只能取0或1</li>
<li>sample_weight：numpy array，含义同fit的同名参数</li>
</ul>
<p>本函数返回一个测试误差的标量值（如果模型没有其他评价指标），或一个标量的list（如果模型还有其他的评价指标）。model.metrics_names将给出list中各个值的含义。</p>
<p>如果没有特殊说明，以下函数的参数均保持与fit的同名参数相同的含义&nbsp;<br>如果没有特殊说明，以下函数的verbose参数（如果有）均只能取0或1</p>
<h3 id="5predict-模型预测"><a name="t22"></a>5.predict 模型预测</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">predict(self, x, batch_size=<span class="hljs-number"><span class="hljs-number">32</span>, verbose=<span class="hljs-number"><span class="hljs-number">0</span>)
</span></span></code></pre>
<p>&nbsp;</p>
<p>本函数按batch获得输入数据对应的输出，其参数有：</p>
<p>函数的返回值是预测值的numpy array</p>
<h3 id="模型检查-onbatch"><a name="t23"></a>模型检查 on_batch</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">train_on_batch(self, x, y, class_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, sample_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span>)
test_on_batch(self, x, y, sample_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span>)
predict_on_batch(self, x)</span></span></span></code></pre>
<p>train_on_batch：本函数在一个batch的数据上进行一次参数更新，函数返回训练误差的标量值或标量值的list，与evaluate的情形相同。&nbsp;</p>
<p>test_on_batch：本函数在一个batch的样本上对模型进行评估，函数的返回与evaluate的情形相同；&nbsp;<br>predict_on_batch：本函数在一个batch的样本上对模型进行测试，函数返回模型在一个batch上的预测结果</p>
<h3 id="generator"><a name="t24"></a>_generator</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">fit_generator(self, generator, steps_per_epoch, epochs=<span class="hljs-number"><span class="hljs-number">1</span>, verbose=<span class="hljs-number"><span class="hljs-number">1</span>, callbacks=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, validation_data=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, validation_steps=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, class_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span>, max_q_size=<span class="hljs-number"><span class="hljs-number">10</span>, workers=<span class="hljs-number"><span class="hljs-number">1</span>, pickle_safe=<span class="hljs-keyword"><span class="hljs-keyword">False</span>, initial_epoch=<span class="hljs-number"><span class="hljs-number">0</span>)
evaluate_generator(self, generator, steps, max_q_size=<span class="hljs-number"><span class="hljs-number">10</span>, workers=<span class="hljs-number"><span class="hljs-number">1</span>, pickle_safe=<span class="hljs-keyword"><span class="hljs-keyword">False</span>)</span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<h3 id="案例一简单的单层-全连接网络"><a name="t25"></a>案例一：简单的单层-全连接网络</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Input, Dense
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> Model

<span class="hljs-comment"><span class="hljs-comment"># This returns a tensor</span>
inputs = Input(shape=(<span class="hljs-number"><span class="hljs-number">784</span>,))

<span class="hljs-comment"><span class="hljs-comment"># a layer instance is callable on a tensor, and returns a tensor</span>
x = Dense(<span class="hljs-number"><span class="hljs-number">64</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>)(inputs)
<span class="hljs-comment"><span class="hljs-comment"># 输入inputs，输出x</span>
<span class="hljs-comment"><span class="hljs-comment"># (inputs)代表输入</span>
x = Dense(<span class="hljs-number"><span class="hljs-number">64</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>)(x)
<span class="hljs-comment"><span class="hljs-comment"># 输入x，输出x</span>
predictions = Dense(<span class="hljs-number"><span class="hljs-number">10</span>, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span>)(x)
<span class="hljs-comment"><span class="hljs-comment"># 输入x，输出分类</span>

<span class="hljs-comment"><span class="hljs-comment"># This creates a model that includes</span>
<span class="hljs-comment"><span class="hljs-comment"># the Input layer and three Dense layers</span>
model = Model(inputs=inputs, outputs=predictions)
model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">'rmsprop'</span>,
              loss=<span class="hljs-string"><span class="hljs-string">'categorical_crossentropy'</span>,
              metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span>])
model.fit(data, labels)  <span class="hljs-comment"><span class="hljs-comment"># starts training</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>其中：&nbsp;<br>可以看到结构与序贯模型完全不一样，其中x = Dense(64, activation=’relu’)(inputs)中：(input)代表输入；x代表输出&nbsp;<br>model = Model(inputs=inputs, outputs=predictions)；该句是函数式模型的经典，可以同时输入两个input，然后输出output两个模型</p>
<h3 id="案例二视频处理"><a name="t26"></a>案例二：视频处理</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering">x = Input(shape=(<span class="hljs-number"><span class="hljs-number">784</span>,))
<span class="hljs-comment"><span class="hljs-comment"># This works, and returns the 10-way softmax we defined above.</span>
y = model(x)
<span class="hljs-comment"><span class="hljs-comment"># model里面存着权重，然后输入x，输出结果，用来作fine-tuning</span>

<span class="hljs-comment"><span class="hljs-comment"># 分类-&gt;视频、实时处理</span>
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> TimeDistributed

<span class="hljs-comment"><span class="hljs-comment"># Input tensor for sequences of 20 timesteps,</span>
<span class="hljs-comment"><span class="hljs-comment"># each containing a 784-dimensional vector</span>
input_sequences = Input(shape=(<span class="hljs-number"><span class="hljs-number">20</span>, <span class="hljs-number"><span class="hljs-number">784</span>))
<span class="hljs-comment"><span class="hljs-comment"># 20个时间间隔，输入784维度的数据</span>

<span class="hljs-comment"><span class="hljs-comment"># This applies our previous model to every timestep in the input sequences.</span>
<span class="hljs-comment"><span class="hljs-comment"># the output of the previous model was a 10-way softmax,</span>
<span class="hljs-comment"><span class="hljs-comment"># so the output of the layer below will be a sequence of 20 vectors of size 10.</span>
processed_sequences = TimeDistributed(model)(input_sequences)
<span class="hljs-comment"><span class="hljs-comment"># Model是已经训练好的</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>其中：&nbsp;<br>Model是已经训练好的，现在用来做迁移学习；&nbsp;<br>其中还可以通过TimeDistributed来进行实时预测；&nbsp;<br>TimeDistributed(model)(input_sequences)，input_sequences代表序列输入；model代表已训练的模型</p>
<h3 id="案例三双输入双模型输出lstm-时序预测"><a name="t27"></a>案例三：双输入、双模型输出：LSTM 时序预测</h3>
<p>本案例很好，可以了解到Model的精髓在于他的任意性，给编译者很多的便利。</p>
<p>输入：&nbsp;<br>新闻语料；新闻语料对应的时间&nbsp;<br>输出：&nbsp;<br>新闻语料的预测模型；新闻语料+对应时间的预测模型&nbsp;<br><img title="" alt="这里写图片描述" src="http://keras-cn.readthedocs.io/en/latest/images/multi-input-multi-output-graph.png"></p>
<h4 id="模型一只针对新闻语料的lstm模型">模型一：只针对新闻语料的LSTM模型</h4>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Input, Embedding, LSTM, Dense
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> Model

<span class="hljs-comment"><span class="hljs-comment"># Headline input: meant to receive sequences of 100 integers, between 1 and 10000.</span>
<span class="hljs-comment"><span class="hljs-comment"># Note that we can name any layer by passing it a "name" argument.</span>
main_input = Input(shape=(<span class="hljs-number"><span class="hljs-number">100</span>,), dtype=<span class="hljs-string"><span class="hljs-string">'int32'</span>, name=<span class="hljs-string"><span class="hljs-string">'main_input'</span>)
<span class="hljs-comment"><span class="hljs-comment"># 一个100词的BOW序列</span>

<span class="hljs-comment"><span class="hljs-comment"># This embedding layer will encode the input sequence</span>
<span class="hljs-comment"><span class="hljs-comment"># into a sequence of dense 512-dimensional vectors.</span>
x = Embedding(output_dim=<span class="hljs-number"><span class="hljs-number">512</span>, input_dim=<span class="hljs-number"><span class="hljs-number">10000</span>, input_length=<span class="hljs-number"><span class="hljs-number">100</span>)(main_input)
<span class="hljs-comment"><span class="hljs-comment"># Embedding层，把100维度再encode成512的句向量，10000指的是词典单词总数</span>


<span class="hljs-comment"><span class="hljs-comment"># A LSTM will transform the vector sequence into a single vector,</span>
<span class="hljs-comment"><span class="hljs-comment"># containing information about the entire sequence</span>
lstm_out = LSTM(<span class="hljs-number"><span class="hljs-number">32</span>)(x)
<span class="hljs-comment"><span class="hljs-comment"># ？ 32什么意思？？？？？？？？？？？？？？？？？？？？？</span>

<span class="hljs-comment"><span class="hljs-comment">#然后，我们插入一个额外的损失，使得即使在主损失很高的情况下，LSTM和Embedding层也可以平滑的训练。</span>

auxiliary_output = Dense(<span class="hljs-number"><span class="hljs-number">1</span>, activation=<span class="hljs-string"><span class="hljs-string">'sigmoid'</span>, name=<span class="hljs-string"><span class="hljs-string">'aux_output'</span>)(lstm_out)
<span class="hljs-comment"><span class="hljs-comment">#再然后，我们将LSTM与额外的输入数据串联起来组成输入，送入模型中：</span>
<span class="hljs-comment"><span class="hljs-comment"># 模型一：只针对以上的序列做的预测模型</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<h4 id="组合模型新闻语料时序">组合模型：新闻语料+时序</h4>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># 模型二：组合模型</span>
auxiliary_input = Input(shape=(<span class="hljs-number"><span class="hljs-number">5</span>,), name=<span class="hljs-string"><span class="hljs-string">'aux_input'</span>)  <span class="hljs-comment"><span class="hljs-comment"># 新加入的一个Input,5维度</span>
x = keras.layers.concatenate([lstm_out, auxiliary_input])   <span class="hljs-comment"><span class="hljs-comment"># 组合起来，对应起来</span>


<span class="hljs-comment"><span class="hljs-comment"># We stack a deep densely-connected network on top</span>
<span class="hljs-comment"><span class="hljs-comment"># 组合模型的形式</span>
x = Dense(<span class="hljs-number"><span class="hljs-number">64</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>)(x)
x = Dense(<span class="hljs-number"><span class="hljs-number">64</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>)(x)
x = Dense(<span class="hljs-number"><span class="hljs-number">64</span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>)(x)
<span class="hljs-comment"><span class="hljs-comment"># And finally we add the main logistic regression layer</span>
main_output = Dense(<span class="hljs-number"><span class="hljs-number">1</span>, activation=<span class="hljs-string"><span class="hljs-string">'sigmoid'</span>, name=<span class="hljs-string"><span class="hljs-string">'main_output'</span>)(x)


<span class="hljs-comment"><span class="hljs-comment">#最后，我们定义整个2输入，2输出的模型：</span>
model = Model(inputs=[main_input, auxiliary_input], outputs=[main_output, auxiliary_output])
<span class="hljs-comment"><span class="hljs-comment">#模型定义完毕，下一步编译模型。</span>
<span class="hljs-comment"><span class="hljs-comment">#我们给额外的损失赋0.2的权重。我们可以通过关键字参数loss_weights或loss来为不同的输出设置不同的损失函数或权值。</span>
<span class="hljs-comment"><span class="hljs-comment">#这两个参数均可为Python的列表或字典。这里我们给loss传递单个损失函数，这个损失函数会被应用于所有输出上。</span>
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>其中：Model(inputs=[main_input, auxiliary_input], outputs=[main_output, auxiliary_output])是核心，&nbsp;<br>Input两个内容，outputs两个模型</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># 训练方式一：两个模型一个loss</span>
model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">'rmsprop'</span>, loss=<span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span>,
              loss_weights=[<span class="hljs-number"><span class="hljs-number">1.</span>, <span class="hljs-number"><span class="hljs-number">0.2</span>])
<span class="hljs-comment"><span class="hljs-comment">#编译完成后，我们通过传递训练数据和目标值训练该模型：</span>

model.fit([headline_data, additional_data], [labels, labels],
          epochs=<span class="hljs-number"><span class="hljs-number">50</span>, batch_size=<span class="hljs-number"><span class="hljs-number">32</span>)

<span class="hljs-comment"><span class="hljs-comment"># 训练方式二：两个模型,两个Loss</span>
<span class="hljs-comment"><span class="hljs-comment">#因为我们输入和输出是被命名过的（在定义时传递了“name”参数），我们也可以用下面的方式编译和训练模型：</span>
model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">'rmsprop'</span>,
              loss={<span class="hljs-string"><span class="hljs-string">'main_output'</span>: <span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span>, <span class="hljs-string"><span class="hljs-string">'aux_output'</span>: <span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span>},
              loss_weights={<span class="hljs-string"><span class="hljs-string">'main_output'</span>: <span class="hljs-number"><span class="hljs-number">1.</span>, <span class="hljs-string"><span class="hljs-string">'aux_output'</span>: <span class="hljs-number"><span class="hljs-number">0.2</span>})

<span class="hljs-comment"><span class="hljs-comment"># And trained it via:</span>
model.fit({<span class="hljs-string"><span class="hljs-string">'main_input'</span>: headline_data, <span class="hljs-string"><span class="hljs-string">'aux_input'</span>: additional_data},
          {<span class="hljs-string"><span class="hljs-string">'main_output'</span>: labels, <span class="hljs-string"><span class="hljs-string">'aux_output'</span>: labels},
          epochs=<span class="hljs-number"><span class="hljs-number">50</span>, batch_size=<span class="hljs-number"><span class="hljs-number">32</span>)
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<p>因为输入两个，输出两个模型，所以可以分为设置不同的模型训练参数</p>
<h3 id="案例四共享层对应关系相似性"><a name="t28"></a>案例四：共享层：对应关系、相似性</h3>
<p>一个节点，分成两个分支出去</p>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">import</span> keras
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Input, LSTM, Dense
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> Model

tweet_a = Input(shape=(<span class="hljs-number"><span class="hljs-number">140</span>, <span class="hljs-number"><span class="hljs-number">256</span>))
tweet_b = Input(shape=(<span class="hljs-number"><span class="hljs-number">140</span>, <span class="hljs-number"><span class="hljs-number">256</span>))
<span class="hljs-comment"><span class="hljs-comment">#若要对不同的输入共享同一层，就初始化该层一次，然后多次调用它</span>
<span class="hljs-comment"><span class="hljs-comment"># 140个单词，每个单词256维度，词向量</span>
<span class="hljs-comment"><span class="hljs-comment"># </span>

<span class="hljs-comment"><span class="hljs-comment"># This layer can take as input a matrix</span>
<span class="hljs-comment"><span class="hljs-comment"># and will return a vector of size 64</span>
shared_lstm = LSTM(<span class="hljs-number"><span class="hljs-number">64</span>)
<span class="hljs-comment"><span class="hljs-comment"># 返回一个64规模的向量</span>

<span class="hljs-comment"><span class="hljs-comment"># When we reuse the same layer instance</span>
<span class="hljs-comment"><span class="hljs-comment"># multiple times, the weights of the layer</span>
<span class="hljs-comment"><span class="hljs-comment"># are also being reused</span>
<span class="hljs-comment"><span class="hljs-comment"># (it is effectively *the same* layer)</span>
encoded_a = shared_lstm(tweet_a)
encoded_b = shared_lstm(tweet_b)

<span class="hljs-comment"><span class="hljs-comment"># We can then concatenate the two vectors:</span>
    <span class="hljs-comment"><span class="hljs-comment"># 连接两个结果</span>
    <span class="hljs-comment"><span class="hljs-comment"># axis=-1？？？？？</span>
merged_vector = keras.layers.concatenate([encoded_a, encoded_b], axis=<span class="hljs-number">-</span><span class="hljs-number"><span class="hljs-number">1</span>)

<span class="hljs-comment"><span class="hljs-comment"># And add a logistic regression on top</span>
predictions = Dense(<span class="hljs-number"><span class="hljs-number">1</span>, activation=<span class="hljs-string"><span class="hljs-string">'sigmoid'</span>)(merged_vector)
<span class="hljs-comment"><span class="hljs-comment"># 其中的1 代表什么？？？？</span>

<span class="hljs-comment"><span class="hljs-comment"># We define a trainable model linking the</span>
<span class="hljs-comment"><span class="hljs-comment"># tweet inputs to the predictions</span>
model = Model(inputs=[tweet_a, tweet_b], outputs=predictions)

model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">'rmsprop'</span>,
              loss=<span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span>,
              metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span>])
model.fit([data_a, data_b], labels, epochs=<span class="hljs-number"><span class="hljs-number">10</span>)
<span class="hljs-comment"><span class="hljs-comment"># 训练模型，然后预测</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<h3 id="案例五抽取层节点内容"><a name="t29"></a>案例五：抽取层节点内容</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment"># 1、单节点</span>
a = Input(shape=(<span class="hljs-number"><span class="hljs-number">140</span>, <span class="hljs-number"><span class="hljs-number">256</span>))
lstm = LSTM(<span class="hljs-number"><span class="hljs-number">32</span>)
encoded_a = lstm(a)
<span class="hljs-keyword"><span class="hljs-keyword">assert</span> lstm.output == encoded_a
<span class="hljs-comment"><span class="hljs-comment"># 抽取获得encoded_a的输出张量</span>

<span class="hljs-comment"><span class="hljs-comment"># 2、多节点</span>
a = Input(shape=(<span class="hljs-number"><span class="hljs-number">140</span>, <span class="hljs-number"><span class="hljs-number">256</span>))
b = Input(shape=(<span class="hljs-number"><span class="hljs-number">140</span>, <span class="hljs-number"><span class="hljs-number">256</span>))

lstm = LSTM(<span class="hljs-number"><span class="hljs-number">32</span>)
encoded_a = lstm(a)
encoded_b = lstm(b)

<span class="hljs-keyword"><span class="hljs-keyword">assert</span> lstm.get_output_at(<span class="hljs-number"><span class="hljs-number">0</span>) == encoded_a
<span class="hljs-keyword"><span class="hljs-keyword">assert</span> lstm.get_output_at(<span class="hljs-number"><span class="hljs-number">1</span>) == encoded_b

<span class="hljs-comment"><span class="hljs-comment"># 3、图像层节点</span>
<span class="hljs-comment"><span class="hljs-comment"># 对于input_shape和output_shape也是一样，如果一个层只有一个节点，</span>
<span class="hljs-comment"><span class="hljs-comment">#或所有的节点都有相同的输入或输出shape，</span>
<span class="hljs-comment"><span class="hljs-comment">#那么input_shape和output_shape都是没有歧义的，并也只返回一个值。</span>
<span class="hljs-comment"><span class="hljs-comment">#但是，例如你把一个相同的Conv2D应用于一个大小为(3,32,32)的数据，</span>
<span class="hljs-comment"><span class="hljs-comment">#然后又将其应用于一个(3,64,64)的数据，那么此时该层就具有了多个输入和输出的shape，</span>
<span class="hljs-comment"><span class="hljs-comment">#你就需要显式的指定节点的下标，来表明你想取的是哪个了</span>
a = Input(shape=(<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">32</span>, <span class="hljs-number"><span class="hljs-number">32</span>))
b = Input(shape=(<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">64</span>, <span class="hljs-number"><span class="hljs-number">64</span>))

conv = Conv2D(<span class="hljs-number"><span class="hljs-number">16</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span>)
conved_a = conv(a)

<span class="hljs-comment"><span class="hljs-comment"># Only one input so far, the following will work:</span>
<span class="hljs-keyword"><span class="hljs-keyword">assert</span> conv.input_shape == (<span class="hljs-keyword"><span class="hljs-keyword">None</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">32</span>, <span class="hljs-number"><span class="hljs-number">32</span>)

conved_b = conv(b)
<span class="hljs-comment"><span class="hljs-comment"># now the `.input_shape` property wouldn't work, but this does:</span>
<span class="hljs-keyword"><span class="hljs-keyword">assert</span> conv.get_input_shape_at(<span class="hljs-number"><span class="hljs-number">0</span>) == (<span class="hljs-keyword"><span class="hljs-keyword">None</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">32</span>, <span class="hljs-number"><span class="hljs-number">32</span>)
<span class="hljs-keyword"><span class="hljs-keyword">assert</span> conv.get_input_shape_at(<span class="hljs-number"><span class="hljs-number">1</span>) == (<span class="hljs-keyword"><span class="hljs-keyword">None</span>, <span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">64</span>, <span class="hljs-number"><span class="hljs-number">64</span>)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>&nbsp;</p>
<h3 id="案例六视觉问答模型"><a name="t30"></a>案例六：视觉问答模型</h3>
<pre class="prettyprint"><code class="language-python hljs  has-numbering"><span class="hljs-comment"><span class="hljs-comment">#这个模型将自然语言的问题和图片分别映射为特征向量，</span>
<span class="hljs-comment"><span class="hljs-comment">#将二者合并后训练一个logistic回归层，从一系列可能的回答中挑选一个。</span>
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Conv2D, MaxPooling2D, Flatten
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span> Input, LSTM, Embedding, Dense
<span class="hljs-keyword"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span> Model, Sequential

<span class="hljs-comment"><span class="hljs-comment"># First, let's define a vision model using a Sequential model.</span>
<span class="hljs-comment"><span class="hljs-comment"># This model will encode an image into a vector.</span>
vision_model = Sequential()
vision_model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">64</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>) activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>, input_shape=(<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">224</span>, <span class="hljs-number"><span class="hljs-number">224</span>)))
vision_model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">64</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>))
vision_model.add(MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))
vision_model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">128</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>))
vision_model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">128</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>))
vision_model.add(MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))
vision_model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">256</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span>))
vision_model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">256</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>))
vision_model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">256</span>, (<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">3</span>), activation=<span class="hljs-string"><span class="hljs-string">'relu'</span>))
vision_model.add(MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span>, <span class="hljs-number"><span class="hljs-number">2</span>)))
vision_model.add(Flatten())

<span class="hljs-comment"><span class="hljs-comment"># Now let's get a tensor with the output of our vision model:</span>
image_input = Input(shape=(<span class="hljs-number"><span class="hljs-number">3</span>, <span class="hljs-number"><span class="hljs-number">224</span>, <span class="hljs-number"><span class="hljs-number">224</span>))
encoded_image = vision_model(image_input)

<span class="hljs-comment"><span class="hljs-comment"># Next, let's define a language model to encode the question into a vector.</span>
<span class="hljs-comment"><span class="hljs-comment"># Each question will be at most 100 word long,</span>
<span class="hljs-comment"><span class="hljs-comment"># and we will index words as integers from 1 to 9999.</span>
question_input = Input(shape=(<span class="hljs-number"><span class="hljs-number">100</span>,), dtype=<span class="hljs-string"><span class="hljs-string">'int32'</span>)
embedded_question = Embedding(input_dim=<span class="hljs-number"><span class="hljs-number">10000</span>, output_dim=<span class="hljs-number"><span class="hljs-number">256</span>, input_length=<span class="hljs-number"><span class="hljs-number">100</span>)(question_input)
encoded_question = LSTM(<span class="hljs-number"><span class="hljs-number">256</span>)(embedded_question)

<span class="hljs-comment"><span class="hljs-comment"># Let's concatenate the question vector and the image vector:</span>
merged = keras.layers.concatenate([encoded_question, encoded_image])

<span class="hljs-comment"><span class="hljs-comment"># And let's train a logistic regression over 1000 words on top:</span>
output = Dense(<span class="hljs-number"><span class="hljs-number">1000</span>, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span>)(merged)

<span class="hljs-comment"><span class="hljs-comment"># This is our final model:</span>
vqa_model = Model(inputs=[image_input, question_input], outputs=output)

<span class="hljs-comment"><span class="hljs-comment"># The next stage would be training this model on actual data.</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h2 id="延伸一fine-tuning时如何加载notop的权重"><a name="t31"></a>延伸一：fine-tuning时如何加载No_top的权重</h2>
<p>如果你需要加载权重到不同的网络结构（有些层一样）中，例如fine-tune或transfer-learning，你可以通过层名字来加载模型：&nbsp;<br>model.load_weights(‘my_model_weights.h5’, by_name=True)&nbsp;<br>例如：</p>
<p>假如原模型为：</p>
<pre class="prettyprint"><code class="hljs r has-numbering">    model = Sequential()
    model.add(Dense(<span class="hljs-number"><span class="hljs-number">2</span>, input_dim=<span class="hljs-number"><span class="hljs-number">3</span>, name=<span class="hljs-string"><span class="hljs-string">"dense_1"</span>))
    model.add(Dense(<span class="hljs-number"><span class="hljs-number">3</span>, name=<span class="hljs-string"><span class="hljs-string">"dense_2"</span>))
    <span class="hljs-keyword"><span class="hljs-keyword">...</span>
    model.save_weights(fname)</span></span></span></span></span></span></code></pre>
<pre class="prettyprint"><code class="hljs avrasm has-numbering makefile"><span class="hljs-preprocessor"><span class="hljs-comment"># new model</span>
model = Sequential()
model<span class="hljs-preprocessor">.add(Dense(<span class="hljs-number">2, input_dim=<span class="hljs-number">3, name=<span class="hljs-string"><span class="hljs-string">"dense_1"</span>))  <span class="hljs-preprocessor"><span class="hljs-comment"># will be loaded</span>
model<span class="hljs-preprocessor">.add(Dense(<span class="hljs-number">10, name=<span class="hljs-string"><span class="hljs-string">"new_dense"</span>))  <span class="hljs-preprocessor"><span class="hljs-comment"># will not be loaded</span>

<span class="hljs-preprocessor"><span class="hljs-comment"># load weights from first model; will only affect the first layer, dense_1.</span>
model<span class="hljs-preprocessor">.load_weights(fname, by_name=True)</span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div>]]></description></item><item><title>NLP（十七） 利用DNN对Email分类</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/07/nlp_17.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 07 Jul 2019 02:38:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/07/nlp_17.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp17/
+ 数据集
scikit-learn中20个新闻组，总邮件18846，训练集11314，测试集7532，类别20
```
from sklearn.datasets import fetch_20newsgroups
newsgroups_train = fetch_20newsgroups(subset='train')
newsgroups_test = fetch_20newsgroups(subset='test')
x_train = newsgroups_train.data
x_test = newsgroups_test.data
y_train = newsgroups_train.target
y_test = newsgroups_test.target
print('List of all 20 categories:')
print(newsgroups_train.target_names,'\n')
print('Sample Email:')
print(x_train[0])
print('Sample Target Category:')
print(y_train[0])
print(newsgroups_train.target_names[y_train[0]])
```
输出：
```
List of all 20 categories:
['alt.atheism', 'comp.graphics', 'comp.os.ms-windows.misc', 'comp.sys.ibm.pc.hardware', 'comp.sys.mac.hardware', 'comp.windows.x', 'misc.forsale', 'rec.autos', 'rec.motorcycles', 'rec.sport.baseball', 'rec.sport.hockey', 'sci.crypt', 'sci.electronics', 'sci.med', 'sci.space', 'soc.religion.christian', 'talk.politics.guns', 'talk.politics.mideast', 'talk.politics.misc', 'talk.religion.misc'] 

Sample Email:
From: lerxst@wam.umd.edu (where's my thing)
Subject: WHAT car is this!?
Nntp-Posting-Host: rac3.wam.umd.edu
Organization: University of Maryland, College Park
Lines: 15

 I was wondering if anyone out there could enlighten me on this car I saw
the other day. It was a 2-door sports car, looked to be from the late 60s/
early 70s. It was called a Bricklin. The doors were really small. In addition,
the front bumper was separate from the rest of the body. This is 
all I know. If anyone can tellme a model name, engine specs, years
of production, where this car is made, history, or whatever info you
have on this funky looking car, please e-mail.

Thanks,
- IL
   ---- brought to you by your neighborhood Lerxst ----
```
+ 实现步骤
1. 预处理
1）去标点符号
2）分词
3）单词都转化成小写
4）去停用词
5）保留长度至少为3的词
6）提取词干
7）词性标注
8）词形还原
2. TF-IDF向量转换
3. 深度学习模型的训练和测试
4. 模型评估和结果分析
+ 代码
```
from sklearn.datasets import fetch_20newsgroups
newsgroups_train = fetch_20newsgroups(subset='train')
newsgroups_test = fetch_20newsgroups(subset='test')
x_train = newsgroups_train.data
x_test = newsgroups_test.data
y_train = newsgroups_train.target
y_test = newsgroups_test.target
# print('List of all 20 categories:')
# print(newsgroups_train.target_names,'\n')
# print('Sample Email:')
# print(x_train[0])
# print('Sample Target Category:')
# print(y_train[0])
# print(newsgroups_train.target_names[y_train[0]])

import nltk
from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
import string
import pandas as pd
from nltk import  pos_tag
from nltk.stem import PorterStemmer

def preprocessing(text):
    # 标点都换成空格，再以空格分割，在以空格为分割合并所以元素
    text2 = ' '.join(''.join([' ' if ch in string.punctuation else ch for ch in text]).split())
    # 分词
    tokens = [word for sent in nltk.sent_tokenize(text2) for word in nltk.word_tokenize(sent)]
    tokens = [word.lower() for word in tokens]
    stopwds = stopwords.words('english')
    # 过滤掉 停用词 和 长度<3 的token
    tokens = [token for token in tokens if token not in stopwds and len(token) >= 3]
    # 词干提取
    stemmer = PorterStemmer()
    tokens = [stemmer.stem(word) for word in tokens]
    # 词性标注
    tagged_corpus = pos_tag(tokens)
    Noun_tags = ['NN','NNP','NNPS','NNS'] # 普通名词 专有名词 专有名词复数 普通名词复数
    Verb_tags = ['VB','VBD','VBG','VBN','VBP','VBZ']
    # 动词 动词过去式 动词现在分词 动词过去分词  动词现在时 动词现在时第三人称单数
    lemmatizer = WordNetLemmatizer()
    def prat_lemmatize(token,tag):
        if tag in Noun_tags:
            return lemmatizer.lemmatize(token,'n')
        elif tag in Verb_tags:
            return lemmatizer.lemmatize(token,'v')
        else:
            return lemmatizer.lemmatize(token,'n')
    pre_proc_text = ' '.join([prat_lemmatize(token,tag) for token,tag in tagged_corpus])
    return pre_proc_text

# 处理数据集
x_train_preprocessed = []
for i in x_train:
    x_train_preprocessed.append(preprocessing(i))
x_test_preprocessed = []
for i in x_test:
    x_test_preprocessed.append(preprocessing(i))

# 得到每个文档的TF-IDF向量
from sklearn.feature_extraction.text import TfidfVectorizer
vectorizer = TfidfVectorizer(min_df=2,ngram_range=(1,2),stop_words='english',
                             max_features=10000,strip_accents='unicode',norm='l2')
x_train_2 = vectorizer.fit_transform(x_train_preprocessed).todense() # 稀疏矩阵=>密集！？
x_test_2 = vectorizer.transform(x_test_preprocessed).todense()

# 导入深度学习模块
import numpy as np
from keras.models import Sequential
from keras.layers.core import Dense,Dropout,Activation
from keras.optimizers import Adadelta,Adam,RMSprop
from keras.utils import np_utils

np.random.seed(0)
nb_classes = 20
batch_size = 64 # 批尺寸
nb_epochs = 20 # 迭代次数

# 将20个类变成one-hot编码向量
Y_train = np_utils.to_categorical(y_train,nb_classes)

# 建立keras模型 3个隐藏层 神经元个数分别为1000 500 50，每层dropout均为50%，优化算法为Adam
model = Sequential()
model.add(Dense(1000,input_shape=(10000,)))
model.add(Activation('relu'))
model.add(Dropout(0.5))
model.add(Dense(500))
model.add(Activation('relu'))
model.add(Dropout(0.5))
model.add(Dense(50))
model.add(Activation('relu'))
model.add(Dropout(0.5))
model.add(Dense(nb_classes))
model.add(Activation('softmax'))
model.compile(loss='categorical_crossentropy',optimizer='adam')
# loss=交叉熵损失函数 optimizer优化程序=adam
print(model.summary())

# 模型训练
model.fit(x_train_2,Y_train,batch_size=batch_size,epochs=nb_epochs,verbose=1)

# 模型预测
y_train_predclass = model.predict_classes(x_train_2,batch_size=batch_size)
y_test_preclass = model.predict_classes(x_test_2,batch_size==batch_size)
from sklearn.metrics import accuracy_score,classification_report
print("\n\nDeep Neural Network - Train accuracy:",round(accuracy_score(y_train,y_train_predclass),3))
print("\nDeep Neural Network - Test accuracy:",round(accuracy_score(y_test,y_test_preclass),3))
print("\nDeep Neural Network - Train Classification Report")
print(classification_report(y_train,y_train_predclass))
print("\nDeep Neural Network - Test Classification Report")
print(classification_report(y_test,y_test_preclass))
```
输出：
```
Using TensorFlow backend.
WARNING:tensorflow:From 
D:\Python37\Lib\site-packages\tensorflow\python\framework\op_def_library.py:263: 
colocate_with (from tensorflow.python.framework.ops) is deprecated and will be removed in a 
future version.
Instructions for updating:
Colocations handled automatically by placer.
WARNING:tensorflow:From 
D:\Anaconda3\lib\site-packages\keras\backend\tensorflow_backend.py:3445: calling dropout 
(from tensorflow.python.ops.nn_ops) with keep_prob is deprecated and will be removed in a 
future version.
Instructions for updating:
Please use `rate` instead of `keep_prob`. Rate should be set to `rate = 1 - keep_prob`.
_________________________________________________________________
Layer (type)                 Output Shape              Param #   

=================================================================
dense_1 (Dense)              (None, 1000)              10001000  
_________________________________________________________________

activation_1 (Activation)    (None, 1000)              0         
_________________________________________________________________

dropout_1 (Dropout)          (None, 1000)              0         
_________________________________________________________________

dense_2 (Dense)              (None, 500)               500500    
_________________________________________________________________

activation_2 (Activation)    (None, 500)               0         
_________________________________________________________________

dropout_2 (Dropout)          (None, 500)               0         
_________________________________________________________________

dense_3 (Dense)              (None, 50)                25050     
_________________________________________________________________

activation_3 (Activation)    (None, 50)                0         
_________________________________________________________________

dropout_3 (Dropout)          (None, 50)                0         
_________________________________________________________________

dense_4 (Dense)              (None, 20)                1020      
_________________________________________________________________
activation_4 (Activation)    (None, 20)                0 

=================================================================
Total params: 10,527,570
Trainable params: 10,527,570
Non-trainable params:0
______________________________________________________________
None
WARNING:tensorflow:From 
D:\Python37\Lib\site-packages\tensorflow\python\ops\math_ops.py:3066: to_int32 (from 
tensorflow.python.ops.math_ops) is deprecated and will be removed in a future version.
Instructions for updating:
Use tf.cast instead.
Epoch 1/20
2019-07-06 23:03:46.934966: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU 
supports instructions that this TensorFlow binary was not compiled to use: AVX2

   64/11314 [..............................] - ETA: 4:41 - loss: 2.9946
  128/11314 [..............................] - ETA: 2:43 - loss: 2.9948
  192/11314 [..............................] - ETA: 2:03 - loss: 2.9951
  256/11314 [..............................] - ETA: 1:43 - loss: 2.9947
  320/11314 [..............................] - ETA: 1:32 - loss: 2.9938
  此处省略一堆epoch的一堆操作
  
Deep Neural Network - Train accuracy: 0.999
Deep Neural Network - Test accuracy: 0.811

Deep Neural Network - Train Classification Report
              precision    recall  f1-score   support

           0       1.00      1.00      1.00       480
           1       1.00      0.99      1.00       584
           2       0.99      1.00      1.00       591
           3       1.00      1.00      1.00       590
           4       1.00      1.00      1.00       578
           5       1.00      1.00      1.00       593
           6       1.00      1.00      1.00       585
           7       1.00      1.00      1.00       594
           8       1.00      1.00      1.00       598
           9       1.00      1.00      1.00       597
          10       1.00      1.00      1.00       600
          11       1.00      1.00      1.00       595
          12       1.00      1.00      1.00       591
          13       1.00      1.00      1.00       594
          14       1.00      1.00      1.00       593
          15       1.00      1.00      1.00       599
          16       1.00      1.00      1.00       546
          17       1.00      1.00      1.00       564
          18       1.00      1.00      1.00       465
          19       1.00      1.00      1.00       377

    accuracy                           1.00     11314
   macro avg       1.00      1.00      1.00     11314
weighted avg       1.00      1.00      1.00     11314

Deep Neural Network - Test Classification Report
              precision    recall  f1-score   support

           0       0.78      0.78      0.78       319
           1       0.70      0.74      0.72       389
           2       0.68      0.69      0.68       394
           3       0.71      0.69      0.70       392
           4       0.82      0.76      0.79       385
           5       0.84      0.74      0.78       395
           6       0.73      0.87      0.80       390
           7       0.85      0.86      0.86       396
           8       0.93      0.91      0.92       398
           9       0.89      0.91      0.90       397
          10       0.96      0.97      0.96       399
          11       0.87      0.95      0.91       396
          12       0.69      0.72      0.70       393
          13       0.88      0.77      0.82       396
          14       0.83      0.92      0.87       394
          15       0.91      0.84      0.88       398
          16       0.78      0.83      0.80       364
          17       0.97      0.87      0.92       376
          18       0.74      0.66      0.70       310
          19       0.59      0.62      0.61       251

    accuracy                           0.81      7532
   macro avg       0.81      0.81      0.81      7532
weighted avg       0.81      0.81      0.81      7532
```]]></description></item><item><title>NLP（十六） DL在NLP中的应用</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/07/nlp_16.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 07 Jul 2019 02:35:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/07/nlp_16.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp16/
+ 深度学习中的核心主题是`卷积神经网络(CNN)`和`循环神经网络(RNN)`
#### 卷积神经网络
+ CNN用于图像处理
卷积：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190707103249963-621527398.png)
原始图像 5×5
滤波器 3×3
滤波器以步长大于小于1，到处平移，并与原始图像里的3×3做乘积运算，得到卷积特征/激活映射(activation map)。
卷积的优势：
1.全连接层代替固定尺寸，减少了神经元的数量
2.滤波器将上一层的像素汇总到下一层
3.反向传播过程中，只需根据反向传播误差更新滤波器权重，就可使效率提高
+ 池化
将激活表示的维数减少
例如，将4×4的矩阵分解成4个2×2的矩阵，只保留最大值，缩减成2×2矩阵
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190707103302335-819810556.png)
+ 填充
可以保持图片大小不发生改变或者使整个网络的大小处于可控状态
比如，零填充，添一圈0，3×3 => 5×5
+ 特征图大小的计算
从卷积层到特征图的大小变化：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190707103312845-752803517.png)
W是原始图像的宽度，F是滤波器的大小，P是填充大小，S是步长
+ CNN的应用
1.图像分类
2.人脸识别
3.场景标注
4.自然语言处理：将句子表示为向量，就可以使用CNN完成分类；CNN进行一维卷积时，宽度是常量，那么滤波器只需在广度上移动。
#### 循环神经网络
+ 输入相互独立时，用CNN；前后依赖，不独立时，用RNN
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190707103326346-1374408387.png)
+ RNN原理公式：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190707103343408-682792181.png)
+ LSTM
长短型记忆网络，解决梯度消失和梯度爆炸问题
LSTM是一个人工神经网络，除常规网络单元外，还有LSTM模块。LSTM包含三个门，输入门、遗忘门、输出门。输入门用来确定何时输入足够重要的信息，遗忘门用来确定何时继续记住或忘记上一刻的信息，输出门则用来确定应该何时输出当前时刻的信息
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190707103357561-940061029.png)
+ RNN在NLP领域应用
1.语言模型：给一次词序列，预测下一个可能出现的单词
2.文本生成：根据作者的作品产生新文本
3.机器翻译：一种语言=>另一种语言
4.聊天机器人：与机器翻译类似，需要用双方问答来训练模型
5.生成图像描述：将RNN与CNN一起训练生成图像的标题或描述]]></description></item><item><title>深度学习常见的优化方法(Optimizer)总结:Adam,SGD,Momentum,AdaGard等</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/07/11145129.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sun, 07 Jul 2019 01:57:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/07/11145129.html</guid><description><![CDATA[<br>
<a class="postTitle2" id="cb_post_title_url" href="https://www.cnblogs.com/GeekDanny/p/9655597.html">原文：https://www.cnblogs.com/GeekDanny/p/9655597.html</a>
<br>

<div class="blogpost-body cnblogs-markdown" id="cnblogs_post_body"><p><font color="purple" size="5"></font></p>
<h4 id="基础知识">基础知识:</h4>
<p><br>机器学习几乎所有的算法都要利用损失函数 lossfunction 来检验算法模型的优劣，同时利用损失函数来提升算法模型．<br>
<br>这个提升的过程就叫做优化(Optimizer)<br>
<br>下面这个内容主要就是介绍可以用来优化损失函数的常用方法</p>
<h4 id="常用的优化方法optimizer">常用的优化方法(Optimizer):</h4>
<ul>
<li><p><strong>1.SGD&amp;BGD&amp;Mini-BGD</strong>:<br>
<br><strong>SGD</strong>(stochastic gradient descent):随机梯度下降,算法在每读入一个数据都会立刻计算loss function的梯度来update参数．假设loss function为L(w)，下同．<span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-1-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>w</mi><mo>&amp;#x2212;</mo><mo>=</mo><mi>&amp;#x03B7;</mi><msub><mo>&amp;#x25BD;</mo><mrow class="MJX-TeXAtom-ORD"><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub></mrow></msub><mi>L</mi><mo stretchy="false">(</mo><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub><mo stretchy="false">)</mo></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-1" style="width: 10.07em; display: inline-block;"><span style="width: 7.93em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(1.38em, 1007.83em, 2.73em, -1000em);"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math; font-style: italic;">w</span><span class="mo" id="MathJax-Span-4" style="font-family: MathJax_Main;">−</span><span class="mo" id="MathJax-Span-5" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="mi" id="MathJax-Span-6" style="padding-left: 0.27em; font-family: MathJax_Math; font-style: italic;">η<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="msubsup" id="MathJax-Span-7" style="padding-left: 0.22em;"><span style="width: 1.69em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.32em, 1000.82em, 4.37em, -1000em);"><span class="mo" id="MathJax-Span-8" style="font-family: MathJax_Main;">▽</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.88em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-9"><span class="mrow" id="MathJax-Span-10"><span class="msubsup" id="MathJax-Span-11"><span style="width: 0.73em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.51em, 1000.48em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-12" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">w</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.5em; top: -3.88em; position: absolute;"><span class="texatom" id="MathJax-Span-13"><span class="mrow" id="MathJax-Span-14"><span class="mi" id="MathJax-Span-15" style="font-family: MathJax_Math; font-size: 50%; font-style: italic;">i</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mi" id="MathJax-Span-16" style="padding-left: 0.22em; font-family: MathJax_Math; font-style: italic;">L</span><span class="mo" id="MathJax-Span-17" style="font-family: MathJax_Main;">(</span><span class="msubsup" id="MathJax-Span-18"><span style="width: 1.03em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.69em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-19" style="font-family: MathJax_Math; font-style: italic;">w</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.71em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-20"><span class="mrow" id="MathJax-Span-21"><span class="mi" id="MathJax-Span-22" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-23" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.42em; overflow: hidden; vertical-align: -0.4em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>w</mi><mo>−</mo><mo>=</mo><mi>η</mi><msub><mo>▽</mo><mrow class="MJX-TeXAtom-ORD"><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub></mrow></msub><mi>L</mi><mo stretchy="false">(</mo><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub><mo stretchy="false">)</mo></math></span></span></div><script id="MathJax-Element-1" type="math/tex; mode=display">w-=\eta \bigtriangledown_{w_{i}}L(w_{i}) </script></span><br>
<br>Pros:收敛的速度快；可以实现在线更新；能够跳出局部最优<br>
<br>Cons:很容易陷入到局部最优，困在马鞍点．<br>
<br><strong>BGD</strong>(batch gradient descent):批量梯度下降，算法在读取整个数据集后累加来计算损失函数的的梯度<br>
<span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-2-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>w</mi><mo>&amp;#x2212;</mo><mo>=</mo><mi>&amp;#x03B7;</mi><msub><mo>&amp;#x25BD;</mo><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow></msub><mi>L</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-24" style="width: 9.45em; display: inline-block;"><span style="width: 7.42em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(1.38em, 1007.33em, 2.72em, -1000em);"><span class="mrow" id="MathJax-Span-25"><span class="mi" id="MathJax-Span-26" style="font-family: MathJax_Math; font-style: italic;">w</span><span class="mo" id="MathJax-Span-27" style="font-family: MathJax_Main;">−</span><span class="mo" id="MathJax-Span-28" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="mi" id="MathJax-Span-29" style="padding-left: 0.27em; font-family: MathJax_Math; font-style: italic;">η<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="msubsup" id="MathJax-Span-30" style="padding-left: 0.22em;"><span style="width: 1.47em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.32em, 1000.82em, 4.37em, -1000em);"><span class="mo" id="MathJax-Span-31" style="font-family: MathJax_Main;">▽</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.88em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-32"><span class="mrow" id="MathJax-Span-33"><span class="mi" id="MathJax-Span-34" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">w</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mi" id="MathJax-Span-35" style="padding-left: 0.22em; font-family: MathJax_Math; font-style: italic;">L</span><span class="mo" id="MathJax-Span-36" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-37" style="font-family: MathJax_Math; font-style: italic;">w</span><span class="mo" id="MathJax-Span-38" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.41em; overflow: hidden; vertical-align: -0.38em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>w</mi><mo>−</mo><mo>=</mo><mi>η</mi><msub><mo>▽</mo><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow></msub><mi>L</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></math></span></span></div><script id="MathJax-Element-2" type="math/tex; mode=display">w-=\eta \bigtriangledown_{w}L(w)</script></span><br>
<br>Pros:如果loss function为convex，则基本可以找到全局最优解<br>
<br>Cons:数据处理量大，导致梯度下降慢;不能实时增加实例，在线更新；训练占内存<br>
<br><strong>Mini-BGD</strong>(mini-batch gradient descent):顾名思义，选择小批量数据进行梯度下降，这是一个折中的方法．采用训练集的子集(mini-batch)来计算loss function的梯度．<span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-3-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>w</mi><mo>&amp;#x2212;</mo><mo>=</mo><mi>&amp;#x03B7;</mi><msub><mo>&amp;#x25BD;</mo><mrow class="MJX-TeXAtom-ORD"><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>:</mo><mi>i</mi><mo>+</mo><mi>n</mi></mrow></msub></mrow></msub><mi>L</mi><mo stretchy="false">(</mo><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>:</mo><mi>i</mi><mo>+</mo><mi>n</mi></mrow></msub><mo stretchy="false">)</mo></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-39" style="width: 13.16em; display: inline-block;"><span style="width: 10.34em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(1.38em, 1010.25em, 2.77em, -1000em);"><span class="mrow" id="MathJax-Span-40"><span class="mi" id="MathJax-Span-41" style="font-family: MathJax_Math; font-style: italic;">w</span><span class="mo" id="MathJax-Span-42" style="font-family: MathJax_Main;">−</span><span class="mo" id="MathJax-Span-43" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="mi" id="MathJax-Span-44" style="padding-left: 0.27em; font-family: MathJax_Math; font-style: italic;">η<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="msubsup" id="MathJax-Span-45" style="padding-left: 0.22em;"><span style="width: 2.69em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.32em, 1000.82em, 4.37em, -1000em);"><span class="mo" id="MathJax-Span-46" style="font-family: MathJax_Main;">▽</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.88em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-47"><span class="mrow" id="MathJax-Span-48"><span class="msubsup" id="MathJax-Span-49"><span style="width: 1.73em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.51em, 1000.48em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-50" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">w</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.5em; top: -3.88em; position: absolute;"><span class="texatom" id="MathJax-Span-51"><span class="mrow" id="MathJax-Span-52"><span class="mi" id="MathJax-Span-53" style="font-family: MathJax_Math; font-size: 50%; font-style: italic;">i</span><span class="mo" id="MathJax-Span-54" style="font-family: MathJax_Main; font-size: 50%;">:</span><span class="mi" id="MathJax-Span-55" style="font-family: MathJax_Math; font-size: 50%; font-style: italic;">i</span><span class="mo" id="MathJax-Span-56" style="font-family: MathJax_Main; font-size: 50%;">+</span><span class="mi" id="MathJax-Span-57" style="font-family: MathJax_Math; font-size: 50%; font-style: italic;">n</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mi" id="MathJax-Span-58" style="padding-left: 0.22em; font-family: MathJax_Math; font-style: italic;">L</span><span class="mo" id="MathJax-Span-59" style="font-family: MathJax_Main;">(</span><span class="msubsup" id="MathJax-Span-60"><span style="width: 2.45em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.69em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-61" style="font-family: MathJax_Math; font-style: italic;">w</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.71em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-62"><span class="mrow" id="MathJax-Span-63"><span class="mi" id="MathJax-Span-64" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span><span class="mo" id="MathJax-Span-65" style="font-family: MathJax_Main; font-size: 70.7%;">:</span><span class="mi" id="MathJax-Span-66" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span><span class="mo" id="MathJax-Span-67" style="font-family: MathJax_Main; font-size: 70.7%;">+</span><span class="mi" id="MathJax-Span-68" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">n</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-69" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.47em; overflow: hidden; vertical-align: -0.44em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>w</mi><mo>−</mo><mo>=</mo><mi>η</mi><msub><mo>▽</mo><mrow class="MJX-TeXAtom-ORD"><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>:</mo><mi>i</mi><mo>+</mo><mi>n</mi></mrow></msub></mrow></msub><mi>L</mi><mo stretchy="false">(</mo><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>:</mo><mi>i</mi><mo>+</mo><mi>n</mi></mrow></msub><mo stretchy="false">)</mo></math></span></span></div><script id="MathJax-Element-3" type="math/tex; mode=display">w-=\eta \bigtriangledown_{w_{i:i+n}}L(w_{i:i+n})</script></span><br>
<br>这个优化方法用的也是比较多的，计算效率高而且收敛稳定，是现在深度学习的主流方法．</p>
<h4 id="上面的方法都存在一个问题就是update更新的方向完全依赖于计算出来的梯度很容易陷入局部最优的马鞍点能不能改变其走向又保证原来的梯度方向就像向量变换一样我们模拟物理中物体流动的动量概念惯性.引入momentum的概念">上面的方法都存在一个问题，就是update更新的方向完全依赖于计算出来的梯度．很容易陷入局部最优的马鞍点．能不能改变其走向，又保证原来的梯度方向．就像向量变换一样，我们模拟物理中物体流动的动量概念(惯性).引入Momentum的概念．</h4></li>
<li><strong>2.Momentum</strong><br>
<br>在更新方向的时候保留之前的方向，增加稳定性而且还有摆脱局部最优的能力<span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-4-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi mathvariant="normal">&amp;#x0394;</mi><mi>w</mi><mo>=</mo><mi>&amp;#x03B1;</mi><mi mathvariant="normal">&amp;#x0394;</mi><mi>w</mi><mo>&amp;#x2212;</mo><mi>&amp;#x03B7;</mi><mo>&amp;#x25BD;</mo><mi>L</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-70" style="width: 13.1em; display: inline-block;"><span style="width: 10.29em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(1.38em, 1010.19em, 2.72em, -1000em);"><span class="mrow" id="MathJax-Span-71"><span class="mi" id="MathJax-Span-72" style="font-family: MathJax_Main;">Δ</span><span class="mi" id="MathJax-Span-73" style="font-family: MathJax_Math; font-style: italic;">w</span><span class="mo" id="MathJax-Span-74" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="mi" id="MathJax-Span-75" style="padding-left: 0.27em; font-family: MathJax_Math; font-style: italic;">α</span><span class="mi" id="MathJax-Span-76" style="font-family: MathJax_Main;">Δ</span><span class="mi" id="MathJax-Span-77" style="font-family: MathJax_Math; font-style: italic;">w</span><span class="mo" id="MathJax-Span-78" style="padding-left: 0.22em; font-family: MathJax_Main;">−</span><span class="mi" id="MathJax-Span-79" style="padding-left: 0.22em; font-family: MathJax_Math; font-style: italic;">η<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mo" id="MathJax-Span-80" style="padding-left: 0.22em; font-family: MathJax_Main;">▽</span><span class="mi" id="MathJax-Span-81" style="padding-left: 0.22em; font-family: MathJax_Math; font-style: italic;">L</span><span class="mo" id="MathJax-Span-82" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-83" style="font-family: MathJax_Math; font-style: italic;">w</span><span class="mo" id="MathJax-Span-84" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.41em; overflow: hidden; vertical-align: -0.38em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi mathvariant="normal">Δ</mi><mi>w</mi><mo>=</mo><mi>α</mi><mi mathvariant="normal">Δ</mi><mi>w</mi><mo>−</mo><mi>η</mi><mo>▽</mo><mi>L</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></math></span></span></div><script id="MathJax-Element-4" type="math/tex; mode=display">\Delta w=\alpha \Delta w- \eta \bigtriangledown L(w)</script></span> <span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-5-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>w</mi><mo>=</mo><mi>w</mi><mo>+</mo><mi mathvariant="normal">&amp;#x0394;</mi><mi>w</mi></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-85" style="width: 7.03em; display: inline-block;"><span style="width: 5.51em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(1.42em, 1005.48em, 2.55em, -1000em);"><span class="mrow" id="MathJax-Span-86"><span class="mi" id="MathJax-Span-87" style="font-family: MathJax_Math; font-style: italic;">w</span><span class="mo" id="MathJax-Span-88" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="mi" id="MathJax-Span-89" style="padding-left: 0.27em; font-family: MathJax_Math; font-style: italic;">w</span><span class="mo" id="MathJax-Span-90" style="padding-left: 0.22em; font-family: MathJax_Main;">+</span><span class="mi" id="MathJax-Span-91" style="padding-left: 0.22em; font-family: MathJax_Main;">Δ</span><span class="mi" id="MathJax-Span-92" style="font-family: MathJax_Math; font-style: italic;">w</span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.15em; overflow: hidden; vertical-align: -0.17em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>w</mi><mo>=</mo><mi>w</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>w</mi></math></span></span></div><script id="MathJax-Element-5" type="math/tex; mode=display">w=w+\Delta w</script></span><br>
<br>若当前梯度的方向与历史梯度一致（表明当前样本不太可能为异常点），则会增强这个方向的梯度，若当前梯度与历史梯方向不一致，则梯度会衰减。一种形象的解释是：我们把一个球推下山，球在下坡时积聚动量，在途中变得越来越快，<span class="math inline"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span tabindex="0" class="MathJax" id="MathJax-Element-6-Frame" role="presentation" style="position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&amp;#x03B7;</mi></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-93" style="width: 0.67em; display: inline-block;"><span style="width: 0.5em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.25em; position: absolute; clip: rect(1.63em, 1000.5em, 2.63em, -1000em);"><span class="mrow" id="MathJax-Span-94"><span class="mi" id="MathJax-Span-95" style="font-family: MathJax_Math; font-style: italic;">η<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span></span><span style="width: 0px; height: 2.25em; display: inline-block;"></span></span></span><span style="width: 0px; height: 0.97em; overflow: hidden; vertical-align: -0.34em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>η</mi></math></span></span><script id="MathJax-Element-6" type="math/tex">\eta</script></span>可视为空气阻力，若球的方向发生变化，则动量会衰减。</li>
<li><strong>3.Adagrad</strong>：(adaptive gradient)自适应梯度算法,是一种改进的随机梯度下降算法．<br>以前的算法中，每一个参数都使用相同的学习率<span class="math inline"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span tabindex="0" class="MathJax" id="MathJax-Element-7-Frame" role="presentation" style="position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&amp;#x03B1;</mi></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-96" style="width: 0.79em; display: inline-block;"><span style="width: 0.61em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.25em; position: absolute; clip: rect(1.63em, 1000.58em, 2.42em, -1000em);"><span class="mrow" id="MathJax-Span-97"><span class="mi" id="MathJax-Span-98" style="font-family: MathJax_Math; font-style: italic;">α</span></span><span style="width: 0px; height: 2.25em; display: inline-block;"></span></span></span><span style="width: 0px; height: 0.71em; overflow: hidden; vertical-align: -0.08em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>α</mi></math></span></span><script id="MathJax-Element-7" type="math/tex">\alpha</script></span>. Adagrad算法能够在训练中自动对learning_rate进行调整，出现频率较低参数采用较大的<span class="math inline"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span tabindex="0" class="MathJax" id="MathJax-Element-8-Frame" role="presentation" style="position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&amp;#x03B1;</mi></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-99" style="width: 0.79em; display: inline-block;"><span style="width: 0.61em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.25em; position: absolute; clip: rect(1.63em, 1000.58em, 2.42em, -1000em);"><span class="mrow" id="MathJax-Span-100"><span class="mi" id="MathJax-Span-101" style="font-family: MathJax_Math; font-style: italic;">α</span></span><span style="width: 0px; height: 2.25em; display: inline-block;"></span></span></span><span style="width: 0px; height: 0.71em; overflow: hidden; vertical-align: -0.08em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>α</mi></math></span></span><script id="MathJax-Element-8" type="math/tex">\alpha</script></span>更新．出现频率较高的参数采用较小的<span class="math inline"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span tabindex="0" class="MathJax" id="MathJax-Element-9-Frame" role="presentation" style="position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&amp;#x03B1;</mi></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-102" style="width: 0.79em; display: inline-block;"><span style="width: 0.61em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.25em; position: absolute; clip: rect(1.63em, 1000.58em, 2.42em, -1000em);"><span class="mrow" id="MathJax-Span-103"><span class="mi" id="MathJax-Span-104" style="font-family: MathJax_Math; font-style: italic;">α</span></span><span style="width: 0px; height: 2.25em; display: inline-block;"></span></span></span><span style="width: 0px; height: 0.71em; overflow: hidden; vertical-align: -0.08em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>α</mi></math></span></span><script id="MathJax-Element-9" type="math/tex">\alpha</script></span>更新．根据描述这个优化方法很适合处理稀疏数据．<span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-10-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>G</mi><mo>=</mo><munderover><mo>&amp;#x2211;</mo><mrow class="MJX-TeXAtom-ORD"><mi>&amp;#x03C4;</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi></mrow></munderover><msub><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mi>&amp;#x03C4;</mi></mrow></msub><msubsup><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mi>&amp;#x03C4;</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>T</mi></mrow></msubsup><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x3000;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x5176;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x4E2D;</mo></mrow><mi>s</mi><mo>.</mo><mi>t</mi><mo>.</mo><msub><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mi>&amp;#x03C4;</mi></mrow></msub><mo>=</mo><mo>&amp;#x25BD;</mo><mi>L</mi><mo stretchy="false">(</mo><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub><mo stretchy="false">)</mo></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-105" style="width: 19.57em; display: inline-block;"><span style="width: 15.41em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(0.44em, 1015.31em, 3.67em, -1000em);"><span class="mrow" id="MathJax-Span-106"><span class="mi" id="MathJax-Span-107" style="font-family: MathJax_Math; font-style: italic;">G</span><span class="mo" id="MathJax-Span-108" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="munderover" id="MathJax-Span-109" style="padding-left: 0.27em;"><span style="width: 1.44em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(2.87em, 1001.38em, 4.61em, -1000em);"><span class="mo" id="MathJax-Span-110" style="font-family: MathJax_Size2; vertical-align: 0em;">∑</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.08em; top: -2.9em; position: absolute; clip: rect(3.35em, 1001.21em, 4.27em, -1000em);"><span class="texatom" id="MathJax-Span-111"><span class="mrow" id="MathJax-Span-112"><span class="mi" id="MathJax-Span-113" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">τ<span style="width: 0.05em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mo" id="MathJax-Span-114" style="font-family: MathJax_Main; font-size: 70.7%;">=</span><span class="mn" id="MathJax-Span-115" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.59em; top: -5.14em; position: absolute; clip: rect(3.28em, 1000.23em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-116"><span class="mrow" id="MathJax-Span-117"><span class="mi" id="MathJax-Span-118" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">t</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="msubsup" id="MathJax-Span-119" style="padding-left: 0.16em;"><span style="width: 0.91em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.48em, 4.36em, -1000em);"><span class="mi" id="MathJax-Span-120" style="font-family: MathJax_Math; font-style: italic;">g<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.47em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-121"><span class="mrow" id="MathJax-Span-122"><span class="mi" id="MathJax-Span-123" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">τ<span style="width: 0.05em; height: 1px; overflow: hidden; display: inline-block;"></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="msubsup" id="MathJax-Span-124"><span style="width: 1.1em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.48em, 4.36em, -1000em);"><span class="mi" id="MathJax-Span-125" style="font-family: MathJax_Math; font-style: italic;">g<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.53em; top: -4.33em; position: absolute; clip: rect(3.34em, 1000.57em, 4.16em, -1000em);"><span class="texatom" id="MathJax-Span-126"><span class="mrow" id="MathJax-Span-127"><span class="mi" id="MathJax-Span-128" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">T<span style="width: 0.08em; height: 1px; overflow: hidden; display: inline-block;"></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.47em; top: -3.85em; position: absolute; clip: rect(3.52em, 1000.44em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-129"><span class="mrow" id="MathJax-Span-130"><span class="mi" id="MathJax-Span-131" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">τ<span style="width: 0.05em; height: 1px; overflow: hidden; display: inline-block;"></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="texatom" id="MathJax-Span-132"><span class="mrow" id="MathJax-Span-133"><span class="mo" id="MathJax-Span-134"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>　</span></span></span></span><span class="texatom" id="MathJax-Span-135"><span class="mrow" id="MathJax-Span-136"><span class="mo" id="MathJax-Span-137"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>其</span></span></span></span><span class="texatom" id="MathJax-Span-138"><span class="mrow" id="MathJax-Span-139"><span class="mo" id="MathJax-Span-140"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>中</span></span></span></span><span class="mi" id="MathJax-Span-141" style="font-family: MathJax_Math; font-style: italic;">s</span><span class="mo" id="MathJax-Span-142" style="font-family: MathJax_Main;">.</span><span class="mi" id="MathJax-Span-143" style="padding-left: 0.16em; font-family: MathJax_Math; font-style: italic;">t</span><span class="mo" id="MathJax-Span-144" style="font-family: MathJax_Main;">.</span><span class="msubsup" id="MathJax-Span-145" style="padding-left: 0.16em;"><span style="width: 0.91em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.48em, 4.36em, -1000em);"><span class="mi" id="MathJax-Span-146" style="font-family: MathJax_Math; font-style: italic;">g<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.47em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-147"><span class="mrow" id="MathJax-Span-148"><span class="mi" id="MathJax-Span-149" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">τ<span style="width: 0.05em; height: 1px; overflow: hidden; display: inline-block;"></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-150" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="mo" id="MathJax-Span-151" style="padding-left: 0.27em; font-family: MathJax_Main;">▽</span><span class="mi" id="MathJax-Span-152" style="font-family: MathJax_Math; font-style: italic;">L</span><span class="mo" id="MathJax-Span-153" style="font-family: MathJax_Main;">(</span><span class="msubsup" id="MathJax-Span-154"><span style="width: 1.03em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.69em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-155" style="font-family: MathJax_Math; font-style: italic;">w</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.71em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-156"><span class="mrow" id="MathJax-Span-157"><span class="mi" id="MathJax-Span-158" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-159" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 3.81em; overflow: hidden; vertical-align: -1.59em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>G</mi><mo>=</mo><munderover><mo>∑</mo><mrow class="MJX-TeXAtom-ORD"><mi>τ</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi></mrow></munderover><msub><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mi>τ</mi></mrow></msub><msubsup><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mi>τ</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>T</mi></mrow></msubsup><mrow class="MJX-TeXAtom-ORD"><mo>　</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>其</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>中</mo></mrow><mi>s</mi><mo>.</mo><mi>t</mi><mo>.</mo><msub><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mi>τ</mi></mrow></msub><mo>=</mo><mo>▽</mo><mi>L</mi><mo stretchy="false">(</mo><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub><mo stretchy="false">)</mo></math></span></span></div><script id="MathJax-Element-10" type="math/tex; mode=display">G=\sum ^{t}_{\tau=1}g_{\tau} g_{\tau}^{T} 　其中 s.t. g_{\tau}=\bigtriangledown L(w_{i})</script></span> 对角线矩阵<span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-11-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>G</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><munderover><mo>&amp;#x2211;</mo><mrow class="MJX-TeXAtom-ORD"><mi>&amp;#x03C4;</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi></mrow></munderover><msubsup><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mi>&amp;#x03C4;</mi><mo>,</mo><mi>j</mi><mo>&amp;#x22C5;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></msubsup></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-160" style="width: 7.87em; display: inline-block;"><span style="width: 6.18em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(0.44em, 1006.18em, 3.67em, -1000em);"><span class="mrow" id="MathJax-Span-161"><span class="msubsup" id="MathJax-Span-162"><span style="width: 1.64em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.12em, 1000.76em, 4.18em, -1000em);"><span class="mi" id="MathJax-Span-163" style="font-family: MathJax_Math; font-style: italic;">G</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.78em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-164"><span class="mrow" id="MathJax-Span-165"><span class="mi" id="MathJax-Span-166" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">j</span><span class="mo" id="MathJax-Span-167" style="font-family: MathJax_Main; font-size: 70.7%;">,</span><span class="mi" id="MathJax-Span-168" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">j</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-169" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="munderover" id="MathJax-Span-170" style="padding-left: 0.27em;"><span style="width: 1.44em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(2.87em, 1001.38em, 4.61em, -1000em);"><span class="mo" id="MathJax-Span-171" style="font-family: MathJax_Size2; vertical-align: 0em;">∑</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.08em; top: -2.9em; position: absolute; clip: rect(3.35em, 1001.21em, 4.27em, -1000em);"><span class="texatom" id="MathJax-Span-172"><span class="mrow" id="MathJax-Span-173"><span class="mi" id="MathJax-Span-174" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">τ<span style="width: 0.05em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mo" id="MathJax-Span-175" style="font-family: MathJax_Main; font-size: 70.7%;">=</span><span class="mn" id="MathJax-Span-176" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.59em; top: -5.14em; position: absolute; clip: rect(3.28em, 1000.23em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-177"><span class="mrow" id="MathJax-Span-178"><span class="mi" id="MathJax-Span-179" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">t</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="msubsup" id="MathJax-Span-180" style="padding-left: 0.16em;"><span style="width: 1.6em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.48em, 4.36em, -1000em);"><span class="mi" id="MathJax-Span-181" style="font-family: MathJax_Math; font-style: italic;">g<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.53em; top: -4.33em; position: absolute; clip: rect(3.35em, 1000.43em, 4.16em, -1000em);"><span class="texatom" id="MathJax-Span-182"><span class="mrow" id="MathJax-Span-183"><span class="mn" id="MathJax-Span-184" style="font-family: MathJax_Main; font-size: 70.7%;">2</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.47em; top: -3.69em; position: absolute; clip: rect(3.35em, 1001.12em, 4.3em, -1000em);"><span class="texatom" id="MathJax-Span-185"><span class="mrow" id="MathJax-Span-186"><span class="mi" id="MathJax-Span-187" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">τ<span style="width: 0.05em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mo" id="MathJax-Span-188" style="font-family: MathJax_Main; font-size: 70.7%;">,</span><span class="mi" id="MathJax-Span-189" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">j</span><span class="mo" id="MathJax-Span-190" style="font-family: MathJax_Main; font-size: 70.7%;">⋅</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 3.81em; overflow: hidden; vertical-align: -1.59em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>G</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow class="MJX-TeXAtom-ORD"><mi>τ</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi></mrow></munderover><msubsup><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mi>τ</mi><mo>,</mo><mi>j</mi><mo>⋅</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></msubsup></math></span></span></div><script id="MathJax-Element-11" type="math/tex; mode=display">G_{j,j}=\sum _{\tau=1}^{t} g_{\tau,j\cdot}^{2}</script></span> 这个对角线矩阵的元素代表的是参数的出现频率.每个参数的更新<span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-12-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi></mrow></msub><mo>&amp;#x2212;</mo><mfrac><mi>&amp;#x03B7;</mi><msqrt><msub><mi>G</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mo>,</mo><mi>j</mi></mrow></msub></msqrt></mfrac><msub><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi></mrow></msub></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-191" style="width: 10.85em; display: inline-block;"><span style="width: 8.54em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(0.99em, 1008.55em, 3.65em, -1000em);"><span class="mrow" id="MathJax-Span-192"><span class="msubsup" id="MathJax-Span-193"><span style="width: 1.08em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.69em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-194" style="font-family: MathJax_Math; font-style: italic;">w</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.71em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-195"><span class="mrow" id="MathJax-Span-196"><span class="mi" id="MathJax-Span-197" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">j</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-198" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="msubsup" id="MathJax-Span-199" style="padding-left: 0.27em;"><span style="width: 1.08em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.69em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-200" style="font-family: MathJax_Math; font-style: italic;">w</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.71em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-201"><span class="mrow" id="MathJax-Span-202"><span class="mi" id="MathJax-Span-203" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">j</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-204" style="padding-left: 0.22em; font-family: MathJax_Main;">−</span><span class="mfrac" id="MathJax-Span-205" style="padding-left: 0.22em;"><span style="width: 2.78em; height: 0px; margin-right: 0.12em; margin-left: 0.12em; display: inline-block; position: relative;"><span style="left: 50%; top: -4.69em; margin-left: -0.25em; position: absolute; clip: rect(3.38em, 1000.5em, 4.37em, -1000em);"><span class="mi" id="MathJax-Span-206" style="font-family: MathJax_Math; font-style: italic;">η<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 50%; top: -3.2em; margin-left: -1.33em; position: absolute; clip: rect(3.01em, 1002.66em, 4.54em, -1000em);"><span class="msqrt" id="MathJax-Span-207"><span style="width: 2.66em; height: 0px; display: inline-block; position: relative;"><span style="left: 1em; top: -3.99em; position: absolute; clip: rect(3.12em, 1001.64em, 4.45em, -1000em);"><span class="mrow" id="MathJax-Span-208"><span class="msubsup" id="MathJax-Span-209"><span style="width: 1.64em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.12em, 1000.76em, 4.18em, -1000em);"><span class="mi" id="MathJax-Span-210" style="font-family: MathJax_Math; font-style: italic;">G</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.78em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-211"><span class="mrow" id="MathJax-Span-212"><span class="mi" id="MathJax-Span-213" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">j</span><span class="mo" id="MathJax-Span-214" style="font-family: MathJax_Main; font-size: 70.7%;">,</span><span class="mi" id="MathJax-Span-215" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">j</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 1em; top: -4.53em; position: absolute; clip: rect(3.55em, 1001.66em, 3.93em, -1000em);"><span style="width: 1.66em; height: 0px; display: inline-block; position: relative;"><span style="left: -0.08em; top: -3.99em; font-family: MathJax_Main; position: absolute;">−<span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.97em; top: -3.99em; font-family: MathJax_Main; position: absolute;">−<span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.43em; top: -3.99em; font-family: MathJax_Main; position: absolute;">−<span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0em; top: -3.95em; position: absolute; clip: rect(2.97em, 1001.02em, 4.51em, -1000em);"><span style="font-family: MathJax_Size1;">√</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0em; top: -1.28em; position: absolute; clip: rect(0.83em, 1002.78em, 1.23em, -1000em);"><span style="width: 2.78em; height: 0px; overflow: hidden; vertical-align: 0em; border-top-color: currentColor; border-top-width: 1.3px; border-top-style: solid; display: inline-block;"></span><span style="width: 0px; height: 1.06em; display: inline-block;"></span></span></span></span><span class="msubsup" id="MathJax-Span-216"><span style="width: 0.84em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.48em, 4.36em, -1000em);"><span class="mi" id="MathJax-Span-217" style="font-family: MathJax_Math; font-style: italic;">g<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.47em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-218"><span class="mrow" id="MathJax-Span-219"><span class="mi" id="MathJax-Span-220" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">j</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 3.08em; overflow: hidden; vertical-align: -1.57em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi></mrow></msub><mo>−</mo><mfrac><mi>η</mi><msqrt><msub><mi>G</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mo>,</mo><mi>j</mi></mrow></msub></msqrt></mfrac><msub><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi></mrow></msub></math></span></span></div><script id="MathJax-Element-12" type="math/tex; mode=display">w_{j}=w_{j}-\frac{\eta}{\sqrt{G_{j,j}}}g_{j}</script></span></li>
<li><strong>4.RMSprop</strong>:(root mean square propagation)也是一种自适应学习率方法．不同之处在于，Adagrad会累加之前所有的梯度平方，RMProp仅仅是计算对应的平均值．可以缓解Adagrad算法学习率下降较快的问题．<span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-13-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>v</mi><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>&amp;#x03B3;</mi><mi>v</mi><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>t</mi><mo>&amp;#x2212;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mi>&amp;#x03B3;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo>&amp;#x25BD;</mo><mi>L</mi><mo stretchy="false">(</mo><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></msup><mo>,</mo><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x5176;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x4E2D;</mo></mrow><mi>&amp;#x03B3;</mi><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x662F;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x9057;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x5FD8;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x56E0;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x5B50;</mo></mrow></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-221" style="width: 31.1em; display: inline-block;"><span style="width: 24.46em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(1.25em, 1024.46em, 2.72em, -1000em);"><span class="mrow" id="MathJax-Span-222"><span class="mi" id="MathJax-Span-223" style="font-family: MathJax_Math; font-style: italic;">v</span><span class="mo" id="MathJax-Span-224" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-225" style="font-family: MathJax_Math; font-style: italic;">w</span><span class="mo" id="MathJax-Span-226" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-227" style="padding-left: 0.16em; font-family: MathJax_Math; font-style: italic;">t</span><span class="mo" id="MathJax-Span-228" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-229" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="mi" id="MathJax-Span-230" style="padding-left: 0.27em; font-family: MathJax_Math; font-style: italic;">γ<span style="width: 0.02em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mi" id="MathJax-Span-231" style="font-family: MathJax_Math; font-style: italic;">v</span><span class="mo" id="MathJax-Span-232" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-233" style="font-family: MathJax_Math; font-style: italic;">w</span><span class="mo" id="MathJax-Span-234" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-235" style="padding-left: 0.16em; font-family: MathJax_Math; font-style: italic;">t</span><span class="mo" id="MathJax-Span-236" style="padding-left: 0.22em; font-family: MathJax_Main;">−</span><span class="mn" id="MathJax-Span-237" style="padding-left: 0.22em; font-family: MathJax_Main;">1</span><span class="mo" id="MathJax-Span-238" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-239" style="padding-left: 0.22em; font-family: MathJax_Main;">+</span><span class="mo" id="MathJax-Span-240" style="padding-left: 0.22em; font-family: MathJax_Main;">(</span><span class="mn" id="MathJax-Span-241" style="font-family: MathJax_Main;">1</span><span class="mo" id="MathJax-Span-242" style="padding-left: 0.22em; font-family: MathJax_Main;">−</span><span class="mi" id="MathJax-Span-243" style="padding-left: 0.22em; font-family: MathJax_Math; font-style: italic;">γ<span style="width: 0.02em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mo" id="MathJax-Span-244" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-245" style="font-family: MathJax_Main;">(</span><span class="mo" id="MathJax-Span-246" style="font-family: MathJax_Main;">▽</span><span class="mi" id="MathJax-Span-247" style="font-family: MathJax_Math; font-style: italic;">L</span><span class="mo" id="MathJax-Span-248" style="font-family: MathJax_Main;">(</span><span class="msubsup" id="MathJax-Span-249"><span style="width: 1.03em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.69em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-250" style="font-family: MathJax_Math; font-style: italic;">w</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.71em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-251"><span class="mrow" id="MathJax-Span-252"><span class="mi" id="MathJax-Span-253" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-254" style="font-family: MathJax_Main;">)</span><span class="msubsup" id="MathJax-Span-255"><span style="width: 0.81em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.07em, 1000.29em, 4.41em, -1000em);"><span class="mo" id="MathJax-Span-256" style="font-family: MathJax_Main;">)</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.38em; top: -4.4em; position: absolute;"><span class="texatom" id="MathJax-Span-257"><span class="mrow" id="MathJax-Span-258"><span class="mn" id="MathJax-Span-259" style="font-family: MathJax_Main; font-size: 70.7%;">2</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-260" style="font-family: MathJax_Main;">,</span><span class="texatom" id="MathJax-Span-261" style="padding-left: 0.16em;"><span class="mrow" id="MathJax-Span-262"><span class="mo" id="MathJax-Span-263"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>其</span></span></span></span><span class="texatom" id="MathJax-Span-264"><span class="mrow" id="MathJax-Span-265"><span class="mo" id="MathJax-Span-266"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>中</span></span></span></span><span class="mi" id="MathJax-Span-267" style="font-family: MathJax_Math; font-style: italic;">γ<span style="width: 0.02em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="texatom" id="MathJax-Span-268"><span class="mrow" id="MathJax-Span-269"><span class="mo" id="MathJax-Span-270"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>是</span></span></span></span><span class="texatom" id="MathJax-Span-271"><span class="mrow" id="MathJax-Span-272"><span class="mo" id="MathJax-Span-273"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>遗</span></span></span></span><span class="texatom" id="MathJax-Span-274"><span class="mrow" id="MathJax-Span-275"><span class="mo" id="MathJax-Span-276"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>忘</span></span></span></span><span class="texatom" id="MathJax-Span-277"><span class="mrow" id="MathJax-Span-278"><span class="mo" id="MathJax-Span-279"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>因</span></span></span></span><span class="texatom" id="MathJax-Span-280"><span class="mrow" id="MathJax-Span-281"><span class="mo" id="MathJax-Span-282"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>子</span></span></span></span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.58em; overflow: hidden; vertical-align: -0.38em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>v</mi><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>γ</mi><mi>v</mi><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>γ</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo>▽</mo><mi>L</mi><mo stretchy="false">(</mo><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></msup><mo>,</mo><mrow class="MJX-TeXAtom-ORD"><mo>其</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>中</mo></mrow><mi>γ</mi><mrow class="MJX-TeXAtom-ORD"><mo>是</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>遗</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>忘</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>因</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>子</mo></mrow></math></span></span></div><script id="MathJax-Element-13" type="math/tex; mode=display">v(w,t)=\gamma v(w,t-1)+(1-\gamma)(\bigtriangledown L(w_{i}))^{2}  ,其中 \gamma 是遗忘因子</script></span>　　参数更新<span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-14-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>w</mi><mo>=</mo><mi>w</mi><mo>&amp;#x2212;</mo><mfrac><mi>&amp;#x03B7;</mi><msqrt><mi>v</mi><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo></msqrt></mfrac><mo>&amp;#x25BD;</mo><mi>L</mi><mo stretchy="false">(</mo><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub><mo stretchy="false">)</mo></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-283" style="width: 15.24em; display: inline-block;"><span style="width: 11.98em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(0.99em, 1011.88em, 3.65em, -1000em);"><span class="mrow" id="MathJax-Span-284"><span class="mi" id="MathJax-Span-285" style="font-family: MathJax_Math; font-style: italic;">w</span><span class="mo" id="MathJax-Span-286" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="mi" id="MathJax-Span-287" style="padding-left: 0.27em; font-family: MathJax_Math; font-style: italic;">w</span><span class="mo" id="MathJax-Span-288" style="padding-left: 0.22em; font-family: MathJax_Main;">−</span><span class="mfrac" id="MathJax-Span-289" style="padding-left: 0.22em;"><span style="width: 3.92em; height: 0px; margin-right: 0.12em; margin-left: 0.12em; display: inline-block; position: relative;"><span style="left: 50%; top: -4.69em; margin-left: -0.25em; position: absolute; clip: rect(3.38em, 1000.5em, 4.37em, -1000em);"><span class="mi" id="MathJax-Span-290" style="font-family: MathJax_Math; font-style: italic;">η<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 50%; top: -3.15em; margin-left: -1.9em; position: absolute; clip: rect(2.96em, 1003.8em, 4.5em, -1000em);"><span class="msqrt" id="MathJax-Span-291"><span style="width: 3.8em; height: 0px; display: inline-block; position: relative;"><span style="left: 1em; top: -3.99em; position: absolute; clip: rect(3.07em, 1002.68em, 4.41em, -1000em);"><span class="mrow" id="MathJax-Span-292"><span class="mi" id="MathJax-Span-293" style="font-family: MathJax_Math; font-style: italic;">v</span><span class="mo" id="MathJax-Span-294" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-295" style="font-family: MathJax_Math; font-style: italic;">w</span><span class="mo" id="MathJax-Span-296" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-297" style="padding-left: 0.16em; font-family: MathJax_Math; font-style: italic;">t</span><span class="mo" id="MathJax-Span-298" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 1em; top: -4.57em; position: absolute; clip: rect(3.55em, 1002.8em, 3.93em, -1000em);"><span style="width: 2.8em; height: 0px; display: inline-block; position: relative;"><span style="left: -0.08em; top: -3.99em; font-family: MathJax_Main; position: absolute;">−<span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 2.1em; top: -3.99em; font-family: MathJax_Main; position: absolute;">−<span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.44em; top: -3.99em; font-family: MathJax_Main; position: absolute;">−<span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 1em; top: -3.99em; font-family: MathJax_Main; position: absolute;">−<span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 1.55em; top: -3.99em; font-family: MathJax_Main; position: absolute;">−<span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0em; top: -4em; position: absolute; clip: rect(2.97em, 1001.02em, 4.51em, -1000em);"><span style="font-family: MathJax_Size1;">√</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0em; top: -1.28em; position: absolute; clip: rect(0.83em, 1003.92em, 1.23em, -1000em);"><span style="width: 3.92em; height: 0px; overflow: hidden; vertical-align: 0em; border-top-color: currentColor; border-top-width: 1.3px; border-top-style: solid; display: inline-block;"></span><span style="width: 0px; height: 1.06em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-299" style="padding-left: 0.22em; font-family: MathJax_Main;">▽</span><span class="mi" id="MathJax-Span-300" style="padding-left: 0.22em; font-family: MathJax_Math; font-style: italic;">L</span><span class="mo" id="MathJax-Span-301" style="font-family: MathJax_Main;">(</span><span class="msubsup" id="MathJax-Span-302"><span style="width: 1.03em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.69em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-303" style="font-family: MathJax_Math; font-style: italic;">w</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.71em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-304"><span class="mrow" id="MathJax-Span-305"><span class="mi" id="MathJax-Span-306" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-307" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 3.08em; overflow: hidden; vertical-align: -1.57em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>w</mi><mo>=</mo><mi>w</mi><mo>−</mo><mfrac><mi>η</mi><msqrt><mi>v</mi><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo></msqrt></mfrac><mo>▽</mo><mi>L</mi><mo stretchy="false">(</mo><msub><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub><mo stretchy="false">)</mo></math></span></span></div><script id="MathJax-Element-14" type="math/tex; mode=display">w=w-\frac{\eta}{\sqrt{v(w,t)}}\bigtriangledown L(w_{i})</script></span></li>
<li><p><strong>5.Adam</strong>:(adaptive moment estimation)是对RMSProp优化器的更新.利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率.<br>优点:每一次迭代学习率都有一个明确的范围,使得参数变化很平稳.<br>
<span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-15-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><msub><mi>&amp;#x03B2;</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow></msub><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi></mrow></msubsup><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&amp;#x2212;</mo><msub><mi>&amp;#x03B2;</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>&amp;#x25BD;</mo><msup><mi>L</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi></mrow></msup><mo>,</mo><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x4E3A;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x4E00;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x9636;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x77E9;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x4F30;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x8BA1;</mo></mrow></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-308" style="width: 24.18em; display: inline-block;"><span style="width: 19.01em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(1.26em, 1019.01em, 2.72em, -1000em);"><span class="mrow" id="MathJax-Span-309"><span class="msubsup" id="MathJax-Span-310"><span style="width: 2.11em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.85em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-311" style="font-family: MathJax_Math; font-style: italic;">m</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.87em; top: -4.39em; position: absolute; clip: rect(3.35em, 1001.23em, 4.22em, -1000em);"><span class="texatom" id="MathJax-Span-312"><span class="mrow" id="MathJax-Span-313"><span class="mi" id="MathJax-Span-314" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">t</span><span class="mo" id="MathJax-Span-315" style="font-family: MathJax_Main; font-size: 70.7%;">+</span><span class="mn" id="MathJax-Span-316" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.87em; top: -3.84em; position: absolute; clip: rect(3.51em, 1000.58em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-317"><span class="mrow" id="MathJax-Span-318"><span class="mi" id="MathJax-Span-319" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">w</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-320" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="msubsup" id="MathJax-Span-321" style="padding-left: 0.27em;"><span style="width: 0.99em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.12em, 1000.57em, 4.35em, -1000em);"><span class="mi" id="MathJax-Span-322" style="font-family: MathJax_Math; font-style: italic;">β<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.56em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-323"><span class="mrow" id="MathJax-Span-324"><span class="mn" id="MathJax-Span-325" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="msubsup" id="MathJax-Span-326"><span style="width: 1.45em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.85em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-327" style="font-family: MathJax_Math; font-style: italic;">m</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.87em; top: -4.34em; position: absolute; clip: rect(3.38em, 1000.33em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-328"><span class="mrow" id="MathJax-Span-329"><span class="mi" id="MathJax-Span-330" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">t</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.87em; top: -3.84em; position: absolute; clip: rect(3.51em, 1000.58em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-331"><span class="mrow" id="MathJax-Span-332"><span class="mi" id="MathJax-Span-333" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">w</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-334" style="padding-left: 0.22em; font-family: MathJax_Main;">+</span><span class="mo" id="MathJax-Span-335" style="padding-left: 0.22em; font-family: MathJax_Main;">(</span><span class="mn" id="MathJax-Span-336" style="font-family: MathJax_Main;">1</span><span class="mo" id="MathJax-Span-337" style="padding-left: 0.22em; font-family: MathJax_Main;">−</span><span class="msubsup" id="MathJax-Span-338" style="padding-left: 0.22em;"><span style="width: 0.99em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.12em, 1000.57em, 4.35em, -1000em);"><span class="mi" id="MathJax-Span-339" style="font-family: MathJax_Math; font-style: italic;">β<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.56em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-340"><span class="mrow" id="MathJax-Span-341"><span class="mn" id="MathJax-Span-342" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-343" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-344" style="padding-left: 0.22em; font-family: MathJax_Main;">▽</span><span class="msubsup" id="MathJax-Span-345" style="padding-left: 0.22em;"><span style="width: 1.01em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.14em, 1000.64em, 4.16em, -1000em);"><span class="mi" id="MathJax-Span-346" style="font-family: MathJax_Math; font-style: italic;">L</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.68em; top: -4.4em; position: absolute;"><span class="texatom" id="MathJax-Span-347"><span class="mrow" id="MathJax-Span-348"><span class="mi" id="MathJax-Span-349" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">t</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-350" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-351" style="padding-left: 0.16em; font-family: MathJax_Math; font-style: italic;">m</span><span class="texatom" id="MathJax-Span-352"><span class="mrow" id="MathJax-Span-353"><span class="mo" id="MathJax-Span-354"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>为</span></span></span></span><span class="texatom" id="MathJax-Span-355"><span class="mrow" id="MathJax-Span-356"><span class="mo" id="MathJax-Span-357"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>一</span></span></span></span><span class="texatom" id="MathJax-Span-358"><span class="mrow" id="MathJax-Span-359"><span class="mo" id="MathJax-Span-360"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>阶</span></span></span></span><span class="texatom" id="MathJax-Span-361"><span class="mrow" id="MathJax-Span-362"><span class="mo" id="MathJax-Span-363"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>矩</span></span></span></span><span class="texatom" id="MathJax-Span-364"><span class="mrow" id="MathJax-Span-365"><span class="mo" id="MathJax-Span-366"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>估</span></span></span></span><span class="texatom" id="MathJax-Span-367"><span class="mrow" id="MathJax-Span-368"><span class="mo" id="MathJax-Span-369"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>计</span></span></span></span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.57em; overflow: hidden; vertical-align: -0.38em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><msub><mi>β</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow></msub><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi></mrow></msubsup><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>β</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>▽</mo><msup><mi>L</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi></mrow></msup><mo>,</mo><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mo>为</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>一</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>阶</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>矩</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>估</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>计</mo></mrow></math></span></span></div><script id="MathJax-Element-15" type="math/tex; mode=display">m_{w}^{t+1}=\beta_{1}m_{w}^{t}+(1-\beta_{1}) \bigtriangledown L^{t} ,m为一阶矩估计</script></span><br>
<span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-16-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msubsup><mi>v</mi><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><msub><mi>&amp;#x03B2;</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></msub><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi></mrow></msubsup><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&amp;#x2212;</mo><msub><mi>&amp;#x03B2;</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo>&amp;#x25BD;</mo><msup><mi>L</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi></mrow></msup><msup><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></msup><mo>,</mo><mi>v</mi><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x4E3A;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x4E8C;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x9636;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x77E9;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x4F30;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x8BA1;</mo></mrow></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-370" style="width: 24.07em; display: inline-block;"><span style="width: 18.95em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(1.25em, 1018.95em, 2.72em, -1000em);"><span class="mrow" id="MathJax-Span-371"><span class="msubsup" id="MathJax-Span-372"><span style="width: 1.71em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.46em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-373" style="font-family: MathJax_Math; font-style: italic;">v</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.48em; top: -4.39em; position: absolute; clip: rect(3.35em, 1001.23em, 4.22em, -1000em);"><span class="texatom" id="MathJax-Span-374"><span class="mrow" id="MathJax-Span-375"><span class="mi" id="MathJax-Span-376" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">t</span><span class="mo" id="MathJax-Span-377" style="font-family: MathJax_Main; font-size: 70.7%;">+</span><span class="mn" id="MathJax-Span-378" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.48em; top: -3.84em; position: absolute; clip: rect(3.51em, 1000.58em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-379"><span class="mrow" id="MathJax-Span-380"><span class="mi" id="MathJax-Span-381" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">w</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-382" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="msubsup" id="MathJax-Span-383" style="padding-left: 0.27em;"><span style="width: 0.99em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.12em, 1000.57em, 4.35em, -1000em);"><span class="mi" id="MathJax-Span-384" style="font-family: MathJax_Math; font-style: italic;">β<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.56em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-385"><span class="mrow" id="MathJax-Span-386"><span class="mn" id="MathJax-Span-387" style="font-family: MathJax_Main; font-size: 70.7%;">2</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="msubsup" id="MathJax-Span-388"><span style="width: 1.45em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.85em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-389" style="font-family: MathJax_Math; font-style: italic;">m</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.87em; top: -4.34em; position: absolute; clip: rect(3.38em, 1000.33em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-390"><span class="mrow" id="MathJax-Span-391"><span class="mi" id="MathJax-Span-392" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">t</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.87em; top: -3.84em; position: absolute; clip: rect(3.51em, 1000.58em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-393"><span class="mrow" id="MathJax-Span-394"><span class="mi" id="MathJax-Span-395" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">w</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-396" style="padding-left: 0.22em; font-family: MathJax_Main;">+</span><span class="mo" id="MathJax-Span-397" style="padding-left: 0.22em; font-family: MathJax_Main;">(</span><span class="mn" id="MathJax-Span-398" style="font-family: MathJax_Main;">1</span><span class="mo" id="MathJax-Span-399" style="padding-left: 0.22em; font-family: MathJax_Main;">−</span><span class="msubsup" id="MathJax-Span-400" style="padding-left: 0.22em;"><span style="width: 0.99em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.12em, 1000.57em, 4.35em, -1000em);"><span class="mi" id="MathJax-Span-401" style="font-family: MathJax_Math; font-style: italic;">β<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.56em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-402"><span class="mrow" id="MathJax-Span-403"><span class="mn" id="MathJax-Span-404" style="font-family: MathJax_Main; font-size: 70.7%;">2</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-405" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-406" style="font-family: MathJax_Main;">(</span><span class="mo" id="MathJax-Span-407" style="font-family: MathJax_Main;">▽</span><span class="msubsup" id="MathJax-Span-408"><span style="width: 1.01em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.14em, 1000.64em, 4.16em, -1000em);"><span class="mi" id="MathJax-Span-409" style="font-family: MathJax_Math; font-style: italic;">L</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.68em; top: -4.4em; position: absolute;"><span class="texatom" id="MathJax-Span-410"><span class="mrow" id="MathJax-Span-411"><span class="mi" id="MathJax-Span-412" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">t</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="msubsup" id="MathJax-Span-413"><span style="width: 0.81em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.07em, 1000.29em, 4.41em, -1000em);"><span class="mo" id="MathJax-Span-414" style="font-family: MathJax_Main;">)</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.38em; top: -4.4em; position: absolute;"><span class="texatom" id="MathJax-Span-415"><span class="mrow" id="MathJax-Span-416"><span class="mn" id="MathJax-Span-417" style="font-family: MathJax_Main; font-size: 70.7%;">2</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-418" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-419" style="padding-left: 0.16em; font-family: MathJax_Math; font-style: italic;">v</span><span class="texatom" id="MathJax-Span-420"><span class="mrow" id="MathJax-Span-421"><span class="mo" id="MathJax-Span-422"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>为</span></span></span></span><span class="texatom" id="MathJax-Span-423"><span class="mrow" id="MathJax-Span-424"><span class="mo" id="MathJax-Span-425"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>二</span></span></span></span><span class="texatom" id="MathJax-Span-426"><span class="mrow" id="MathJax-Span-427"><span class="mo" id="MathJax-Span-428"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>阶</span></span></span></span><span class="texatom" id="MathJax-Span-429"><span class="mrow" id="MathJax-Span-430"><span class="mo" id="MathJax-Span-431"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>矩</span></span></span></span><span class="texatom" id="MathJax-Span-432"><span class="mrow" id="MathJax-Span-433"><span class="mo" id="MathJax-Span-434"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>估</span></span></span></span><span class="texatom" id="MathJax-Span-435"><span class="mrow" id="MathJax-Span-436"><span class="mo" id="MathJax-Span-437"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>计</span></span></span></span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.58em; overflow: hidden; vertical-align: -0.38em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msubsup><mi>v</mi><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><msub><mi>β</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></msub><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi></mrow></msubsup><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>β</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo>▽</mo><msup><mi>L</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi></mrow></msup><msup><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></msup><mo>,</mo><mi>v</mi><mrow class="MJX-TeXAtom-ORD"><mo>为</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>二</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>阶</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>矩</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>估</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>计</mo></mrow></math></span></span></div><script id="MathJax-Element-16" type="math/tex; mode=display">v_{w}^{t+1}=\beta_{2}m_{w}^{t}+(1-\beta_{2}) (\bigtriangledown L^{t})^{2},v为二阶矩估计</script></span><br>
<span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-17-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mrow class="MJX-TeXAtom-ORD"><mover><mi>m</mi><mo stretchy="false">&amp;#x005E;</mo></mover></mrow><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow></msub><mo>=</mo><mfrac><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mrow><mn>1</mn><mo>&amp;#x2212;</mo><msubsup><mi>&amp;#x03B2;</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow></mfrac><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#xFF0C;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x4F30;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x8BA1;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x6821;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x6B63;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#xFF0C;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x5B9E;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x73B0;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x65E0;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x504F;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x4F30;</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>&amp;#x8BA1;</mo></mrow></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-438" style="width: 20.58em; display: inline-block;"><span style="width: 16.19em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(0.58em, 1016.19em, 3.63em, -1000em);"><span class="mrow" id="MathJax-Span-439"><span class="msubsup" id="MathJax-Span-440"><span style="width: 1.45em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.07em, 1000.85em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-441"><span class="mrow" id="MathJax-Span-442"><span class="munderover" id="MathJax-Span-443"><span style="width: 0.87em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.85em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-444" style="font-family: MathJax_Math; font-style: italic;">m</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.18em; top: -4.04em; position: absolute; clip: rect(3.13em, 1000.38em, 3.63em, -1000em);"><span class="mo" id="MathJax-Span-445" style="font-family: MathJax_Main;">^</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.87em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-446"><span class="mrow" id="MathJax-Span-447"><span class="mi" id="MathJax-Span-448" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">w</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-449" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="mfrac" id="MathJax-Span-450" style="padding-left: 0.27em;"><span style="width: 3.69em; height: 0px; margin-right: 0.12em; margin-left: 0.12em; display: inline-block; position: relative;"><span style="left: 50%; top: -4.67em; margin-left: -1.05em; position: absolute; clip: rect(2.95em, 1002.11em, 4.31em, -1000em);"><span class="msubsup" id="MathJax-Span-451"><span style="width: 2.11em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.85em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-452" style="font-family: MathJax_Math; font-style: italic;">m</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.87em; top: -4.39em; position: absolute; clip: rect(3.35em, 1001.23em, 4.22em, -1000em);"><span class="texatom" id="MathJax-Span-453"><span class="mrow" id="MathJax-Span-454"><span class="mi" id="MathJax-Span-455" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">t</span><span class="mo" id="MathJax-Span-456" style="font-family: MathJax_Main; font-size: 70.7%;">+</span><span class="mn" id="MathJax-Span-457" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.87em; top: -3.84em; position: absolute; clip: rect(3.51em, 1000.58em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-458"><span class="mrow" id="MathJax-Span-459"><span class="mi" id="MathJax-Span-460" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">w</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 50%; top: -3.13em; margin-left: -1.78em; position: absolute; clip: rect(2.95em, 1003.57em, 4.46em, -1000em);"><span class="mrow" id="MathJax-Span-461"><span class="mn" id="MathJax-Span-462" style="font-family: MathJax_Main;">1</span><span class="mo" id="MathJax-Span-463" style="padding-left: 0.22em; font-family: MathJax_Main;">−</span><span class="msubsup" id="MathJax-Span-464" style="padding-left: 0.22em;"><span style="width: 1.85em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.12em, 1000.57em, 4.35em, -1000em);"><span class="mi" id="MathJax-Span-465" style="font-family: MathJax_Math; font-style: italic;">β<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.62em; top: -4.39em; position: absolute; clip: rect(3.35em, 1001.23em, 4.22em, -1000em);"><span class="texatom" id="MathJax-Span-466"><span class="mrow" id="MathJax-Span-467"><span class="mi" id="MathJax-Span-468" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">t</span><span class="mo" id="MathJax-Span-469" style="font-family: MathJax_Main; font-size: 70.7%;">+</span><span class="mn" id="MathJax-Span-470" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.56em; top: -3.68em; position: absolute; clip: rect(3.35em, 1000.43em, 4.16em, -1000em);"><span class="texatom" id="MathJax-Span-471"><span class="mrow" id="MathJax-Span-472"><span class="mn" id="MathJax-Span-473" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0em; top: -1.28em; position: absolute; clip: rect(0.83em, 1003.69em, 1.23em, -1000em);"><span style="width: 3.69em; height: 0px; overflow: hidden; vertical-align: 0em; border-top-color: currentColor; border-top-width: 1.3px; border-top-style: solid; display: inline-block;"></span><span style="width: 0px; height: 1.06em; display: inline-block;"></span></span></span></span><span class="texatom" id="MathJax-Span-474"><span class="mrow" id="MathJax-Span-475"><span class="mo" id="MathJax-Span-476"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>，</span></span></span></span><span class="texatom" id="MathJax-Span-477"><span class="mrow" id="MathJax-Span-478"><span class="mo" id="MathJax-Span-479"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>估</span></span></span></span><span class="texatom" id="MathJax-Span-480"><span class="mrow" id="MathJax-Span-481"><span class="mo" id="MathJax-Span-482"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>计</span></span></span></span><span class="texatom" id="MathJax-Span-483"><span class="mrow" id="MathJax-Span-484"><span class="mo" id="MathJax-Span-485"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>校</span></span></span></span><span class="texatom" id="MathJax-Span-486"><span class="mrow" id="MathJax-Span-487"><span class="mo" id="MathJax-Span-488"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>正</span></span></span></span><span class="texatom" id="MathJax-Span-489"><span class="mrow" id="MathJax-Span-490"><span class="mo" id="MathJax-Span-491"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>，</span></span></span></span><span class="texatom" id="MathJax-Span-492"><span class="mrow" id="MathJax-Span-493"><span class="mo" id="MathJax-Span-494"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>实</span></span></span></span><span class="texatom" id="MathJax-Span-495"><span class="mrow" id="MathJax-Span-496"><span class="mo" id="MathJax-Span-497"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>现</span></span></span></span><span class="texatom" id="MathJax-Span-498"><span class="mrow" id="MathJax-Span-499"><span class="mo" id="MathJax-Span-500"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>无</span></span></span></span><span class="texatom" id="MathJax-Span-501"><span class="mrow" id="MathJax-Span-502"><span class="mo" id="MathJax-Span-503"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>偏</span></span></span></span><span class="texatom" id="MathJax-Span-504"><span class="mrow" id="MathJax-Span-505"><span class="mo" id="MathJax-Span-506"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>估</span></span></span></span><span class="texatom" id="MathJax-Span-507"><span class="mrow" id="MathJax-Span-508"><span class="mo" id="MathJax-Span-509"><span style='font-family: STIXGeneral,"Arial Unicode MS",serif; font-size: 79%; font-style: normal; font-weight: normal;'>计</span></span></span></span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 3.58em; overflow: hidden; vertical-align: -1.54em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mrow class="MJX-TeXAtom-ORD"><mover><mi>m</mi><mo stretchy="false">^</mo></mover></mrow><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow></msub><mo>=</mo><mfrac><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mrow><mn>1</mn><mo>−</mo><msubsup><mi>β</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow></mfrac><mrow class="MJX-TeXAtom-ORD"><mo>，</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>估</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>计</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>校</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>正</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>，</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>实</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>现</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>无</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>偏</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>估</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>计</mo></mrow></math></span></span></div><script id="MathJax-Element-17" type="math/tex; mode=display">\hat{m}_{w}=\frac{m_{w}^{t+1}}{1-\beta_{1}^{t+1}}，估计校正，实现无偏估计</script></span><br>
<span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-18-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mrow class="MJX-TeXAtom-ORD"><mover><mi>v</mi><mo stretchy="false">&amp;#x005E;</mo></mover></mrow><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow></msub><mo>=</mo><mfrac><msubsup><mi>v</mi><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mrow><mn>1</mn><mo>&amp;#x2212;</mo><msubsup><mi>&amp;#x03B2;</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow></mfrac></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-510" style="width: 8.1em; display: inline-block;"><span style="width: 6.35em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(0.58em, 1006.35em, 3.63em, -1000em);"><span class="mrow" id="MathJax-Span-511"><span class="msubsup" id="MathJax-Span-512"><span style="width: 1.1em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.07em, 1000.47em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-513"><span class="mrow" id="MathJax-Span-514"><span class="munderover" id="MathJax-Span-515"><span style="width: 0.52em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.46em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-516" style="font-family: MathJax_Math; font-style: italic;">v</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.02em; top: -4.04em; position: absolute; clip: rect(3.13em, 1000.38em, 3.63em, -1000em);"><span class="mo" id="MathJax-Span-517" style="font-family: MathJax_Main;">^</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.52em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-518"><span class="mrow" id="MathJax-Span-519"><span class="mi" id="MathJax-Span-520" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">w</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-521" style="padding-left: 0.27em; font-family: MathJax_Main;">=</span><span class="mfrac" id="MathJax-Span-522" style="padding-left: 0.27em;"><span style="width: 3.69em; height: 0px; margin-right: 0.12em; margin-left: 0.12em; display: inline-block; position: relative;"><span style="left: 50%; top: -4.67em; margin-left: -0.85em; position: absolute; clip: rect(2.95em, 1001.72em, 4.31em, -1000em);"><span class="msubsup" id="MathJax-Span-523"><span style="width: 1.71em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.46em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-524" style="font-family: MathJax_Math; font-style: italic;">v</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.48em; top: -4.39em; position: absolute; clip: rect(3.35em, 1001.23em, 4.22em, -1000em);"><span class="texatom" id="MathJax-Span-525"><span class="mrow" id="MathJax-Span-526"><span class="mi" id="MathJax-Span-527" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">t</span><span class="mo" id="MathJax-Span-528" style="font-family: MathJax_Main; font-size: 70.7%;">+</span><span class="mn" id="MathJax-Span-529" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.48em; top: -3.84em; position: absolute; clip: rect(3.51em, 1000.58em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-530"><span class="mrow" id="MathJax-Span-531"><span class="mi" id="MathJax-Span-532" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">w</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 50%; top: -3.13em; margin-left: -1.78em; position: absolute; clip: rect(2.95em, 1003.57em, 4.46em, -1000em);"><span class="mrow" id="MathJax-Span-533"><span class="mn" id="MathJax-Span-534" style="font-family: MathJax_Main;">1</span><span class="mo" id="MathJax-Span-535" style="padding-left: 0.22em; font-family: MathJax_Main;">−</span><span class="msubsup" id="MathJax-Span-536" style="padding-left: 0.22em;"><span style="width: 1.85em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.12em, 1000.57em, 4.35em, -1000em);"><span class="mi" id="MathJax-Span-537" style="font-family: MathJax_Math; font-style: italic;">β<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.62em; top: -4.39em; position: absolute; clip: rect(3.35em, 1001.23em, 4.22em, -1000em);"><span class="texatom" id="MathJax-Span-538"><span class="mrow" id="MathJax-Span-539"><span class="mi" id="MathJax-Span-540" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">t</span><span class="mo" id="MathJax-Span-541" style="font-family: MathJax_Main; font-size: 70.7%;">+</span><span class="mn" id="MathJax-Span-542" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.56em; top: -3.68em; position: absolute; clip: rect(3.35em, 1000.43em, 4.16em, -1000em);"><span class="texatom" id="MathJax-Span-543"><span class="mrow" id="MathJax-Span-544"><span class="mn" id="MathJax-Span-545" style="font-family: MathJax_Main; font-size: 70.7%;">2</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0em; top: -1.28em; position: absolute; clip: rect(0.83em, 1003.69em, 1.23em, -1000em);"><span style="width: 3.69em; height: 0px; overflow: hidden; vertical-align: 0em; border-top-color: currentColor; border-top-width: 1.3px; border-top-style: solid; display: inline-block;"></span><span style="width: 0px; height: 1.06em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 3.58em; overflow: hidden; vertical-align: -1.54em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mrow class="MJX-TeXAtom-ORD"><mover><mi>v</mi><mo stretchy="false">^</mo></mover></mrow><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow></msub><mo>=</mo><mfrac><msubsup><mi>v</mi><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mrow><mn>1</mn><mo>−</mo><msubsup><mi>β</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow></mfrac></math></span></span></div><script id="MathJax-Element-18" type="math/tex; mode=display">\hat{v}_{w}=\frac{v_{w}^{t+1}}{1-\beta_{2}^{t+1}}</script></span><br>
<span class="math display"><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span tabindex="0" class="MathJax" id="MathJax-Element-19-Frame" role="presentation" style="text-align: center; position: relative;" data-mathml='<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">&amp;#x2190;=</mo><msup><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi></mrow></msup><mo>&amp;#x2212;</mo><mi>&amp;#x03B7;</mi><mfrac><msub><mrow class="MJX-TeXAtom-ORD"><mover><mi>m</mi><mo stretchy="false">&amp;#x005E;</mo></mover></mrow><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow></msub><mrow><msqrt><msub><mrow class="MJX-TeXAtom-ORD"><mover><mi>v</mi><mo stretchy="false">&amp;#x005E;</mo></mover></mrow><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow></msub></msqrt><mo>+</mo><mi>&amp;#x03F5;</mi></mrow></mfrac></math>'><nobr aria-hidden="true"><span class="math" id="MathJax-Span-546" style="width: 14.28em; display: inline-block;"><span style="width: 11.24em; height: 0px; font-size: 127%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.3em; position: absolute; clip: rect(0.71em, 1011.25em, 3.65em, -1000em);"><span class="mrow" id="MathJax-Span-547"><span class="msubsup" id="MathJax-Span-548"><span style="width: 1.95em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.69em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-549" style="font-family: MathJax_Math; font-style: italic;">w</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.71em; top: -4.4em; position: absolute;"><span class="texatom" id="MathJax-Span-550"><span class="mrow" id="MathJax-Span-551"><span class="mi" id="MathJax-Span-552" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">t</span><span class="mo" id="MathJax-Span-553" style="font-family: MathJax_Main; font-size: 70.7%;">+</span><span class="mn" id="MathJax-Span-554" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-555" style="padding-left: 0.27em; font-family: MathJax_Main;">←<span style="font-family: MathJax_Main; font-style: normal; font-weight: normal;">=</span></span><span class="msubsup" id="MathJax-Span-556" style="padding-left: 0.27em;"><span style="width: 1.04em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.69em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-557" style="font-family: MathJax_Math; font-style: italic;">w</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.71em; top: -4.4em; position: absolute;"><span class="texatom" id="MathJax-Span-558"><span class="mrow" id="MathJax-Span-559"><span class="mi" id="MathJax-Span-560" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">t</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-561" style="padding-left: 0.22em; font-family: MathJax_Main;">−</span><span class="mi" id="MathJax-Span-562" style="padding-left: 0.22em; font-family: MathJax_Math; font-style: italic;">η<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mfrac" id="MathJax-Span-563"><span style="width: 3.96em; height: 0px; margin-right: 0.12em; margin-left: 0.12em; display: inline-block; position: relative;"><span style="left: 50%; top: -4.67em; margin-left: -0.73em; position: absolute; clip: rect(3.07em, 1001.46em, 4.32em, -1000em);"><span class="msubsup" id="MathJax-Span-564"><span style="width: 1.45em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.07em, 1000.85em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-565"><span class="mrow" id="MathJax-Span-566"><span class="munderover" id="MathJax-Span-567"><span style="width: 0.87em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.85em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-568" style="font-family: MathJax_Math; font-style: italic;">m</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.18em; top: -4.04em; position: absolute; clip: rect(3.13em, 1000.38em, 3.63em, -1000em);"><span class="mo" id="MathJax-Span-569" style="font-family: MathJax_Main;">^</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.87em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-570"><span class="mrow" id="MathJax-Span-571"><span class="mi" id="MathJax-Span-572" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">w</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 50%; top: -3.11em; margin-left: -1.92em; position: absolute; clip: rect(2.92em, 1003.81em, 4.46em, -1000em);"><span class="mrow" id="MathJax-Span-573"><span class="msqrt" id="MathJax-Span-574"><span style="width: 2.21em; height: 0px; display: inline-block; position: relative;"><span style="left: 1em; top: -3.99em; position: absolute; clip: rect(3.07em, 1001.11em, 4.32em, -1000em);"><span class="mrow" id="MathJax-Span-575"><span class="msubsup" id="MathJax-Span-576"><span style="width: 1.1em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.07em, 1000.47em, 4.17em, -1000em);"><span class="texatom" id="MathJax-Span-577"><span class="mrow" id="MathJax-Span-578"><span class="munderover" id="MathJax-Span-579"><span style="width: 0.52em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -3.99em; position: absolute; clip: rect(3.38em, 1000.46em, 4.17em, -1000em);"><span class="mi" id="MathJax-Span-580" style="font-family: MathJax_Math; font-style: italic;">v</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.02em; top: -4.04em; position: absolute; clip: rect(3.13em, 1000.38em, 3.63em, -1000em);"><span class="mo" id="MathJax-Span-581" style="font-family: MathJax_Main;">^</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.52em; top: -3.84em; position: absolute;"><span class="texatom" id="MathJax-Span-582"><span class="mrow" id="MathJax-Span-583"><span class="mi" id="MathJax-Span-584" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">w</span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 1em; top: -4.62em; position: absolute; clip: rect(3.55em, 1001.21em, 3.93em, -1000em);"><span style="width: 1.21em; height: 0px; display: inline-block; position: relative;"><span style="left: -0.08em; top: -3.99em; font-family: MathJax_Main; position: absolute;">−<span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0.52em; top: -3.99em; font-family: MathJax_Main; position: absolute;">−<span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0em; top: -4.04em; position: absolute; clip: rect(2.97em, 1001.02em, 4.51em, -1000em);"><span style="font-family: MathJax_Size1;">√</span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-585" style="padding-left: 0.22em; font-family: MathJax_Main;">+</span><span class="mi" id="MathJax-Span-586" style="padding-left: 0.22em; font-family: MathJax_Math; font-style: italic;">ϵ</span></span><span style="width: 0px; height: 3.99em; display: inline-block;"></span></span><span style="left: 0em; top: -1.28em; position: absolute; clip: rect(0.83em, 1003.96em, 1.23em, -1000em);"><span style="width: 3.96em; height: 0px; overflow: hidden; vertical-align: 0em; border-top-color: currentColor; border-top-width: 1.3px; border-top-style: solid; display: inline-block;"></span><span style="width: 0px; height: 1.06em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 2.3em; display: inline-block;"></span></span></span><span style="width: 0px; height: 3.44em; overflow: hidden; vertical-align: -1.57em; border-left-color: currentColor; border-left-width: 0px; border-left-style: solid; display: inline-block;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">←=</mo><msup><mi>w</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi></mrow></msup><mo>−</mo><mi>η</mi><mfrac><msub><mrow class="MJX-TeXAtom-ORD"><mover><mi>m</mi><mo stretchy="false">^</mo></mover></mrow><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow></msub><mrow><msqrt><msub><mrow class="MJX-TeXAtom-ORD"><mover><mi>v</mi><mo stretchy="false">^</mo></mover></mrow><mrow class="MJX-TeXAtom-ORD"><mi>w</mi></mrow></msub></msqrt><mo>+</mo><mi>ϵ</mi></mrow></mfrac></math></span></span></div><script id="MathJax-Element-19" type="math/tex; mode=display">w^{t+1} \leftarrow=w^{t}-\eta \frac{\hat{m}_{w}}{\sqrt{\hat{v}_{w}}+\epsilon}</script></span><br>
<font color="red" size="4">Adam是实际学习中最常用的算法</font> <br></p></li>
</ul>
<h4 id="优化方法在实际中的直观体验">优化方法在实际中的直观体验</h4>
<p><img src="https://img2018.cnblogs.com/blog/1425630/201809/1425630-20180917092038787-2101213597.gif"></p>
<h5 id="损失曲面的轮廓和不同优化算法的时间演化-注意基于动量的方法的过冲行为这使得优化看起来像一个滚下山的球">损失曲面的轮廓和不同优化算法的时间演化。 注意基于动量的方法的“过冲”行为，这使得优化看起来像一个滚下山的球</h5>
<p><img src="https://img2018.cnblogs.com/blog/1425630/201809/1425630-20180917092153639-1928194678.gif"></p>
<h5 id="优化环境中鞍点的可视化其中沿不同维度的曲率具有不同的符号一维向上弯曲另一维向下-请注意sgd很难打破对称性并陷入困境-相反诸如rmsprop之类的算法将在鞍座方向上看到非常低的梯度-由于rmsprop更新中的分母术语这将提高此方向的有效学习率从而帮助rmsprop继续进行.">优化环境中鞍点的可视化，其中沿不同维度的曲率具有不同的符号（一维向上弯曲，另一维向下）。 请注意，SGD很难打破对称性并陷入困境。 相反，诸如RMSprop之类的算法将在鞍座方向上看到非常低的梯度。 由于RMSprop更新中的分母术语，这将提高此方向的有效学习率，从而帮助RMSProp继续进行.</h5>
<h4 id="参考文献">参考文献：</h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent">wiki-Stochastic gradient descent</a></li>
<li><a href="http://cs231n.github.io/neural-networks-3/">cs231n-lecture6,notes3:Parameter updates</a></li>
</ul>
</div>]]></description></item><item><title>2019中国计算机学会推荐国际学术会议和期刊</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/06/11142891.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Sat, 06 Jul 2019 07:33:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/06/11142891.html</guid><description><![CDATA[![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190706152821163-944374406.png)
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190706152846171-2143452227.png)
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190706152856002-1329246988.png)
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190706152907686-315205676.png)
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190706152917719-1582659060.png)
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190706152928488-1593493999.png)
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190706152936698-1231512314.png)
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190706152945370-410264299.png)
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190706152953163-520978888.png)
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190706153001116-2113581262.png)
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190706153012035-1430773050.png)
#### 推荐论文
ML会议：NIPS,ICML,UAI,AISTATS;期刊：JMLR,ML,Trends in ML,IEEE T-NN
CV会议：ICCV,CVPR,ECCV;期刊：IEEE T-PAMI,IJCV,IEEE T-IP
AI会议：IJCAI,AIII;期刊：ACL]]></description></item><item><title>NLP（十五） 聊天机器人</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_15.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 05 Jul 2019 08:34:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_15.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp15/
+ 对话引擎
1.了解目标用户
2.理解用于沟通得语言
3.了解用户的意图
4.应答用户，并给出进一步线索
+ NLTK中的引擎
`eliza,iesha,rude,suntsu,zen`
```
import nltk

def builtinEngines(whichOne): # 测试自带的聊天机器人
    if whichOne == 'eliza':
        nltk.chat.eliza.demo()
    elif whichOne == 'iesha':
        nltk.chat.iesha.demo()
    elif whichOne == 'rude':
        nltk.chat.rude.demo()
    elif whichOne == 'suntsu':
        nltk.chat.suntsu.demo()
    elif whichOne == 'zen':
        nltk.chat.zen.demo()
    else:
        print('unknown built-in chat engine {}'.format(whichOne))

def myEngine(): # 自己的简单对话机器人
    chatpairs = (
        (r"(.*?)Stock price(.*)",
         ("Today stock price is 100",
          "I am unable to find out the stock price.")),
        (r"(.*?)not well(.*)",
         ("Oh, take care. May be you should cisit a doctor",
          "Did you take some medicine ?")),
        (r"(.*?)raining(.*)",
         ("It's monsoon season, what more do you expect ?",
          "Yes, it's good for farmers")),
        (r"How(.*?)health(.*)",
         ("I am always healthy.",
          "I am a program, super healthy!")),
        (r".*",
         ("I am good. How are you today ?",
          "What brings you here ?"))
    )
    def chat():
        print('!'*60)
        print(' >> my Engine << ')
        print('Talk to the program using normal english')
        print('='*60)
        print("Enter 'quit' when done")
        chatbot = nltk.chat.util.Chat(chatpairs,nltk.chat.util.reflections)
        chatbot.converse()
    chat()

if __name__ == "__main__":
    myEngine()
    for engine in ['eliza','iesha','rude','suntsu','zen']:
        print("=== demo of {} ===".format(engine))
        builtinEngines(engine)
        print()
```]]></description></item><item><title>NLP（十四） 情感分析</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_14.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 05 Jul 2019 08:32:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_14.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp14/
+ 情感在自然语言中的表达方式

| 例句 | 解释 |
| --- | --- |
| I am very happy | 开心的情感  |
| She is so :( | 表达悲伤的图标 |
```
import nltk
import nltk.sentiment.sentiment_analyzer

def wordBasedSentiment():
    positive_words = ['love','hope','joy']
    text = 'Rainfall this year brings lot of hope and joy to Farmers.'.split()
    analysis = nltk.sentiment.util.extract_unigram_feats(text,positive_words)
    # 查看text中是否含positive_words中的单词
    print('-- single word sentiment --')
    print(analysis)

def multiWordBasedSentiment():
    word_sets = [('heavy','rains'),('flood','bengaluru')]
    text = 'heavy rains cause flash flooding in bengaluru'.split()
    analysis = nltk.sentiment.util.extract_bigram_feats(text,word_sets)
    # 查看text中是否含word_sets中的单词集
    print('-- multi word sentiment --')
    print(analysis)

def markNegativity():
    text = 'Rainfall last year did not bring joy to Farmers'.split()
    negation = nltk.sentiment.util.mark_negation(text) # 负向性单词分析
    print('-- negativity --')
    print(negation)
    
if __name__ == "__main__":
    wordBasedSentiment()
    multiWordBasedSentiment()
    markNegativity()
```
输出：
```
-- single word sentiment --
{'contains(love)': False, 'contains(hope)': True, 'contains(joy)': True}
-- multi word sentiment --
{'contains(heavy - rains)': True, 'contains(flood - bengaluru)': False}
-- negativity --
['Rainfall', 'last', 'year', 'did', 'not', 'bring_NEG', 'joy_NEG', 'to_NEG', 'Farmers_NEG']
```
+ 高阶情感分析
```
import nltk
import nltk.sentiment.util
import nltk.sentiment.sentiment_analyzer
from nltk.sentiment.vader import SentimentIntensityAnalyzer

def mySentimentAnalyzer():
    def score_feedback(text): # 输入句子 输出得分 1正 0中性 -1负
        # 优先级 -1 => +1 => 0
        positive_words = ['love','genuine','liked']
        # 先用函数标记，如果词标记了_NEG，得分为-1
        if '_NEG' in ' '.join(nltk.sentiment.util.mark_negation(text.split())):
            score = -1
        else:
            analysis = nltk.sentiment.util.extract_unigram_feats(text.split(),positive_words)
            if True in analysis.values(): # 如果存在文本存在正向词
                score = 1
            else:
                score = 0
        return score

    feedback = """I love the items in this shop, very genuine and quality is well maintained.
    I have visited this shop and had samosa, my friends liked it very much.
    ok average food in this shop.
    Fridays are very busy in this shop, do not place orders during this day."""
    print('-- custom scorer --')
    for text in feedback.split('\n'): # 分句遍历
        print('score = {} for >> {}'.format(score_feedback(text),text))

def advancedSentimentAnalyzer():
    sentences = [
        ':)',
        ':(',
        'she is so :(',
        'I love the way cricket is played by the champions',
        'She neither likes coffee or tea',
    ]
    senti = SentimentIntensityAnalyzer()
    print('-- built-in intensity analyser --')
    for sentence in sentences:
        print('[{}]'.format(sentence),end=' --> ') # 打印每个句子
        kvp = senti.polarity_scores(sentence) # 处理句子，得到各种得分得字典
        for k in kvp: # 遍历字典
            print('{} = {}, '.format(k,kvp[k]),end='')
        print()

if __name__ == "__main__":
    mySentimentAnalyzer()
    advancedSentimentAnalyzer()
```
输出：
```
-- custom scorer --
score = 1 for >> I love the items in this shop, very genuine and quality is well maintained.
score = 1 for >>     I have visited this shop and had samosa, my friends liked it very much.
score = 0 for >>     ok average food in this shop.
score = -1 for >>     Fridays are very busy in this shop, do not place orders during this day.
-- built-in intensity analyser --
[:)] --> neg = 0.0, neu = 0.0, pos = 1.0, compound = 0.4588, 
[:(] --> neg = 1.0, neu = 0.0, pos = 0.0, compound = -0.4404, 
[she is so :(] --> neg = 0.555, neu = 0.445, pos = 0.0, compound = -0.5777, 
[I love the way cricket is played by the champions] --> neg = 0.0, neu = 0.375, pos = 0.625, compound = 0.875, 
[She neither likes coffee or tea] --> neg = 0.318, neu = 0.682, pos = 0.0, compound = -0.3252, 
```]]></description></item><item><title>NLP（十三） 词义消歧</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_13.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 05 Jul 2019 08:31:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_13.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp13/
+ 一个词可能有多个词义

| 例句 | 解释 |
| --- | --- |
| She is my date | date: 约会，日期 |
| You have taken too many leaves to skip cleaning leaves in the garden | leave：休息，树叶 |
用Lesk算法
+ 代码
```
import nltk

def understandWordSenseExamples():
    words = ['wind','date','left']
    print('-- examples --')
    for word in words:
        syns = nltk.corpus.wordnet.synsets(word)
        for syn in syns[:2]:
            for example in syn.examples()[:2]:
                print('{} -> {} -> {}'.format(word,syn.name(),example))
                # 打印 : 单词 -> 同义词集 -> 例句

def understandBuiltinWSD():
    print('-- built-in wsd --')
    maps = [
        ('It is the fish net that you are using to catch fish ?','fish','n'),
        ('Please dont point your finger at others.','point','n'),
        ('I went to the river bank to see the sun rise','bank','n'),
    ]
    for m in maps:
        print("Sense '{}' for '{}' -> '{}'".format(m[0],m[1],nltk.wsd.lesk(m[0],m[1],m[2])))

if __name__ == "__main__":
    understandWordSenseExamples()
    understandBuiltinWSD()
```
输出：
```
-- examples --
wind -> wind.n.01 -> trees bent under the fierce winds
wind -> wind.n.01 -> when there is no wind, row
wind -> wind.n.02 -> the winds of change
date -> date.n.01 -> what is the date today?
date -> date.n.02 -> his date never stopped talking
left -> left.n.01 -> she stood on the left
-- built-in wsd --
Sense 'It is the fish net that you are using to catch fish ?' for 'fish' -> 'Synset('pisces.n.02')'
Sense 'Please dont point your finger at others.' for 'point' -> 'Synset('point.n.25')'
Sense 'I went to the river bank to see the sun rise' for 'bank' -> 'Synset('savings_bank.n.02')'
```]]></description></item><item><title>NLP（十二）指代消解</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_12.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 05 Jul 2019 08:29:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_12.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp12/
+ 代词是用来代替重复出现的名词
例句：
1.Ravi is a boy. He often donates money to the poor.
先出现主语，后出现代词，所以流动的方向从左到右，这类句子叫回指(Anaphora)
2.He was already on his way to airport.Realized Ravi.
这种句子表达的方式的逆序的，这类句子叫预指(Cataphora)
+ 代码
```
import nltk
from nltk.chunk import tree2conlltags
from nltk.corpus import names # 有 人名和性别 标签
import random

class AnaphoraExample:
    def __init__(self): # 不需要参数就能构造
        males = [(name,'male') for name in names.words('male.txt')]
        females = [(name,'female') for name in names.words('female.txt')]
        combined = males + females # 列表元素：人名和性别构成的元组
        random.shuffle(combined)
        # print(combined)
        training = [(self.feature(name),gender) for (name,gender) in combined]
        self._classifier = nltk.NaiveBayesClassifier.train(training) # 分类器

    def feature(self,word): # 单词最后一个字母当特征
        return {'last(1)' : word[-1]}

    def gender(self,word): # 返回单词放到分类器中得到的性别标签
        return self._classifier.classify(self.feature(word))

    def learnAnaphora(self):
        sentences = [
            "John is a man. He walks",
            "John and Mary are married. They have two kids",
            "In order for Ravi to be successful, he should follow John",
            "John met Mary in Barista. She asked him to order a Pizza",
        ]

        for sent in sentences:
            chunks = nltk.ne_chunk(nltk.pos_tag(nltk.word_tokenize(sent)),binary=False)
            # 实现分词，词性标注，组块(实体)抽取，返回组块树结果，赋给chunks
            stack = []
            print(sent)
            items = tree2conlltags(chunks) # 将一个句子展平成一个列表，并以IOB格式表示
            for item in items:
                if item[1] == 'NNP' and (item[2] == 'B-PERSON' or item[2] == '0'): # 人名
                    stack.append((item[0],self.gender(item[0]))) # 人名和性别的元组
                elif item[1] == 'CC': # 连词
                    stack.append(item[0])
                elif item[1] == 'PRP': # 人称代词
                    stack.append(item[0])
            print('\t{}'.format(stack))

if __name__ == "__main__":
    anaphora = AnaphoraExample()
    anaphora.learnAnaphora()
```
输出：
```
John is a man. He walks
	[('John', 'male'), 'He']
John and Mary are married. They have two kids
	[('John', 'male'), 'and', ('Mary', 'female'), 'They']
In order for Ravi to be successful, he should follow John
	[('Ravi', 'female'), 'he', ('John', 'male')]
John met Mary in Barista. She asked him to order a Pizza
	[('John', 'male'), ('Mary', 'female'), 'She', 'him']
```]]></description></item><item><title>NLP（十一） 提取文本摘要</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_11.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 05 Jul 2019 08:28:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_11.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp11/
+ gensim.summarization库的函数
gensim.summarization.summarize(text, ratio=0.2, word_count=None, split=False)
    Parameters（参数）：
    text : str
        Given text.
    ratio : float, optional
        Number between 0 and 1 that determines the proportion of the number of
        sentences of the original text to be chosen for the summary.
    word_count : int or None, optional
        Determines how many words will the output contain.
        If both parameters are provided, the ratio will be ignored.
    split : bool, optional
        If True, list of sentences will be returned. Otherwise joined
        strings will bwe returned.
+ 代码
```
from gensim.summarization import summarize # 基于文本排序的摘要算法
from bs4 import BeautifulSoup # 用于解析HTML文档的BeautifulSoup库
import requests # 用于下载HTTP资源的库
urls = { # 题目:网站 字典
    'Deconstructing Voice-over-IP':
    'http://scigen.csail.mit.edu/scicache/269/scimakelatex.25977.A.+G.+Hassan.html',
    'Exploration of the Location-Identity Split':
    'http://scigen.csail.mit.edu/scicache/270/scimakelatex.26087.Ali+Veli.Veli+Ali.Vel+Al.html',
}
# 摘要(真实的)：
# 1.The implications of ambimorphic archetypes have been far-reaching and pervasive. After years of natural research into consistent hashing, we argue the simulation of public-private key pairs, which embodies the confirmed principles of theory. Such a hypothesis might seem perverse but is derived from known results. Our focus in this paper is not on whether the well-known knowledge-based algorithm for the emulation of checksums by Herbert Simon runs in Θ( n ) time, but rather on exploring a semantic tool for harnessing telephony (Swale).
# 2.Superblocks must work. Given the current status of homogeneous configurations, security experts particularly desire the simulation of 802.11b. we consider how the Internet can be applied to the refinement of Scheme.
for key in urls.keys():
    url = urls[key]
    r = requests.get(url)
    soup = BeautifulSoup(r.text,'html.parser')
    data = soup.get_text() # HTML去标签后的文本
    pos1 = data.find('1 Introduction') + len('1 Introduction')
    pos2 = data.find('Related Work')
    text = data[pos1:pos2].strip() # 提取pos1与pos2之间的引言部分
    print('PAPER URL: {}'.format(url))
    print('TITLE: {}'.format(key))
    print('GENERATED SUMMARY: {}'.format(summarize(text)))
    print()
```
输出：
```
PAPER URL: http://scigen.csail.mit.edu/scicache/269/scimakelatex.25977.A.+G.+Hassan.html
TITLE: Deconstructing Voice-over-IP
GENERATED SUMMARY: 。。。。。。

PAPER URL: http://scigen.csail.mit.edu/scicache/270/scimakelatex.26087.Ali+Veli.Veli+Ali.Vel+Al.html
TITLE: Exploration of the Location-Identity Split
GENERATED SUMMARY: 。。。。。。
```]]></description></item><item><title>NLP（十） 主题识别</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_10.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 05 Jul 2019 08:26:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_10.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp10/
+ 主题识别
是发现输入文本集合中存在的主题的过程
LDA算法，即狄利克雷分布算法
```
from nltk.tokenize import RegexpTokenizer
from nltk.corpus import stopwords
from gensim import corpora,models
import feedparser

class IdentifyingTopicExample:
    def getDocuments(self): # 获取文档 放到documents中
        url = 'https://sports.yahoo.com/mlb/rss.xml'
        feed = feedparser.parse(url)
        self.documents = []
        for entry in feed['entries'][:5]:
            text = entry['summary']
            if 'ex' in text:
                continue
            self.documents.append(text)
            print('-- {}'.format(text))
        print('INFO: Fetching documents from {} completed'.format(url))

    def cleanDocuments(self):
        tokenizer = RegexpTokenizer(r'[a-zA-Z]+') # 想要只处理字母9
        en_stop = set(stopwords.words('english')) # 英文停用词放到en_stop中
        self.cleaned = [] # 用于存储所有被清洗且分词后的文档
        for doc in self.documents:
            lowercase_doc = doc.lower() # 字母都变小写
            words = tokenizer.tokenize(lowercase_doc) # 分词
            non_stopped_words = [i for i in words if not i in en_stop] # 过滤掉停用词
            self.cleaned.append(non_stopped_words) # cleaned 二维列表
        print('INFO: Clearning {} documents completed'.format(len(self.documents)))

    def doLDA(self):
        dictionary = corpora.Dictionary(self.cleaned) # 创建字典
        corpus = [dictionary.doc2bow(cleandoc) for cleandoc in self.cleaned]
        # 由每个清洗后的句子，以词袋形式定义corpus变量
        ldamodel = models.ldamodel.LdaModel(corpus,num_topics=2,id2word=dictionary)
        # 在corpus上创建一个模型，主题数量设为2，id2word设置词典的大小/映射情况
        print(ldamodel.print_topics(num_topics=2,num_words=4)) # 打印主题 每个主题含4个单词

    def run(self):
        self.getDocuments()
        self.cleanDocuments()
        self.doLDA()

if __name__ == "__main__":
    topicExample = IdentifyingTopicExample()
    topicExample.run()
```
输出：
```
-- MLB Network documentary shines spotlight on 1995 Mariners team that saved baseball in Seattle.
-- Marcus Semien's second big swing of the day finally gave the Oakland Athletics some breathing room in an oh-so-tight series with the AL Central-leading Twins.  Semien hit a grand slam in the eighth inning after his tying homer leading off the fifth, Chris Herrmann had a career-high four hits, and
-- It wasn't long until Cleveland took advantage of it.  Francisco Lindor drove in the go-ahead runs during a six-run seventh inning, Jose Ramirez homered twice and Carlos Santana pushed his on-base streak to 27 games as the Indians rallied to beat bumbling Kansas City 8-4 on Thursday and complete a
-- A look at what's happening around the majors Friday:
INFO: Fetching documents from https://sports.yahoo.com/mlb/rss.xml completed
INFO: Clearning 4 documents completed
[(0, '0.022*"look" + 0.022*"friday" + 0.022*"around" + 0.022*"majors"'), (1, '0.023*"leading" + 0.023*"semien" + 0.022*"inning" + 0.014*"homer"')]
```]]></description></item><item><title>NLP（九） 文本相似度问题</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_9.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 05 Jul 2019 08:24:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_9.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp9/
+ 多个维度判别文本之间相似度
1. 情感维度 Sentiment/Emotion
2. 感官维度 Sense
3. 特定词的出现
+ 词频 TF
逆文本频率 IDF
构建N个M维向量，N是文档总数，M是所有文档的去重词汇量
+ 余弦相似度：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190705162324746-101870451.png)
A,B分别是两个词的向量
```
import nltk
import math
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

class TextSimilarityExample:
    def __init__(self):
        self.statements = [ # 例句
            'ruled india',
            'Chalukyas ruled Badami',
            'So many kingdoms ruled India',
            'Lalbagh is a botanical garden in India',
        ]
    def TF(self,sentence):
        words = nltk.word_tokenize(sentence.lower()) # 分词,都化成小写
        freq = nltk.FreqDist(words) # 计算词频分布，词和词频组成的字典
        dictionary = {}
        for key in freq.keys():
            norm = freq[key] / float(len(words)) # 把词频正则化
            dictionary[key] = norm
        return dictionary # 返回 词:词频
    def IDF(self):
        def idf(TotalNumberOfDocuments,NumberOfDocumentsWithThisWord):
            return 1.0 + math.log(TotalNumberOfDocuments/NumberOfDocumentsWithThisWord)
        # idf = 1 + log(总文件数/含该词的文件数)
        numDocuments = len(self.statements) # 总文档数
        uniqueWords = {} # 不重复的 字典
        idfValues = {} # 词:IDF 字典
        for sentence in self.statements: # 得到每个句子的 词:含该词文章数量 字典
            for word in nltk.word_tokenize(sentence.lower()):
                if word not in uniqueWords:
                    uniqueWords[word] = 1
                else:
                    uniqueWords[word] += 1
        for word in uniqueWords: # 词:含该词文章数量 字典 => 词:IDF 字典
            idfValues[word] = idf(numDocuments,uniqueWords[word])
        return idfValues
    def TF_IDF(self,query): # 返回每句话的向量
        words = nltk.word_tokenize(query.lower())
        idf = self.IDF() # IDF 由所有文档求出
        vectors = {}
        for sentence in self.statements: # 遍历所有句子
            tf = self.TF(sentence) # TF 由单个句子得出
            for word in words:
                tfv = tf[word] if word in tf else 0.0
                idfv = idf[word] if word in idf else 0.0
                mul = tfv * idfv
                if word not in vectors:
                    vectors[word] = []
                vectors[word].append(mul) # 字典里添加元素7
        return vectors
    def displayVectors(self,vectors): # 显示向量内容
        print(self.statements)
        for word in vectors:
            print("{} -> {}".format(word,vectors[word]))
    def cosineSimilarity(self):
        vec = TfidfVectorizer() # 创建新的向量对象
        matrix = vec.fit_transform(self.statements) # 计算所有文本的TF-IDF值矩阵
        for j in range(1,5):
            i = j - 1
            print("\tsimilarity of document {} with others".format(j))
            similarity = cosine_similarity(matrix[i:j],matrix) # scikit库的余弦相似度函数
            print(similarity)
    def demo(self):
        inputQuery = self.statements[0] # 第一个句子作为输入查询
        vectors = self.TF_IDF(inputQuery) # 建立第一句的向量
        self.displayVectors(vectors) # 屏幕上显示所有句子的TF×IDF向量
        self.cosineSimilarity() # 计算输入句子与所有句子的余弦相似度
if __name__ == "__main__":
    similarity = TextSimilarityExample()
    similarity.demo()
```
输出：
```
['ruled india', 'Chalukyas ruled Badami', 'So many kingdoms ruled India', 'Lalbagh is a botanical garden in India']
ruled -> [0.6438410362258904, 0.42922735748392693, 0.2575364144903562, 0.0]
india -> [0.6438410362258904, 0.0, 0.2575364144903562, 0.18395458177882582]
	similarity of document 1 with others
[[1.         0.29088811 0.46216171 0.19409143]]
	similarity of document 2 with others
[[0.29088811 1.         0.13443735 0.        ]]
	similarity of document 3 with others
[[0.46216171 0.13443735 1.         0.08970163]]
	similarity of document 4 with others
[[0.19409143 0.         0.08970163 1.        ]]
```]]></description></item><item><title>NLP（八） 创建自然语言处理管道</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_8.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 05 Jul 2019 08:21:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/05/nlp_8.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp8/
+ 一条管道可以被看作一个多阶段的数据流系统，其中一个组件的输出被视为另一个组件的输入
+ 管道特点：
1. 数据始终从一个组件流向另一个组件
2. 组件是一个只考虑输入和输出数据的黑盒
+ NLP管道应有的功能：
1. 采集输入数据
2. 对输入数据进行分词
3. 识别输入数据中单词的词性
4. 从单词中抽取命名实体
5. 识别命名实体之间的关系
```
import nltk
import threading # 轻量级任务的线程库
import queue #可在多线程程序中使用的队列库
import feedparser # RSS源解析库
import uuid # 基于RFC-4122的uuid版本1，3，4，5的生成库

threads = [] # 创建一个空列表来跟踪程序中的所有线程
queues = [queue.Queue(),queue.Queue()] # 创建一个包含两个队列对象的列表
# 第一个队列：存储分词后的句子
# 第二个队列：存储所有标注过词性的单词

def extractWords():
    url = 'http://sports.yahoo.com/mlb/rss.xml'
    feed = feedparser.parse(url)
    for entry in feed['entries'][:5]:
        text = entry['title'] # 标题存到text里
        if 'ex' in text: # 跳过包含敏感词的标题，有ex存在就不处理了
            continue
        words = nltk.word_tokenize(text) # 将标题分词
        data = {'uuid':uuid.uuid4(),'input':words} # 两个键值对，存储UUID和输入的单词
        queues[0].put(data,True) # 将字典放到第一个队列
        print(">> {} : {}".format(data['uuid'],text))

# 从第一个队列读取数据，并处理数据，将这些单词的词性保存在第二个队列中
def extractPOS():
    while True: # 无限循环，直到第一个队列为空
        if queues[0].empty():
            break
        else:
            data = queues[0].get()
            words = data['input']
            postags = nltk.pos_tag(words)
            queues[0].task_done() # 已经处理完毕由此线程获取的条目
            # 将标注词性的单词列表存储在第二个队列
            queues[1].put({'uuid':data['uuid'],'input':postags},True)

# 从第二个队列读取数据，即处理标注词性后的词，并在屏幕打印命名实体
def extractNE():
    while True: # 无限循环，直到第二个队列为空
        if queues[1].empty():
            break
        else:
            data = queues[1].get()
            postags = data['input']
            queues[1].task_done()
            # 将postags中的命名实体抽取出来存入chunks中
            chunks = nltk.ne_chunk(postags,binary=False)
            print(" << {} : ".format(data['uuid']),end='')
            for path in chunks:
                try:
                    label = path.label()
                    print(path,end=', ')
                except:
                    pass
            print()

def runProgram():
    # 启动该线程，并将该线程放到队列
    e = threading.Thread(target=extractWords())
    e.start()
    threads.append(e)

    p = threading.Thread(target=extractPOS())
    p.start()
    threads.append(p)

    n = threading.Thread(target=extractNE())
    n.start()
    threads.append(n)

    # 将在所有工作处理完毕后释放分配给queues资源
    queues[0].join()
    queues[1].join()

    # 遍历线程列表，将当前的线程对象存储在t中
    for t in threads:
        t.join() # 标记线程的完成，并释放分配给线程的资源

if __name__ == "__main__":
    runProgram()
```
输出：
```
>> be849c82-41cf-4e98-ac32-9766a199e763 : The Bandwagon: All-Stars, America and more
>> 690c174d-a365-4b8a-8712-abd222f13902 : Cards regain power, look for series win vs. Mariners
>> e75f4270-8922-4eab-b688-69e34e387c6f : Yankees look to continue success against Rays
>> f829392a-3702-45bb-bff8-d35261dfa03b : Recap: STL 5, SEA 2
>> ad953f96-21ac-46ea-979d-78086efb964c : Pirates going for 4-game sweep of Cubs
 << be849c82-41cf-4e98-ac32-9766a199e763 : (GPE America/NNP), 
 << 690c174d-a365-4b8a-8712-abd222f13902 : 
 << e75f4270-8922-4eab-b688-69e34e387c6f : (ORGANIZATION Yankees/NNS), (PERSON Rays/NNP), 
 << f829392a-3702-45bb-bff8-d35261dfa03b : (GPE Recap/NN), (ORGANIZATION SEA/NNP), 
 << ad953f96-21ac-46ea-979d-78086efb964c : (GPE Cubs/NNP), 
```]]></description></item><item><title>SyntaxError: invalid syntax ： if not 0 &lt;= time_low &lt; 1&lt;&lt;32L:</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/04/11133235.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 04 Jul 2019 08:30:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/04/11133235.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/bug5/
+ 报错
Traceback (most recent call last):
  File "D:/PyCharm 5.0.3/WorkSpace/2.NLP/8.高阶实践/1.PipelineQ.py", line 1, in <module>
    import nltk
  File "D:\Anaconda3\lib\site-packages\nltk\__init__.py", line 143, in <module>
    from nltk.chunk import *
  File "D:\Anaconda3\lib\site-packages\nltk\chunk\__init__.py", line 157, in <module>
    from nltk.chunk.api import ChunkParserI
  File "D:\Anaconda3\lib\site-packages\nltk\chunk\api.py", line 13, in <module>
    from nltk.parse import ParserI
  File "D:\Anaconda3\lib\site-packages\nltk\parse\__init__.py", line 100, in <module>
    from nltk.parse.transitionparser import TransitionParser
  File "D:\Anaconda3\lib\site-packages\nltk\parse\transitionparser.py", line 22, in <module>
    from sklearn.datasets import load_svmlight_file
  File "D:\Python37\Lib\site-packages\sklearn\__init__.py", line 76, in <module>
    from .base import clone
  File "D:\Python37\Lib\site-packages\sklearn\base.py", line 16, in <module>
    from .utils import _IS_32BIT
  File "D:\Python37\Lib\site-packages\sklearn\utils\__init__.py", line 17, in <module>
    from . import _joblib
  File "D:\Python37\Lib\site-packages\sklearn\utils\_joblib.py", line 8, in <module>
    import joblib
  File "D:\Python37\Lib\site-packages\joblib\__init__.py", line 119, in <module>
    from .parallel import Parallel
  File "D:\Python37\Lib\site-packages\joblib\parallel.py", line 28, in <module>
    from ._parallel_backends import (FallbackToBackend, MultiprocessingBackend,
  File "D:\Python37\Lib\site-packages\joblib\_parallel_backends.py", line 20, in <module>
    from .pool import MemmappingPool
  File "D:\Python37\Lib\site-packages\joblib\pool.py", line 33, in <module>
    from ._memmapping_reducer import get_memmapping_reducers
  File "D:\Python37\Lib\site-packages\joblib\_memmapping_reducer.py", line 17, in <module>
    from uuid import uuid4
  File "D:\Python37\Lib\site-packages\uuid.py", line 138
    if not 0 <= time_low < 1<<32L:
    
SyntaxError: invalid syntax
+ 原因
uuid版本不对，导致语法错误
+ 解决
在系统命令行卸载uuid：
pip uninstall uuid
在Anacanda3中重新安装：
pip install uuid]]></description></item><item><title>NLP（七） 信息抽取和文本分类</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/04/nlp_7.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Thu, 04 Jul 2019 06:04:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/04/nlp_7.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp7/
+ 命名实体
专有名词：人名 地名 产品名

| 例句 | 命名实体 |
| --- | --- |
| Hampi is on the South Bank of Tungabhabra river | Hampi,Tungabhabra River |
| Paris is famous for Fashion | Paris |
| Burj Khalifa is one of the SKyscrapers in Dubai |Burj Khalifa,Dubai  |
| Jeff Weiner is the CEO of LinkedIn | Jeff Weiner,LinkedIn |
命名实体是独一无二的名词
分类：`TIMEZONE,LOCATION,RIVERS,COSMETICS(化妆品),CURRENCY(货币),DATE,TIME,PERSON`
+ NLTK识别命名实体
使用的数据已经经过以下预处理（之前学过的）：
1.将大文档分割成句子
2.将句子分割成词
3.对句子进行词性标注
4.从句子中提取包含连续词（非重叠）的组块（短语）
5.给这些组块包含的词标注IOB标签
分析treebank语料库：
```
import nltk

def sampleNE():
    sent = nltk.corpus.treebank.tagged_sents()[0] # 语料库第一句
    print(nltk.ne_chunk(sent)) # nltk.ne_chunk()函数分析识别一个句子的命名实体

def sampleNE2():
    sent = nltk.corpus.treebank.tagged_sents()[0]
    print(nltk.ne_chunk(sent,binary=True))  # 包含识别无类别的命名实体

if __name__ == "__main__":
    sampleNE()
    sampleNE2()
```
输出：
```
(S
  (PERSON Pierre/NNP)
  (ORGANIZATION Vinken/NNP)
  ,/,
  61/CD
  years/NNS
  old/JJ
  ,/,
  will/MD
  join/VB
  the/DT
  board/NN
  as/IN
  a/DT
  nonexecutive/JJ
  director/NN
  Nov./NNP
  29/CD
  ./.)
(S
  (NE Pierre/NNP Vinken/NNP)
  ,/,
  61/CD
  years/NNS
  old/JJ
  ,/,
  will/MD
  join/VB
  the/DT
  board/NN
  as/IN
  a/DT
  nonexecutive/JJ
  director/NN
  Nov./NNP
  29/CD
  ./.)
```
+ 创建字典、逆序字典和使用字典
字典：一对一映射，将词和词性一一对应放入字典，下次可高效查找
```
import nltk

class LearningDictionary():
    def __init__(self,sentence): # 实例化时直接运行,建立了两个字典
        self.words = nltk.word_tokenize(sentence)
        self.tagged = nltk.pos_tag(self.words)
        self.buildDictionary()
        self.buildReverseDictionary()

    # 将词和词性放到字典
    def buildDictionary(self):
        self.dictionary = {}
        for (word,pos) in self.tagged:
            self.dictionary[word] = pos

    # 在原来的字典基础上，新建一个key和value调过来的字典
    def buildReverseDictionary(self):
        self.rdictionary = {}
        for key in self.dictionary.keys():
            value = self.dictionary[key]
            if value not in self.rdictionary:
                self.rdictionary[value] = [key]
            else:
                self.rdictionary[value].append(key)

    # 判断词是否在字典里
    def isWordPresent(self,word):
        return 'Yes' if word in self.dictionary else 'No'

    # 词 => 词性
    def getPOSForWord(self,word):
        return self.dictionary[word] if word in self.dictionary else None

    # 词性 => 词
    def getWordsForPOS(self,pos):
        return self.rdictionary[pos] if pos in self.rdictionary else None

# 测试
if __name__ == "__main__":
    # 以sentence实例化一个对象
    sentence = 'All the flights got delayed due to bad weather'
    learning = LearningDictionary(sentence)

    words = ['chair','flights','delayed','pencil','weather']
    pos = ['NN','VBS','NNS']
    for word in words:
        status = learning.isWordPresent(word)
        print("It '{}' present in dictionary ? : '{}'".format(word,status))
        if status is 'Yes':
            print("\tPOS For '{}' is '{}'".format(word,learning.getPOSForWord(word)))
    for pword in pos:
        print("POS '{}' has '{}' words".format(pword,learning.getWordsForPOS(pword)))
```
输出：
```
It 'chair' present in dictionary ? : 'No'
It 'flights' present in dictionary ? : 'Yes'
	POS For 'flights' is 'NNS'
It 'delayed' present in dictionary ? : 'Yes'
	POS For 'delayed' is 'VBN'
It 'pencil' present in dictionary ? : 'No'
It 'weather' present in dictionary ? : 'Yes'
	POS For 'weather' is 'NN'
POS 'NN' has '['weather']' words
POS 'VBS' has 'None' words
POS 'NNS' has '['flights']' words
```
+ 特征集合选择
```
import nltk
import random

sampledata = [
    ('KA-01-F 1034 A','rtc'),
    ('KA-02-F 1030 B','rtc'),
    ('KA-03-FA 1200 C','rtc'),
    ('KA-01-G 0001 A','gov'),
    ('KA-02-G 1004 A','gov'),
    ('KA-03-G 0204 A','gov'),
    ('KA-04-G 9230 A','gov'),
    ('KA-27 1290','oth')
]
random.shuffle(sampledata) # 随机排序
testdata = [
    'KA-01-G 0109',
    'KA-02-F 9020 AC',
    'KA-02-FA 0801',
    'KA-01 9129'
]

def learnSimpleFeatures():
    def vehicleNumberFeature(vnumber):
        return {'vehicle_class':vnumber[6]} # 返回第7个字母  
    # 元组（第7个字母作为特征，类别）构成的列表
    featuresets = [(vehicleNumberFeature(vn),cls) for (vn,cls) in sampledata]
    # 朴素贝叶斯训练数据 将分类器保存在classifier中
    classifier = nltk.NaiveBayesClassifier.train(featuresets)
    # 测试数据
    for num in testdata:
        feature = vehicleNumberFeature(num)
        print('(simple) %s is type of %s'%(num,classifier.classify(feature)))

def learnFeatures(): # 用6，7两位作为特征
    def vehicleNumberFeature(vnumber):
        return {
            'vehicle_class':vnumber[6],
            'vehicle_prev':vnumber[5],
        }
    featuresets = [(vehicleNumberFeature(vn),cls) for (vn,cls) in sampledata]
    classifier = nltk.NaiveBayesClassifier.train(featuresets)
    for num in testdata:
        feature = vehicleNumberFeature(num)
        print('(dual) %s is type of %s'%(num,classifier.classify(feature)))

if __name__ == "__main__":
    learnSimpleFeatures()
    learnFeatures()
```
输出：
```
(simple) KA-01-G 0109 is type of gov
(simple) KA-02-F 9020 AC is type of rtc
(simple) KA-02-FA 0801 is type of rtc
(simple) KA-01 9129 is type of gov
(dual) KA-01-G 0109 is type of gov
(dual) KA-02-F 9020 AC is type of rtc
(dual) KA-02-FA 0801 is type of rtc
(dual) KA-01 9129 is type of oth
```
+ 利用分类器分割句子
依据：以'.'结尾，下一单词首字母大写
```
import nltk

# 定义特征 返回（字典，下一个句子首字母是否为大写的布尔值）
def featureExtractor(words,i):
    return ({'current-word':words[i],'next-is-upper':words[i+1][0].isupper()},words[i+1][0].isupper())

# 得到特征集合
def getFeaturesets(sentence):
    words = nltk.word_tokenize(sentence) # 得到句子的单词数组
    featuresets = [featureExtractor(words,i) for i in range(1,len(words)-1) if words[i] == '.']
    return featuresets

# 将文章分句的函数
def segmentTextAndPrintSentences(data):
    words = nltk.word_tokenize(data) # 整个文章分词
    for i in range(0,len(words)-1):
        if words[i] == '.':
            if classifier.classify(featureExtractor(words,i)[0]) == True:
                print(".")
            else:
                print(words[i],end='')
        else:
            print("{} ".format(words[i]),end='')
    print(words[-1]) # 输出最后一个标点
traindata = "The train and test data consist of three columns separated by spaces.Each word has been put on a separate line and there is an empty line after each sentence. The first column contains the current word, the second its part-of-speech tag as derived by the Brill tagger and the third its chunk tag as derived from the WSJ corpus. The chunk tags contain the name of the chunk type, for example I-NP for noun phrase words and I-VP for verb phrase words. Most chunk types have two types of chunk tags, B-CHUNK for the first word of the chunk and I-CHUNK for each other word in the chunk. Here is an example of the file format."
testdata = "The baseline result was obtained by selecting the chunk tag which was most frequently associated with the current part-of-speech tag. At the workshop, all 11 systems outperformed the baseline. Most of them (six of the eleven) obtained an F-score between 91.5 and 92.5. Two systems performed a lot better: Support Vector Machines used by Kudoh and Matsumoto [KM00] and Weighted Probability Distribution Voting used by Van Halteren [Hal00]. The papers associated with the participating systems can be found in the reference section below."
traindataset = getFeaturesets(traindata)
classifier = nltk.NaiveBayesClassifier.train(traindataset)
segmentTextAndPrintSentences(testdata)
```
输出：
```
The baseline result was obtained by selecting the chunk tag which was most frequently associated with the current part-of-speech tag .
At the workshop , all 11 systems outperformed the baseline .
Most of them ( six of the eleven ) obtained an F-score between 91.5 and 92.5 .
Two systems performed a lot better : Support Vector Machines used by Kudoh and Matsumoto [ KM00 ] and Weighted Probability Distribution Voting used by Van Halteren [ Hal00 ] .
The papers associated with the participating systems can be found in the reference section below .
```
+ 文本分类
以RSS(丰富站点，Rich Site Summary)源的分类为例
```
import nltk
import random
import feedparser

# 两个跟雅虎体育相关的RSS源
urls = {
    'mlb':'http://sports.yahoo.com/mlb/rss.xml',
    'nfl':'http://sports.yahoo.com/nfl/rss.xml',
}

feedmap = {} # 字典存RSS源
stopwords = nltk.corpus.stopwords.words('english') # 停用词

# 输入单词列表 返回特征字典 key是非停用词 value是True
def featureExtractor(words):
    features = {}
    for word in words:
        if word not in stopwords:
            features["word({})".format(word)] = True
    return features

# 空列表 用于储存正确标注的句子
sentences = []

for category in urls.keys():
    feedmap[category] = feedparser.parse(urls[category]) # 下载数据源存到feedmap字典中
    print("downloading {}".format(urls[category]))
    for entry in feedmap[category]['entries']: # 遍历所有RSS条目
        data = entry['summary']
        words = data.split()
        sentences.append((category,words)) # 将类别和所有单词以元组形式存到sentences中

# 将 （类别，单词列表） 转化成 '所有单词的特征：类别' 组成的字典
featuresets = [(featureExtractor(words),category) for category,words in sentences]

# 打乱 一半训练集 一半测试集
random.shuffle(featuresets)
total = len(featuresets)
off = int(total/2)
trainset = featuresets[off:]
testset = featuresets[:off]

# 调用NaiveBayesClassifier模块train()函数 构造一个分类器
classifier = nltk.NaiveBayesClassifier.train(trainset)

# 打印准确率
print(nltk.classify.accuracy(classifier,testset))

# 打印数据的有效特征
classifier.show_most_informative_features(5)

for (i,entry) in enumerate(feedmap['nfl']['entries']):
    if i < 4: # 从nfl随机选取4个样本测试
        features = featureExtractor(entry['title'].split())
        category = classifier.classify(features)
        print('{} -> {}'.format(category,entry['summary']))
```
输出：
```
downloading http://sports.yahoo.com/mlb/rss.xml
downloading http://sports.yahoo.com/nfl/rss.xml
0.9148936170212766
Most Informative Features
               word(NFL) = True              nfl : mlb    =      8.6 : 1.0
       word(quarterback) = True              nfl : mlb    =      3.7 : 1.0
              word(team) = True              nfl : mlb    =      2.9 : 1.0
               word(two) = True              mlb : nfl    =      2.4 : 1.0
         word(Wednesday) = True              mlb : nfl    =      2.4 : 1.0
nfl -> The Cowboys RB will not be suspended for his role in an incident in May in Las Vegas.
nfl -> Giants defensive lineman Dexter Lawrence was 6 years old when Eli Manning began his NFL career. Manning is entering his 16th season, while Lawrence is arriving as a first-round draft pick. Age isn't always "just a number." "In the locker room, I feel their age," Manning said,
nfl -> Hue Jackson compiled a 3-36-1 record in two-and-a-half seasons with the Cleveland Browns before later joining division rival the Cincinnati Bengals.
nfl -> NFL Network's David Carr and free agent defensive lineman Andre Fluellen predict every game on the Minnesota Vikings' 2019 schedule.
```
+ 利用上下文进行词性标注
```
import nltk

# 给出一些包含双词性的例句 address laugh
sentences = [
    "What is your address when you're in Beijing?",
    "the president's address on the state of economy.",
    "He addressed his remarks to the lawyers in the audience.",
    "In order to address an assembly, we should be ready",
    "He laughed inwardly at the scene.",
    "After all the advance publicity, the prizefight turned out to be a laugh.",
    "We can learn to laugh a little at even our most serious foibles.",
]

# 将每句话的 词和词性 放到列表中，构成一个二维列表
def getSentenceWords():
    sentwords = []
    for sentence in sentences:
        words = nltk.pos_tag(nltk.word_tokenize(sentence))
        sentwords.append(words)
    return sentwords

# 无上下文词性标注
def noContextTagger():
    # 构建一个基准系统
    tagger = nltk.UnigramTagger(getSentenceWords())
    print(tagger.tag('the little remarks towards assembly are laughable'.split()))

# 有上下文词性标注
def withContextTagger():
    # 返回字典：  4 x 特征:特征值
    def wordFeatures(words,wordPosInSentence):
        # 单词的倒数1，2，3个字母作为特征
        endFeatures = {
            'last(1)':words[wordPosInSentence][-1],
            'last(2)':words[wordPosInSentence][-2:],
            'last(3)':words[wordPosInSentence][-3:],
        }
        # 如果一个词不是句子中第一个 用前面的词决定
        if wordPosInSentence > 1:
            endFeatures['prev'] = words[wordPosInSentence - 1]
        else:
            endFeatures['prev'] = '|NONE|'
        return endFeatures
    allsentences = getSentenceWords() # 二维列表
    featureddata = [] # 准备放元组，元组包括 特征信息(featurelist)和标记(tag)
    for sentence in allsentences:
        untaggedSentence = nltk.tag.untag(sentence)
        featuredsentence = [(wordFeatures(untaggedSentence,index),tag) for index,(word,tag) in enumerate(sentence)]
        featureddata.extend(featuredsentence)
    breakup = int(len(featureddata) * 0.5)
    traindata = featureddata[breakup:]
    testdata = featureddata[:breakup]
    classifier = nltk.NaiveBayesClassifier.train(traindata)
    print("分类器准确率 : {}".format(nltk.classify.accuracy(classifier,testdata)))

if __name__ == "__main__":
    noContextTagger()
    withContextTagger()
```
输出：
```
[('the', 'DT'), ('little', 'JJ'), ('remarks', 'NNS'), ('towards', None), ('assembly', 'NN'), ('are', None), ('laughable', None)]
分类器准确率 : 0.38461538461538464
```]]></description></item><item><title>NLP（六） 分块、句法分析、依存分析</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/03/nlp_6.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Wed, 03 Jul 2019 07:49:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/03/nlp_6.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp6/
+ 内置分块器
分块：从文本中抽取短语
```
import nltk

text = 'Lalbagh Botanical Garden is a well known botanical garden in Bengaluru, India.'

# 文本切割成多个句子
sentences = nltk.sent_tokenize(text)
for sentence in sentences:
    words = nltk.word_tokenize(sentence)
    tags = nltk.pos_tag(words)
    chunks = nltk.ne_chunk(tags) # 实现分块，返回树结构
    print(chunks)
```
输出：
```
(S
  (PERSON Lalbagh/NNP)
  (PERSON Botanical/NNP Garden/NNP)
  is/VBZ
  a/DT
  well/RB
  known/VBN
  botanical/JJ
  garden/NN
  in/IN
  (GPE Bengaluru/NNP)
  ,/,
  (GPE India/NNP)
  ./.)
```
+ 编写简单的RE分块器
```
import nltk

text = 'Ravi is the CEO of a company. He is very powerful public speaker also.'

# 词性语法规则
grammar = '\n'.join([
    'NP: {<DT>*<NNP>}', # 一个或多个DT后紧跟一个NNP
    'NP: {<JJ>*<NN>}', # 一个或多个JJ后紧跟一个NN
    'NP: {<NNP>+}', # 一个或多个NNP组成
])

sentences = nltk.sent_tokenize(text)
for sentence in sentences:
    words = nltk.word_tokenize(sentence)
    tags = nltk.pos_tag(words)
    # 将语法规则放到RegexpParser对象中
    chunkparser = nltk.RegexpParser(grammar)
    result = chunkparser.parse(tags)
    print(result)
```
输出：
```
(S
  (NP Ravi/NNP)
  is/VBZ
  (NP the/DT CEO/NNP)
  of/IN
  a/DT
  (NP company/NN)
  ./.)
(S
  He/PRP
  is/VBZ
  very/RB
  (NP powerful/JJ public/JJ speaker/NN)
  also/RB
  ./.)
```
+ 训练分块器
IOB标注格式：

| 列 | 描述 |
| --- | --- |
| IOB第一列 | 输入句子中的单词 |
| IOB第二列 | 单词对应的词性 |
| IOB第三列 | I（内部词），O（外部词），B（开始词）；加上词种类的后缀 |
例子：
Rockwell NNP B-NP
International NNP I-NP
Corp. NNP I-NP
's POS B-NP
Tulsa NNP I-NP
unit NN I-NP
said VBD B-VP
it PRP B-NP
代码：
```
import nltk
from nltk.corpus import conll2000,treebank_chunk # 两个数据集

# 简单的分块器，抽取NNP(专有名词)
def mySimpleChunker():
    grammar = 'NP: {<NNP>+}'
    return nltk.RegexpParser(grammar)

# 不抽取任何东西，只用于检验算法能否正常运行
def test_nothing(data):
    cp = nltk.RegexpParser("")
    print(cp.evaluate(data))

# 测试mySimpleChunker()函数
def test_mysimplechunker(data):
    schunker = mySimpleChunker()
    print(schunker.evaluate(data))

datasets = [
    conll2000.chunked_sents('test.txt',chunk_types=['NP']),
    treebank_chunk.chunked_sents(),
]

# 前50个IOB标注语句 计算分块器的准确率
for dataset in datasets:
    test_nothing(dataset[:50])
    print('---------------------')
    test_mysimplechunker(dataset[:50])
    print()
```
输出：
```
ChunkParse score:
    IOB Accuracy:  38.6%%
    Precision:      0.0%%
    Recall:         0.0%%
    F-Measure:      0.0%%
---------------------
ChunkParse score:
    IOB Accuracy:  48.2%%
    Precision:     71.1%%
    Recall:        17.2%%
    F-Measure:     27.7%%

ChunkParse score:
    IOB Accuracy:  45.0%%
    Precision:      0.0%%
    Recall:         0.0%%
    F-Measure:      0.0%%
---------------------
ChunkParse score:
    IOB Accuracy:  50.7%%
    Precision:     51.9%%
    Recall:         8.8%%
    F-Measure:     15.1%%
```
+ 递归下降句法分析
递归先序遍历句法分析树
NLTK的RD分析器
```
import nltk

def RDParserExample(grammar,textlist):
    # RecursiveDescentParser递归下降分析器
    parser = nltk.parse.RecursiveDescentParser(grammar)
    for text in textlist:
        sentence = nltk.word_tokenize(text)
        for tree in parser.parse(sentence):
            print(tree)
            tree.draw()

# 利用grammar创建CFG对象
grammar = nltk.CFG.fromstring("""
S -> NP VP
NP -> NNP VBZ
VP -> IN NNP | DT NN IN NNP
NNP -> 'Tajmahal' | 'Agra' | 'Bangalore' | 'Karnataka'
VBZ -> 'is'
IN -> 'in' | 'of'
DT -> 'the'
NN -> 'capital'
""")

# 测试
text = [
    "Tajmahal is in Agra",
    "Bangalore is the capital of Karnataka",
]
RDParserExample(grammar,text)
```
输出：
```
(S (NP (NNP Tajmahal) (VBZ is)) (VP (IN in) (NNP Agra)))
(S
  (NP (NNP Bangalore) (VBZ is))
  (VP (DT the) (NN capital) (IN of) (NNP Karnataka)))
```
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190703154657788-1555027184.png)
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190703154705207-1887456877.png)

+ shift-reduce句法分析
shift-reduce句法分析器：从左到右单线程，也可以从上到下多线程
```
import nltk

def SRParserExample(grammer,textlist):
    parser = nltk.parse.ShiftReduceParser(grammer)
    for text in textlist:
        sentence = nltk.word_tokenize(text)
        for tree in parser.parse(sentence):
            print(tree)
            tree.draw()

grammar = nltk.CFG.fromstring("""
S -> NP VP
NP -> NNP VBZ
VP -> IN NNP | DT NN IN NNP
NNP -> 'Tajmahal' | 'Agra' | 'Bangalore' | 'Karnataka'
VBZ -> 'is'
IN -> 'in' | 'of'
DT -> 'the'
NN -> 'capital'
""")

text = [
    "Tajmahal is in Agra",
    "Bangalore is the capital of Karnataka",
]

SRParserExample(grammar,text)
```
输出：
```
(S (NP (NNP Tajmahal) (VBZ is)) (VP (IN in) (NNP Agra)))
```
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190703154728509-1471518014.png)
+ 依存句法分析和主观依存分析
```
import nltk

# 依存相关规则
grammar = nltk.grammar.DependencyGrammar.fromstring("""
'savings' -> 'small'
'yield' -> 'savings'
'gains' -> 'large'
'yield' -> 'gains'
""")

sentence = 'small savings yield large gains'
dp = nltk.parse.ProjectiveDependencyParser(grammar)
print(sorted(dp.parse(sentence.split())))
for t in sorted(dp.parse(sentence.split())):
    print(t)
    t.draw()
```
输出：
```
[Tree('yield', [Tree('savings', ['small']), Tree('gains', ['large'])])]
(yield (savings small) (gains large))
```
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190703154742137-1213778320.png)
+ 线图句法分析
```
from nltk.grammar import CFG
from nltk.parse.chart import ChartParser,BU_LC_STRATEGY

# BNF格式文法 开始符号：S 终结符号：单词
grammar = CFG.fromstring("""
S -> T1 T4
T1 -> NNP VBZ
T2 -> DT NN
T3 ->IN NNP
T4 -> T3 | T2 T3
NNP -> 'Tajmahal' | 'Agra' | 'Bangalore' | 'Karnataka'
VBZ -> 'is'
IN -> 'in' | 'of'
DT -> 'the'
NN -> 'capital'
""")

cp = ChartParser(grammar,BU_LC_STRATEGY,trace=True)
# trace=True可以看见分析过程
# strategy=BU_LC_STRATEGY是默认的，不写好像也行

sentence = 'Bangalore is the capital of Karnataka'
tokens = sentence.split()
chart = cp.chart_parse(tokens) # 对单词列表分析，并存到chart对象 
parses = list(chart.parses(grammar.start())) # 将chart取到的所有分析树赋给parses
print('Total Edges :',len(chart.edges())) # 输出chart对象所有边的数量
for tree in parses: # 打印所有分析树
    print(tree)
tree.draw()
```
输出：
```
|.Bangal.  is  . the  .capita.  of  .Karnat.|
|[------]      .      .      .      .      .| [0:1] 'Bangalore'
|.      [------]      .      .      .      .| [1:2] 'is'
|.      .      [------]      .      .      .| [2:3] 'the'
|.      .      .      [------]      .      .| [3:4] 'capital'
|.      .      .      .      [------]      .| [4:5] 'of'
|.      .      .      .      .      [------]| [5:6] 'Karnataka'
|[------]      .      .      .      .      .| [0:1] NNP -> 'Bangalore' *
|[------>      .      .      .      .      .| [0:1] T1 -> NNP * VBZ
|.      [------]      .      .      .      .| [1:2] VBZ -> 'is' *
|[-------------]      .      .      .      .| [0:2] T1 -> NNP VBZ *
|[------------->      .      .      .      .| [0:2] S  -> T1 * T4
|.      .      [------]      .      .      .| [2:3] DT -> 'the' *
|.      .      [------>      .      .      .| [2:3] T2 -> DT * NN
|.      .      .      [------]      .      .| [3:4] NN -> 'capital' *
|.      .      [-------------]      .      .| [2:4] T2 -> DT NN *
|.      .      [------------->      .      .| [2:4] T4 -> T2 * T3
|.      .      .      .      [------]      .| [4:5] IN -> 'of' *
|.      .      .      .      [------>      .| [4:5] T3 -> IN * NNP
|.      .      .      .      .      [------]| [5:6] NNP -> 'Karnataka' *
|.      .      .      .      .      [------>| [5:6] T1 -> NNP * VBZ
|.      .      .      .      [-------------]| [4:6] T3 -> IN NNP *
|.      .      .      .      [-------------]| [4:6] T4 -> T3 *
|.      .      [---------------------------]| [2:6] T4 -> T2 T3 *
|[=========================================]| [0:6] S  -> T1 T4 *
Total Edges : 24
(S
  (T1 (NNP Bangalore) (VBZ is))
  (T4 (T2 (DT the) (NN capital)) (T3 (IN of) (NNP Karnataka))))
```
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190703154817178-1536865312.png)]]></description></item><item><title>HTML（七）CSS</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/02/html_7.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 02 Jul 2019 13:05:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/02/html_7.html</guid><description><![CDATA[#### 一个实例
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
<style>
body
{
	background-color:#d0e4fe;
}
h1
{
	color:orange;
	text-align:center;
}
p
{
	font-family:"Times New Roman";
	font-size:20px;
}
</style>
</head>
<body>
<h1>CSS 实例!</h1>
<p>这是一个段落。</p>
</body>
</html>

#### 什么是 CSS?
CSS 指层叠样式表 (Cascading Style Sheets)
样式定义如何显示 HTML 元素
样式通常存储在样式表中
把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题
外部样式表可以极大提高工作效率
外部样式表通常存储在 CSS 文件中
多个样式定义可层叠为一

#### CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明:
    h1    {  color : blue ; font-size : 12px ;}
选择器 {        声 明      ;           声 明         ;}
选择器 {   属性  :  值    ;    属性    :     值   ;}

#### CSS 注释
注释是用来解释你的代码，并且可以随意编辑它，浏览器会忽略它
CSS注释以 "/*" 开始, 以 "*/" 结束

#### style放在html的任何地方都会生效,一般都放到<head>里

### CSS Id 和 Class

#### id 选择器
id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式
HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 "#" 来定义
id属性不要以数字开头
实例:
#para1
{
    text-align:center;
    color:red;
}
<p id="para1">Hello World!</p>
<p>这个段落不受该样式的影响。</p>

//class 选择器
class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，
class可以在多个元素中使用
class 选择器在HTML中以class属性表示, 在 CSS 中,类选择器以一个点"."号显示
类名的第一个字符不能使用数字
实例1:
.center
{
	text-align:center;
}
<h1 class="center">标题居中</h1>
<p class="center">段落居中。</p> 
也可以指定特定的HTML元素使用class
实例2:
p.center
{
	text-align:center;
}
<h1 class="center">这个标题不受影响</h1>
<p class="center">这个段落居中对齐。</p> 

#### 四种 css 选择器有修饰上的优先级
直接在标签内部写css代码>id>class>style,就近原则

### CSS 创建

#### 插入样式表
外部样式表(External style sheet)
内部样式表(Internal style sheet)
内联样式(Inline style)

#### 优先级
内联样式 > 内部样式 > 外部样式 > 浏览器默认样式
注意：如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式

### CSS 背景

#### CSS 属性定义背景效果
background-color
background-image
background-repeat
background-attachment
background-position

#### 背景颜色
CSS中，颜色值通常以以下方式定义:
十六进制 - 如："#ff0000"
RGB - 如："rgb(255,0,0)"
颜色名称 - 如："red"

#### 背景图像
background-image 属性描述了元素的背景图像.
默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体
<style>
body
{
	background-image:url('sources/img1.JPG');
}
</style>

#### 背景图像 - 水平或垂直平铺
水平平铺:
body
{
	background-image:url('gradient2.png');
	background-repeat:repeat-x;
} 
垂直平铺:
body
{
	background-image:url('gradient2.png');
	background-repeat:repeat-y;
} 
不平埔:
body
{
background-image:url('img_tree.png');
background-repeat:no-repeat;
} 

#### 背景图像- 设置定位
body
{
	background-image:url('img_tree.png');
	background-repeat:no-repeat;
	background-position:right top;
	margin-right:200px;
}
position属性值中后面的top是图片与文字的对齐方式

#### 背景- 简写属性
在以上实例中我们可以看到页面的背景颜色通过了很多的属性来控制。
为了简化这些属性的代码，我们可以将这些属性合并在同一个属性中.
背景颜色的简写属性为 "background":
实例:
body {background:#ffffff url('img_tree.png') no-repeat right top;}
当使用简写属性时，属性值的顺序为：:
background-color
background-image
background-repeat
background-attachment
background-position

#### background-attachment属性值
值说明
scroll	背景图片随页面的其余部分滚动,这是默认
fixed	背景图像是固定的,即无论网页怎么滚动,图片在浏览器中位置不变
inherit	指定background-attachment的设置应该从父元素继承

### CSS 文本格式

#### 文本颜色
RGB红绿蓝
对于W3C标准的CSS：如果你定义了颜色属性，你还必须定义背景色属性

#### 文本的对齐方式
默认左对齐
h1 {text-align:center;}
p.date {text-align:right;}
p.main {text-align:justify;}
当text-align设置为"justify"，每一行被展开为宽度相等，
左，右外边距是对齐（如杂志和报纸）

#### 文本修饰
text-decoration 属性用来设置或删除文本的装饰。
从设计的角度看 text-decoration属性主要是用来删除链接的下划线
也可以这样装饰文字:
h1 {text-decoration:overline;}
h2 {text-decoration:line-through;}
h3 {text-decoration:underline;}
我们不建议强调指出不是链接的文本，因为这常常混淆用户

#### 文本转换
文本转换属性是用来指定在一个文本中的大写和小写字母
可用于所有字句变成大写或小写字母，或每个单词的首字母大写
p.uppercase {text-transform:uppercase;}
p.lowercase {text-transform:lowercase;}
p.capitalize {text-transform:capitalize;}

#### 文本缩进
文本缩进属性是用来指定文本的第一行的缩进
p {text-indent:50px;}

#### 字符之间的空间
letter-spacing:2px;

#### 行间距
line-height:150%;

#### 单词之间的空白空间
word-spacing:30px;

#### 在元素内禁用文字环绕
white-space:nowrap;

#### 垂直对齐图像
默认是bottom,图片的底部与文本对应
vertical-align:text-top;
vertical-align:text-bottom;

#### 添加文本阴影
h1 {text-shadow:2px 2px #FF0000;}
### CSS 字体

#### 字体系列
font-family 属性应该设置几个字体名称作为一种"后备"机制，
如果浏览器不支持第一种字体，他将尝试下一种字体
<style>
p.serif{font-family:"Times New Roman",Times,serif;}
p.sansserif{font-family:Arial,Helvetica,sans-serif;}
</style>
</head>
<body>
<h1>CSS font-family</h1>
<p class="serif">这一段的字体是 Times New Roman </p>
<p class="sansserif">这一段的字体是 Arial.</p>
</body>

#### 字体样式
这个属性有三个值：
正常 - 正常显示文本
斜体 - 以斜体字显示的文字
倾斜的文字 - 文字向一边倾斜（和斜体非常类似，但不太支持）
实例:
p.normal {font-style:normal;}
p.italic {font-style:italic;}
p.oblique {font-style:oblique;}

#### 字体大小
绝对大小：
设置一个指定大小的文本
不允许用户在所有浏览器中改变文本大小
确定了输出的物理尺寸时绝对大小很有用
相对大小：
相对于周围的元素来设置大小
允许用户在浏览器中改变文字大小
如果你不指定一个字体的大小，默认大小和普通文本段落一样，
是16像素（16px=1em）

#### 设置字体大小像素
h1 {font-size:40px;}

#### 用em来设置字体大小
h1 {font-size:2.5em;}       /* 40px/16=2.5em */

#### 使用百分比和EM组合
在所有浏览器的解决方案中，设置 <body>元素的默认字体大小的是百分比： 
实例:
body {font-size:100%;}
h1 {font-size:2.5em;}
h2 {font-size:1.875em;}
p {font-size:0.875em;}

#### 设置字体加粗
p.normal {font-weight:normal;}
p.light {font-weight:lighter;}
p.thick {font-weight:bold;}
p.thicker {font-weight:900;}

### CSS 链接

#### 链接样式
a:link {color:#000000;}      /* 未访问链接*/
a:visited {color:#00FF00;}  /* 已访问链接 */
a:hover {color:#FF00FF;}  /* 鼠标移动到链接上,聚焦 */
a:active {color:#0000FF;}  /* 鼠标点击时 */

#### 文本修饰
text-decoration 属性主要用于删除链接中的下划线：
a:link {text-decoration:none;}
a:visited {text-decoration:none;}
a:hover {text-decoration:underline;}
a:active {text-decoration:underline;}
注意:hover必须在:link和 a:visited之后定义才有效
注意:active必须在hover之后定义是有效的

#### 背景颜色
a:link {background-color:#B2FF99;}
a:visited {background-color:#FFFF85;}
a:hover {background-color:#FF704D;}
a:active {background-color:#FF704D;}

+ 除了改变以上的属性,还可以添加更多属性,自由添加

#### 创建链接框的实例
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"> 
<title>菜鸟教程(runoob.com)</title> 
<style>
a:link,a:visited
{
	display:block;
	font-weight:bold;
	color:#FFFFFF;
	background-color:#98bf21;
	width:120px;
	text-align:center;
	padding:4px;
	text-decoration:none;
}
a:hover,a:active
{
	background-color:#7A991A;
}
</style>
</head>
<body>
<a href="/css/" target="_blank">这是一个链接</a>
</body>
</html>

### CSS 列表

#### 列表
在HTML中，有两种类型的列表：
无序列表 - 列表项标记用特殊图形（如小黑点、小方框等）
有序列表 - 列表项的标记有数字或字母

#### 不同的列表项标记
list-style-type属性指定列表项标记的类型是：
无序列表实例:
ul.a {list-style-type: circle;}  //空心圆圈
ul.b {list-style-type: square;}  //实心方块
有序列表实例:
ol.c {list-style-type: upper-roman;}  //大写罗马数字
ol.d {list-style-type: lower-alpha;}  //小写字母

#### 作为列表项标记的图像
要指定列表项标记的图像，使用列表样式图像属性：
ul
{
    list-style-image: url('sqpurple.gif');
}

#### 列表 -简写属性
可以按顺序设置如下属性： 
list-style-type
list-style-position (有关说明，请参见下面的CSS属性表)
list-style-image

### CSS 表格

#### 表格边框
指定CSS表格边框，使用border属性
<style>
table,th,td
{
	border:1px solid black;
}
</style>

#### 折叠边框
border-collapse属性设置表格的边框是否被折叠成一个单一的边框或隔开：
实例
table
{
    border-collapse:collapse;
}
table,th, td
{
    border: 1px solid black;
}

#### 表格宽度和高度
Width和height属性定义表格的宽度和高度
table {width:100%;}
th{height:100px;}
td{height:50px}

#### 表格文字对齐
表格中的文本对齐和垂直对齐属性
text-align属性设置水平对齐方式,向左,右,或中心
td{text-align:right;}
垂直对齐属性设置垂直对齐,比如顶部,底部或中间：
td{height:50px;vertical-align:bottom;}

#### 表格填充
如果在表的内容中控制空格之间的边框,应使用td和th元素的填充属性:
td{padding:15px;}

#### 表格颜色
下面的例子指定边框的颜色，和th元素的文本和背景颜色：
table, td, th{border:1px solid green;}
th{background-color:green;color:white;}]]></description></item><item><title>HTML（六）框架，颜色，脚本，字符实体，统一资源定位器</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/02/html_6.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 02 Jul 2019 12:52:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/02/html_6.html</guid><description><![CDATA[### HTML 框架

#### HTML框架
通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面
<iframe src="URL" width="800" height="600"></iframe>

#### Iframe移除边框
<iframe src="demo_iframe.htm" frameborder="0"></iframe>

#### 使用iframe来显示目标链接页面
<iframe src="demo_iframe.htm" name="iframe_a"></iframe>
<p><a href="http://www.runoob.com" target="iframe_a">RUNOOB.COM</a></p>

### HTML 颜色

#### rgb(255,255,00,0.5) = #FFFF00
0.5代表透明度

#### Web安全色
各种颜色由33,66,99,CC,FF组成

### HTML 脚本

#### HTML 脚本
JavaScript 使 HTML 页面具有更强的动态和交互性
<script> 标签用于定义客户端脚本，比如 JavaScript
<script> 元素既可包含脚本语句，也可通过 src 属性指向外部脚本文件
JavaScript 最常用于图片操作、表单验证以及内容动态更新

#### 实例
<p>
JavaScript 能够直接写入 HTML 输出流中：
</p>
<script>
document.write("<h1>这是一个标题</h1>");
document.write("<p>这是一个段落。</p>");
</script>
<p>
您只能在 HTML 输出流中使用 <strong>document.write</strong>。
如果您在文档已加载后使用它（比如在函数中），会覆盖整个文档。
</p>

### HTML 字符实体

#### HTML 中的预留字符必须被替换为字符实体
一些在键盘上找不到的字符也可以使用字符实体来替换  

#### 常用字符实体
 	空格	&nbsp;	&#160;
<	小于号	&lt;	&#60;
>	大于号	&gt;	&#62;
&	和号	&amp;	&#38;
"	引号	&quot;	&#34;
'	撇号 	&apos; (IE不支持)	&#39;
￠	分	&cent;	&#162;
￡	镑	&pound;	&#163;
￥	人民币	&yen;	&#165;
€	欧元	&euro;	&#8364;
§	小节	&sect;	&#167;
?	版权	&copy;	&#169;
?	注册商标	&reg;	&#174;
?	商标	&trade;	&#8482;
×	乘号	&times;	&#215;
÷	除号	&divide;	&#247;

#### 音标符
  ?	a	a&#768;	a?
  ?	a	a&#769;	a?
  ?	a	a&#770;	a?
  ?	a	a&#771;	a?

### HTML 统一资源定位器(Uniform Resource Locators)

#### URL - 统一资源定位器
语法规则:
scheme://host.domain:port/path/filename 
说明:
scheme - 定义因特网服务的类型。最常见的类型是 http
host - 定义域主机（http 的默认主机是 www）
domain - 定义因特网域名，比如 runoob.com
:port - 定义主机上的端口号（http 的默认端口号是 80）
path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。
filename - 定义文档/资源的名称

#### 常见的 URL Scheme
Scheme	访问		用于...
http	超文本传输协议	以 http:// 开头的普通网页。不加密。
https	安全超文本传输协议	安全网页，加密所有信息交换。
ftp	文件传输协议	用于将文件下载或上传至网站。
file	 		您计算机上的文件]]></description></item><item><title>HTML（五）列表，区块，布局，表单和输入</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/02/html_5.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 02 Jul 2019 12:50:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/02/html_5.html</guid><description><![CDATA[### HTML 列表

#### 无序列表
<ul>
  <li>Coffee</li>
  <li>Tea</li>
  <li>Milk</li>
</ul>
默认是圆点,也可以 <ul style="list-style-type:disc">
圆圈 <ul style="list-style-type:circle">
正方形 <ul style="list-style-type:square">

#### 有序列表
<ol>
  <li>Coffee</li>
  <li>Tea</li>
  <li>Milk</li>
</ol>
<ol start="50">
  <li>Coffee</li>
  <li>Tea</li>
  <li>Milk</li>
</ol>
默认是用数字排序
大写字母<ol type="A">
小写字母<ol type="a">
罗马大写<ol type="I">
罗马小写<ol type="i">

#### 自定义列表
<dl>
<dt>Coffee</dt>
<dd>- black hot drink</dd>
<dt>Milk</dt>
<dd>- white cold drink</dd>
</dl> 

### HTML 区块

#### HTML <div> 元素
HTML <div> 元素是块级元素，它可用于组合其他 HTML 元素的容器
<div> 元素没有特定的含义。除此之外，由于它属于块级元素，
浏览器会在其前后显示折行
如果与 CSS 一同使用，<div> 元素可用于对大的内容块设置样式属性
<div> 元素的另一个常见的用途是文档布局
它取代了使用表格定义布局的老式方法
使用 <table> 元素进行文档布局不是表格的正确用法
<table> 元素的作用是显示表格化的数据

#### HTML <span> 元素
HTML <span> 元素是内联元素，可用作文本的容器
<span> 元素也没有特定的含义
当与 CSS 一同使用时，<span> 元素可用于为部分文本设置样式属性

#### HTML <div> 标签
文档中的一个区域将显示为蓝色：
<div style="color:#0000FF" align="center">
  <h3>这是一个在 div 元素中的标题</h3>
  <p>这是一个在 div 元素中的文本</p>
</div>
align属性:
left 左对齐内容     right 右对齐内容    center 居中对齐内容
justify 对行进行伸展,这样每行都可以有相等的长度(就像在报纸和杂志中)

#### HTML <span> 标签
使用 <span> 元素对文本中的一部分进行着色：
<p>我的母亲有<span style="color:blue">蓝色</span> 的眼睛</p>

### HTML 布局

#### 使用<div> 元素.
div 元素是用于分组 HTML 元素的块级元素

#### 使用表格
使用 HTML <table> 标签是创建布局的一种简单的方式
大多数站点可以使用 <div> 或者 <table> 元素来创建多列
CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观

### HTML 表单和输入

#### 创建文本字段
<form action="">
First name: <input type="text" name="firstname"><br>
Last name: <input type="text" name="lastname">
</form>

#### 创建密码字段
<form action="">
Username: <input type="text" name="user"><br>
Password:  <input type="password" name="password">
</form>       
密码打出来的全是圆点

#### 单选按钮(Radio Buttons)
<form>
<input type="radio" name="sex" value="male">Male<br>
<input type="radio" name="sex" value="female">Female
</form> 

#### 复选框(Checkboxes)
<form>
<input type="checkbox" name="vehicle" value="Bike">I have a bike<br>
<input type="checkbox" name="vehicle" value="Car">I have a car 
</form> 

#### 提交按钮(Submit Button)
<form name="input" action="html_form_action.php" method="get">
Username: <input type="text" name="user">
<input type="submit" value="Submit">
</form>

#### 简单的下拉列表
<form action="">
<select name="cars">
<option value="volvo">Volvo</option>
<option value="saab">Saab</option>
<option value="fiat">Fiat</option>
<option value="audi">Audi</option>
</select>
</form>

#### 预选下拉列表
<form action="">
<select name="cars">
<option value="volvo">Volvo</option>
<option value="saab">Saab</option>
<option value="fiat" selected>Fiat</option>
<option value="audi">Audi</option>
</select>
</form>

#### 带边框的表单
<form action="">
<fieldset>
<legend>Personal information:</legend>
Name: <input type="text" size="30"><br>
E-mail: <input type="text" size="30"><br>
Date of birth: <input type="text" size="10">
</fieldset>
</form>

#### 发送邮件实例
<form action="MAILTO:18810556325@163.com" method="post" enctype="text/plain">
Name:<br>
<input type="text" name="name" value="your name"><br>
E-mail:<br>
<input type="text" name="mail" value="your email"><br>
Comment:<br>
<input type="text" name="comment" value="your comment" size="50"><br><br>
<input type="submit" value="发送">
<input type="reset" value="重置">
</form>]]></description></item><item><title>HTML（四）图像，表格</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/02/html_4.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 02 Jul 2019 12:46:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/02/html_4.html</guid><description><![CDATA[### HTML 图像

 插入动图的语法和静态图的语法是一样的

#### HTML 图像- 图像标签（ <img>）和源属性（Src）
<p>一个来自文件夹中的图像:</p>
<img src="sources/img1.JPG" alt="Jiajia" width="90" height="120">
<p>一个来自网站的图像:</p>
<img src="http://www.runoob.com/images/logo.png" alt="runoob.com" width="336" height="69">
alt 属性用来为图像定义一串预备的可替换的文本,
当图像未显示时就有用了

#### 图片在文字中位置
<h4>默认对齐的图像 (align="bottom"):</h4>
<p>这是一些文本。 <img src="sources/img1.JPG" alt="Jiajia" width="90" height="120"> 这是一些文本。</p>
<h4>图片使用 align="middle":</h4>
<p>这是一些文本。 <img src="sources/img1.JPG" alt="Jiajia" align="middle" width="90" height="120">这是一些文本。</p>
<h4>图片使用 align="top":</h4>
<p>这是一些文本。 <img src="sources/img1.JPG" alt="Jiajia" align="top" width="90" height="120">这是一些文本。</p>

#### 图片浮动
<p>
<img src="sources/img1.JPG" alt="Jiajia" style="float:left" align="top" width="90" height="120"> 一个带图片的段落，图片浮动在这个文本的左边。
</p>
<br/><br/><br/><br/><br/>
<p>
<img src="sources/img1.JPG" alt="Jiajia" align="top" style="float:right" width="90" height="120"> 一个带图片的段落，图片浮动在这个文本的右边。
</p>

+ 创建图像链接:往链接里放图片

+ 创建图像映射

#### HTML 图像标签
<img>  定义图像
<map> 定义图像地图
<area> 定义图像地图中的可点击区域

#### <map><area>实例
<img src="sources/img1.JPG" width="300" height="400" alt="Jiajia" usemap="#jmap">
<map name="jmap">
<area shape="circle" coords="150,390,20" alt="foot" href="hello1.html">
</map>

1、矩形：(左上角顶点坐标为(x1,y1)，右下角顶点坐标为(x2,y2)) 
<area shape="rect" coords="x1,y1,x2,y2" href=url>
2、圆形：(圆心坐标为(X1,y1)，半径为r) 
<area shape="circle" coords="x1,y1,r" href=url>
3、多边形：(各顶点坐标依次为(x1,y1)、(x2,y2)、(x3,y3) ......) 
<area shape="poly" coords="x1,y1,x2,y2 ......" href=url>

### HTML 表格

#### 表格实例
<table border="1">
    <tr>
        <td>row 1, cell 1</td>
        <td>row 1, cell 2</td>
    </tr>
    <tr>
        <td>row 2, cell 1</td>
        <td>row 2, cell 2</td>
    </tr>
</table>

<border> 边框宽度 : 向下取整
 <tr> 行 </tr> <td> 列 </td>

#### 加表头(Heading)
对应的想加表头的地方把<td>换成<th>

#### 加标题 (caption)
在<table>下第一行加<caption>Monthly savings</caption>

#### 跨行或跨列的表格单元格
跨行<th colspan="2">Telephone</th>
跨列<th rowspan="2">Telephone:</th>

#### 表格内标签的实例
<table border="1">
<tr>
  <td>
   <p>这是一个段落</p>
   <p>这是另一个段落</p>
  </td>
  <td>这个单元格包含一个表格:
   <table border="1">
   <tr>
     <td>A</td>
     <td>B</td>
   </tr>
   <tr>
     <td>C</td>
     <td>D</td>
   </tr>
   </table>
  </td>
</tr>
<tr>
  <td>这个单元格包含一个列表
   <ul>
    <li>apples</li>
    <li>bananas</li>
    <li>pineapples</li>
   </ul>
  </td>
  <td>HELLO</td>
</tr>
</table>

#### 单元格边距
<table border="1" cellpadding="10">

#### 单元格间距
<table border="1" cellspacing="0">

#### <colgroup>
<colgroup>定义表格列的组
<col>定义用于表格列的属性
<colgroup>
    <col span="2" style="background-color:red">
    <col style="background-color:yellow">
 </colgroup>

#### <thead> 页眉<tbody> 主体<tfoot> 页脚 
他们放在<td>或<th>之外,不影响布局,但是可以统一进行修饰]]></description></item><item><title>HTML（三）链接，，css样式</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/02/html_3.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 02 Jul 2019 12:45:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/02/html_3.html</guid><description><![CDATA[### HTML链接

#### HTML 超链接
一个未访问过的链接显示为蓝色字体并带有下划线
访问过的链接显示为紫色并带有下划线
点击链接时，链接显示为红色并带有下划线
注意：如果为这些超链接设置了 CSS 样式，展示样式会根据 CSS 的设定而显示

#### HTML 链接语法
<a href="url">链接文本</a>

#### HTML 链接 - target 属性
<a href="http://www.runoob.com/" target="_blank">访问菜鸟教程!</a>
使用 target 属性，你可以定义被链接的文档在何处显示
target 属性参数有4个:
_blank
浏览器总在一个新打开、未命名的窗口中载入目标文档。
_self
这个目标的值对所有没有指定目标的 <a> 标签是默认目标，它使得目标文档载入并显示在相同的框架或者窗口中作为源文档。这个目标是多余且不必要的，除非和文档标题 <base> 标签中的 target 属性一起使用。
_parent
这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标 _self 等效。
_top
这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。

#### 图片链接
<p>创建图片链接:
<a href="http://www.runoob.com/html/html-tutorial.html">
<img  border="10" src="smiley.gif" alt="HTML 教程" width="32" height="32"></a></p>
<p>无边框的图片链接:
<a href="http://www.runoob.com/html/html-tutorial.html">
<img border="0" src="smiley.gif" alt="HTML 教程" width="32" height="32"></a></p>

### HTML <head>

#### HTML <head> 元素
<head> 元素包含了所有的头部标签元素
在 <head>元素中你可以插入脚本（scripts）,
样式文件（CSS），及各种meta信息。
可以添加在头部区域的元素标签为: 
<title>, <style>, <meta>, <link>, <script>, <noscript>, <base>

#### HTML <title> 元素
<title>文档标题</title>定义了浏览器工具栏的标题

#### HTML <base> 元素
<base> 标签描述了基本的链接地址/链接目标，
该标签作为HTML文档中所有的链接标签的默认链接
<base href="http://www.runoob.com/images/" target="_blank">

#### HTML <link> 元素
<link> 标签定义了文档与外部资源之间的关系
<link> 标签通常用于链接到样式表

#### HTML <style> 元素
<style> 标签定义了HTML文档的样式文件引用地址
在<style> 元素中你也可以直接添加样式来渲染 HTML 文档
<style type="text/css">
body {background-color:yellow}
p {color:blue}
</style>

#### HTML <meta> 元素
为搜索引擎定义关键词:
<meta name="keywords" content="HTML, CSS, XML, XHTML, JavaScript">
为网页定义描述内容:
<meta name="description" content="免费 Web & 编程 教程">
定义网页作者:
<meta name="author" content="Runoob">
每30秒钟刷新当前页面:
<meta http-equiv="refresh" content="30">

#### HTML <script> 元素
<script>标签用于加载脚本文件,如:JavaScript

### HTML 样式-CSS

#### 如何使用CSS
内联样式- 在HTML元素中使用"style" 属性
内部样式表 -在HTML文档头部 <head> 区域使用<style> 元素 来包含CSS
外部引用 - 使用外部 CSS 文件

#### 没有下划线的链接
<a href="http://www.runoob.com/" style="text-decoration:none;">访问 runoob.com!</a>

#### HTML内联样式实例 - 背景颜色
<body style="background-color:yellow;">
<h2 style="background-color:red;">这是一个标题</h2>
<p style="background-color:green;">这是一个段落。</p>
</body>

#### HTML 内联样式实例 - 字体, 字体颜色 ，字体大小
<h1 style="font-family:verdana;">一个标题</h1>
<p style="font-family:arial;color:red;font-size:20px;">一个段落。</p>

#### HTML 内联样式实例 - 文本对齐方式
<h1 style="text-align:center;">居中对齐的标题</h1>
<p>这是一个段落。</p>

#### 内部样式表
在<head>中添加<style>,设置默认样式
<head>
<style type="text/css">
h1 {color:red;}
p {color:blue;}
</head>

#### 外部样式表
<head>
<link rel="stylesheet" type="text/css" href="mystyle.css">
</head>

#### html引用css
html里加一个class属性,css中加上特效]]></description></item><item><title>HTML（二）属性，标题，段落，文本格式化</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/02/html_2.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 02 Jul 2019 12:43:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/02/html_2.html</guid><description><![CDATA[### HTML属性

#### HTML属性
HTML 元素可以设置属性
属性可以在元素中添加附加信息
属性一般描述于开始标签
属性总是以名称/值对的形式出现,比如:name="value"

#### 常用属性(尽量小写)
name 名字
href 链接
class 为html元素定义一个或多个类名(classname)(类名从样式文件引入)
id 定义元素的唯一id
style 规定元素的行内样式（inline style）
title 描述了元素的额外信息 (作为工具条使用)

### HTML标题

#### 标题(Heading)
是通过 <h1> - <h6> 标签进行定义的
<h1> 定义最大的标题</h1>
<h6> 定义最小的标题</h6>

#### HTML水平线
<hr> 标签在 HTML 页面中创建水平线

#### HTML注释
<!--这是一个注释-->

### HTML段落

#### HTML拆行
如果您希望在不产生一个新段落的情况下进行换行（新行），
请使用 <br /> 标签：
实例
<p>这个<br>段落<br>演示了分行的效果</p>

### HTML文本格式化

#### 文本格式
<b>加粗文本</b><br><br>
<i>斜体文本</i><br><br>
<code>电脑自动输出</code><br><br>
这是 <sub> 下标</sub> 和 <sup> 上标</sup>
<strong>strong突出显示,类似加粗</strong>
<em>em突出显示,类似斜体</em>
<big>字体放大</big>
<small>字体缩小<small>
<p>该段落文字从左到右显示。</p>  
<p><bdo dir="rtl">该段落文字从右到左显示。</bdo></p>

#### 计算机输出 标签
<code>计算机输出</code>
<kbd>键盘输入</kbd>
<tt>打字机文本<tt>
<samp>计算机代码样本</samp>
<var>计算机变量</var>

#### 地址
<address>
Written by <a href="mailto:6325@163.com">Jon Doe</a>.
</address>

#### 引用
<p>WWF's goal is to: 
<q>Build a future where people live in harmony with nature.</q>
We hope they succeed.</p>
输出<q></q>里的内容带双引号

#### 删除字效果和插入字效果
<p>My favorite color is <del>blue</del> <ins>red</ins>!</p>

#### HTML 引文, 引用, 及标签定义
<abbr>定义缩写
The <abbr title="World Health Organization">WHO</abbr> was founded in 1948.
<blockquote>定义长的引用(作为一个块被引用)
<blockquote cite="http://www.worldwildlife.org/who/index.html">
For 50 years, WWF has been protecting the future of nature. The world's leading conservation organization, WWF works in 100 countries and is supported by 1.2 million members in the United States and close to 5 million globally.
</blockquote>
<cite>定义引用、引证
<p><cite>The Scream</cite> by Edward Munch. Painted in 1893.</p>
<dfn>定义一个定义项目
<dfn>定义项目</dfn>]]></description></item><item><title>NLP（五） 词性标注和文法</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/02/nlp_5.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 02 Jul 2019 12:37:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/02/nlp_5.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp5/
+ NLTK内置词性标注器
用nltk.pos_tag()函数进行词性标注
```
import nltk
nltk.download('averaged_perceptron_tagger')

simpleSentence = 'Bangalore is the capital of Karnataka.'

# 分词
wordsInSentence = nltk.word_tokenize(simpleSentence)
print(wordsInSentence)

# 词性标注
partsOfSpeechTags = nltk.pos_tag(wordsInSentence)
print(partsOfSpeechTags)
```
输出：
```
['Bangalore', 'is', 'the', 'capital', 'of', 'Karnataka', '.']
[('Bangalore', 'NNP'), ('is', 'VBZ'), ('the', 'DT'), ('capital', 'NN'), ('of', 'IN'), ('Karnataka', 'NNP'), ('.', '.')]
```
+ 自己的词性标注器
```
import nltk

# 默认：不认识的都标成NN
def learnDefaultTagger(simpleSentence):
    wordsInSentence = nltk.word_tokenize(simpleSentence)
    tagger = nltk.DefaultTagger('NN')
    posEnabledTags = tagger.tag(wordsInSentence)
    print(posEnabledTags)

# 正则表达式标注
def learnRETagger(simpleSentence):
    # 元组列表，r不能省哦
    customPatterns =[
        (r'.*ing$','ADJECTIVE'),
        (r'.*ly$','ADVERB'),
        (r'.*ion$','NOUN'),
        (r'(.*ate|.*en|is)$','VERB'),
        (r'^an$','INDEFINITE-ARTICLE'),
        (r'^(with|on|at)$','PREPOSITION'),
        (r'^[0-9]*$','NUMBER'),
        (r'.*$',None),
    ]
    tagger = nltk.RegexpTagger(customPatterns)
    wordsInSentencs = nltk.word_tokenize(simpleSentence)
    posEnabledTags =tagger.tag(wordsInSentencs)
    print(posEnabledTags)

# 字典标注
def learnLookupTagger(simpleSentence):
    mapping = {
        '.':'.','place':'NN','on':'IN','earth':'NN','Mysore':'NNP',
        'is':'VBZ','an':'DT','amazing':'JJ',
    }
    tagger = nltk.UnigramTagger(model=mapping)
    wordsInSentencs = nltk.word_tokenize(simpleSentence)
    posEnabledTags = tagger.tag(wordsInSentencs)
    print(posEnabledTags)

if __name__ == "__main__":
    testSentence = 'Mysore is an amazing place on earth. I have visited Mysore 10 times.'
    learnDefaultTagger(testSentence)
    learnRETagger(testSentence)
    learnLookupTagger(testSentence)
```
输出：
```
[('Mysore', 'NN'), ('is', 'NN'), ('an', 'NN'), ('amazing', 'NN'), ('place', 'NN'), ('on', 'NN'), ('earth', 'NN'), ('.', 'NN'), ('I', 'NN'), ('have', 'NN'), ('visited', 'NN'), ('Mysore', 'NN'), ('10', 'NN'), ('times', 'NN'), ('.', 'NN')]
[('Mysore', None), ('is', 'VERB'), ('an', 'INDEFINITE-ARTICLE'), ('amazing', 'ADJECTIVE'), ('place', None), ('on', 'PREPOSITION'), ('earth', None), ('.', None), ('I', None), ('have', None), ('visited', None), ('Mysore', None), ('10', 'NUMBER'), ('times', None), ('.', None)]
[('Mysore', 'NNP'), ('is', 'VBZ'), ('an', 'DT'), ('amazing', 'JJ'), ('place', 'NN'), ('on', 'IN'), ('earth', 'NN'), ('.', '.'), ('I', None), ('have', None), ('visited', None), ('Mysore', 'NNP'), ('10', None), ('times', None), ('.', '.')]
```
+ 训练自己的词性标注器
```
import nltk
import pickle

# 训练集
def sampleData():
    return [
        'Bangalore is the capital of Karnataka.',
        'Steve Jobs was the CEO of Apple.',
        'iPhone was Invented by Apple.',
        'Books can be purchased in Market.',
    ]

# 逐句分词，得到词性，将训练集的词和词性放到字典里
def buildDictionary():
    dictionary = {}
    for sent in sampleData():
        partsOfSpeechTags = nltk.pos_tag(nltk.word_tokenize(sent))
        for tag in partsOfSpeechTags:
            value = tag[0]
            pos = tag[1]
            dictionary[value] = pos
    return dictionary

def saveMyTagger(tagger,fileName):
    fileHandle = open(fileName,'wb')
    pickle.dump(tagger,fileHandle) # 写入二进制
    fileHandle.close()

# 用学习的字典得到tagger
def saveMyTraining(fileName):
    tagger = nltk.UnigramTagger(model=buildDictionary())
    saveMyTagger(tagger,fileName)

# 读取自己的模型
def loadMyTagger(fileName):
    return pickle.load(open(fileName,'rb'))

sentence = 'IPhone is purchased by Steve Jobs in Bangalore Market.'
fileName = 'myTagger.pickle'

saveMyTraining(fileName)

myTagger = loadMyTagger(fileName)

print(myTagger.tag(nltk.word_tokenize(sentence)))
```
输出：
```
[('IPhone', None), ('is', 'VBZ'), ('purchased', 'VBN'), ('by', 'IN'), ('Steve', 'NNP'), ('Jobs', 'NNP'), ('in', 'IN'), ('Bangalore', 'NNP'), ('Market', 'NNP'), ('.', '.')]
```
+ 编写自己的文法
上下文无关文法：
1.开始符号/标记
2.终结符号集合
3.非终结符号集合
4.定义开始符号和规则（产生式）
5.语言是英文时，a-z是符号/标记/字母
6.语言是数字时，0-9是符号/标记/字母
产生式是用**巴克斯-诺尔**(**BNF**)范式写的
```
import nltk
import string
from nltk.parse.generate import generate
import sys

# 定义一个起始符号为ROOT的文法
productions = [
    'ROOT -> WORD',
    'WORD -> \' \'',
    'WORD -> NUMBER LETTER',
    'WORD -> LETTER NUMBER',
]

# 添加新的生成方式 'NUMBER -> 0|1|2|3'
digits = list(string.digits) # str格式的数字
for digit in digits[:4]:
    productions.append('NUMBER -> \'{w}\''.format(w=digit))

# 添加新的生成方式 'LETTER -> a|b|c|d'
letters ="' | '".join(list(string.ascii_lowercase)[:4])
productions.append('LETTER -> \'{w}\''.format(w=letters))

# 将文法分行存于grammarString
grammarString = '\n'.join(productions)

# 创建文法对象，并查看之
grammar = nltk.CFG.fromstring(grammarString)
print(grammar)

# 读取语法树 最多个数：5 最多层数：4
for sentence in generate(grammar,n=5,depth=4):
    palindrome = ''.join(sentence).replace(' ','')
    print('Generated Word: {} , Size : {}'.format(palindrome,len(palindrome)))
```
+ 输出
```
Grammar with 12 productions (start state = ROOT)
    ROOT -> WORD
    WORD -> ' '
    WORD -> NUMBER LETTER
    WORD -> LETTER NUMBER
    NUMBER -> '0'
    NUMBER -> '1'
    NUMBER -> '2'
    NUMBER -> '3'
    LETTER -> 'a'
    LETTER -> 'b'
    LETTER -> 'c'
    LETTER -> 'd'
Generated Word:   , Size : 0
Generated Word: 0a , Size : 2
Generated Word: 0b , Size : 2
Generated Word: 0c , Size : 2
Generated Word: 0d , Size : 2
```
+ 基于概率的上下文无关文法
所有非终结符号（左侧）的概率之和等于1

| 描述 | 内容 |
| --- | --- |
| 开始符号 | ROOT |
| 非终结符号 | WORD,P1,P2,P3,P4 |
| 终结符号 | 'A','B','C','D','E','F','G','H' |
```
import nltk
from nltk.parse.generate import generate

productions = [
    "ROOT -> WORD [1.0]",
    "WORD -> P1 [0.25]",
    "WORD -> P1 P2 [0.25]",
    "WORD -> P1 P2 P3 [0.25]",
    "WORD -> P1 P2 P3 P4 [0.25]",
    "P1 -> 'A' [1.0]",
    "P2 -> 'B' [0.5]",
    "P2 -> 'C' [0.5]",
    "P3 -> 'D' [0.3]",
    "P3 -> 'E' [0.3]",
    "P3 -> 'F' [0.4]",
    "P4 -> 'G' [0.9]",
    "P4 -> 'H' [0.1]",
]
grammarString = '\n'.join(productions)

# 创建grammar对象
grammar = nltk.PCFG.fromstring(grammarString)
print(grammar)

for sentence in generate(grammar,n=5,depth=4):
    palindrome = ''.join(sentence).replace(' ','')
    print('String : {} , Size : {}'.format(palindrome,len(palindrome)))
```
输出：
```
Grammar with 13 productions (start state = ROOT)
    ROOT -> WORD [1.0]
    WORD -> P1 [0.25]
    WORD -> P1 P2 [0.25]
    WORD -> P1 P2 P3 [0.25]
    WORD -> P1 P2 P3 P4 [0.25]
    P1 -> 'A' [1.0]
    P2 -> 'B' [0.5]
    P2 -> 'C' [0.5]
    P3 -> 'D' [0.3]
    P3 -> 'E' [0.3]
    P3 -> 'F' [0.4]
    P4 -> 'G' [0.9]
    P4 -> 'H' [0.1]
String : A , Size : 1
String : AB , Size : 2
String : AC , Size : 2
String : ABD , Size : 3
String : ABE , Size : 3
```
+ 编写递归的上下文无关文法
以递归方法生成回文为例，回文：比如01语言系统的 010010 等
```
# 生成偶数回文数字
import nltk
import string
from nltk.parse.generate import generate

productions = [
    'ROOT -> WORD',
    "WORD -> ' '",
]

alphabets = list(string.digits)

for alphabet in alphabets:
    productions.append("WORD -> '{w}' WORD '{w}'".format(w=alphabet))

grammarString = '\n'.join(productions)

grammar = nltk.CFG.fromstring(grammarString)
print(grammar)

for sentence in generate(grammar,n=5,depth=5):
    palindrome = ''.join(sentence).replace(' ','')
    print('Palindrome : {} , Size : {}'.format(palindrome,len(palindrome)))
```
输出：
```
Grammar with 12 productions (start state = ROOT)
    ROOT -> WORD
    WORD -> ' '
    WORD -> '0' WORD '0'
    WORD -> '1' WORD '1'
    WORD -> '2' WORD '2'
    WORD -> '3' WORD '3'
    WORD -> '4' WORD '4'
    WORD -> '5' WORD '5'
    WORD -> '6' WORD '6'
    WORD -> '7' WORD '7'
    WORD -> '8' WORD '8'
    WORD -> '9' WORD '9'
Palindrome :  , Size : 0
Palindrome : 00 , Size : 2
Palindrome : 0000 , Size : 4
Palindrome : 0110 , Size : 4
Palindrome : 0220 , Size : 4
```]]></description></item><item><title>HTML（一）简介，元素</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/02/html_1.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 02 Jul 2019 03:21:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/02/html_1.html</guid><description><![CDATA[### HTML简介

#### html实例:
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程</title>
</head>
<body>

<h1>我的第一个标题</h1>

<p>我的第一个段落</p>

</body>
</html>

#### 实例解析:
<!DOCTYPE html> 声明为 HTML5 文档,不区分大小写
<html> 元素是 HTML 页面的根元素
<head> 元素包含了文档的元（meta）数据，
如 <meta charset="utf-8"> 定义网页编码格式为 utf-8。
<title> 元素描述了文档的标题
<body> 元素包含了可见的页面内容
<h1> 元素定义一个大标题
<p> 元素定义一个段落

### HTML元素

#### HTML标签
HTML 标签是由尖括号包围的关键词，比如 <html>
HTML 标签通常是成对出现的，比如 <b> 和 </b>
标签对中的第一个标签是开始标签,第二个标签是结束标签<标签>内容</标签>
开始和结束标签也被称为开放标签和闭合标签

#### HTML标题
HTML 标题（Heading）是通过<h1> - <h6> 标签来定义的
<h1>这是一个标题</h1>
<h2>这是一个标题</h2>
<h3>这是一个标题</h3>

#### HTML段落
HTML 段落是通过标签 <p> 来定义的
<p>段落一</p>
<p>段落二</p>

#### HTML链接
HTML 链接是通过标签 <a> 来定义的
<a href="http://www.baidu.com">这是一个链接</a>

#### HTML图像
HTML 图像是通过标签 <img> 来定义的
<img src="https://www.cnblogs.com/images/logo.png" width="258" height="39" />



#### HTML元素
HTML 文档由 HTML 元素定义
<p>这是一个段落</p>
<a href="default.htm">这是一个链接</a>
<br>换行(没有结束标签)

#### HTML元素语法
HTML 元素以开始标签起始
HTML 元素以结束标签终止
元素的内容是开始标签与结束标签之间的内容
某些 HTML 元素具有空内容（empty content）
空元素在开始标签中进行关闭（以开始标签的结束而结束）
大多数 HTML 元素可拥有属性

#### 嵌套的HTML元素

<p> 元素:
<p>这是第一个段落。</p>
这个 <p> 元素定义了 HTML 文档中的一个段落
这个元素拥有一个开始标签<p>以及一个结束标签</p>
元素内容是: 这是第一个段落

<body> 元素:
<body>
<p>这是第一个段落。</p>
</body> 
<body> 元素定义了 HTML 文档的主体。
这个元素拥有一个开始标签<body>以及一个结束标签</body>
元素内容是另一个 HTML 元素(p 元素)

<html> 元素：
<html>
..............
<body>
<p>这是第一个段落。</p>
</body>
..............
</html> 
<html> 元素定义了整个 HTML 文档。
这个元素拥有一个开始标签 <html> ,以及一个结束标签 </html>
元素内容是另一个 HTML 元素(body 元素)

<br/> 空元素

标签要是用小写]]></description></item><item><title>NLP（四） 正则表达式</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/02/nlp_4.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Tue, 02 Jul 2019 03:05:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/02/nlp_4.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp4/
+ \*  \+  ?
\* ：0个或多个
\+ ：1个或多个
? ：0个或1个
re.search()函数，将str和re匹配，匹配正确返回True
```
import re

# 匹配函数，输入：文本，匹配模式（即re）
def text_match(text,patterns):
    if re.search(patterns,text):
        return 'Found a match!'
    else:
        return 'Not matched!'

# 测试
print(text_match('ac','ab?'))
print(text_match('abc','ab?'))
print(text_match('abbc','ab?'))

print(text_match('ac','ab*'))
print(text_match('abc','ab*'))
print(text_match('abbc','ab*'))

print(text_match('ac','ab+'))
print(text_match('abc','ab+'))
print(text_match('abbc','ab+'))

print(text_match('abbc','ab{2}'))

print(text_match('aabbbbc','ab{3,5}?'))
```
输出：
```
Found a match!
Found a match!
Found a match!
Found a match!
Found a match!
Found a match!
Not matched!
Found a match!
Found a match!
Found a match!
Found a match!
```
+ $ ^ .
$ ：结尾
^ ：开头
. ：除换行符以外的任何字符
\w ：字母，数字，下划线
\s ：空格符
\S ：非空格符
\b ：空格
\B ：非空格
```
import re
def text_match(text,patterns):
    if re.search(patterns,text):
        return 'Found a match!'
    else:
        return 'Not matched!'

# 任意以a开头，以c结尾
print(text_match('abbc','^a.*c$'))

# 以文本开始，后面有出现一次或多次的文本
print(text_match('Tuffy eats pie, Loki eats peas!','^\w+'))

# 文末一个或多个\w加上0个或多个非空字符，\S在\w后面表示标点符号
print(text_match('Tuffy eats pie, Loki eats peas!','\w+\S*$'))

# 含u在中间的单词
print(text_match('Tuffy eats pie, Loki eats peas!','\Bu\B'))
```
输出：
```
Found a match!
Found a match!
Found a match!
Found a match!
```
+ 字符串匹配
re.search(pattern,text) ：判断text里是否有pattern
re.finditer(pattern,text) ：在text里找到pattern
```
import re

patterns = ['Tuffy','Pie','Loki']
text = 'Tuffy eats pie, Loki eats peas!'

# 匹配字符串
for pattern in patterns:
    print('Searching for "%s" in "%s" -&gt;' % (pattern,text))
    if re.search(pattern,text):
    # 如果不想区分大小写，加参数 flags=re.IGHORECASE
        print('Found!')
    else:
        print('Not Found!')

# 匹配字符串，并找到他的位置
pattern = 'eats'
for match in re.finditer(pattern,text):
    s = match.start()
    e = match.end()
    print('Found "%s" at %d:%d'%(text[s:e],s,e))
```
输出：
```
Searching for "Tuffy" in "Tuffy eats pie, Loki eats peas!" -&gt;
Found!
Searching for "Pie" in "Tuffy eats pie, Loki eats peas!" -&gt;
Not Found!
Searching for "Loki" in "Tuffy eats pie, Loki eats peas!" -&gt;
Found!
Found "eats" at 6:10
Found "eats" at 21:25
```
+ 日期，一组字符集合(或字符范围)
\d ：数字
re.compile() ：string => RegexObject的对象
方括号[]内的所有内容都是OR关系
```
import re
url = 'http://www.awdawd.com/da/wda/2019/7/2/wda.html'

# YYYY/MM/DD
date_regex = '/(\d{4})/(\d{1,2})/(\d{1,2})'
print('Data found in the URL :',re.findall(date_regex,url))

# 有特殊字符返回Flase
def is_allowed_specific_char(string):
    charRe = re.compile(r'[^a-zA-Z0-9.]')
    string = charRe.search(string)
    return not bool(string)

print(is_allowed_specific_char('adIDHihdHDIh.'))
print(is_allowed_specific_char('*#$%^&!{}'))
```
输出：
```
Data found in the URL : [('2019', '7', '2')]
True
False
```
+ 找到所有长度为5的单词，缩写替换单词
```
import re

# 用缩写替换
street = '21 Ramkrishna Road'
print(re.sub('Road','Rd',street))

# 找到长度为5的单词
text = 'Tuffy eats pie, Loki eats bread!'
print(re.findall(r'\b\w{5}\b',text))
```
输出：
```
21 Ramkrishna Rd
['Tuffy', 'bread']
```
+ 基于RE的分词器
```
import re

raw = 'I am big!  It\'s the pictures that got small.'

# 用一个或多个空格分词
print(re.split(r' +',raw))

# 非 字母数字下划线 分词
print(re.split(r'\W+',raw))

# 匹配分词 ！
print(re.findall(r'\w+|\S\w*',raw))
```
输出：
```
['I', 'am', 'big!', "It's", 'the', 'pictures', 'that', 'got', 'small.']
['I', 'am', 'big', 'It', 's', 'the', 'pictures', 'that', 'got', 'small', '']
['I', 'am', 'big', '!', 'It', "'s", 'the', 'pictures', 'that', 'got', 'small', '.']
```
+ 基于RE的词干提取器
```
import re

# 自己的词干提取器
def stem(word):
    split = re.findall(r'^(.*?)(ing|ly|ed|ies|ive|es|s|ment)?$',word)
    stem = split[0][0]
    return stem

# 上节中re分词
raw = 'Keep your friends close, but your enemies closer.'
tokens = re.findall(r'\w+|\S\w*',raw)
print(tokens)

# 测试
for t in tokens:
    print("'",stem(t),"'")
```
输出：
```
['Keep', 'your', 'friends', 'close', ',', 'but', 'your', 'enemies', 'closer', '.']
' Keep ' ' your ' ' friend ' ' close ' ' , ' ' but ' ' your ' ' enem ' ' closer ' ' . ' 
```]]></description></item><item><title>NLP（三） 预处理</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/01/nlp_3.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 01 Jul 2019 12:22:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/01/nlp_3.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp3/
+ 分词
```
from nltk.tokenize import LineTokenizer,SpaceTokenizer,TweetTokenizer
from nltk import word_tokenize

# 根据行分词，将每行作为一个元素放到list中
lTokenizer = LineTokenizer()
print('Line tokenizer output :',lTokenizer.tokenize('hello hello\npython\nworld'))

# 根据空格分词
rawText = 'hello python,world'
sTokenizer = SpaceTokenizer()
print('Space tokenizer output :',sTokenizer.tokenize(rawText))

# word_tokenize分词
print('Word tokenizer output :',word_tokenize(rawText))

# 能使特殊符号不被分开
tTokenizer = TweetTokenizer()
print('Tweet tokenizer output :',tTokenizer.tokenize('This is a cooool #dummysmiley: :-) :-p <3'))
```
输出：
```
Line tokenizer output : ['hello hello', 'python', 'world']
Space tokenizer output : ['hello', 'python,world']
Word tokenizer output : ['hello', 'python', ',', 'world']
Tweet tokenizer output : ['This', 'is', 'a', 'cooool', '#dummysmiley', ':', ':-)', ':-p', '<3']
```
+ 词干提取
去除词的后缀，输出词干，如 `wanted=>want`
```
from nltk import PorterStemmer,LancasterStemmer,word_tokenize

# 创建raw并将raw分词
raw = 'he wants to be loved by others'
tokens = word_tokenize(raw)
print(tokens)

# 输出词干
porter = PorterStemmer()
pStems = [porter.stem(t) for t in tokens]
print(pStems)

# 这种方法去除的多，易出错
lancaster = LancasterStemmer()
lTems = [lancaster.stem(t) for t in tokens]
print(lTems)
```
输出：
```
['he', 'wants', 'to', 'be', 'loved', 'by', 'others']
['he', 'want', 'to', 'be', 'love', 'by', 'other']
['he', 'want', 'to', 'be', 'lov', 'by', 'oth']
```
+ 词形还原
词干提取只是去除后缀，词形还原是对应字典匹配还原
```
from nltk import word_tokenize,PorterStemmer,WordNetLemmatizer

raw = 'Tom flied kites last week in Beijing'
tokens = word_tokenize(raw)

# 去除后缀
porter = PorterStemmer()
stems = [porter.stem(t) for t in tokens]
print(stems)

# 还原器:字典找到才还原，特殊大写词不还原
lemmatizer = WordNetLemmatizer()
lemmas = [lemmatizer.lemmatize(t) for t in tokens]
print(lemmas)
```
输出：
```
['tom', 'fli', 'kite', 'last', 'week', 'in', 'beij']
['Tom', 'flied', 'kite', 'last', 'week', 'in', 'Beijing']
```
+ 停用词
古登堡语料库：18个未分类的纯文本
```
import nltk
from nltk.corpus import gutenberg
# nltk.download('gutenberg')
# nltk.download('stopwords')
print(gutenberg.fileids())
# print(stopwords)

# 获得bible-kjv.txt的所有单词，并过滤掉长度<3的单词
gb_words = gutenberg.words('bible-kjv.txt')
words_filtered = [e for e in gb_words if len(e) >= 3]

# 加载英文的停用词，并用它过滤
stopwords = nltk.corpus.stopwords.words('english')
words = [w for w in words_filtered if w.lower() not in stopwords]

# 处理的词表和未做处理的词表 词频的比较
fdistPlain = nltk.FreqDist(words)
fdist = nltk.FreqDist(gb_words)

# 观察他们的频率分布特征
print('Following are the most common 10 words in the bag')
print(fdistPlain.most_common(10))
print('Following are the most common 10 words in the bag minus the stopwords')
print(fdist.most_common(10))
```
输出：
```
['austen-emma.txt', 'austen-persuasion.txt', 'austen-sense.txt', 'bible-kjv.txt', 'blake-poems.txt', 'bryant-stories.txt', 'burgess-busterbrown.txt', 'carroll-alice.txt', 'chesterton-ball.txt', 'chesterton-brown.txt', 'chesterton-thursday.txt', 'edgeworth-parents.txt', 'melville-moby_dick.txt', 'milton-paradise.txt', 'shakespeare-caesar.txt', 'shakespeare-hamlet.txt', 'shakespeare-macbeth.txt', 'whitman-leaves.txt']
Following are the most common 10 words in the bag
[('shall', 9760), ('unto', 8940), ('LORD', 6651), ('thou', 4890), ('thy', 4450), ('God', 4115), ('said', 3995), ('thee', 3827), ('upon', 2730), ('man', 2721)]
Following are the most common 10 words in the bag minus the stopwords
[(',', 70509), ('the', 62103), (':', 43766), ('and', 38847), ('of', 34480), ('.', 26160), ('to', 13396), ('And', 12846), ('that', 12576), ('in', 12331)]
```
+ 编辑距离 Levenshtein_distance
从一个字符串变到另外一个字符串所需要最小的步骤，衡量两个字符串的相似度
动态规划算法：创建一个二维表，若相等，则=左上；否则=min(左，上，左上)+1
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190701202010942-1694900343.gif)
填完表计算编辑距离和相似度：
设两个字符串的长度分别是m，n，填的二维表为A
则
`编辑距离 = A[m][n]`
`相似度 = 1 - 编辑距离/max(m,n)`
代码实现：
```
from nltk.metrics.distance import edit_distance

def my_edit_distance(str1,str2):
    m = len(str1) + 1
    n = len(str2) + 1

    # 创建二维表，初始化第一行和第一列
    table = {}
    for i in range(m): table[i,0] = i
    for j in range(n): table[0,j] = j

    # 填表
    for i in range(1,m):
        for j in range(1,n):
            cost = 0 if str1[i-1] == str2[j-1] else 1
            table[i,j] = min(table[i,j-1]+1,table[i-1,j]+1,table[i-1,j-1]+cost)

    return table[i,j],1-table[i,j]/max(i,j)

print('My Algorithm :',my_edit_distance('aboard','abroad'))
print('NLTK Algorithm :',edit_distance('aboard','abroad'))
```
输出：
```
My Algorithm : (2, 0.6666666666666667)
NLTK Algorithm : 2
```
+ 提取两个文本共有词汇
```
story1 = open('story1.txt','r',encoding='utf-8').read()
story2 = open('story2.txt','r',encoding='utf-8').read()

# 删除特殊字符，所有字符串小写
story1 = story1.replace(',',' ').replace('\n',' ').replace('.',' ').replace('"',' ')\
    .replace("'",' ').replace('!',' ').replace('?',' ').casefold()
story2 = story2.replace(',',' ').replace('\n',' ').replace('.',' ').replace('"',' ')\
    .replace("'",' ').replace('!',' ').replace('?',' ').casefold()

# 分词
story1_words = story1.split(' ')
story2_words = story2.split(' ')

# 去掉重复词
story1_vocab = set(story1_words)
story2_vocab = set(story2_words)

# 找共同词
common_vocab = story1_vocab & story2_vocab
print('Common Vocabulary :',common_vocab)
```
输出：
```
Common Vocabulary : {'', 'got', 'for', 'but', 'out', 'you', 'caught', 'so', 'very', 'away', 'could', 'to', 'not', 'it', 'a', 'they', 'was', 'of', 'and', 'said', 'ran', 'the', 'saw', 'have'}
```]]></description></item><item><title>Python MySQL 数据库</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/01/python_basis_9.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 01 Jul 2019 08:56:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/01/python_basis_9.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/python9/
#### python DB API
+ python访问数据库的统一接口规范,完成不同数据库的访问
+ 包含的内容: `connection cursor exceptions`
+ 访问数据库流程: 1.创建connection 2.获取cursor 3.操作 4.关闭cursor 5.关闭connection
#### python MySQL开发环境
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190701165326228-985976292.png)
#### 连接对象connection
+ 连接对象: python客户端与数据库的网络连接
+ 创建方法: `pymysql.connect(参数)`
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190701165342799-74031243.png)
+ connection对象支持的方法:
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190701165354775-10614444.png)
+ 例子:
```
import pymysql

conn = pymysql.connect(
    host = '127.0.0.1',
    port = 3306,
    user = 'root',
    db = 'database1',
    charset = 'utf-8')
cursor = conn.cursor()

print(conn)
print(cursor)

cursor.close()
conn.close()
```
#### 游标对象cursor
+ 游标对象: 用于执行查询和获取结果
+ cursor对象支持的方法:
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190701165442975-1523160464.png)
+ `execute()`方法: 执行SQL,将结果从数据库获取到客户端
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190701165455996-1039285642.png)
+ `fetch*()`方法: 移动rownumber,返回数据
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190701165508423-420760824.png)
#### 实例 - select查询数据
+ 流程
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190701165520907-1565146266.png)
+ 代码
```
import pymysql

conn = pymysql.connect(
    host = '127.0.0.1',
    port = 3306,
    user = 'root',
    db = 'database1',
    charset = 'utf-8'
)
cursor = conn.cursor()

sql = "select * from table"
cursor.execute(sql)

print(cursor.rowcount)

rs = cursor.fetchone()
print(rs)

rs = cursor.fetchmany(3)
print(rs)

rs = cursor.fetchall()
print(rs)

cursor.close()
conn.close()
```
#### 实例 - insert/update/delete更新数据
+ 流程
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190701165533935-1681774147.png)
+ 事务: 访问和更新数据库的一个程序执行单元
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190701165546098-1555590176.png)
+ 开发中怎样使用事务
1.关闭自动commit: 设置conn.autocommit(False),默认就是这个状态
2.正常结束事务: conn.commit()
3.异常结束任务: conn.rollback()
+ 代码
```
import pymysql

conn = pymysql.connect(
    host = '127.0.0.1',
    port = 3306,
    user = 'root',
    db = 'database1',
    charset = 'utf-8'
)
cursor = conn.cursor()

sql_insert = "insert into database1(userid,username) values(10,'name10')"
sql_update = "update database1 set username='name91' where userid = 9"
sql_delete = "delete from database1 where userid < 3"

try:
    cursor.execute(sql_insert)
    print(cursor.rowcount) # 查看对多少行造成了影响
    cursor.execute(sql_update)
    print(cursor.rowcount)
    cursor.execute(sql_delete)
    print(cursor.rowcount)
    conn.commit() #提交,更新数据库
exception Exception as e:
    print e
    conn.rollback() #回滚,只要有一条有错就啥都不提交了

cursor.close()
conn.close()
```
#### 银行转账实例 - A给B转账100元
+ 流程
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190701165603735-581350930.png)
+ 实例数据库
+ 代码
```
# coding:utf8
import pymysql
import sys

class TransferMoney(object):
    def __init__(self,conn):
        self.conn = conn

    def check_acct_available(self,acctid):
        cursor = self.conn.cursor()
        try:
            sql = "select * from account where acctid=%s" % acctid
            cursor.execute(sql)
            print("check_acct_available:"+sql)
            rs = cursor.fetchall()
            if len(rs)!=1:
                raise Exception("账号%s不存在" % acctid)
        finally:
            cursor.close()

    def has_enough_money(self,acctid, money):
        cursor = self.conn.cursor()
        try:
            sql = "select * from account where acctid=%s and money>%s" % (acctid,money)
            cursor.execute(sql)
            print("has_enough_money:" + sql)
            rs = cursor.fetchall()
            if len(rs) != 1:
                raise Exception("账号%s没有足够的钱" % acctid)
        finally:
            cursor.close()

    def reduce_money(self,acctid):
        cursor = self.conn.cursor()
        try:
            sql = "update account set money=money-%s where acctid=%s" % (money,acctid)
            cursor.execute(sql)
            print("reduce_money:" + sql)
            rs = cursor.fetchall()
            if cursor.rowcount != 1:
                raise Exception("账号%s减款失败" % acctid)
        finally:
            cursor.close()

    def add_money(self,acctid):
        cursor = self.conn.cursor()
        try:
            sql = "update account set money=money+%s where acctid=%s" % (money, acctid)
            cursor.execute(sql)
            print("reduce_money:" + sql)
            rs = cursor.fetchall()
            if cursor.rowcount != 1:
                raise Exception("账号%s加款失败" % acctid)
        finally:
            cursor.close()

    def transfer(self,source_acctid,target_acctid,money):
        try:
            self.check_acct_available(source_acctid)
            self.check_acct_available(target_acctid)
            self.has_enough_money(source_acctid,money)
            self.reduce_money(source_acctid)
            self.add_money(target_acctid)
            self.conn.commit()
        except Exception as e:
            self.conn.rollback()
            raise e

if __name__ == "__main__":
    source_acctid = sys.argv[1]
    target_acctid = sys.argv[2]
    money = sys.argv[3]

    conn = pymysql.connect(host='127.0.0.1',user='root',
                passwd='123456',port=3306,db='database1')
    tr_money = TransferMoney(conn)

    try:
        tr_money.transfer(source_acctid,target_acctid,money)
    except Exception as e:
        print("出现问题:"+str(e))
    finally:
        conn.close()
```]]></description></item><item><title>Python 网络编程</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/01/python_basis_8.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 01 Jul 2019 08:49:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/01/python_basis_8.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/python8/
+ Python 提供了两个级别访问的网络服务：
1. 低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。
2. 高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
#### 什么是 Socket ?
Socket又称"套接字"，应用程序通常通过"套接字"向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。
#### `socket()`函数
Python中，我们用 `socket()`函数来创建套接字，语法格式如下：
`socket.socket([family[, type[, proto]]])`
+ 参数
family: 套接字家族可以使`AF_UNIX`或者`AF_INET`.
type: 套接字类型可以根据是面向连接的还是非连接分为`SOCK_STREAM`或`SOCK_DGRAM`.
protocol: 一般不填默认为`0`.
#### Socket 对象(内建)方法
+ 服务器端套接字
`s.bind()` 绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。
`s.listen()` 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。
`s.accept()` 被动接受TCP客户端连接,(阻塞式)等待连接的到来
+ 客户端套接字
`s.connect()` 主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。
`s.connect_ex()` connect()函数的扩展版本,出错时返回出错码,而不是抛出异常
+ 公共用途的套接字函数
`s.recv()`
接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。
`s.send()`
发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。
`s.sendall()`
完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。
`s.recvfrom()`
接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。
`s.sendto()`
发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。
`s.close()` 关闭套接字
`s.getpeername()` 返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。
`s.getsockname()` 返回套接字自己的地址。通常是一个元组(ipaddr,port)
`s.setsockopt(level,optname,value)` 设置给定套接字选项的值。
`s.getsockopt(level,optname[.buflen])` 返回套接字选项的值。
`s.settimeout(timeout)` 设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）
`s.gettimeout()` 返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。
`s.fileno()` 返回套接字的文件描述符。
`s.setblocking(flag)` 如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。
`s.makefile()` 创建一个与该套接字相关连的文件
#### 简单实例
+ 服务器
```
# 文件名：server.py

# 导入 socket、sys 模块
import socket
import sys

# 创建 socket 对象
serversocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

# 获取本地主机名
host = socket.gethostname()

port = 9941

# 绑定端口号
serversocket.bind((host,port))

# 设置最大连接数，超过后排队
serversocket.listen(5)

while True:
    clientsocket,addr = serversocket.accept()

    print("连接地址: %s" % str(addr))

    msg = '欢迎访问!'+'\r\n'
    clientsocket.send(msg.encode('utf-8'))
    clientsocket.close()
```
+ 客户端
```
# 文件名：client.py

# 导入 socket、sys 模块
import socket
import sys

# 创建 socket 对象
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

# 获取本地主机名
host = socket.gethostname()

# 设置端口号
port = 9999

# 连接服务，指定主机和端口
s.connect((host, port))

# 接收小于 1024 字节的数据
msg = s.recv(1024)

s.close()

print (msg.decode('utf-8'))
```
+ 说明
1. 先运行server.py,再运行client.py,在客户端中会出现"`欢迎访问 a!`"的信息,回去看服务器,会监听到访问它的客户端的连接地址
2. socket只能在不同终端通信,在linux中直接打开另一个终端,在windows编译器中要打开两个IDLE进行测试
#### Python Internet 常用模块
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190701164749588-217965023.png)]]></description></item><item><title>简单的 Python 人脸识别实例</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/01/python_basis_7.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 01 Jul 2019 08:46:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/01/python_basis_7.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/python7/
### 案例一 导入图片
+ 思路: 1.导入库 2.加载图片 3.创建窗口 4.显示图片 5.暂停窗口 6.关闭窗口
```
# 1.导入库
import cv2

# 2.加载图片
img = cv2.imread('a.png')

# 3.创建窗口
cv2.namedWindow('window 1 haha')

# 4.显示图片
cv2.imshow('window 1',img)

# 5.暂停窗口
cv2.waitKey(0)

# 6.关闭窗口
cv2.destroyAllWindows()
```
### 案例二 在图片上添加人脸识别
+ 思路: 1.导入库 2.加载图片 3.加载人脸模型 4.调整图片灰度 5.检查人脸 6.标记人脸 7.创建窗口 8.显示图片 9.暂停窗口 10.关闭窗口
```
# 1.导入库
import cv2

# 2.加载图片
img = cv2.imread('a.png')

# 3.加载人脸模型,opencv官网下载
face = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')

# 4.调整图片灰度:没必要识别颜色,灰度可以提高性能
gray = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)

# 5.检查人脸
faces = face.detectMultiScale(gray)

# 6.标记人脸for (x,y,w,h) in faces:    
    # 里面有4个参数 1.写图片 2.坐标原点 3.识别大小 4.颜色 5.线宽    
    cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),4)

# 7.创建窗口    
    cv2.namedWindow('window 1 haha')

# 8.显示图片
cv2.imshow('window 1', img)

# 9.暂停窗口
cv2.waitKey(0)

# 10.关闭窗口
cv2.destroyAllWindows()
```
### 案例三 调用摄像头
+ 思路: 1.导入库 2.打开摄像头 3.获取摄像头实时画面 4.释放资源 5.关闭窗口
```
# 1.导入库
import cv2

# 2.打开摄像头
capture = cv2.VideoCapture(0)

# 3.获取摄像头实时画面
cv2.namedWindow('camera')
while True:    
    #3.1 获取摄像头的帧画面    
    ret,frame = capture.read()    
    #3.2 显示图片(渲染画面)    
    cv2.imshow('window 1',frame)    
    #3.3 暂停窗口    
    if cv2.waitKey(5) & 0xFF == ord('q'):
        break
        
# 4.释放资源
capture.release()

# 5.关闭窗口
cv2.destroyAllWindows()
```
### 案例四 摄像头识别人脸
+ 思路: 1.导入库 2.加载人脸模型 3.打开摄像头 4.创建窗口 5.获取摄像头实时画面 6.释放资源 7.关闭窗口
```
# 1.导入库
import cv2

# 2.加载人脸模型
face = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')

# 3.打开摄像头
capture = cv2.VideoCapture(0)

# 4.创建窗口cv2.namedWindow('window 1')

# 5.获取摄像头实时画面
while True:    
    # 5.1 获取摄像头的帧画面    
    ret,frame = capture.read()    
    # 5.2 图片灰度调整    
    gray = cv2.cvtColor(frame,cv2.COLOR_RGB2GRAY)    
    # 5.3 检查人脸    
    faces = face.detectMultiScale(gray)    
    # 5.4 标记人脸    
    for (x, y, w, h) in faces:        
        # 里面有4个参数 1.写图片 2.坐标原点 3.识别大小 4.颜色 5.线宽        
        cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 4)    
    # 5.5 显示图片        
        cv2.imshow('camera',frame)    
    # 5.6 暂停窗口        
        if cv2.waitKey(5) & 0xFF == ord('q'):            
            break

# 6.释放资源
capture.release()

# 7.关闭窗口
cv2.destroyAllWindows()
```]]></description></item><item><title>NLP（二） 获取数据源和规范化</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/01/nlp_2.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 01 Jul 2019 08:41:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/01/nlp_2.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp2/
+ Why we do this
将获取的数据统一格式，得到规范化和结构化得数据
+ 字符串操作
```
# 创建字符串列表和字符串对象
namesList = ['Tuffy','Ali','Nysha','Tim']
sentence = 'My dog sleeps on sofa'

# join的功能
names = ';'.join(namesList) # 以';'为分隔符将所有对象连成一个对象
print(type(names),':',names)

# split的功能
wordList = sentence.split(' ') # 以' '为分隔符将一个对象分割成多个对象的list
print(type(wordList),':',wordList)

# + 和 * 的功能：都能拼接
print('a'+'a'+'a')
print('b' * 3)

# 字符串中的字符索引
str = 'Python NLTK'
print(str[1])
print(str[-3])
```
输出：
```
<class 'str'> : Tuffy;Ali;Nysha;Tim
<class 'list'> : ['My', 'dog', 'sleeps', 'on', 'sofa']
aaa
bbb
y
L
```
+ 字符串操作深入
```
str = 'NLTK Dolly Python'

# 访问0-3个字符
print(str[:4])

# 访问从11到结束
print(str[11:])

# 访问Dolly,5到10,不包括10
print(str[5:10])

# 也可以从后往前数
print(str[-12:-7])

# in的用法
if 'NLTK' in str:
    print('found NLTK')

# replace的用法
replaced = str.replace('Dolly','Dorothy')
print('Replaced String:',replaced)

# 字符逐个打印
for s in replaced:
    print(s,end='/')
```
输出：
```
NLTK
Python
Dolly
Dolly
found NLTK
Replaced String: NLTK Dorothy Python
N/L/T/K/ /D/o/r/o/t/h/y/ /P/y/t/h/o/n/
```
+ Pyhton读取PDF
```
from PyPDF2 import PdfFileReader

# 定义读取pdf的函数，密码为可选项
def get_text_pdf(pdf_filename,password=''):
    pdf_file = open(pdf_filename,'rb')
    read_pdf = PdfFileReader(pdf_file)

    # 密码不为空，则用输入的密码解密
    if password != '':
        read_pdf.decrypt(password)

    # 读取文本：创建字符串列表，把每页的文本都加到列表中
    text = []
    for i in range(0,read_pdf.getNumPages()):
        text.append(read_pdf.getPage(i).extractText())

    return '\n'.join(text)

# 测试
if __name__ == "__main__":
    pdfFile = 'sample-one-line.pdf'
    pdfFileEncrypted = 'sample-one-line.protected.pdf'
    print('PDF 1:\n',get_text_pdf(pdfFile))
    print('PDF 2:\n',get_text_pdf(pdfFileEncrypted,'tuffy'))
```
输出：
```
PDF 1:
 This is a sample PDF document I am using to demonstrate in the tutorial.
 
PDF 2:
 This is a sample PDF document
 
password protected.
```
+ Python读取Word
每个文档有多个paragraph，每个paragraph有多个Run对象，Run对象表示格式的变化：字体，尺寸，颜色，其他样式元素（下划线 加粗 斜体等），这些元素每次发生变化时，都会创建一个新的Run对象。
```
import docx

def get_text_word(word_filename):
    doc = docx.Document(word_filename)
    full_text = []
    for para in doc.paragraphs:
        full_text.append(para.text)
    return '\n'.join(full_text)

# 测试
if __name__ == "__main__":
    docFile = 'sample-one-line.docx'
    print('Document in full :\n',get_text_word(docFile))

    # 其他功能
    doc = docx.Document(docFile)
    print('段落个数：',len(doc.paragraphs))
    print('第二段内容：',doc.paragraphs[1].text)
    print('第二段样式：',doc.paragraphs[1].style)

    # 打印第一段所有的run对象
    # 通过run对象体现文本样式的变化
    print('第一段：',doc.paragraphs[0].text)
    print('Number of runs in paragraph 1 :',len(doc.paragraphs[0].runs))
    for idx,run in enumerate(doc.paragraphs[0].runs):
        print('Run %s : %s' % (idx,run.text))

    # 检查run对象的样式 ：下划线 加粗 斜体
    print('is Run 5 underlined:',doc.paragraphs[0].runs[5].underline)
    print('is Run 1 bold:',doc.paragraphs[0].runs[1].bold)
    print('is Run 3 italic',doc.paragraphs[0].runs[3].italic)
```
输出：
```
Document in full :
 This is a sample PDF document with some text in BOLD, some in ITALIC and some underlined. We are also embedding a Title down below.
This is my TITLE.
This is my third paragraph.
段落个数： 3
第二段内容： This is my TITLE.
第二段样式： _ParagraphStyle('Title') id: 2046137402144
第一段： This is a sample PDF document with some text in BOLD, some in ITALIC and some underlined. We are also embedding a Title down below.
Number of runs in paragraph 1 : 8
Run 0 : This is a sample PDF document with 
Run 1 : some text in BOLD
Run 2 : , 
Run 3 : some in ITALIC
Run 4 :  and 
Run 5 : some underlined.
Run 6 :  We are also embedding a Title down below
Run 7 : .
is Run 5 underlined: True
is Run 1 bold: True
is Run 3 italic True
```
+ 创建自定义语料库
通过txt，pdf，word创建：
```
import pdf,word
import os
from nltk.corpus.reader.plaintext  import PlaintextCorpusReader

# 编写一个函数用来打开纯文本文件
def get_text(text_filename):
    file = open(text_filename,'r') # 只读
    return file.read() # 内容=>string对象

# 创建一个新文件夹
newCorpusDir = 'mycorpus/'
if not os.path.isdir(newCorpusDir):
    os.mkdir(newCorpusDir)

# 读取三个文件
txt1 = get_text('sample_feed.txt')
txt2 = pdf.get_text_pdf('sample-pdf.pdf')
txt3 = word.get_text_word('sample-one-line.docx')

# 将以上3个字符串写到新建的文件夹中
files = [txt1,txt2,txt3]
for idx,f in enumerate(files):
    with open(newCorpusDir+str(idx) + '.txt','w') as fout:
        fout.write(f)

# 创建一个PlaintextCorpusReader对象
newCorpus = PlaintextCorpusReader(newCorpusDir,'.*')

# 测试
print(newCorpus.words()) # 打印语料库中所有的单词数组
print(newCorpus.sents(newCorpus.fileids()[1])) # 打印1.txt中的句子
print(newCorpus.paras(newCorpus.fileids()[0])) # 打印0.txt中的段落
```
输出：
```
['i', 'want', 'to', 'eat', 'dinner', 'i', 'want', 'to', ...]
[['A', 'generic', 'NLP'], ['(', 'Natural', 'Language', 'Processing', ')', 'toolset'], ...]
[[['i', 'want', 'to', 'eat', 'dinner']], [['i', 'want', 'to', 'run']]]
```
+ 读取RSS信息源的内容
RSS = rich site summary 丰富网站摘要
以全球之声为例(url=http://feeds.mashable.com/Mashable)：
```
import feedparser

# 载入信息源，自动下载和解析
myFeed = feedparser.parse('http://feeds.mashable.com/Mashable')

# 检查当前信息源的标题，计算帖子数目
print('Feed Title :',myFeed['feed']['title'])
print('Number of posts :',len(myFeed.entries)) # entries返回所有帖子的list

# entries列表中的第一个post
post = myFeed.entries[0]
print('Post Title :',post.title)

# 访问post原始的HTML内容,并存起来
content = post.content[0].value
print('Raw content :\n',content)
fout = open('sample-html.html','w')
fout.write(content)
fout.close()
```
输出：
```
Feed Title : Mashable
Number of posts : 30
Post Title : Revolut launches new, effortless way to donate to charities
Raw content :
 <img alt="" src="https://mondrian.mashable.com/uploads%252Fcard%252Fimage%252F1007924%252F37167fff-e81c-446d-849a-37d0b625b7a7.jpg%252F575x323__filters%253Aquality%252880%2529.jpg?signature=ReYfFvy3gpD2t0oTt7_Z4kd7NQo=&amp;source=https%3A%2F%2Fblueprint-api-production.s3.amazonaws.com" /><div style="float: right; width: 50px;"><a href="https://twitter.com/share?via=Mashable&text=Revolut+launches+new%2C+effortless+way+to+donate+to+charities&url=https%3A%2F%2Fmashable.com%2Farticle%2Frevolut-donations" style="margin: 10px;"><img alt="Twitter" border="0" src="https://a.amz.mshcdn.com/assets/feed-tw-e71baf64f2ec58d01cd28f4e9ef6b2ce0370b42fbd965068e9e7b58be198fb13.jpg" /></a><a href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Fmashable.com%2Farticle%2Frevolut-donations&src=sp" style="margin: 10px;"><img alt="Facebook" border="0" src="https://a.amz.mshcdn.com/assets/feed-fb-8e3bd31e201ea65385a524ef67519d031e6851071807055648790d6a4ca77139.jpg" /></a></div><p><a href="https://www.revolut.com/">Revolut</a> is a&#160;UK-based financial services company that offers clients a bank account and a pre-paid card, with many of its services free or incurring a lower fee than you'd get from a typical bank. It's now also offering a new feature that makes it really easy to donate to charities &#8212; every time you make a payment.&#160;</p>
<p>The feature, called Donations, lets you round up your Revolut card payments and donate the spare change to a charity of your choice. The service is kicking off with three charities: <a href="https://www.ilga-europe.org/">ILGA-Europe</a>, <a href="https://www.savethechildren.net/">Save the Children</a> and <a href="https://www.worldwildlife.org/">WWF</a>.&#160;</p>
<div><p>SEE ALSO: <a href="http://mashable.com/article/instagram-stories-donation-sticker-causes?utm_campaign&amp;utm_cid=a-seealso&amp;utm_context=textlink&amp;utm_medium=rss&amp;utm_source">You can now donate through stickers in Instagram Stories</a> <a href="https://mashable.com/article/revolut-donations">Read more...</a></p></div>More about <a href="https://mashable.com/category/donations/?utm_campaign=Mash-Prod-RSS-Feedburner-All-Partial&amp;utm_cid=Mash-Prod-RSS-Feedburner-All-Partial">Donations</a>, <a href="https://mashable.com/category/revolut/?utm_campaign=Mash-Prod-RSS-Feedburner-All-Partial&amp;utm_cid=Mash-Prod-RSS-Feedburner-All-Partial">Revolut</a>, <a href="https://mashable.com/tech/?utm_campaign=Mash-Prod-RSS-Feedburner-All-Partial&amp;utm_cid=Mash-Prod-RSS-Feedburner-All-Partial">Tech</a>, and <a href="https://mashable.com/category/big-tech-companies/?utm_campaign=Mash-Prod-RSS-Feedburner-All-Partial&amp;utm_cid=Mash-Prod-RSS-Feedburner-All-Partial">Big Tech Companies</a><img src="http://feeds.feedburner.com/~r/Mashable/~4/s9f4V3jFdyg" height="1" width="1" alt=""/>
```
+ 使用BeautifulSoup解析HTML
BeautifulSoup可用于解析任何HTML和XML内容
用于解析的HTML:
```
<img alt="" src="https://mondrian.mashable.com/uploads%252Fcard%252Fimage%252F1008631%252F256dd624-5852-4df0-81b3-e686a3ac5fd2.jpg%252F575x323__filters%253Aquality%252880%2529.jpg?signature=o6SwiPnemiiF5QUbmAb8lh89GJw=&amp;source=https%3A%2F%2Fblueprint-api-production.s3.amazonaws.com" /><div style="float: right; width: 50px;"><a href="https://twitter.com/share?via=Mashable&text=Android+might+finally+get+a+better+AirDrop+alternative&url=https%3A%2F%2Fmashable.com%2Farticle%2Fandroid-fast-share-airdrop-alternative" style="margin: 10px;"><img alt="Twitter" border="0" src="https://a.amz.mshcdn.com/assets/feed-tw-e71baf64f2ec58d01cd28f4e9ef6b2ce0370b42fbd965068e9e7b58be198fb13.jpg" /></a><a href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Fmashable.com%2Farticle%2Fandroid-fast-share-airdrop-alternative&src=sp" style="margin: 10px;"><img alt="Facebook" border="0" src="https://a.amz.mshcdn.com/assets/feed-fb-8e3bd31e201ea65385a524ef67519d031e6851071807055648790d6a4ca77139.jpg" /></a></div><p>Google might finally deliver a viable version of AirDrop for Android phones.</p>
<p>The company is testing a new Android feature called "Fast Share" that would allow phone owners to wirelessly transmit photos, text, and other files to nearby devices using Bluetooth. The currently unreleased feature was uncovered by two separate publications, <a href="https://9to5google.com/2019/06/29/google-android-fast-share/">9to5Google</a> and <a href="https://www.xda-developers.com/fast-share-android-beam-airdrop-android/">XDA Developers</a>.</p>
<p>According to screenshots posted by the publications, Fast Share allows you to share photos, text, and URLs with devices that are nearby even if you don't have an internet connection. Interestingly, the list of devices in the screenshots includes an iPhone as well as a Chromebook and Pixel 3 phone, suggesting the intention is for Fast Share to enable cross-platform sharing. <a href="https://mashable.com/article/android-fast-share-airdrop-alternative">Read more...</a></p>More about <a href="https://mashable.com/tech/?utm_campaign=Mash-Prod-RSS-Feedburner-All-Partial&amp;utm_cid=Mash-Prod-RSS-Feedburner-All-Partial">Tech</a>, <a href="https://mashable.com/category/google/?utm_campaign=Mash-Prod-RSS-Feedburner-All-Partial&amp;utm_cid=Mash-Prod-RSS-Feedburner-All-Partial">Google</a>, <a href="https://mashable.com/category/airdrop/?utm_campaign=Mash-Prod-RSS-Feedburner-All-Partial&amp;utm_cid=Mash-Prod-RSS-Feedburner-All-Partial">Airdrop</a>, <a href="https://mashable.com/category/android-q/?utm_campaign=Mash-Prod-RSS-Feedburner-All-Partial&amp;utm_cid=Mash-Prod-RSS-Feedburner-All-Partial">Android Q</a>, and <a href="https://mashable.com/tech/?utm_campaign=Mash-Prod-RSS-Feedburner-All-Partial&amp;utm_cid=Mash-Prod-RSS-Feedburner-All-Partial">Tech</a><img src="http://feeds.feedburner.com/~r/Mashable/~4/VGJnaGJtlxQ" height="1" width="1" alt=""/>
```
解析代码：
```
from bs4 import BeautifulSoup

# 将HTML文件以str送给BeautifulSoup对象
html_doc = open('sample-html.html','r').read()
soup = BeautifulSoup(html_doc,'html.parser')

# 去除标签，获取文本
print('Full text HTML Stripped:')
print(soup.get_text())

# 获取第一个指定标签内容
print('Accessing the <img> tag :',end=' ')
print(soup.img)

# 获取第一个指定标签的指定内容
print('Accessing the text of <p> tag :',end=' ')
print(soup.p.string)

# 访问第一个指定标签的某个属性
print('Accessing property of <img> tag :',end=' ')
print(soup.img['src'])

# 获取所有某标签的内容
print('Accessing all occurences of the <p> tag :')
for p in soup.find_all('p'):
    print(p.string)
```
输出：
```
Full text HTML Stripped:
Google might finally deliver a viable version of AirDrop for Android phones.
The company is testing a new Android feature called "Fast Share" that would allow phone owners to wirelessly transmit photos, text, and other files to nearby devices using Bluetooth. The currently unreleased feature was uncovered by two separate publications, 9to5Google and XDA Developers.
According to screenshots posted by the publications, Fast Share allows you to share photos, text, and URLs with devices that are nearby even if you don't have an internet connection. Interestingly, the list of devices in the screenshots includes an iPhone as well as a Chromebook and Pixel 3 phone, suggesting the intention is for Fast Share to enable cross-platform sharing. Read more...More about Tech, Google, Airdrop, Android Q, and Tech
Accessing the <img> tag : <img alt="" src="https://mondrian.mashable.com/uploads%252Fcard%252Fimage%252F1008631%252F256dd624-5852-4df0-81b3-e686a3ac5fd2.jpg%252F575x323__filters%253Aquality%252880%2529.jpg?signature=o6SwiPnemiiF5QUbmAb8lh89GJw=&amp;source=https%3A%2F%2Fblueprint-api-production.s3.amazonaws.com"/>
Accessing the text of <p> tag : Google might finally deliver a viable version of AirDrop for Android phones.
Accessing property of <img> tag : https://mondrian.mashable.com/uploads%252Fcard%252Fimage%252F1008631%252F256dd624-5852-4df0-81b3-e686a3ac5fd2.jpg%252F575x323__filters%253Aquality%252880%2529.jpg?signature=o6SwiPnemiiF5QUbmAb8lh89GJw=&source=https%3A%2F%2Fblueprint-api-production.s3.amazonaws.com
Accessing all occurences of the <p> tag :
Google might finally deliver a viable version of AirDrop for Android phones.
None
None
```]]></description></item><item><title>import同目录的py文件 ：ModuleNotFoundError: No module named 'pdf'</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/01/11114513.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 01 Jul 2019 07:50:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/01/11114513.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/bug4/
+ 报错
Traceback (most recent call last):
  File "D:/PyCharm 5.0.3/WorkSpace/2.NLP/2.获取数据源和规范化/5.createCorpus.py", line 1, in <module>
    import pdf
ModuleNotFoundError: No module named 'pdf'
+ 原因
pycharm不会将当前文件目录自动加入source_path
+ 解决
右键该文件的目录=>标记目录为=>source_root，即可
参考：<u>https://www.cnblogs.com/dongfengl/p/8458365.html</u>]]></description></item><item><title>ImportError: DLL load failed: %1 不是有效的 Win32 应用程序。</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/01/11112988.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 01 Jul 2019 03:14:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/01/11112988.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/bug3/
+ 报错
Traceback (most recent call last):
  File "D:/PyCharm 5.0.3/WorkSpace/2.NLP/2.获取数据源和规范化/4.word.py", line 1, in <module>
    import docx
  File "D:\Anaconda3\lib\site-packages\docx\__init__.py", line 3, in <module>
    from docx.api import Document  # noqa
  File "D:\Anaconda3\lib\site-packages\docx\api.py", line 14, in <module>
    from docx.package import Package
  File "D:\Anaconda3\lib\site-packages\docx\package.py", line 9, in <module>
    from docx.opc.package import OpcPackage
  File "D:\Anaconda3\lib\site-packages\docx\opc\package.py", line 9, in <module>
    from docx.opc.part import PartFactory
  File "D:\Anaconda3\lib\site-packages\docx\opc\part.py", line 12, in <module>
    from .oxml import serialize_part_xml
  File "D:\Anaconda3\lib\site-packages\docx\opc\oxml.py", line 12, in <module>
    from lxml import etree
ImportError: DLL load failed: %1 不是有效的 Win32 应用程序。
+ 原因
安装的包与python位数不一样
+ 解决
用Anaconda3将python从64位切换到32位：
`set CONDA_FORCE_32BIT=1`
在系统命令提示符中下载python-docx：
`pip install python-docx`
参考：<u>https://blog.csdn.net/weixin_41710606/article/details/86747877</u>]]></description></item><item><title>NLP（一）语料库和WordNet</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/01/nlp_1.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 01 Jul 2019 01:08:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/01/nlp_1.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/nlp1/
+ 访问语料库
NLTK数据库的安装：http://www.nltk.org/data.html
NLTK语料库列表：http://www.nltk.org/nltk_data/
内部访问(以Reuters corpus为例)：
```
import nltk
from nltk.corpus import reuters

# 下载路透社语料库
nltk.download('reuters')

# 查看语料库的内容
files = reuters.fileids()
print(files)

# 访问其中一个文件的内容
words14826 = reuters.words(['test/14826'])
print(words14826[:20])

# 输出主题（一共90个）
reutersGenres = reuters.categories()
print(reutersGenres)

# 访问一个主题，一句话一行输出
for w in reuters.words(categories=['tea']):
    print(w + ' ',end='')
    if w is '.':
        print()
```
+ 下载外部语料库并访问（以影评数据集为例）
下载数据集：http://www.cs.cornell.edu/people/pabo/movie-review-data/
本例下载了1000积极和1000消极的影评
```
from nltk.corpus import CategorizedPlaintextCorpusReader

# 读取语料库
reader = CategorizedPlaintextCorpusReader(r'D:\PyCharm 5.0.3\WorkSpace\2.NLP\语料库\1.movie_review_data_1000\txt_sentoken',r'.*\.txt',cat_pattern=r'(\w+)/*')
print(reader.categories())
print(reader.fileids())

# 语料库分成两类
posFiles = reader.fileids(categories='pos')
negFiles = reader.fileids(categories='neg')

# 从posFiles或negFiles随机选择一个文件
from random import randint
fileP = posFiles[randint(0,len(posFiles)-1)]
fileN = negFiles[randint(0,len(negFiles)-1)]

# 逐句打印随机的选择文件
for w in reader.words(fileP):
    print(w + ' ',end='')
    if w is '.':
        print()
for w in reader.words(fileN):
    print(w + ' ',end='')
    if w is '.':
        print()
```
CategorizedPlaintextCorpusReader类通过参数的设置，从内部将样本加载到合适的位置
+ 语料库中的词频计算和计数分布分析
以布朗语料库为例：布朗大学 500个文本 15个类
```
import nltk
from nltk.corpus import brown

nltk.download('brown')

# 查看brown中的类别
print(brown.categories())

# 挑选出三种类别，并获取其中的疑问词
genres = ['fiction','humor','romance']
whwords = ['what','which','how','why','when','where','who']

# 迭代器分别分析3种类
for i in range(0,len(genres)):
    genre = genres[i]
    print()
    print("Analysing '"+ genre + "' wh words")
    genre_text = brown.words(categories = genre)
    print(genre_text)

    # 返回输入单词对象的wh类及对应的频率
    fdist = nltk.FreqDist(genre_text)
    for wh in whwords:
        print(wh + ':',fdist[wh],end='  ')
    print()
```
输出：
```
['adventure', 'belles_lettres', 'editorial', 'fiction', 'government', 'hobbies', 'humor', 'learned', 'lore', 'mystery', 'news', 'religion', 'reviews', 'romance', 'science_fiction']

Analysing 'fiction' wh words
['Thirty-three', 'Scotty', 'did', 'not', 'go', 'back', ...]
what: 128  which: 123  how: 54  why: 18  when: 133  where: 76  who: 103  

Analysing 'humor' wh words
['It', 'was', 'among', 'these', 'that', 'Hinkle', ...]
what: 36  which: 62  how: 18  why: 9  when: 52  where: 15  who: 48  

Analysing 'romance' wh words
['They', 'neither', 'liked', 'nor', 'disliked', 'the', ...]
what: 121  which: 104  how: 60  why: 34  when: 126  where: 54  who: 89  
```
+ 网络文本和聊天文本的词频分布
```
import nltk
from nltk.corpus import webtext

# nltk.download('webtext')
print(webtext.fileids())

# 选择一个数据文件，并计算频率分布,获得FreqDist的对象fdist
fileid = 'singles.txt'  # 个人广告
wbt_words = webtext.words(fileid)
fdist = nltk.FreqDist(wbt_words)

# 获取高频单词及其计数
print('最多出现的词 "' , fdist.max() , '" :' , fdist[fdist.max()])

# 获取所有单词的计数
print(fdist.N())

# 找出最常见的10个词
print(fdist.most_common(10))

# 将单词和频率制成表格
print(fdist.tabulate(5))

# 将单词和频率制成分布图
fdist.plot(cumulative=True) # 计数显示，cumulative=percents为百分比显示
```
输出：
```
['firefox.txt', 'grail.txt', 'overheard.txt', 'pirates.txt', 'singles.txt', 'wine.txt']
最多出现的词 " , " : 539
4867
[(',', 539), ('.', 353), ('/', 110), ('for', 99), ('and', 74), ('to', 74), ('lady', 68), ('-', 66), ('seeks', 60), ('a', 52)]
  ,   .   / for and 
539 353 110  99  74 
None
```
累计计数分布图：
![](https://img2018.cnblogs.com/blog/1205669/201907/1205669-20190701090516672-604976586.png)
+ 使用WordNet获取一个词的不同含义
```
# import nltk
# nltk.download('wordnet')

from nltk.corpus import wordnet as wn
chair = 'chair'

# 输出chair的各种含义
chair_synsets = wn.synsets(chair)
print('Chair的意思:',chair_synsets,'\n\n')

# 迭代输出 含义，含义的定义，同义词条，例句
for synset in chair_synsets:
    print(synset,': ')
    print('Definition: ',synset.definition())
    print('Lemmas/Synonymous words: ',synset.lemma_names())
    print('Example: ',synset.examples(),'\n')
```
输出：
```
Chair的意思: [Synset('chair.n.01'), Synset('professorship.n.01'), Synset('president.n.04'), Synset('electric_chair.n.01'), Synset('chair.n.05'), Synset('chair.v.01'), Synset('moderate.v.01')] 

Synset('chair.n.01') : 
Definition:  a seat for one person, with a support for the back
Lemmas/Synonymous words:  ['chair']
Example:  ['he put his coat over the back of the chair and sat down'] 

Synset('professorship.n.01') : 
Definition:  the position of professor
Lemmas/Synonymous words:  ['professorship', 'chair']
Example:  ['he was awarded an endowed chair in economics'] 

Synset('president.n.04') : 
Definition:  the officer who presides at the meetings of an organization
Lemmas/Synonymous words:  ['president', 'chairman', 'chairwoman', 'chair', 'chairperson']
Example:  ['address your remarks to the chairperson'] 

Synset('electric_chair.n.01') : 
Definition:  an instrument of execution by electrocution; resembles an ordinary seat for one person
Lemmas/Synonymous words:  ['electric_chair', 'chair', 'death_chair', 'hot_seat']
Example:  ['the murderer was sentenced to die in the chair'] 

Synset('chair.n.05') : 
Definition:  a particular seat in an orchestra
Lemmas/Synonymous words:  ['chair']
Example:  ['he is second chair violin'] 

Synset('chair.v.01') : 
Definition:  act or preside as chair, as of an academic department in a university
Lemmas/Synonymous words:  ['chair', 'chairman']
Example:  ['She chaired the department for many years'] 

Synset('moderate.v.01') : 
Definition:  preside over
Lemmas/Synonymous words:  ['moderate', 'chair', 'lead']
Example:  ['John moderated the discussion'] 
```
+ 上位词和下位词
下位词更具体，上位词更一般（泛化）
以`bed.n.01`和`woman.n.01`为例：
```
from nltk.corpus import wordnet as wn

woman = wn.synset('woman.n.01')
bed = wn.synset('bed.n.01')

# 返回据有直系关系的同义词集，上位词！
print(woman.hypernyms())
woman_paths = woman.hypernym_paths()

# 打印从根节点到woman.n.01的所有路径
for idx,path in enumerate(woman_paths):
    print('\n\nHypernym Path :',idx+1)
    for synset in path:
        print(synset.name(),',',end='')

# 更具体的术语，下位词！
types_of_bed = bed.hyponyms()
print('\n\nTypes of beds(Hyponyms): ',types_of_bed)

# 打印出更有意义的lemma(词条)
print('\n',sorted(set(lemma.name() for synset in types_of_bed for lemma in synset.lemmas())))
```
输出：
```
[Synset('adult.n.01'), Synset('female.n.02')]

Hypernym Path : 1
entity.n.01 ,physical_entity.n.01 ,causal_agent.n.01 ,person.n.01 ,adult.n.01 ,woman.n.01 ,

Hypernym Path : 2
entity.n.01 ,physical_entity.n.01 ,object.n.01 ,whole.n.02 ,living_thing.n.01 ,organism.n.01 ,person.n.01 ,adult.n.01 ,woman.n.01 ,

Hypernym Path : 3
entity.n.01 ,physical_entity.n.01 ,causal_agent.n.01 ,person.n.01 ,female.n.02 ,woman.n.01 ,

Hypernym Path : 4
entity.n.01 ,physical_entity.n.01 ,object.n.01 ,whole.n.02 ,living_thing.n.01 ,organism.n.01 ,person.n.01 ,female.n.02 ,woman.n.01 ,

Types of beds(Hyponyms):  [Synset('berth.n.03'), Synset('built-in_bed.n.01'), Synset('bunk.n.03'), Synset('bunk_bed.n.01'), Synset('cot.n.03'), Synset('couch.n.03'), Synset('deathbed.n.02'), Synset('double_bed.n.01'), Synset('four-poster.n.01'), Synset('hammock.n.02'), Synset('marriage_bed.n.01'), Synset('murphy_bed.n.01'), Synset('plank-bed.n.01'), Synset('platform_bed.n.01'), Synset('sickbed.n.01'), Synset('single_bed.n.01'), Synset('sleigh_bed.n.01'), Synset('trundle_bed.n.01'), Synset('twin_bed.n.01'), Synset('water_bed.n.01')]

 ['Murphy_bed', 'berth', 'built-in_bed', 'built_in_bed', 'bunk', 'bunk_bed', 'camp_bed', 'cot', 'couch', 'deathbed', 'double_bed', 'four-poster', 'hammock', 'marriage_bed', 'plank-bed', 'platform_bed', 'sack', 'sickbed', 'single_bed', 'sleigh_bed', 'truckle', 'truckle_bed', 'trundle', 'trundle_bed', 'twin_bed', 'water_bed']
```
+ 基于WordNet计算某种词性的多义性
以名词n为例：
```
from nltk.corpus import wordnet as wn

type = 'n' #动词v，副词r，形容词a

# 返回WordNet中所有type类型的同义词集
sysnets = wn.all_synsets(type)

# 将所有词条合并成一个大list
lemmas = []
for sysnet in sysnets:
    for lemma in sysnet.lemmas():
        lemmas.append(lemma.name())

# 删除重复词条,list=>set
lemmas = set(lemmas)

# 计算每个词条type类型的含义数并加到一起
count = 0
for lemma in lemmas:
    count = count + len(wn.synsets(lemma,type)) # lemma在type类型下的所有含义

# 打印所有数值
print('%s总词条数: '%(type),len(lemmas))
print('%s总含义数: '%(type),count)
print('%s平均多义性: '%(type),count/len(lemmas))
```
输出：
```
n总词条数:  119034
n总含义数:  152763
n平均多义性:  1.2833560159282222
```]]></description></item><item><title>UnicodeDecodeError: 'gbk' codec can't decode byte 0x80 in position 16: illegal multibyte sequence</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/01/11112188.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 01 Jul 2019 01:01:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/01/11112188.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/bug2/
+ 报错
UnicodeDecodeError: 'gbk' codec can't decode byte 0x80 in position 16: illegal multibyte sequence
+ 原因
文档是中文，在open函数中没有指定编码类型
+ 解决
`fp = open('text.txt')`
改成
`fp = open('text.txt',encoding='utf-8')`]]></description></item><item><title>This probably means that Tcl wasn't installed properly.</title><link>http://www.cnblogs.com/peng8098/archive/2019/07/01/11112185.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Mon, 01 Jul 2019 01:00:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/07/01/11112185.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/bug1/
+ 报错
D:/Anaconda3/tcl/tcl8.6/init.tcl: version conflict for package "Tcl": have 8.6.8, need exactly 8.6.9
version conflict for package "Tcl": have 8.6.8, need exactly 8.6.9
    while executing
"package require -exact Tcl 8.6.9"
    (file "D:/Anaconda3/tcl/tcl8.6/init.tcl" line 19)
    invoked from within
"source D:/Anaconda3/tcl/tcl8.6/init.tcl"
    ("uplevel" body line 1)
    invoked from within
"uplevel #0 [list source $tclfile]"
This probably means that Tcl wasn't installed properly.
+ 原因
找不到合适的tcl
+ 解决
用notepad把以下两个文件打开
D:\Anaconda3\tcl\tcl8.6\init.tcl
D:\Anaconda3\tcl\tcl8.6\tk8.6\tk.tcl
将package require -exact Tcl 8.6.9和package require -exact Tk 8.6.9的版本号改成 8.6.8]]></description></item><item><title>Python 正则表达式</title><link>http://www.cnblogs.com/peng8098/archive/2019/06/28/python_basis_6.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 28 Jun 2019 08:03:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/06/28/python_basis_6.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/python6/
#### 简介
+ 正则表达式
Regular Expression，简称RE
#### 语法
+ 普通字符
可打印字符 + 不可打印字符
包括所有大写和小写字母，所有数字，所有标点符号以及一些其他符号
+ 非打印字符

| 字符 | 描述 |
| --- | --- |
| \cx |Control+x,x属于[A-Z a-z] |
| \f | 换页符 |
| \n | 换行符 |
| \s | 任何空白字符，包括空格、制表符、换页符等，等价于[\f\n\r\t\v] |
| \S | 任何非空白字符 |
| \t | 制表符 |
| \v | 垂直制表符 |
| \r | 回车符 |
+ 特殊字符
放到匹配字符的后边，有特殊的含义，要相匹配他们要加反斜杠转义

| 字符 | 描述 |
| --- | --- |
| $ | 输入字符串的结尾位置，特殊的：\n \r |
| ( ) | 标记一个子表达式的开始和结束位置 |
| * | 前面的子表达式零次或多次 |
| + | 前面的子表达式一次或多次 |
| . | 除换行符 \n 之外的任何单字符 |
| [ ] | 标记一个中括号表达式 |
| ? | 前面的子表达式零次或一次，非贪婪的，尽可能匹配短的 |
| \ | 转义 |
| ^ | 输入字符串的开始位，特殊的：\n \r  |
| { } | 限定符表达式的开始 |
| \| | 指明两项之间的一个选择 |
+ 限定符
指定正则表达式的一个给定组件必须要出现多少次才能满足匹配

| 字符 | 描述 |
| --- | --- |
| * | 前面的子表达式零次或多次 |
| + | 前面的子表达式一次或多次 |
| ? | 前面的子表达式零次或一次 |
|{n}| 匹配确定的 n 次 |
|{n,}|至少匹配n 次|
|{n,m}|最少匹配 n 次且最多匹配 m 次|
+ 定位符

| 字符 | 描述 |
| --- | --- |
| ^ | 输入字符串的开始位，特殊的：\n \r  |
| $ | 输入字符串的结尾位置，特殊的：\n \r |
| \b | 匹配一个单词边界，即字与空格间的位置 |
| \B | 非单词边界匹配 |
#### 其他的元字符

| 字符 | 描述 |
| --- | --- |
| (pattern) | 匹配 pattern 并获取这一匹配 |
| (?:pattern) | 匹配 pattern 但不获取匹配结果 |
| (?=pattern) | 正向肯定预查 |
| (?!pattern) |  正向否定预查|
| (?<=pattern) | 反向肯定预查，与正向肯定预查类似，只是方向相反 |
| (?<!pattern) | 反向否定预查，与正向否定预查类似，只是方向相反 |
| x|y |  x 或 y |
| [xyz] | 字符集合，匹配所包含的任意一个字符 |
| [^xyz | 负值字符集合，匹配未包含的任意字符 |
| [a-z] | 字符范围，匹配指定范围内的任意字符|
| [^a-z] | 负值字符范围，匹配任何不在指定范围内的任意字符 |
| \d | 匹配一个数字字符，等价于 [0-9] |
| \D | 匹配一个非数字字符，等价于 [^0-9] |
|\w|匹配字母、数字、下划线。、，等价于 [A-Za-z0-9_]|
|\W|与\w相反，等价于 [^A-Za-z0-9_]|
|\num|匹配num个，其中 num 是一个正整数，对所获取的匹配的引用。如，'(.)\1' 匹配两个连续的相同字符。|
#### 运算符优先级
优先级相同的从左到右运算

| 运算符 | 描述 |
| --- | --- |
| \ | 转义符 |
| ()[] | 括号 |
| \* , +, ?, {n}, {n,}, {n,m} | 限定符 |
| ^, $, \任何元字符、任何字符 | 位置和序列 |
| \| | 或 |
#### 常用表达式
##### 数字
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628160006441-515281346.png)
##### 字符
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628160018826-1079015714.png)
##### 其他
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628160031031-1280876142.png)
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628160039277-1052171436.png)]]></description></item><item><title>数学基础（二）</title><link>http://www.cnblogs.com/peng8098/archive/2019/06/28/math_basis_2.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 28 Jun 2019 02:42:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/06/28/math_basis_2.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/shuxuejichu2/
+ 特征值的性质
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102234041-466326787.png)
+ 奇异矩阵,不可逆矩阵,降秩矩阵
+ 正交矩阵:n阶方阵A与其转置的乘积=E
+ 线性无关组➡规范正交组
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102249844-1628138160.png)
#### 古典概型
+ 排列数 
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102321912-913202100.png)
+ 组合数
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102334840-560644316.png)
+ a为发生的事件.b为不发生的事件,概率 `P=a/(a+b)`
+ 联合概率:AB都发生的概率 `P(AB)=P(A∩B)` ,A和B事件独立时:`P(AB)=P(A)P(B)`
+ 条件概率:A在B已经发生条件下的发生概率 `P(A|B)=P(AB)/P(B)`,例题2: 
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102354791-2021218029.png)
+ 条件概率推广
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102407919-878120982.png)
+ 全概率公式: 样本空间Ω=A1∪A2...∪An
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102420241-860563869.png)
+ 贝叶斯公式案例
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102434722-1927592082.png)
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102443217-1564268321.png)
#### 离散变量分布
+ Bernoulli(贝努利)分布,0-1分布,二点分布,`p`与`1-p`,二项分布的特例
+ 二项分布,多次Bernoulli实验,n次实验中出现k次的概率:
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102503013-1104630249.png)
+ Poisson(泊松)分布,λ＞0是常数,泊松分布的期望和方差均为λ
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102531244-437064144.png)
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102539905-1415083791.png)
+ 二项分布与泊松分布的关系,n足够大时, `λ=np`
二项分布数太大时不好计算,可用此方法转为泊松分布计算
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102554473-1564259044.png)
#### 连续变量分布
+ 概率密度`f(x)`的性质:
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102613494-1058948713.png)
+ 常用连续随机变量
1)均匀分布 
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102635234-203911460.png)
2)指数分布
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102645597-2034144590.png)
3)正态分布,μ是期望,σ是标准差.μ=0,σ=1是标准正态分布
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102731098-847814465.png)
4)Γ-分布:
Γ-函数: ![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628102802312-1377037846.png)
#### 数字特征
+ 期望
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103026338-268008594.png)
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103034465-1277767107.png)
+ 方差:衡量数据偏移程度
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103049761-632721011.png)
连续型:![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103106964-1999261158.png)
离散型:![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103157972-650313381.png)
+ 方差与期望的关系
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103257393-1793300649.png)
+ 标准差 ![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103314015-372807640.png)
+ 协方差:衡量两个变量的总体误差,两个变量独立,则协方差为0
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103331441-2089098982.png)
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103339046-1282901582.png)
#### 中心矩 峰度 最大似然
+ 中心矩,原点矩
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103356859-106599291.png)
+ 峰度,峰度>3,峰的形状尖,比正态分布要陡,反之亦然
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103414671-1731178069.png)
+ 偏度系数,描述分布对称性,系数为0,分布对称,>0右偏,<0左偏
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103425406-63699951.png)
+ 切比雪夫定理
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103437704-1254537861.png)
+ 大数定律
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103448702-820693935.png)
+ 中心极限定理
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103500966-1207717412.png)
+ 点估计,矩估计
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103512842-525283118.png)
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103520424-1466867698.png)
+ 极大似然估计,实际情况除概率估计总量,求解步骤:
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628103533737-158656014.png)]]></description></item><item><title>数学基础（一）</title><link>http://www.cnblogs.com/peng8098/archive/2019/06/28/math_basis_1.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 28 Jun 2019 02:19:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/06/28/math_basis_1.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/shuxuejichu1/
#### 函数
+ 函数
给数集A一个法则/映射f,得到另一个数集B,记为`B=f(A)`
+ 反函数
x,y一一对应才有反函数,与原函数关于y=x对称
反函数一定是单调的,而且单调性与原函数相同
+ 复合函数 `(f 。g)(x) = f[g(x)]`
+ 基本初等函数
1)幂函数 2)指数函数 3)对数函数 4)三角函数(sin,cos,tan,cot,sec,csc) 
5)反三角函数(arcsin,arccos,arctanarccot)
#### 极限
+ 数列极限
对f(x),有常数a,对任意无论多小的δ,总存在正数X,使x>X时,|f(x)-a|<δ恒成立
+ 函数极限
1)x0 2)x0+ 3)x0- 4)∞ 5)+∞ 6)-∞
+ 函数极限性质
1)唯一性 2)局部有限性
+ 两个准则
1)夹逼准则
+ 重要极限
1)lim(x➡0)sinx/x=1 2)lim(x➡∞)(1+1/x)^x=e
#### 导数
+ 导数
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628100809270-754465070.png)
+ 常用导数
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101020730-2086708296.png)
+ 导数法则
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101035686-1136695350.png)
+ 反函数求导
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101054513-1473416251.png)
+ 复合函数求导
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101110629-867257872.png)
+ 高阶导数
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101124342-960067243.png)
+ 导数的应用
1)函数单调性
凹凸性:二阶导>0:凹,二阶导数<0:凸
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101140190-1619889309.png)
2)函数极值与最值
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101158293-834476067.png)
3)泰勒公式
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101211791-1038462241.png)
#### 多元函数
+ 二元函数
每个点(x,y)∈平面D,有对应的法则得到z,记为`z=f(x,y)`
+ 多元函数:多维
+ 多元函数极限
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101243528-770000184.png)
+ 多元函数偏导
+ 高阶偏导数
#### 向量
+ 向量,向量的模,单位向量,向量的运算
+ 方向导数
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101301165-1063722999.png)
对于二元函数
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101317871-341887393.png)
+ 梯度:下降最快方向,各方向偏导向量相加
+ 矩阵,矩阵运算,转置
+ 方阵行列式:`|A|`或`det(A)`
+ 代数余子式:`Aij = (-1)^(i+j)Mij`
`det(A)`=某一行或某一列元素与其代数余子式的乘积和
+ 伴随矩阵:由代数余子式代替对应元素构成的矩阵
+ 方阵的逆:A,存在B使 AB=BA=E,称A与B互为逆矩阵
可逆矩阵 = 非奇异矩阵
判定可逆: 可逆矩阵的行列式 ≠ 0
运算:
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101401753-2128450474.png)
+ 矩阵的初等行变换
目的: 化简矩阵,化成阶梯型
1)对调两行 2)对第i行乘不为0的数 3)第i行的k倍加到第j行
A经过有限次的初等变换➡B,即A与B等价,记为 A~B,等价的线性方程同解
等价的性质:
1)自反性:A~A 2)对称性:若A~B,则B~A 3)传递性:若A~B,且B~C,则A~C
初等行列变换➡最简矩阵(标准形),能看出几阶,即秩
+ 初等行变换求逆 `( A , E ) = ( E , A^-1 )`
+ 矩阵线性表示 
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101530761-1415000872.png)
+ 对称矩阵: A = A的转置
+ 线性方程组的解
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101549993-1084694686.png)
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101643192-1998992978.png)
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101653888-1053993547.png)
#### 特征值 特征向量
+ 概念:A为n阶矩阵,若数λ和n维非零列向量满足`Ax=λx`,那么数λ称为A的**特征值**,x称为A的对应于特征值λ的**特征向量**,并且`|λE-A|`叫做A的特征多项式
+ 求法:解`|λE-A| = 0`,解出λ,然后解`|λE-A|*x = 0`
![](https://img2018.cnblogs.com/blog/1205669/201906/1205669-20190628101741841-1871787159.png)]]></description></item><item><title>Python 基础（五）</title><link>http://www.cnblogs.com/peng8098/archive/2019/06/28/python_basis_5.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 28 Jun 2019 02:02:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/06/28/python_basis_5.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/python5/
+ `pandas`缺失值处理
```
import pandas as pd
importrandom
df01 = pd.DataFrame(np.random.randint(1,9),size = (4,4))
print(df01)
df01.ix[1:2,1:2] = np.NaN #从0开始算的第1,2行的第1,2列赋为空值
print(df01)

print(df01.dropna()) #只要包含NaN的数据行都删掉
print(df01.dropna(axis = 1)) #只要包含NaN的数据列都删掉
print(df01.dropna(how = 'all')) #必须全是NaN的数据行才删除

print(df01.fillna(0)) #将所有NaN变成0
print(df01.fillna({0:1,1:4,2:3,3:8})) #将每列的NaN指定变成不同的数
```
+ `pandas`常用数学统计方法(默认都按列)
count(): 非NaN数据的个数
sum(): 默认按列求和 sum(axis = 1)按行求和
min()/max(): 最大最小值
quantile(0.25): 计算样本分数位(0到1),参数默认0.5,即中位数
median(): 中位数
cumsum(): 累加和
pct_change(): 计算百分数的变化
std(): 标准差
var(): 方差
describe(): 得到以上一堆方法及各列结果的表
+ 相关数据与协方差
```
df01 = pd.DataFrame({'year':[1,2,3,4],'money':[40,50,60,70]})
df01.cov() #协方差: 正数正相关,负数负相关
df01.corr() #相关数 : -1到1之间

ser01 = pd.Series(['a','b','c','d','a','b','c'])
ser01.value_counts() #统计数
ser01[ser01.isin(['b','c'])] #分别判断是否在列表当中,相当于过滤,成员资格
ser01.unique() #去重
```
+ `pandas`层次索引
swaplevel交换内外层索引
+ `matplotlib`绘图库
```
import matplotlib.pyplot as plt
import numpy as np

plt.plot([1,2,7],[3,5,2]) #绘制 折线图
plt.show() #显示图片

#显示情况
%matplotlib tk #在GUI中显示
%matplotlib inline #在行内显示

#figure
x = np.arange(-3,3,0.1)
y1 = np.sin(x)
y2 = np.cos(x)

plt.figure(num = 5,figsize = (8,5)) #创建第一个图形,figsize单位为100像素
plt.plot(x,y1)
plt.plot(x,y2)
plt.show() #两条曲线在一个图里显示

#也可以
plt.plot(x,y1,x,y2)
plt.show()

plt.plot([2,3,4,5],color = 'red',linestyle = 'dashed',marker = 'o',alpha = 0.5) 
#一维数组为y值,index为x值(从0开始)
#颜色也可以同RGB格式,即'#FF0000'
#dashed参数表示虚线,虚线也可以用'--'表示,还有'-.'也可以用
#marker 的 'o'参数表示用圆点标记点
#alpha表示透明度
#具体各种style可查看帮助 help(plt.plot)

#简写方式
plt.plot(x,y1,'ro--')

'''
    刻度,标题,标签,图例
'''
x1 = [1,2,3]
y1 = [5,7,4]
x2 = [1,2,3]
y2 = [10,12,14]

#解决中文显示问题
import matplotlib as mpl
mpl.rcParams['font.sans-serif'] = ["SimHei"]
mpl.rcParams['axes.unicode_minus'] = False

plt.figure()
plt.plot(x1,y1,'ro-',label = '红实线) 
plt.plot(x2,y2,'bo--',label = '蓝虚线') 

#设置标题标签
plt.xlabel('月份')
plt.xlabel('美元/亿')
plt.xlabel('月份')
plt.title('进出口数据')

#设置范围
plt.xlim(0,6)
plt.ylim(0,15)

#设置刻度
plt.xticks([1,2,3,4,5,6],str(i)+'月' for i in range(1,7))
plt.yticks(np.arange(2,16,2),['200','300','400','500','600','700','800'])

#设置坐标轴信息
ax = plt.gca()
#设置边框
ax.spines['top'].set_color(none)
ax.spines['right'].set_color(none)

#生成默认图例
plt.legend() 

plt.show()
```
+ subplot子图:`subplot(numRows,numCols,plotNum)`
```
import matplotlib.pyplot as plt
import numpy as np

x1 = [1,2,3]
y1 = [5,7,4]
x2 = [1,2,3]
y2 = [10,12,14]

plt.figure() #创建图像
plt.subplot(221) #创建第1个子图,2行2列的第1个位置
plt.plot(x1,y1,'ro--')
plt.subplot(223) #创建第2个子图,2行2列的第3个位置
plt.plot(x2,y2,'bo-')

plt.show()

#面向对象的形式
x1 = [1,2,3]
y1 = [5,7,4]
x2 = [1,2,3]
y2 = [10,12,14]

fig = plt.figure() #创建图像(实例化对象)
ax1 = fig.add_subplot(221)
ax2 = fig.add_subplot(222)
ax3 = fig.add_subplot(212)

#在ax123上画图
ax1.plot(np.random.randn(50).cumsum(),'g--')
ax2.plot(np.random.randn(50).cumsum(),'b--')
ax3.plot(np.random.randn(50).cumsum(),'r--')

plt.show()
```
+ subplots子图
```
import matplotlib.pyplot as plt

fig,axes = plt.subplots(2,2) 
#也可以fig,axes = plt.subplots(nrows = 2,ncols = 2,sharex = True,sharey = True)
'''
    print(axes) #输出: 由图片object构成的 2x2的列表
'''
#axes是一个列表
axes[0].plot(range(10),'ro-')
axes[1].plot(range(10),'bo-')
axes[2].plot(range(10),'yo-')
axes[3].plot(range(10),'mo-')

plt.show()
```
+ 柱状图`hist`代替`plot`
+ `numpy`以矩阵为基础的数学计算模块
```
import numpy as np

#创建数组 help(array)
np.array([1,2,3]) #用一维列表创建
np.array((1,2,3)) #用元组创建
np.array([
        [
            [1,2,3],
            [4,5,6]
        ],
        [
            [3,4,6],
            [8,6,4]
        ]  
]) #多维数组
np.zeros((3,3)) #创建元素为0的数组,用元组(3,3)表示3行3列
np.zeros((2,3,3)) #三维0数组
np.ones((3,3)) #创建元素为1的数组
np.empty((3,3)) #初始化一个空矩阵
np.arange(1,9,2) #一维数组
np.linspace(1,10,5) #生成等差数列
np.logspace(0,2,5,base = 10) #生成等比数列,从1(10**0)到100(10**2)生成5个数,base默认为10
np.random.random((3,3)) #0到1的随机数二维数组
np.random.randn((3,3)) #-1到1的随机数二维数组
np.random.randint(10,20,size = (3,3)) #范围内随机数二维数组
```
+ `numpy`属性
```
import numpy as np

#基本属性
arr = np.random.randint(1,9,size = (3,3))
print(arr.ndim) #维数,输出: 2
print(arr.shape) #形状,输出: (3,3)
print(arr.dtype) #类型,输出: int32
print(arr.itemsize) #字节长度,输出: 4
print(arr.size) #大小,输出: 9(=3x3)

#改变数组形状
arr2 = np.random.randint(1,9,size = (2,5))
#shape修改
arr2.shape(5,2) # 5x2=2x5 !!! 必须相等,也可以arr2.shape(5,-1),让电脑自己算
print(arr2)
#reshape修改
arr3 = np.arange(9)
arr4 = arr.reshape(3,3)
print(arr4)
arr4[0][1] = 100 #改变新数组的一个元素
print(arr4)
print(arr3) #发现原数组对应的数据也被改了,类似浅拷贝
#所以,一般这样创建
arr5 = np.arange(9).resahpe(3,3)
```
+ `numpy`基本操作
数组不再用循环,直接就能批量运算
```
import numpy as np

#数组与标量运算
arr = np.anrange(0,9).reshape(3,3)
print(arr)
print(arr + 2)

#数组间运算
arr1 = np.array([
    [1,2,3],
    [4,5,6]
])
arr2 = np.array([
    [10,20,30],
    [40,50,60]
])
print(arr1+arr2) #大小要相等,才能一一对应
'''
    输出:[
        [11,22,33],
        [44,55,66]
        ]
'''

#数组的矩阵积(矩阵点积)
arr1 = np.array([
    [1,2,3],
    [4,5,6]
])
arr2 = np.array([
    [10,20],
    [40,50,,
    [70,80]
])
print(np.dot(arr1,arr2))

#多维数组的索引和切片
arr3 = np.array([
    [
        [1,2],
        [3,4]
    ],
    [
        [5,6],
        [7,8]
    ]
])
print(arr3[0][1][0]) #输出: 3
print(arr3[1,:,1]) #输出: [6,8]
print(arr3[:,:,0]) #输出: [[1,3],[5,7]]

#花式索引
arr = np.random.randint(1,9,size = (8,4))
print(arr)
print(arr[(0,3,5)]) #获取0,3,5行数据
print(arr[[0,3,5],[0,3,2]]) #获取0,0 3,3 5,2 数据
print(arr[np.ix_([0,3,5],[0,3,2])] #索引器,分别获取0,3,5行的0,3,2数据,返回一个3x3数组

#布尔索引
arr2 = np.random.random((3,3))
print(arr2)
arr3 = arr2 < 0.5
print(arr3) #布尔值构成的3x3数组
#应用
name = np.array('joe','susan','tom')
score = np.array([
    [70,80,90],
    [77,88,99],
    [66,86,96]
])
classes = np.array('语文','数学','英语')
print(score[name = 'joe']) #输出第一行数据
name2 = name=='joe' #name2为布尔一维数组[true,false,false]
score[name2].reshape(-1) #相当于score[[true,false,false]],只输出第一行
score[name = 'joe',classes = '数学'] 
#输出: [80],相当于score[[true,false,false],[false,true,false]]

#数组转置
arr2 = arr.T
```
+ `numpy`常用一元函数
`np.abs(arr)`绝对值
`np.sqrt(arr)`平方根
`np.exp(arr)`计算指数e的多少次方
`np.log2(arr)`log默认为10
`np.isnan(arr)`判断is not a number?
`np.isfinite(arr)`有穷的
`np.isinf(arr)`无穷的
`np.sin(arr)`各种三角函数和反三角函数
+ `numpy`常用二元函数
`np.dot(arr1,arr2)`点乘
`np.greater(arr1,arr2)`比较if arr1>arr2
`np.logical_and np.logial_or np.logical_xor`相当于 与 或 异或
`np.power(arr,3)`幂
+ `numpy`聚合函数
`arr.min() arr.max() arr.sum() arr.mean() arr.std()`最小 最大 总和 平均 标准差
参数加上`axis = 0`按列算,`axis = 1`按行算
+ `np.where`函数,三元表达式`x if condition else y`的矢量化版本
语法:`np.where(codition,x,y)`
`np.where([[True,False],[True,True]],[[1,2],[3,4]],[[9,8],[7,6]])`
输出: [ [ 1 , 8 ] , [ 3 , 4 ] ]
+ `unique`去重
`arr = np.array(['a','b','c','a','b'])`
`arr2 = np.unique(arr)`

+ loc 和 iloc
loc用于标签名，比如arr.loc['A','B']
iloc用于标签编号，比如arr.iloc[:,1:3]]]></description></item><item><title>Python 基础（四）</title><link>http://www.cnblogs.com/peng8098/archive/2019/06/28/python_basis_4.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 28 Jun 2019 02:01:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/06/28/python_basis_4.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/python4/
+ `open`函数
`open(name[,mode[,buffering[,encoding]]])`
mode(访问模式):
-1 : r(只读) w(只写,若文件存在则覆盖) a(追加) rb(二进制只读) wb(二进制只写)
-2 : ab(二进制追加) r+,w+,a+(都是读写) rb+,wb+,ab+(都是二进制读写)
r+,w+,a+区别
r+ :文件的指针调到文件头部
w+:如果文件不存在直接创建,存在覆盖源文件
a+ :文件的指针调到文件末尾 
+ 打开关闭文件
`open`
```
#打开文件
file1 = open('python.txt','r')
print(file1)

#读写操作

#关闭文件
file1.close() 
```
`with open`完成后自己自动关闭
```
with open('python.txt','r',encoding = 'utf-8') as file1:
    content = file1.read()
    print(content)
```
+ 读文件
`read(num)`:读取文件内容,num表示指定长度,如果没有则读取所有数据
```
file1 = open('python.txt','r',encoding = 'utf-8')
content = file1.read() #读取数据保存在content变量当中
print(content)
```
`readlines()`按行读取,返回一个列表,每一行的数据为一个元素,换行也会转换成`str`格式即`'\n'`
```
file1 = open('python.txt','r',encoding = 'utf-8')
content = file1.readlines() #逐行读取内容
print(content)
file1.close()
```
+ 逐行读取
1. 用`open`结合`for`循环
```
file1 = open('python.txt','r',encoding = 'utf-8')
i = 1
for line in file1:
    #没有使用read,像迭代器一样节省空间
    print('这是第%d行:%s'%(i,line))
file1.close()
```
2. 用`with`结合`for`循环
```
with open('python.txt','r',encoding = 'utf-8') as file1:
    i = 1
    for line in file1:
    #没有使用read,像迭代器一样节省空间
        print('这是第%d行:%s'%(i,line))
        i += 1
```
+ 写入文件`write`

```
#以写的方式打开一个文件
file1 = open('python.txt','w',encoding = 'utf-8') #覆盖源文件
#file1 = open('python.txt','a',encoding = 'utf-8') #追加
content = 'hello'
file1.write(content)
file.close()
```
```
with open('python.txt','w',encoding = 'utf-8') as file1:
#with open('python.txt','a',encoding = 'utf-8') as file1:
    content = 'hello'
    file1.write(content)
```
+ 常用函数
`flush` 把缓冲区内容写入硬盘
`tell()` 查看文件指针
```
file1 = open('python.txt','r',encoding = 'utf-8')
str = file1.read(5) #读取数据保存在content变量当中
print('当前读取的数据是:'+str)

#查看当前指针位置
position = files.tell()
print('当前位置是:',position)

file1.close()
```
`seek(offset[,whence])`设置指针位置
`offset`是偏移量,`whence`有三个变量:0,1,2
`0`:从头开始算
`1`:从当前位置开始算
`2`:从末尾开始算
+ 文件夹的操作,要`import os`模块
```
import os
#获取当前路径
print(os.getcwd())

#列出当前(默认的)或指定目录的文件和文件夹
print(os.listdir('F:\python3.7\\))

#判断是否是一个文件
print(os.path.isfile('1.txt'))

#判断文件是否存在
print(os.path.exists('1.txt'))

#重命名文件
os.rename('1.txt','2.txt')

#删除文件
os.remove('2.txt')

#将目录和文件分割成2个元素,作为列表输出
os.path.split(F:\python3.7\1.txt)

#创建目录
os.mkdir('py')

#删除目录
os.rmdir('py')
```
+ 异常处理`try except else finally`
+ 简单异常处理
```
try:
    print(a) #如果有错,就会捕获到异常
except ValueError:
    print('变量未定义') #ValueError对异常的处理
except NameError:
    print('变量未定义') #NameError对异常的处理
    
#捕获异常的具体信息
try:
    print(a)
    file = open('a.txt','r')
except (NameError,FileNotFoundError) as e: #异常元组,若不知道什么异常可以用基类Exception
    print(e) #打印异常的具体信息,捕捉第一个异常就输出了
```
+ `else`没有异常时执行的语句
+ `finally`不管有没有异常都执行
+ 常用模块—`time`模块
```
import time

print(time.altzone) #返回格林威治西部的夏令时地区的偏移秒数

print(time.asctime()) #默认返回可读形式的当前时间
print(time.asctime((2017,12,12,12,12,12,3,340,1))) #返回可读形式的时间,感觉没啥用啊

print(time.gmtime()) #返回时间元组,格林威治时间的元组
print(time.localtime()) #返回本地时间元组

print(time.clock()) #返回进程时间,以秒为单位记时间戳

print(time.ctime()) #获取当前时间
print(time.time()) #返回当前时间的时间戳,从今年1月1日0点到现在的秒数

for i in range(3):
    print(1)
    time.sleep(2) #睡眠两秒
```
格式化时间:时间戳->时间元组->时间字符串
```
import time
times = time.time() #获取当前时间戳
formatTime = time.localtime(times)
print(time.strftime('%Y-%m-%d %H:%M:%S'.formatTime))

#time.strptime将时间字符串转换为时间元组
times = '2017-12-12 12:12:12'
formatTime = time.strptime(times,'%Y-%m-%d %H:%M:%S')
print(formatTime)

#mktime将时间元组转换为时间戳
print(time.mktime(formatTime))
```
+ 三天前的时间
`print(time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time()-3*24*60*60)))`
+ 进程与线程
```
import time
import threading

#单线程
def music(name,loop):
    for i in range(loop):
        print('listen music %s %s'%(name,time.ctime()))
        time.sleep(1)
def movie(name,loop):
    for i in range(loop):
        print('watch movie %s %s'%(name,time.ctime()))
        time.sleep(1)  

if __name__ = '__main__':
    music('music1',3)
    movie('movie2',2)
    print('end time %s'%time.ctime())

#创建多线程:假多线程,不建议使用
t1 = threading.Thread(target = music,args = ('music1',3))
t2 = threading.Thread(target = movie,args = ('movie2',2))     

if __name__ = '__main__':
    #守护主线程,主线程结束杀死子线程
    t1.setDaemon(True)
    t2.setDaemon(True)
    
    #启动线程
    t1.start()
    t2.start()
    
    #对主线程进行阻塞,等所有的子线程运行结束,再运行主线程
    t1.join()
    t2.join()
    
    print('end time %s'%time.ctime())
```
+ 全局解释锁GIL
```
#加锁
balance = 0
def change(n):
    global balance
    balance += n
    balance -= n
    
lock = threading.Lock() #获取线程锁
def run_thread(n):
    for i in range(100000):
        #获取锁
        lock.acquire()
        try:
            change(n)
        finally:
            #释放锁
            lock.release()
        
t1 = threading.Thread(target = run_thread,args = (4,))
t2 = threading.Thread(target = run_thread,args = (8,))

t1.start()
t2.start()

t1.join()
t2.join()

print(balance)
```
+ 多进程:用`multiprocessing`代替`Thread`
单进程
```
import time

def work1(f,n):
    print('work1 start')
    for i in range(n):
        with open(f,'a') as fs:
            fs.write('hello\n')
            time.sleep(1)
    print('work1 end')
    
def work2(f,n):
    print('work2 start')
    for i in range(n):
        with open(f,'a') as fs:
            fs.write('world\n')
            time.sleep(1)
    print('work2 end')
    
if __name__ = '__main__':
    work1('1.txt',3)
    work2('1.txt',3)
```
多进程加锁
```
import time
import multiprocessing

def work1(f,n,lock):
    print('work1 start')
    lock.acquire()
    for i in range(n):
        with open(f,'a') as fs:
            fs.write('hello\n')
            time.sleep(1)
    print('work1 end')
    lock.release()
    
def work2(f,n,lock):
    print('work2 start')
    lock.acquire()
    for i in range(n):
        with open(f,'a') as fs:
            fs.write('world\n')
            time.sleep(1)
    print('work2 end')
    lock.release()
    
if __name__ = '__main__':
    lock = multiprocessing.Lock()
    p1 = multiprocessing.Process(target=work1,args=('1.txt',3,lock))
    p2 = multiprocessing.Process(target=work2,args=('1.txt',3,lock))
    p1.start()
    p1.start()
```
+ 进程池`pool`
```
import os
import multiprocessing
import time

def work(n):
    print('run work(%s),work id %s'%(n,os.getpid()))
    time.sleep(5)
    print('work(%s) stop,work id %s'%(n,os.getpid()))

if __name__ = '__main__':
    print('parent process %s.'% os.getpid())
    #创建进程池
    p = multiprocessing.Pool(3)
    for i in range(5):
        #创建5个进程
        p.apply_async(work,args=(i,))
        p.close()
        p.join()
```
+ `pandas`数据分析包
引入约定:
`drom pandas import Series,DataFrame` 系列,帧
`import pandas as pd`
`Series`:类似一维数组的对象,索引值是可以重复的
`DataFrame` :表格型,没列可以是不同的数据类型,既有行索引也有列索引
+ 通过一维数组创建`Series`
```
import pandas as pd

#通过一维数组创建Series
ser01 = pd.Series([1,2,3,4])
ser01
print(ser01.dtype) #获取类型,输出: int32
print(ser01.values) #获取值,输出: [1 2 3 4]
print(ser01.index) #获取索引,输出: RangeIndex(start=0,stop=4,step=1)

#设置索引 通过 index 属性
ser01.index = ['a','b','c','d']
ser01

#也可以在创建时设置属性
ser02 = pd.Series(np.Series(np.array([1,2,3,4]),dtype = np.float64,index = ['a','b','c','d'])

#通过字典的方式创建
ser02 = pd.Series({'a':10,'b':20,'c':30})
ser02

#获取Series
print(ser02['a']) #通过key,输出:10
print(ser02[0]) #通过坐标,输出:10
print(ser02[0:2]) #类似切片,含左不含右,输出2对数据
print(ser02['a':'c']) #类似切片,但输出3对数据
```
+ `Numpy`的运算`Series`基本都可以用
```
import pandas as pd
ser01 = pd.Series([1,2,3,4])
ser01+1 #每个数都+1,很简单
```
+ `Series`缺失值处理
```
ser01 = pd.Series([1,2,3])
ser02 = pd.Series(ser01,index=['a','b','c','d'])
ser02 #缺失的数据用NaN来代替
ser02[pd.isnull(ser02)]
ser02[pd.notnull(ser02)] #过滤掉缺失值
```
+ `Series`自动对齐:有的自动对齐,没有的自动NaN
```
ser01 = pd.Series([1,2,3,4],index = ['a','b','c','d'])
ser02 = pd.Series([10,20,30,40],index = ['e','a','b','f'])
print(ser01+ser02)
'''
    输出:
    a   21.0
    b   32.0
    c   NaN
    d   NaN
    e   NaN
    f   NaN
'''
```
+ `Series`的`name`属性
`ser01.name` 总名字
`ser01.index.name` 第一列索引名
+ `DataFrame`创建
`df01 = pd.DataFrame(['joe','susan','anne'],[70,80,90],index = ['one','two','three'],columns = ['name','score'])`
通过字典方式创建
```
df01 = pd.DataFrame({
        'name':['joe','susan','anne'],  #key 变成列索引
        'age':[18,19,20],
        'class':3
},index = ['one','two','three'])
print(df01) #输出一个表
```
+ `DataFrame` 数据处理
`df01['name']` 通过列索引获取数据
`df01['address'] = ['shanghai','beijing','hangzhou']` 添加列数据
`df01.pop('address')` 列删除
`df01.ix['one']`行获取,古老的方法
`df01.loc['two']`行获取
`df01.ix['four'] = ['batman',25,4]`行修改,没这行就添加,有这行就修改
`df02 = df01.drop('four')`行删除
+ `pandas`基本操作
```
import pandas as pd

#读取文件
df01 = pd.read_csv('data1.csv') #读取csv
print(df01)

df02 = pd.read_excel('data1.xlsx') #读取excel
print(df02)

df03 = pd.read_csv('data1.txt',sep = ';',header = None) 
#读取txt,sep表示用什么分割,header=None表示不用第一排作为列索引
print(df03)
```]]></description></item><item><title>Python 基础 （三）</title><link>http://www.cnblogs.com/peng8098/archive/2019/06/28/python_basis_3.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 28 Jun 2019 02:00:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/06/28/python_basis_3.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/python3/
+ 字典排序
`dict = {'a':1,'c':3,'b':2}`
字典没有`sort`方法,可使用`sorted`排序,默认通过key排序
`dict = sorted(dict)`,`print(dict)`key的排序
`dict = sorted(dict,reverse = True)`,`print(dict)`逆序key
`dict = sorted(dict.items)`,`print(dict)`key-value作为元组的排序列表
`dict = sorted(dict.items)`,`print({k:v for k,v in dict})`实现字典的排序
使用`lambda`排序:
```
dict = sorted(dict.items(),key = lambda x:x[1],reverse = True)
#x[1]表示按照value排序,因为ict.items()是元组的列表,x[1]是元组的第二项即value,赋给要排序的关键字key
print({k:v for k,v in dict})
#用字典推导式将得到的元组列表转换成字典输出
```
+ 字典列表排序
```
list = [{name':b,'age':17},{name':a,'age':15},{'name':c,'age':16}]
dict = sorted(list,key= lambda x:x['age'],reverse = True)
#按age排序,倒序,不给key的话默认用第一个属性排
print(dict)
#输出的还是字典列表
```
+ 常用内置函数
`abs(num) sorted(list) sum(list) round(a,b)小数点后取b位 eval()执行一个表达式,或字符串作为运算 exec()输出python语句`
+ 常用高阶函数
`map(func,seq[,seq...])`映射
```
list = [1,2,3,4,5]
newlist = map(lambda x : x*2,list) #还不如newlist = [x*2 forx in list]方便!
print(newlist)
print(list(newlist)) #将map对象转换为list打印
list2 = [3,4,5,6,7]
newlist2 = map(lambda x,y : x*y,list,list2) #map后多个对象的例子
```
`filter(func,seq)`过滤
```
list = [1,2,3,4,5]
newlist = filter(lambda x:x>2,list)
print(list(newlist)) #输出:[3,4,5]
#用map试试
newlist = map(lambda x:x>2,list)
print(list(newlist)) 输出:[false,false,true,true,true]
```
`reduce(func,seq[,初始值])`
```
from functools import reduce
list = [1,2,3,4,5]
list2 = [3,4,5,6,7]
newlist = reduce(lambda x,y : x+y,list,10) 
#10是初始值,默认为0,第一步就是x=10
print(newlist) #输出:25
```
+ 类定义
```
class 类名():
    #类文档说明
    属性
    方法
```
例子:
```
#创建person类
class person():
    '''
        这是一个人类
    '''
    country = 'china' #声明类属性,并赋值
    #实例属性通过构造方法来声明
    #self不是关键字,代表的是当前对象
    def __init__(self,name,age,sex): #构造方法
        #构造方法不需要调用,在实例化时自动调用
        print('我是构造方法,在实例化时调用')
        self.name = name #通过self,创建实例属性,并赋值
        self.age = age
        self.sex = sex
    #创建普通方法
    def getName(self):
        #在方法里面使用实例属性
        print('我叫%s,来自%s'%(self.name,person.country)) 
        
#实例化对象
people01 = person('joe',18,'男') #在实例化时传递参数
#这个people01有3个属性和1个方法

#访问属性
#通过 对象名.属性名 访问实例属性
print(people01.name)
print(people01.age)
print(people01.sex)

print(getattr(people01,'name')) #通过内置方法访问属性
print(hasattr(people01,'name')) #是否有该属性,返回bool
print(setattr(people01,'name','susan')) #修改属性
delattr(people01,'name')) #删除属性

#通过对象调用实例方法
people01.getName()

#内置类属性
print(people01.__dict__) #将对象的属性通过字典形式返回
print(people01.__doc__) #查看文档说明(输出:这是一个人类)
print(person.__name__) #返回类名,不知道有啥用
print(people01.__bases__) #返回基类,也不知道有啥用
```
+ `__name__`
```
package name
def a():
    print('我是a方法')
if __name__ == '__main__': #判断是否在当前脚本运行
    a()
    print(__name__) #在当前脚本运行,输出:__main__
```
在另一个文件引用:
```
package name2
import name #没有输出
```
+ 继承
```
class Animal():
    def __init__(self,name,food):
        self.name = name
        self.food = food   
    def eat(self):
        print('%s eat %s'%(self.name,self.food))
        
class Dog(Animal):
    def __init__(self,name,food,drink):
        #加载父类构造方法
        super().__init__(name,food) 
        #或者Animal.__init__(self,name,food)也行
        self.drink = drink #子类自己的属性
    def drinks(self): #子类自己的方法
        print('%s drink %s`%(self.name,self.drink))
       
if __name__ = '__main__':
    dog1 = Dog('金毛','骨头','可乐')
    dog1.eat()
    dog1.drinks()
```
+ 多继承:若父类有相同的属性或方法,从左往右找
```
class A():
    def a(self):
        print('Aa')
class B():
    def b(self)):
        print('Bb')
    def a(self)):
        print('Ba')
class C():
    def c(self)):
        print('Cc')
class D(A,B,C):
    def d(self)):
        print('Dd')

dd = D()
dd.d() #调用自己的方法
dd.a() #输出:Aa
```
+ 多态:重写
```
class A():
    def a(self):
        print('Aa')
class B(A)
class D(A):
    def a(self)):
        print('Da')
bb = B()
bb.a() #输出:Aa
dd = D()
dd.a() #输出Da
```
+ 私有属性(相当于private)
双下划线开头的属性,不能通过 对象名.属性名 访问和修改!
外部修改私有属性,预留一个接口修改或访问,如
```
def getAddre(self,pwd):
    if pwd == '123':
        return self.__address
    else:
        return '权限不够'

#强制访问,尽量不这样做
print(people01._person__address)
```
+ 静态方法和类方法
```
@staticmethod #静态方法:不能访问实例属性,只能访问类属性
def aa(): #不需要传递实例,没有self
    print(person.country)
people01.aa()
person.aa() #推荐使用通过类名来调用静态方法
    
@classmethod #类方法:不能访问实例属性,
def bb(cls):
    print(cls.country)
people01.bb()
person.bb() #推荐使用通过类名来调用类方法
```
+ 模块:官方,第三方,每一个脚本都是一个模块
同一目录直接引用,不同目录从两个文件的最高相同目录开始`from`
创建一个包一定要创建一个__init__.py文件,里面有`__all__ = ['moduel1','moduel2',...]`表示运行被允许导入的模块
+ 重新加载:模块被导入一次后,其他的导入不再有效
```
import test
import imp
imp.reload(test)
```]]></description></item><item><title>Python 基础（二）</title><link>http://www.cnblogs.com/peng8098/archive/2019/06/28/python_basis_2.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 28 Jun 2019 01:58:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/06/28/python_basis_2.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/python2/
+ 输入一个字符串,以列表输出大写,如果包含整数,转为整型
```
str = input()
list = []
for i in str:
    if i.isdecimal() == True:
        list.append(int(i))
    else:
        list.append(i.upper())
```
+ 判断字符的类型:字母,数字,空格
`char.isalpha()`
`char.isdigit()`
`char.isspace()`
+ 两个矩阵相加
```
m = [[1,2,3],[4,5,6],[7,8,9]]
n = [[1,2,3],[4,5,6],[7,8,9]]
num = [m[i][j] + n[i][j] for i in range(3) for j in range(3)]
```
+ 列表推导式
```
list = []
for i in range(3,10):
    if i % 2 == 0:
    list.append(i)
```
可简写成:
`list = [i for i in range(3,10) if i % 2 == 0]`
+ 嵌套列表推导
```
m = [[1,2,3],
        [4,5,6],
        [7,8,9]]
list = []
for i in m:
    for j in i:
        list.append(j)
```
可简写成:
`list = [j for i in m for j in i]`
+ 打印菱形
```
for i in range(1,8,2):
    print(('*'*i).center(7))
for i in range(5,0,-2):
    print(('*'*i).center(7))
```
+ 判断回文数:当成`str`比较是否相同就行了,用数字麻烦
也可以使用切片,比较其与反切是否相等(`num == num[::-1]`)
+ 四个数字1,2,3,4组成的多少互不相同且无重复的数字
```
for x in range(1,5):
    for y in range(1,5):
        for z in range(1,5):
            if x != y and x != z and y != z:
                print(x * 100 + y * 10 + z)
```
用列表推导式:
`num = [x*100+y*10+z for for x in range(1,5) for y in range(1,5) for z in range(1,5) if x != y and x != z and y != z]`
+ 字典推导式
```
names = ['tom','jerry','jack']
name = {k:v for k,v in enumerate(names)}
print(name)
```
输出为:`{0:'tom',1:'jerry',2:'jack'}`
+ 冒泡排序:将2,6,4,9,3,10从大到小排列
```
list = [2,6,4,9,3,10]
for i in range(len(list)-1):
    for j in range(len(list)-1-i):
        if list[j] < list[j+1]:
            list[j],list[j+1] = list[j+1],list[j]
print(list)
```
+ 函数的定义
```
def function_name([参数](形参)):
    #函数说明
    要封装的代码块
function_name([参数(实参)]) #调用函数
```
+ 可以将函数名赋值给另一个变量,相当于起个别名
+ 函数的参数要一一对应,或者用关键字参数
```
def f(x,y):
    print(x-y)
f(2,1)
f(y=1,x=2)
```
+ 不定长参数
```
def getInfo(name,address,*args,**args2):
    #*args 是接受所有未命名的参数(关键字)
    #**args2 是接受所有命名的参数(带关键字的)
    print('我叫%s,来自%s'%(name,address))
    print(args) #元组类型
    print(args2) #字典类型
getInfo('tom','china','a','b','c',age = 18)
```
输出:
`我叫tom,来自china`
`('a','b','c')`
`{'age' : 18}`
+ 可变参数与不可变参数
```
def fun(*args):
    args = hello
    print(args)
str = 'baby'
fun(str1) #输出hello
print(str1) #输出baby,因为string是不可变类型,若为可变类型(如list),则参数也会被修改
```
+ `return`之后的代码不会执行,例如
```
def sum(x,y):
    return x+y #将结果回到调用的位置上
    print(x+y) #不会执行
print(sum(1,2))
```
+ `yield`生成器,生成一个迭代器
```
def getNum(n):
    i = 0
    while i <= n:
        #print(i) #打印i
        #return i #返回第一个i(即0),结束函数的运行
        b = yield i #将函数变成一个generator,直接在yield处暂停了,没有赋值操作
        i += 1
#getNum(5)
print(getNum(5))
a = getNum(5) 
for i in a:
    print(i)
```
+ `a = [ x for x in range(100000)]`会占用很大内存
`a = (x for x in range(100000))`生成迭代器,用`next(a)`一次输出一个数据
+ 迭代器:能被`next()`不断调用返回下一个对象
可迭代对象:`list string dict` ≠ 迭代器
```
list = [1,2,3,4]
a = iter(list)
print(a)
print(next(a))
```
+ `isinstance(s,str)`判断数据类型,相当于`type(s) == str`
+ 变量的作用域
局部变量:声明在函数内部的是局部变量,外部无法使用
全局变量:大家都能使用
+ 修改全局变量:
对于不可变类型:在函数内用`global`修改为全局变量
对于可变类型::可以不使用`global`声明
```
def fun1():
    global a
    a = 1
    print(a)
def fun2():
    global a
    a = 2
    print(a)
a = 3
fun1()
fun2()
print(a)
```
输出为:
`1`
`2`
`2`
+ 递归函数
```
def main(n):
    print(n)
    if n == 3:
        print('start')
    else:
        main(n+1)
    print(n)
main(1)
```
输出:
`1`
`2`
`3`
`'start'`
`3`
`2`
`1`
分析:
`main(1)=print(1)+main(2)+print(1)=print(1)+print(2)+main(3)+print(2)+print(1)=print(1)+print(2)+print(3)+print('start')+print(3)+print(2)+print(1)`
+ 匿名函数:`lambda [参数](可有可无): 表达式(相当于return xx)`
`lambda`内部一般只能放简单的表达式,特殊地,`s = lambda x,y : x if x > y else y`
没有参数:`s = lambda : 'abc'`;`print(s())`
一个参数:`s = lambda x : x*2`;`print(s(3))`
多个参数:`s = lambda x,y : x+y`;`print(s(1,2))`]]></description></item><item><title>Python 基础（一）</title><link>http://www.cnblogs.com/peng8098/archive/2019/06/28/python_basis_1.html</link><dc:creator>鹏懿如斯</dc:creator><author>鹏懿如斯</author><pubDate>Fri, 28 Jun 2019 01:54:00 GMT</pubDate><guid>http://www.cnblogs.com/peng8098/archive/2019/06/28/python_basis_1.html</guid><description><![CDATA[原文链接：http://www.one2know.cn/python1/
+ 输入：`str = input('请输入:')`
+ 输出：`print('hello',end = ' ' )`默认结束符为换行符
+ 多行注释：3个单引号
+ 标识符建议使用驼峰命名法
+ 数据类型
 数字：`int float complex bool`
 字符串
 列表
 元组：不可修改，只能 `del`
 集合：确定，互异，无序
 字典
 + `type(a)` 查看a的数据类型
 + `str = 'aaa'bbbb'`会报错
 `str =  'aaa\'bbbb'`正确！
 + 截取字符串 变量[开始下标(默认到最后):结束下标(默认到最后):步长(默认为1)]
 下标从0开始，取前不取后
 `str =  'abcdfeg'`
` print(str[5:2:-1])`
  输出: efd
 + 算术运算符
 `a**b`a的b次幂
`a//b`整除
+ 空串和0的布尔值都是False
`str = ''`
`str = []`
`str = ()`
`str = {}`
`num = 0`
`print(bool(str))`
`print(bool(num))`
输出都是: False
+ 位运算符
`a,b = 60,13`
`a&b = 12`与
`a|b = 61`或
`a^b = 49`异或：相异为1
`a~ = -61`取反：-a-1
`a << 2 = 240`左移
`a >> 2 = 15` 右移
+ 格式化输出：d 整数 f 浮点数 s 字符串
```
name = 'joe'
age = 18
address = 'beijing'
print('我是%s,我今年%d岁,来自%s'%(name,age,address))
```
+ 字符串常用函数
`str = 'i love python'`
`print(str.find'o')`输出:3,返回字母o的位置，如果没找到返回-1
`print(str.index'o')`输出:3,返回字母o的位置，如果没找到则报错
`print(str.count'o',2,6)`输出:1,返回范围内字母o出现的次数,默认整个字符串
`print(str.replace('o','O'))`输出:i lOve pythOn,后面替换前面
`print(str.split(' '))`输出一个列表:['i',' love','python'],用指定字符切割字符串
常用还有：`upper lower title`(每个单词首字母大写) `capitalize`(句子首字母大写) `center`(前后加空格)
+ 判断列表是否存在某元素 `print(element in list)` 输出bool值
+ 常用列表函数：`len(list) max(list) min(list) list.count(element) list1.extend(list2) list.index(element) list.sort() list.reverse() list.clear() list.copy()`
+ `tuple(list) list(tuple)` 列表与元组转换
+ del与clear，删除与清空
+ `dict.fromkeys(seq[,value])`以序列`seq`的元素作为字典的key，value默认初始值`None`
`dict.get(key,default=None)`返回指定key的值，若不存在返回默认
`print(key in dict)`输出bool值
`print(dict.keys())`返回所有key组成的列表
`print(dict.values())`返回所有value组成的列表
`print(dict.items())`返回所有(key,value)元组组成的列表
+ 可变参数：`dict list`
不可变参数：`string tuple number`
+ 深拷贝和浅拷贝(可变类型才有)
`print(id(a))`查看`a`在内存中的位置
直接赋值：`a = [...];b = a`地址没变，相当于起个新名，修改`a`后，`b`也会被修改，因为都是一块内存
浅拷贝：开辟新的地址内存，但内部还是用别人的，如切片
深拷贝：`import copy;a = [...];b.copy.deepcopy()`,完全拷贝，递归拷贝对象
+ `random.randint(x,y)` 返回`x`到`y`的随机数，取前不取后
+ `while-else`语句
```
while 条件:
    条件成立时的代码块
else:
    条件不成立时的代码块
```
+ `break`跳出循环，拔电源不干了；`continue`直接开始下一轮，作弊
+ `for`循环遍历列表
```
list = [...]
for element in list:
    print(element)
```
+ `for`遍历字典能得到字典的**key**
+ `pass`语句，空操作
+ `list(range(5))` means `list = [0,1,2,3,4]`]]></description></item></channel></rss>